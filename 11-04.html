<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Pushing the 286 and 386</title><!-- HEADER -->
  <!-- Empty Reference Subhead -->
  <!--ISBN=1576101746//-->
  <!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
  <!--AUTHOR=Michael Abrash//-->
  <!--PUBLISHER=The Coriolis Group, Inc.//-->
  <!--CHAPTER=11//-->
  <!--PAGES=216-220//-->
  <!--UNASSIGNED1//-->
  <!--UNASSIGNED2//-->
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="11-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="11-05.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p>When I was developing the Zen timer, I used my trusty 10 MHz 286-based AT clone to verify the basic functionality of the timer by measuring the performance of simple instruction sequences. I was cruising along with no problems until I timed the following code:</p><!-- CODE SNIP //-->
  <pre>

    mov    cx,1000
    call   ZTimerOn
LoopTop:
    loop   LoopTop
    call   ZTimerOff
</pre><!-- END CODE SNIP //-->

  <p><a id="Fig2"><!-- </A><A HREF="javascript:displayWindow('images/11-02.jpg',406,204 )"> --><img src="images/11-02.jpg" /><br />
  <!-- </A>
<BR><A HREF="javascript:displayWindow('images/11-02.jpg',406,204)"> --><b>Figure 11.2</b></a>&nbsp;&nbsp;<i>Word-aligned prefetching on the 286.</i></p>

  <p><a id="Fig3"><!-- </A><A HREF="javascript:displayWindow('images/11-03.jpg',408,240 )"> --><img src="images/11-03.jpg" /><br />
  <!-- </A>
<BR><A HREF="javascript:displayWindow('images/11-03.jpg',408,240)"> --><b>Figure 11.3</b></a>&nbsp;&nbsp;<i>How instruction bytes are fetched after a branch.</i></p>

  <p>Now, this code <i>should</i> run in, say, about 12 cycles per loop at most. Instead, it took over 14 cycles per loop, an execution time that I could not explain in any way. After rolling it around in my head for a while, I took a look at the code under a debugger...and the answer leaped out at me. <i>The loop began at an odd address!</i> That meant that two instruction fetches were required each time through the loop; one to get the opcode byte of the <b>LOOP</b> instruction, which resided at the end of one word-aligned word, and another to get the displacement byte, which resided at the start of the next word-aligned word.</p>

  <p>One simple change brought the execution time down to a reasonable 12.5 cycles per loop:</p><!-- CODE SNIP //-->
  <pre>
  mov   cx,1000
  call  ZTimerOn
  even
LoopTop:
  loop  LoopTop
  call  ZTimerOff
</pre><!-- END CODE SNIP //-->

  <p>While word-aligning branch destinations can improve branching performance, it&rsquo;s a nuisance and can increase code size a good deal, so it&rsquo;s not worth doing in most code. Besides, <b>EVEN</b> inserts a <b>NOP</b> instruction if necessary, and the time required to execute a <b>NOP</b> can sometimes cancel the performance advantage of having a word-aligned branch destination.</p>

  <table width="100%">
    <tr>
      <td width="5%" valign="top" align="left"><img src="images/i.jpg" /></td>

      <td width="95%" valign="top" align="left"><small><i>Consequently, it&rsquo;s best to word-align only those branch destinations that can be reached solely by branching.</i></small></td>
    </tr>
  </table>

  <p>I recommend that you only go out of your way to word-align the start offsets of your subroutines, as in:</p><!-- CODE SNIP //-->
  <pre>
          even
FindChar  proc near
          :
</pre><!-- END CODE SNIP //-->

  <p>In my experience, this simple practice is the one form of code alignment that consistently provides a reasonable return for bytes and effort expended, although sometimes it also pays to word-align tight time-critical loops.</p>

  <h4 align="center"><a id="Heading9"></a>Alignment and the 386</h4>

  <p>So far we&rsquo;ve only discussed alignment as it pertains to the 286. What, you may well ask, of the 386?</p>

  <p>The 386 adds the issue of <i>doubleword</i> alignment (that is, alignment to addresses that are multiples of four.) The rule for the 386 is: Word-sized memory accesses should be word-aligned (it&rsquo;s impossible for word-aligned word-sized accesses to cross doubleword boundaries), and doubleword-sized memory accesses should be doubleword-aligned. However, in real (as opposed to 32-bit protected) mode, doubleword-sized memory accesses are rare, so the simple word-alignment rule we&rsquo;ve developed for the 286 serves for the 386 in real mode as well.</p>

  <p>As for code alignment...the subroutine-start word-alignment rule of the 286 serves reasonably well there too since it avoids the worst case, where just 1 byte is fetched on entry to a subroutine. While optimum performance would dictate doubleword alignment of subroutines, that takes 3 bytes, a high price to pay for an optimization that improves performance <i>only</i> on the post 286 processors.</p>

  <h4 align="center"><a id="Heading10"></a>Alignment and the Stack</h4>

  <p>One side-effect of the data alignment cycle-eater of the 286 and 386 is that you should <i>never</i> allow the stack pointer to become odd. (You can make the stack pointer odd by adding an odd value to it or subtracting an odd value from it, or by loading it with an odd value.) An odd stack pointer on the 286 or 386 (or a non-doubleword-aligned stack in 32-bit protected mode on the 386, 486, or Pentium) will significantly reduce the performance of <b>PUSH,</b> <b>POP,</b> <b>CALL</b>, and <b>RET</b>, as well as <b>INT</b> and <b>IRET</b>, which are executed to invoke DOS and BIOS functions, handle keystrokes and incoming serial characters, and manage the mouse. I know of a Forth programmer who vastly improved the performance of a complex application on the AT simply by forcing the Forth interpreter to maintain an even stack pointer at all times.</p>

  <p>An interesting corollary to this rule is that you shouldn&rsquo;t <b>INC SP</b> twice to add 2, even though that takes fewer bytes than <b>ADD SP,2</b>. The stack pointer is odd between the first and second <b>INC</b>, so any interrupt occurring between the two instructions will be serviced more slowly than it normally would. The same goes for decrementing twice; use <b>SUB SP,2</b> instead.</p>

  <table width="100%">
    <tr>
      <td width="5%" valign="top" align="left"><img src="images/i.jpg" /></td>

      <td width="95%" align="left" valign="top"><small><i>Keep the stack pointer aligned at all times.</i></small></td>
    </tr>
  </table>

  <h4 align="center"><a id="Heading11"></a>The DRAM Refresh Cycle-Eater: Still an Act of God</h4>

  <p>The DRAM refresh cycle-eater is the cycle-eater that&rsquo;s least changed from its 8088 form on the 286 and 386. In the AT, DRAM refresh uses a little over five percent of all available memory accesses, slightly less than it uses in the PC, but in the same ballpark. While the DRAM refresh penalty varies somewhat on various AT clones and 386 computers (in fact, a few computers are built around static RAM, which requires no refresh at all; likewise, caches are made of static RAM so cached systems generally suffer less from DRAM refresh), the 5 percent figure is a good rule of thumb.</p>

  <p>Basically, the effect of the DRAM refresh cycle-eater is pretty much the same throughout the PC-compatible world: fairly small, so it doesn&rsquo;t greatly affect performance; unavoidable, so there&rsquo;s no point in worrying about it anyway; and a nuisance since it results in fractional cycle counts when using the Zen timer. Just as with the PC, a given code sequence on the AT can execute at varying speeds at different times as a result of the interaction between the code and DRAM refresh.</p>

  <p>There&rsquo;s nothing much new with DRAM refresh on 286/386 computers, then. Be aware of it, but don&rsquo;t overly concern yourself&mdash;DRAM refresh is still an act of God, and there&rsquo;s not a blessed thing you can do about it. Happily, the internal caches of the 486 and Pentium make DRAM refresh largely a performance non-issue on those processors.</p>

  <h4 align="center"><a id="Heading12"></a>The Display Adapter Cycle-Eater</h4>

  <p>Finally we come to the last of the cycle-eaters, the display adapter cycle-eater. There are two ways of looking at this cycle-eater on 286/386 computers: (1) It&rsquo;s much worse than it was on the PC, or (2) it&rsquo;s just about the same as it was on the PC.</p>

  <p>Either way, the display adapter cycle-eater is extremely bad news on 286/386 computers and on 486s and Pentiums as well. In fact, this cycle-eater on those systems is largely responsible for the popularity of VESA local bus (VLB).</p>

  <p>The two ways of looking at the display adapter cycle-eater on 286/386 computers are actually the same. As you&rsquo;ll recall from my earlier discussion of the matter in Chapter 4, display adapters offer only a limited number of accesses to display memory during any given period of time. The 8088 is capable of making use of most but not all of those slots with <b>REP MOVSW</b>, so the number of memory accesses allowed by a display adapter such as a standard VGA is reasonably well-matched to an 8088&rsquo;s memory access speed. Granted, access to a VGA slows the 8088 down considerably&mdash;but, as we&rsquo;re about to find out, &ldquo;considerably&rdquo; is a relative term. What a VGA does to PC performance is nothing compared to what it does to faster computers.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="11-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="11-05.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div><!-- all of the reference materials (books) have the footer and subfoot reveresed -->
  <!-- reference_subfoot = footer -->
  <!-- reference_footer = subfoot -->
  <!-- BEGIN SUB FOOTER -->
  <!-- END FOOTER -->
</body>
</html>
