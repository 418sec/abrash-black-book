<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: There Ain't No Such Thing as the Fastest Code</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=16//-->
<!--PAGES=295-300//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><BODY LINK=#0000FF ALINK=#000099 VLINK=#0000FF BGCOLOR=#FFFFFF>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="15-04.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="16-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H2><A NAME="Heading1"></A><FONT COLOR="#000077">Chapter 16<BR>There Ain&#146;t No Such Thing as the Fastest Code
</FONT></H2>
<H3><A NAME="Heading2"></A><FONT COLOR="#000077">Lessons Learned in the Pursuit of the Ultimate Word Counter</FONT></H3>
<P>I remember reading an overview of C<SMALL>&#43;&#43;</SMALL> development tools for Windows in a past issue of <I>PC Week</I>. In the lower left corner was the familiar box listing the 10 leading concerns of corporate buyers when it comes to C<SMALL>&#43;&#43;</SMALL>. Boiled down, the list looked like this, in order of descending importance to buyers:</P>
<DL>
<DD><B>1.</B>&nbsp;&nbsp;Debugging
<DD><B>2.</B>&nbsp;&nbsp;Documentation
<DD><B>3.</B>&nbsp;&nbsp;Windows development tools
<DD><B>4.</B>&nbsp;&nbsp;High-level Windows support
<DD><B>5.</B>&nbsp;&nbsp;Class library
<DD><B>6.</B>&nbsp;&nbsp;Development cycle efficiency
<DD><B>7.</B>&nbsp;&nbsp;Object-oriented development aids
<DD><B>8.</B>&nbsp;&nbsp;Programming management aids
<DD><B>9.</B>&nbsp;&nbsp;Online help
<DD><B>10.</B>&nbsp;&nbsp;Windows development cycle automation
</DL>
<P>Is something missing here? You bet your maximum <I>gluteus</I> something&#146;s missing&#151;nowhere on that list is there so much as one word about how fast the compiled code runs! I&#146;m not saying that performance is everything, but optimization isn&#146;t even down there at number 10, below online help! Ye gods and little fishes! We are talking here about people who would take a bus from LA to New York instead of a plane because it had a cleaner bathroom; who would choose a painting from a Holiday Inn over a Matisse because it had a fancier frame; who would buy a Yugo instead of&#151;well, hell, anything&#151;because it had a nice owner&#146;s manual and particularly attractive keys. We are talking about people who are focusing on means, and have forgotten about ends. We are talking about people with no programming souls.</P>
<H3><A NAME="Heading3"></A><FONT COLOR="#000077">Counting Words in a Hurry</FONT></H3>
<P>What are we to make of this? At the very least, we can safely guess that very few corporate buyers ever enter optimization contests. Most of my readers do, however; in fact, far more than I thought ever would, but that gladdens me to no end. I issued my first optimization challenge in a &#147;Pushing the Envelope&#148; column in <I>PC TECHNIQUES</I> back in 1991, and was deluged by respondents who, one might also gather, do not live by <I>PC Week</I>.</P>
<P>That initial challenge was sparked by a column David Gerrold wrote (also in <I>PC TECHNIQUES</I> ) concerning the matter of counting the number of words in a document; David turned up some pretty interesting optimization issues along the way. David did all his coding in Pascal, pointing out that while an assembly language version would probably be faster, his Pascal utility worked properly and was fast enough for him.</P>
<P>It wasn&#146;t, however, fast enough for me. The logical starting place for speeding up word counting would be David&#146;s original Pascal code, but I&#146;m much more comfortable with C, so Listing 16.1 is a loose approximation of David&#146;s word count program, translated to C. I left out a few details, such as handling comment blocks, partly because I don&#146;t use such blocks myself, and partly so we can focus on optimizing the core word-counting code. As Table 16.1 indicates, Listing 16.1 counts the words in a 104,448-word file in 4.6 seconds. The file was stored on a RAM disk, and Listing 16.1 was compiled with Borland C<SMALL>&#43;&#43;</SMALL> with all optimization enabled. A RAM disk was used partly because it returns consistent times&#151;no seek times, rotational latency, or cache to muddy the waters&#151;and partly to highlight word-counting speed rather than disk access speed.</P>
<TABLE WIDTH="80%"><TR>
<TD COLSPAN="2"><HR>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Listing
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="30%">Time to Count Words
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">16.1 (C)
<TD ALIGN="LEFT" VALIGN="TOP">4.6 seconds
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">16.2 &amp 16.3 (C&#43;ASM)
<TD ALIGN="LEFT" VALIGN="TOP">2.4 seconds
<TR>
<TD ALIGN="LEFT" VALIGN="TOP">16.2 &amp 16.4 (C&#43;ASM w/lookup)
<TD ALIGN="LEFT" VALIGN="TOP">1.6 seconds
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="2"><SMALL>These are the times taken to search a file containing 104,448 words, timed from a RAM disk on a 20 MHz 386.</SMALL>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" COLSPAN="2">Table 16.1 Word count timings.
<TR>
<TD COLSPAN="2"><HR>
</TABLE>
<P><B>LISTING 16.1 L16-1.C</B></P>
<!-- CODE //-->
<PRE>
 /* Word-counting program. Tested with Borland C&#43;&#43; in C
    compilation mode and the small model. */
 
 #include &ltstdio.h&gt
 #include &ltfcntl.h&gt
 #include &ltsys\stat.h&gt
 #include &ltstdlib.h&gt
 #include &ltio.h&gt
 
 #define  <I>B</I> UFFER_SIZE  0x8000   /* largest chunk of file worked 
                                  with at any one time */
 int main(int, char **);
 
 int main(int argc, char **argv) {
    int Handle;
    unsigned int BlockSize;
    long FileSize;
    unsigned long WordCount = 0;
    char *Buffer, CharFlag = 0, PredCharFlag, *BufferPtr, Ch;
 
    if (argc != 2) {
       printf(&#147;usage: wc &ltfilename&gt\n&#148;);
       exit(1);
    }
 
    if ((Buffer = malloc(BUFFER_SIZE)) == NULL) {
       printf(&#147;Can&#146;t allocate adequate memory\n&#148;);
       exit(1);
    }
 
    if ((Handle = open(argv[1], O_RDONLY | O_BINARY)) == -1) {
       printf(&#147;Can&#146;t open file %s\n&#148;, argv[1]);
       exit(1);
    }
 
    if ((FileSize = filelength(Handle)) == -1) {
       printf(&#147;Error sizing file %s\n&#148;, argv[1]);
       exit(1);
    }
 
    /* Process the file in chunks */
    while (FileSize &gt 0) {
       /* Get the next chunk */
       FileSize -= (BlockSize = min(FileSize, BUFFER_SIZE));
       if (read(Handle, Buffer, BlockSize) == -1) {
          printf(&#147;Error reading file %s\n&#148;, argv[1]);
          exit(1);
       }
       /* Count words in the chunk */
       BufferPtr = Buffer;
       do {
          PredCharFlag = CharFlag;
          Ch = *BufferPtr&#43;&#43; &amp 0x7F; /* strip high bit, which some
                                       word processors set as an
                                       internal flag */
          CharFlag = ((Ch &gt= &#145;a&#146;) &amp&amp (Ch &lt= &#145;z&#146;)) ||
                     ((Ch &gt= &#145;A&#146;) &amp&amp (Ch &lt= &#145;Z&#146;)) ||
                     ((Ch &gt= &#145;0&#146;) &amp&amp (Ch &lt= &#145;9&#146;)) ||
                     (Ch == &#145;\&#146;&#146;);
          if ((!CharFlag) &amp&amp PredCharFlag) {
             WordCo <I>u</I> nt&#43;&#43;; 
          }
       } while (&#151;BlockSize);
    }
 
    /*  Catch the last word, if any */ 
    if (CharFlag) {
       WordCount&#43;&#43;;
    }
    printf(&#147;\nTotal words in file: %lu\n&#148;, WordCount);
    return(0);
 }
 
</PRE>
<!-- END CODE //-->
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="15-04.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="16-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Graphics Programming Black Book &copy; 2001 Michael Abrash</font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


