<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Bit-Plane Animation</title><!-- HEADER -->
  <!-- Empty Reference Subhead -->
  <!--ISBN=1576101746//-->
  <!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
  <!--AUTHOR=Michael Abrash//-->
  <!--PUBLISHER=The Coriolis Group, Inc.//-->
  <meta name="chapter" content="43" />
  <meta name="pages" content="813-815" />
  <!--UNASSIGNED1//-->
  <!--UNASSIGNED2//-->
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="43-05.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="44-01.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p>If the CRT controller scans more slowly than the CPU can modify memory (likely with a 386, a fast VGA, and narrow images), then the CPU can rip right past the CRT controller, with the same net result of mismatched top and bottom parts of the image, as the CRT controller scans out first unchanged bytes and then changed bytes. Basically, shear will occasionally occur unless the CPU and CRT proceed at exactly the same rate, which is most unlikely. Shear is more noticeable when there are fewer but larger images, since it&rsquo;s more apparent when a larger screen area is sheared, and because it&rsquo;s easier to spot one out of three large images momentarily shearing than one out of twenty small images.</p>

  <p>Image shear isn&rsquo;t terrible&mdash;I&rsquo;ve written and sold several games in which images occasionally shear, and I&rsquo;ve never heard anyone complain&mdash;but neither is it ideal. One solution is page flipping, in which drawing is done to a non-displayed page of display memory while another page of display memory is shown on the screen. (We saw page flipping back in Chapter 23, we&rsquo;ll see it again in the next chapter, and we&rsquo;ll use it heavily starting in Chapter 47.) When the drawing is finished, the newly-drawn part of display memory is made the displayed page, so that the new screen becomes visible all at once, with no shearing or flicker. The other page is then drawn to, and when the drawing is complete the display is switched back to that page.</p>

  <p>Page flipping can be used in conjunction with bit-plane animation, although page flipping does diminish some of the unique advantages of bit-plane animation. Page flipping produces animation of the highest visual quality whether bit-plane animation is used or not. There are a few drawbacks to page flipping, however.</p>

  <p>Page flipping requires two display memory buffers, one to draw in and one to display at any given time. Unfortunately, in mode 12H there just isn&rsquo;t enough memory for two buffers, so page flipping is not an option in that mode.</p>

  <p>Also, page flipping requires that you keep the contents of both buffers up to date, which can require a good deal of extra drawing.</p>

  <p>Finally, page flipping requires that you wait until you&rsquo;re sure the page has flipped before you start drawing to the other page. Otherwise, you could end up modifying a page while it&rsquo;s still being displayed, defeating the whole purpose of page flipping. Waiting for pages to flip takes time and can slow overall performance significantly. What&rsquo;s more, it&rsquo;s sometimes difficult to be sure when the page has flipped, since not all VGA clones implement the display adapter status bits and page flip timing identically.</p>

  <p>To sum up, bit-plane animation by itself is very fast and looks good. In conjunction with page flipping, bit-plane animation looks a little better but is slower, and the overall animation scheme is more difficult to implement and perhaps a bit less reliable on some computers.</p>

  <h3><a id="Heading8"></a>Beating the Odds in the Jaw-Dropping Contest</h3>

  <p>Bit-plane animation is neat stuff. Heck, good animation of <i>any</i> sort is fun, and the PC is as good a place as any (well, almost any) to make people&rsquo;s jaws drop. (Certainly it&rsquo;s the place to go if you want to make a <i>lot</i> of jaws drop.) Don&rsquo;t let anyone tell you that you can&rsquo;t do good animation on the PC. You can&mdash;<i>if</i> you stretch your mind to find ways to bring the full power of the VGA to bear on your applications. Bit-plane animation isn&rsquo;t for every task; neither are page flipping, exclusive-ORing, pixel panning, or any of the many other animation techniques you have available. One or more tricks from that grab-bag should give you what you need, though, and the bigger your grab-bag, the better your programs.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="43-05.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="44-01.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div><!-- all of the reference materials (books) have the footer and subfoot reveresed -->
  <!-- reference_subfoot = footer -->
  <!-- reference_footer = subfoot -->
  <!-- BEGIN SUB FOOTER -->
  <!-- END FOOTER -->
</body>
</html>
