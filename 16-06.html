<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: There Ain't No Such Thing as the Fastest Code</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=16//-->
<!--PAGES=311-313//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><body>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="16-05.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="16-07.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H3><A NAME="Heading9"></A>Levels of Optimization</H3>
<P>Three levels of optimization were evident in the word-counting entries I received in response to my challenge. I&rsquo;d briefly describe them as &ldquo;fine-tuning,&rdquo; &ldquo;new perspective,&rdquo; and &ldquo;table-driven state machine.&rdquo; The latter categories produce faster code, but, by the same token, they are harder to design, harder to implement, and more difficult to understand, so they&rsquo;re suitable for only the most demanding applications. (Heck, I don&rsquo;t even guarantee that David Stafford&rsquo;s entry works perfectly, although, knowing him, it probably does; the more complex and cryptic the code, the greater the chance for obscure bugs.) 
</P>
<TABLE WIDTH="100%"><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="5%"><IMG SRC="images/i.jpg"><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95%"><SMALL><I>Remember, optimize only when needed, and stop when further optimization will not be noticed. Optimization that&rsquo;s not perceptible to the user is like buying Telly Savalas a comb; it&rsquo;s not going to do any harm, but it&rsquo;s nonetheless a waste of time.</I></SMALL>
</TABLE>
<H4 ALIGN="LEFT"><A NAME="Heading10"></A>Optimization Level 1: Good Code</H4>
<P>The first level of optimization involves fine-tuning and clever use of the instruction set. The basic framework is still the same as my code (which in turn is basically the same as that of the original C code), but that framework is implemented more efficiently.
</P>
<P>One obvious level 1 optimization is using a <B>word</B> rather than <B>dword</B> counter. <B>ScanBuffer</B> can never be called upon to handle more than 64K bytes at a time, so no more than 32K words can ever be found. Given that, it&rsquo;s a logical step to use <B>INC</B> rather than <B>ADD/ADC</B> to keep count, adding the tally into the full 32-bit count only upon exiting the function. Another useful optimization is aligning loop tops and other branch destinations to <B>word</B> , or better yet <B>dword</B> , boundaries.</P>
<P>Eliminating branches was very popular, as it should be on x86 processors. Branches were eliminated in a remarkable variety of ways. Many of you unrolled the loop, a technique that does pay off nicely. A word of caution: Some of you unrolled the loop by simply stacking repetitions of the inner loop one after the other, with <B>DEC CX/JZ</B> appearing after each repetition to detect the end of the buffer. Part of the point of unrolling a loop is to reduce the number of times you have to check for the end of the buffer! The trick to this is to set CX to the number of repetitions of the <I>unrolled</I> loop and count down only once each time through the unrolled loop. In order to handle repetition counts that aren&rsquo;t exact multiples of the unrolling factor, you must enter the loop by branching into the middle of it to perform whatever fraction of the number of unrolled repetitions is required to make the whole thing come out right. Listing 16.5 (QSCAN3.ASM) illustrates this technique.</P>
<P>Another effective optimization is the use of <B>LODSW</B> rather than <B>LODSB</B> , thereby processing two bytes per memory access. This has the effect of unrolling the loop one time, since with <B>LODSW</B> , looping is performed at most only once every two bytes.</P>
<P>Cutting down the branches used to loop is only part of the branching story. More often than not, my original code also branched in the process of checking whether it was time to count a word. There are many ways to reduce this sort of branching; in fact, it is quite possible to eliminate it entirely. The most straightforward way to reduce such branching is to employ two loops. One loop is used to look for the end of a word when the last byte was a non-separator, and one loop is used to look for the start of a word when the last byte was a separator. This way, it&rsquo;s no longer necessary to maintain a flag to indicate the state of the last byte; that state is implied by whichever loop is currently executing. This considerably simplifies and streamlines the inner loop code.</P>
<P>Listing 16.6, contributed by Willem Clements, of Granada, Spain, illustrates a variety of level 1 optimizations: the two-loop approach, the use of a 16- rather than 32-bit counter, and the use of <B>LODSW</B> . Together, these optimizations made Willem&rsquo;s code nearly twice as fast as mine in Listing 16.4. A few details could stand improvement; for example, <B>AND AX,AX</B> is a shorter way to test for zero than <B>CMP AX,0</B> , and <B>ALIGN 2</B> could be used. Nonetheless, this is good code, and it&rsquo;s also fairly compact and reasonably easy to understand. In short, this is an excellent example of how an hour or so of hand-optimization might accomplish significantly improved performance at a reasonable cost in complexity and time. This level of optimization is adequate for most purposes (and, in truth, is beyond the abilities of most programmers).</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="16-05.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="16-07.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
Graphics Programming Black Book &copy; 2001 Michael Abrash
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


