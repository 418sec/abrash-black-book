<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Higher 256-Color Resolution on the VGA</title>
  <meta name="chapter" content="31" />
  <meta name="pages" content="599-600" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="31-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="31-05.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p>The interesting aspects of Listing 31.1 are three. First, the <b>Set320x400Mode</b> subroutine selects 320x400 256-color mode. This is accomplished by performing a mode 13H mode set followed by then putting the VGA into standard planar byte mode. <b>Set320x400Mode</b> zeros display memory as well. It&rsquo;s necessary to clear display memory even after a mode 13H mode set because the mode 13H mode set clears only the 64K of display memory that can be accessed in that mode, leaving 192K of display memory untouched.</p>

  <p>The second interesting aspect of Listing 31.1 is the <b>WritePixel</b> subroutine, which draws a colored pixel at any <i>x,y</i> addressable location on the screen. Although it may not be obvious because I&rsquo;ve optimized the code a little, the process of drawing a pixel is remarkably simple. First, the pixel&rsquo;s display memory address is calculated as</p>

  <p><i>address</i>=(<i>y</i> * (SCREEN_WIDTH / 4)) + (<i>x</i> / 4)</p>

  <p>which might be more recognizable as:</p>

  <p><i>address</i>=((<i>y</i> * SCREEN_WIDTH) + <i>x</i>) / 4</p>

  <p>(There are 4 pixels at each display memory address in 320x400 mode, hence the division by 4.) Then the pixel&rsquo;s plane is calculated as</p>

  <p><i>plane</i>=<i>x</i> and 3</p>

  <p>which is equivalent to:</p>

  <p><i>plane</i>=<i>x</i> modulo 4</p>

  <p>The pixel&rsquo;s color is then written to the addressed byte in the addressed plane. That&rsquo;s all there is to it!</p>

  <p>The third item of interest in Listing 31.1 is the <b>ReadPixel</b> subroutine. <b>ReadPixel</b> is virtually identical to <b>WritePixel</b>, save that in <b>ReadPixel</b> the Read Map register is programmed with a plane number, while <b>WritePixel</b> uses a plane <i>mask</i> to set the Map Mask register. Of course, that difference merely reflects a fundamental difference in the operation of the two registers. (If that&rsquo;s Greek to you, refer back to Chapters 23-30 for a refresher on VGA programming.) <b>ReadPixel</b> isn&rsquo;t used in Listing 31.1, but I&rsquo;ve included it because, as I said above, the read and write pixel functions together can support a whole host of more complex graphics functions.</p>

  <p>How does 320x400 256-color mode stack up as regards performance? As it turns out, the programming model of 320x400 mode is actually pretty good for pixel drawing, pretty much on a par with the model of mode 13H. When you run Listing 31.1, you&rsquo;ll no doubt notice that the lines are drawn quite rapidly. (In fact, the drawing could be considerably faster still with a dedicated line-drawing subroutine, which would avoid the multiplication associated with each pixel in Listing 31.1.)</p>

  <p>In 320x400 mode, the calculation of the memory address is not significantly slower than in mode 13H, and the calculation and selection of the target plane is quickly accomplished. As with mode 13H, 320x400 mode benefits tremendously from the byte-per-pixel organization of 256-color mode, which eliminates the need for the time-consuming pixel-masking of the 16-color modes. Most important, byte-per-pixel modes never require read-modify-write operations (which can be extremely slow due to display memory wait states) in order to clip and draw pixels. To draw a pixel, you just store its color in display memory&mdash;what could be simpler?</p>

  <p>More sophisticated operations than pixel drawing are less easy to accomplish in 320x400 mode, but with a little ingenuity it is possible to implement a reasonably efficient version of just about any useful graphics function. A fast line draw for 320x400 256-color mode would be simple (although not as fast as would be possible in mode 13H). Fast image copies could be implemented by copying one-quarter of the image to one plane, one-quarter to the next plane, and so on for all four planes, thereby eliminating the <b>OUT</b> per pixel that sequential processing requires. If you&rsquo;re really into performance, you could store your images with all the bytes for plane 0 grouped together, followed by all the bytes for plane 1, and so on. That would allow a single <b>REP MOVS</b> instruction to copy all the bytes for a given plane, with just four <b>REP MOVS</b> instructions copying the whole image. In a number of cases, in fact, 320x400 256-color mode can actually be much faster than mode 13H, because the VGA&rsquo;s hardware can be used to draw four or even eight pixels with a single access; I&rsquo;ll return to the topic of high-performance programming in 256-color modes other than mode 13H (&ldquo;non-chain 4&rdquo; modes) in Chapter 47.</p>

  <p>It&rsquo;s all a bit complicated, but as I say, you should be able to design an adequately fast&mdash;and often <i>very</i> fast&mdash;version for 320x400 mode of whatever graphics function you need. If you&rsquo;re not all that concerned with speed, <b>WritePixel</b> and <b>ReadPixel</b> should meet your needs.</p>

  <h3 id="Heading7">Two 256-Color Pages</h3>

  <p>Listing 31.2 demonstrates the two pages of 320x400 256-color mode by drawing slanting color bars in page 0, then drawing color bars slanting the other way in page 1 and flipping to page 1 on the next key press. (Note that page 1 is accessed starting at offset 8000H in display memory, and is&mdash;unsurprisingly&mdash;displayed by setting the start address to 8000H.) Finally, Listing 31.2 draws vertical color bars in page 0 and flips back to page 0 when another key is pressed.</p>

  <p>The color bar routines don&rsquo;t use the <b>WritePixel</b> subroutine from Listing 31.1; they go straight to display memory instead for improved speed. As I mentioned above, better speed yet could be achieved by a color-bar algorithm that draws all the pixels in plane 0, then all the pixels in plane 1, and so on, thereby avoiding the overhead of constantly reprogramming the Map Mask register.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="31-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="31-05.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
