<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Pentium Rules</title>
  <meta name="chapter" content="20" />
  <meta name="pages" content="381-386" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td>
          <a href="19-04.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="20-02.html">Next</a>
        </td>
      </tr>
    </table>
  </center>

  <h2 id="Heading1">Chapter 20<br />
  Pentium Rules</h2>

  <h3 id="Heading2">How Your Carbon-Based Optimizer Can Put the &ldquo;Super&rdquo; in Superscalar</h3>

  <p>At the 1983 West Coast Computer Faire, my friend Dan Illowsky, Andy Greenberg (co-author of Wizardry, at that time the best-selling computer game ever), and I had an animated discussion about starting a company in the then-budding world of microcomputer software. One hot new software category at the time was educational software, and one of the hottest new educational software companies was Spinnaker Software. Andy used Spinnaker as an example of a company that had been aimed at a good market and started up properly, and was succeeding as a result. Dan didn&rsquo;t buy this; his point was that Spinnaker had been given a bundle of money to get off the ground, and was growing only by spending a lot of that money in order to move its products. &ldquo;Heck,&rdquo; said Dan, &ldquo;I could get that kind of market share too if I gave away a fifty-dollar bill with each of my games.&rdquo;</p>

  <p>Remember, this was a time when a program, two diskette drives (for duplicating disks), and a couple of ads were enough to start a company, and, in fact, Dan built a very successful game company out of not much more than that. (I&rsquo;ll never forget coming to visit one day and finding his apartment stuffed literally to the walls and ceiling with boxes of diskettes and game packages; he had left a narrow path to the computer so his wife and his mother could get in there to duplicate disks.) Back then, the field was wide open, with just about every competent programmer thinking of striking out on his or her own to try to make their fortune, and Dan and Andy and I were no exceptions. In short, we were having a perfectly normal conversation, and Dan&rsquo;s comment was both appropriate, and, in retrospect, accurate.</p>

  <p>Appropriate, save for one thing: We were having this conversation while walking through a low-rent section of Market Street in San Francisco at night. A bum sitting against a nearby building overheard Dan, and rose up, shouting in a quavering voice loud enough to wake the dead, &ldquo;Fifty-dollar bill! Fifty-dollar bill! He&rsquo;s giving away fifty-dollar bills!&rdquo; We ignored him; undaunted, he followed us for a good half mile, stopping every few feet to bellow &ldquo;fifty-dollar bill!&rdquo; No one else seemed to notice, and no one hassled us, but I was mighty happy to get to the sanctuary of the Fairmont Hotel and slip inside.</p>

  <p>The point is, most actions aren&rsquo;t inherently good or bad; it&rsquo;s all a matter of context. If Dan had uttered the words &ldquo;fifty-dollar bill&rdquo; on the West Coast Faire&rsquo;s show floor, no one would have batted an eye. If he had said it in a slightly worse part of town than he did, we might have learned just how fast the three of us could run.</p>

  <p>Similarly, there&rsquo;s no such thing as inherently fast code, only fast code in context. At the moment, the context is the Pentium, and the truth is that a sizable number of the x86 optimization tricks that you and I have learned over the past ten years are obsolete on the Pentium. True, the Pentium contains what amounts to about one-and-a-half 486s, but, as we&rsquo;ll see shortly, that doesn&rsquo;t mean that optimized Pentium code looks much like optimized 486 code, or that fast 486 code runs particularly well on a Pentium. (Fast Pentium code, on the other hand, does tend to run well on the 486; the only major downsides are that it&rsquo;s larger, and that the <b>FXCH</b> instruction, which is largely free on the Pentium, is expensive on the 486.) So discard your x86 preconceptions as we delve into superscalar optimization for this one-of-a-kind processor.</p>

  <h3 id="Heading3">An Instruction in Every Pipe</h3>

  <p>In the last chapter, we took a quick tour of the Pentium&rsquo;s architecture, and started to look into the Pentium&rsquo;s optimization rules. Now we&rsquo;re ready to get to the key rules, those having to do with the Pentium&rsquo;s most unique and powerful feature, the ability to execute more than one instruction per cycle. This is known as <i>superscalar execution</i>, and has heretofore been the sole province of fast RISC CPUs. The Pentium has two integer execution units, called the <i>U-pipe</i> and the <i>V-pipe</i>, which can execute two separate instructions simultaneously, potentially doubling performance&mdash;but only under the proper conditions. (There is also a separate floating-point execution unit that I won&rsquo;t have the space to cover in this book.) Your job, as a performance programmer, is to understand the conditions needed for superscalar performance and make sure they&rsquo;re met, and that&rsquo;s what this and the next chapters are all about.</p>

  <p>The two pipes are not independent processors housed in a single chip; that is, the Pentium is not like having two 486s in a single computer. Rather, the two pipes are integral, parallel parts of the same processor. They operate on the same instruction stream, with the V-pipe simply executing the next instruction that the U-pipe would have handled, as shown in Figure 20.1. What the Pentium does, pure and simple, is execute a single instruction stream and, whenever possible, take the next two waiting instructions and execute both at once, rather than one after the other.</p>

  <p>The U-pipe is the more capable of the two pipes, able to execute any instruction in the Pentium&rsquo;s instruction set. (A number of instructions actually use both pipes at once. Logically, though, you can think of such instructions as U-pipe instructions, and of the Pentium optimization model as one in which the U-pipe is able to execute all instructions and is always active, with the objective being to keep the V-pipe also working as much of the time as possible.) The U-pipe is generally similar to a full 486 in terms of both capabilities and instruction cycle counts. The V-pipe is a 486 subset, able to execute simple instructions such as <b>MOV</b> and <b>ADD</b>, but unable to handle <b>MUL, DIV</b>, string instructions, any sort of rotation or shift, or even <b>ADC</b> or <b>SBB</b>.</p>

  <p><a id="Fig1"><img src="images/20-01.jpg" /><br />
  <b>Figure 20.1</b></a>&nbsp;&nbsp;<i>The Pentium&rsquo;s two pipes.</i></p>

  <p>Getting two instructions executing simultaneously in the two pipes is trickier than it sounds, not only because the V-pipe can handle only a relatively small subset of the Pentium&rsquo;s instruction set, but also because those instructions that the V-pipe can handle are able to pair only with certain U-pipe instructions. For example, <b>MOVSD</b> uses both pipes, so no instruction can be executed in parallel with <b>MOVSD</b>.</p>

  <table width="100%">
    <tr>
      <td valign="top" align="left" width="5%"><img src="images/i.jpg" /></td>

      <td valign="top" align="left" width="95%"><small><i>The use of both pipes does make <b>MOVSD</b> nearly twice as fast on the Pentium as on the 486, but it&rsquo;s nonetheless slower than using equivalent simpler instructions that allow for superscalar execution. Stick to the Pentium&rsquo;s RISC-like instructions&mdash;the pairable instructions I&rsquo;ll discuss next&mdash;when you&rsquo;re seeking maximum performance, with just a few exceptions such as <b>REP MOVS</b> and <b>REP STOS</b>.</i></small></td>
    </tr>
  </table>

  <p>Trickier yet, register contention can shut down the V-pipe on any given cycle, and Address Generation Interlocks (AGIs) can stall either pipe at any time, as we&rsquo;ll see in the next chapter.</p>

  <p>The key to Pentium optimization is to view execution as a stream of instructions going through the U- and V-pipes, and to eliminate, as much as possible, instruction mixes that take the V-pipe out of action. In practice, this is not too difficult. The only hard part is keeping in mind the long list of rules governing instruction pairing. The place to begin is with the set of instructions that can go through the V-pipe.</p>

  <center>
    <table border="1">
      <tr>
        <td>
          <a href="19-04.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="20-02.html">Next</a>
        </td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
