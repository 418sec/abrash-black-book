<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Hints My Readers Gave Me</title>
  <meta name="chapter" content="09" />
  <meta name="pages" content="182-185" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="09-05.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="09-07.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p><b>LISTING 9.5 L9-5.ASM</b></p>
  <pre>
; Divides an arbitrarily long unsigned dividend by a 16-bit unsigned
; divisor. C near-callable as:
;     unsigned int Div(unsigned int * Dividend,
;     int DividendLength, unsigned int Divisor,
;     unsigned int * Quotient);
;
; Returns the remainder of the division.
;
; Tested with TASM 2.

parms struc
          dw     2 dup (?)     ;pushed BP &amp; return address
Dividend  dw     ?             ;pointer to value to divide, stored in Intel
                               ; order, with lsb at lowest address, msb at
                               ; highest. Must be composed of an integral
                               ; number of words
DividendLength   dw  ?         ;# of bytes in Dividend. Must be a multiple
                               ; of 2
Divisor          dw ?          ;value by which to divide. Must not be zero,
                               ; or a Divide By Zero interrupt will occur
Quotient         dw ?          ;pointer to buffer in which to store the
                               ; result of the division, in Intel order.
                               ; The quotient returned is of the same
                               ; length as the dividend
parmsends

               .model     small
               .code
               public     _Div
_Divprocnear
               push    bp      ;preserve caller&rsquo;s stack frame
               mov     bp,sp   ;point to our stack frame
               push    si      ;preserve caller&rsquo;s register variables
               push    di

               std             ;we&rsquo;re working from msb to lsb
               mov  ax,ds
               mov  es,ax      ;for STOS
               mov  cx,[bp+DividendLength]
               sub  cx,2
               mov  si,[bp+Dividend]
               add  si,cx      ;point to the last word of the dividend
                               ; (the most significant word)
               mov  di,[bp+Quotient]
               add  di,cx      ;point to the last word of the quotient
                               ; buffer (the most significant word)
               mov  bx,[bp+Divisor]
               shr  cx,1
               inc  cx         ;# of words to process
               sub  dx,dx      ;convert initial divisor word to a 32-bit
                               ;value for DIV
DivLoop:
               lod  sw         ;get next most significant word of divisor
               div  bx
               sto  sw         ;save this word of the quotient
                               ;DX contains the remainder at this point,
                               ; ready to prepend to the next divisor word
               loop  DivLoop
               mov   ax,dx     ;return the remainder
               cld             ;restore default Direction flag setting
               pop   di        ;restore caller&rsquo;s register variables
               pop   si
               pop   bp        ;restore caller&rsquo;s stack frame
               ret
_Divendp
               end
</pre>

  <p><b>LISTING 9.6 L9-6.C</b></p>
  <pre>
/* Sample use of Div function to perform division when the result
   doesn&rsquo;t fit in 16 bits */

#include &lt;stdio.h&gt;

extern unsigned int Div(unsigned int * Dividend,
          int DividendLength, unsigned int Divisor,
          unsigned int * Quotient);

main() {
   unsigned long m, i = 0x20000001;
   unsigned int k, j = 0x10;

   k = Div((unsigned int *)&amp;i, sizeof(i), j, (unsigned int *)&amp;m);
   printf(&ldquo;%lu / %u = %lu r %u\n&rdquo;, i, j, m, k);
}
</pre>

  <h4 align="left" id="Heading9">Sweet Spot Revisited</h4>

  <p>Way back in Volume 1, Number 1 of <i>PC TECHNIQUES</i>, (April/May 1990) I wrote the very first of that magazine&rsquo;s HAX (#1), which extolled the virtues of placing your most commonly-used automatic (stack-based) variables within the stack&rsquo;s &ldquo;sweet spot,&rdquo; the area between +127 to -128 bytes away from BP, the stack frame pointer. The reason was that the 8088 can store addressing displacements that fall within that range in a single byte; larger displacements require a full word of storage, increasing code size by a byte per instruction, and thereby slowing down performance due to increased instruction fetching time.</p>

  <p>This takes on new prominence in 386 native mode, where straying from the sweet spot costs not one, but two or three bytes. Where the 8088 had two possible displacement sizes, either byte or word, on the 386 there are three possible sizes: byte, word, or dword. In native mode (32-bit protected mode), however, a prefix byte is needed in order to use a word-sized displacement, so a variable located outside the sweet spot requires either two extra bytes (an extra displacement byte plus a prefix byte) or three extra bytes (a dword displacement rather than a byte displacement). Either way, instructions grow alarmingly.</p>

  <p>Performance may or may not suffer from missing the sweet spot, depending on the processor, the memory architecture, and the code mix. On a 486, prefix bytes often cost a cycle; on a 386SX, increased code size often slows performance because instructions must be fetched through the half-pint 16-bit bus; on a 386, the effect depends on the instruction mix and whether there&rsquo;s a cache.</p>

  <table width="100%">
    <tr>
      <td width="5%" valign="top" align="left"><img src="images/i.jpg" /></td>

      <td width="95%" valign="top" align="left"><small><i>On balance, though, it&rsquo;s as important to keep your most-used variables in the stack&rsquo;s sweet spot in 386 native mode as it was on the 8088.</i></small></td>
    </tr>
  </table>

  <p>In assembly, it&rsquo;s easy to control the organization of your stack frame. In C, however, you&rsquo;ll have to figure out the allocation scheme your compiler uses to allocate automatic variables, and declare automatics appropriately to produce the desired effect. It can be done: I did it in Turbo C some years back, and trimmed the size of a program (admittedly, a large one) by several K&mdash;not bad, when you consider that the &ldquo;sweet spot&rdquo; optimization is essentially free, with no code reorganization, change in logic, or heavy thinking involved.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="09-05.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="09-07.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
