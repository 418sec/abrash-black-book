<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: Zenning and the Flexible Mind</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=22//-->
<!--PAGES=413-417//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><BODY LINK=#0000FF ALINK=#000099 VLINK=#0000FF BGCOLOR=#FFFFFF>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="21-05.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="22-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H2><A NAME="Heading1"></A><FONT COLOR="#000077">Chapter 22<BR>Zenning and the Flexible Mind
</FONT></H2>
<H3><A NAME="Heading2"></A><FONT COLOR="#000077">Taking a Spin through What You&#146;ve Learned</FONT></H3>
<P>And so we come to the end of our journey; for now, at least. What follows is a modest bit of optimization, one which originally served to show readers of <I>Zen of Assembly Language</I> that they had learned more than just bits and pieces of knowledge; that they had also begun to learn how to apply the flexible mind&#151;unconventional, broadly integrative thinking&#151;to approaching high-level optimization at the algorithmic and program design levels. You, of course, need no such reassurance, having just spent 21 chapters learning about the flexible mind in many guises, but I think you&#146;ll find this example instructive nonetheless. Try to stay ahead as the level of optimization rises from instruction elimination to instruction substitution to more creative solutions that involve broader understanding and redesign. We&#146;ll start out by compacting individual instructions and bits of code, but by the end we&#146;ll come up with a solution that involves the very structure of the subroutine, with each instruction carefully integrated into a remarkably compact whole. It&#146;s a neat example of how optimization operates at many levels, some much less determininstic than others&#151;and besides, it&#146;s just plain fun.</P>
<P>Enjoy!</P>
<H3><A NAME="Heading3"></A><FONT COLOR="#000077">Zenning</FONT></H3>
<P>In Jeff Duntemann&#146;s excellent book <I>Borland Pascal From Square One</I> (Random House, 1993), there&#146;s a small assembly subroutine that&#146;s designed to be called from a Turbo Pascal program in order to fill the screen or a systemscreen buffer with a specified character/attribute pair in text mode. This subroutine involves only 21 instructions and works perfectly well; however, with what we know, we can compact the subroutine tremendously and speed it up a bit as well. To coin a verb, we can &#147;Zen&#148; this already-tight assembly code to an astonishing degree. In the process, I hope you&#146;ll get a feel for how advanced your assembly skills have become.</P>
<P>Jeff&#146;s original code follows as Listing 22.1 (with some text converted to lowercase in order to match the style of this book), but the comments are mine.</P>
<P><B>LISTING 22.1 L22-1.ASM</B></P>
<!-- CODE //-->
<PRE>
OnStack      struc      ;data that&#146;s stored on the stack after PUSH BP
OldBP        dw   ?     ;caller&#146;s BP
RetAddr      dw   ?     ;return address
Filler       dw   ?     ;character to fill the buffer with
Attrib       dw   ?     ;attribute to fill the buffer with
BufSize      dw   ?     ;number of character/attribute pairs to fill
BufOfs       dw   ?     ;buffer offset
BufSeg       dw   ?     ;buffer segment
EndMrk       db   ?     ;marker for the end of the stack frame
OnStack      ends
;
ClearS       proc near
     push    bp                         ;save caller&#146;s BP
     mov     bp,sp                      ;point to stack frame
     cmp     word ptr [bp].BufSeg,0     ;skip the fill if a null
    jne      Start                      ; pointer is passed
    cmp      word ptr [bp].BufOfs,0
    je       Bye
Start: cld                           ;make STOSW count up
    mov      ax,[bp].Attrib          ;load AX with attribute parameter
    and      ax,0ff00h               ;prepare for merging with fill char
    mov      bx,[bp].Filler          ;load BX with fill char
    and      bx,0ffh                 ;prepare for merging with attribute
    or       ax,bx                   ;combine attribute and fill char
    mov      bx,[bp].BufOfs          ;load DI with target buffer offset
    mov      di,bx
    mov      bx,[bp].BufSeg          ;load ES with target buffer segment
    mov      es,bx
    mov      cx,[bp].BufSize         ;load CX with buffer size
    rep      stosw                   ;fill the buffer
Bye:mov      sp,bp                   ;restore original stack pointer
    pop      bp                      ; and caller&#146;s BP
    ret      EndMrk-RetAddr-2        ;return, clearing the parms from the stack
ClearS       endp
</PRE>
<!-- END CODE //-->
<P>The first thing you&#146;ll notice about Listing 22.1 is that <B>ClearS</B> uses a <B>REP STOSW</B> instruction. That means that we&#146;re not going to improve performance by any great amount, no matter how clever we are. While we can eliminate some cycles, the bulk of the work in <B>ClearS</B> is done by that one repeated string instruction, and there&#146;s no way to improve on that.</P>
<P>Does that mean that Listing 22.1 is as good as it can be? Hardly. While the speed of <B>ClearS</B> is very good, there&#146;s another side to the optimization equation: size. The whole of <B>ClearS</B> is 52 bytes long as it stands&#151;but, as we&#146;ll see, that size is hardly set in stone.</P>
<P>Where do we begin with <B>ClearS</B>? For starters, there&#146;s an instruction in there that serves no earthly purpose&#151;<B>MOV SP,BP</B>. SP is guaranteed to be equal to BP at that point anyway, so why reload it with the same value? Removing that instruction saves us two bytes.</P>
<P>Well, that was certainly easy enough! We&#146;re not going to find any more totally non-functional instructions in <B>ClearS</B>, however, so let&#146;s get on to some serious optimizing. We&#146;ll look first for cases where we know of better instructions for particular tasks than those that were chosen. For example, there&#146;s no need to load any register, whether segment or general, through BX; we can eliminate two instructions by loading ES and DI directly as shown in Listing 22.2.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="21-05.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="22-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Graphics Programming Black Book &copy; 2001 Michael Abrash</font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


