<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Looking Past Face Value</title>
  <meta name="chapter" content="06" />
  <meta name="pages" content="125-129" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td>
          <a href="05-05.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="06-02.html">Next</a>
        </td>
      </tr>
    </table>
  </center>

  <h2 id="Heading1">Chapter 6<br />
  Looking Past Face Value</h2>

  <h3 id="Heading2">How Machine Instructions May Do More Than You Think</h3>

  <p>I first met Jeff Duntemann at an authors&rsquo; dinner hosted by <i>PC Tech Journal</i> at Fall Comdex, back in 1985. Jeff was already reasonably well-known as a computer editor and writer, although not as famous as <i>Complete Turbo Pascal</i>, editions 1 through 672 (or thereabouts), <i>TURBO TECHNIX</i>, and <i>PC TECHNIQUES</i> would soon make him. I was fortunate enough to be seated next to Jeff at the dinner table, and, not surprisingly, our often animated conversation revolved around computers, computer writing, and more computers (not necessarily in that order).</p>

  <p>Although I was making a living at computer work and enjoying it at the time, I nonetheless harbored vague ambitions of being a science-fiction writer when I grew up. (I have since realized that this hardly puts me in elite company, especially in the computer world, where it seems that every other person has told me they plan to write science fiction &ldquo;someday.&rdquo; Given that probably fewer than 500&mdash;I&rsquo;m guessing here&mdash;original science fiction and fantasy short stories, and perhaps a few more novels than that, are published each year in this country, I see a few mid-life crises coming.)</p>

  <p>At any rate, I had accumulated a small collection of rejection slips, and fancied myself something of an old hand in the field. At the end of the dinner, as the other writers complained half-seriously about how little they were paid for writing for <i>Tech Journal</i>, I leaned over to Jeff and whispered, &ldquo;You know, the pay isn&rsquo;t so bad here. You should see what they pay for science fiction&mdash;even to the guys who win awards!&rdquo;</p>

  <p>To which Jeff replied, &ldquo;I know. I&rsquo;ve been nominated for two Hugos.&rdquo;</p>

  <p>Oh.</p>

  <p>Had I known I was seated next to a real, live science-fiction writer&mdash;an <i>award-nominated</i> writer, by God!&mdash;I would have pumped him for all I was worth, but the possibility had never occurred to me. I was at a dinner put on by a computer magazine, seated next to an editor who had just finished a book about Turbo Pascal, and, gosh, it was <i>obvious</i> that the appropriate topic was computers.</p>

  <p>For once, the moral is <i>not</i> &ldquo;don&rsquo;t judge a book by its cover.&rdquo; Jeff is in fact what he appeared to be at face value: a computer writer and editor. However, he is more, too; face value wasn&rsquo;t full value. You&rsquo;ll similarly find that face value isn&rsquo;t always full value in computer programming, and especially so when working in assembly language, where many instructions have talents above and beyond their obvious abilities.</p>

  <p>On the other hand, there are also a number of instructions, such as <b>LOOP</b>, that are designed to perform specific functions but aren&rsquo;t always the best instructions for those functions. So don&rsquo;t judge a book by its cover, either.</p>

  <p>Assembly language for the x86 family isn&rsquo;t like any other language (for which we should, without hesitation, offer our profuse thanks). Assembly language reflects the design of the processor rather than the way we think, so it&rsquo;s full of multiple instructions that perform similar functions, instructions with odd and often confusing side effects, and endless ways to string together different instructions to do much the same things, often with seemingly minuscule differences that can turn out to be surprisingly important.</p>

  <p>To produce the best code, you must decide precisely what you need to accomplish, then put together the sequence of instructions that accomplishes that end most efficiently, regardless of what the instructions are usually used for. That&rsquo;s why optimization for the PC is an art, and it&rsquo;s why the best assembly language for the x86 family will almost always handily outperform compiled code. With that in mind, let&rsquo;s look past face value&mdash;and while we&rsquo;re at it, I&rsquo;ll toss in a few examples of not judging a book by its cover.</p>

  <p>The point to all this: You must come to regard the x86 family instructions for what they do, not what you&rsquo;re used to thinking they do. Yes, <b>SHL</b> shifts a pattern left&mdash;but a look-up table can do the same thing, and can often do it faster. <b>ADD</b> can indeed add two operands, but it can&rsquo;t put the result in a third register; <b>LEA</b> can. The instruction set is your raw material for writing high-performance code. By limiting yourself to thinking only in certain well-established ways about the various instructions, you&rsquo;re putting yourself at a substantial disadvantage every time you sit down to program.</p>

  <p>In short, the x86 family can do much more than you think&mdash;if you&rsquo;ll use everything it has to offer. Give it a shot!</p>

  <h4 id="Heading3">Memory Addressing and Arithmetic</h4>

  <p>Years ago, I saw a clip on the David Letterman show in which Letterman walked into a store by the name of &ldquo;Just Lamps&rdquo; and asked, &ldquo;So what do you sell here?&rdquo;</p>

  <p>&ldquo;Lamps,&rdquo; he was told. &ldquo;Just lamps. Can&rsquo;t you read?&rdquo;</p>

  <p>&ldquo;Lamps,&rdquo; he said. &ldquo;I see. And what else?&rdquo;</p>

  <p>From that bit of sublime idiocy we can learn much about divining the full value of an instruction. To wit:</p>

  <p>Quick, what do the x86&rsquo;s memory addressing modes do?</p>

  <p>&ldquo;Calculate memory addresses,&rdquo; you no doubt replied. And you&rsquo;re right, of course. But what <i>else</i> do they do?</p>

  <p>They perform arithmetic, that&rsquo;s what they do, and that&rsquo;s a distinctly different and often useful perspective on memory address calculations.</p>

  <p>For example, suppose you have an array base address in BX and an index into the array in SI. You could add the two registers together to address memory, like this:</p>
  <pre>
add  bx,si
mov  al,[bx]
</pre>

  <p>Or you could let the processor do the arithmetic for you in a single instruction:</p>
  <pre>
mov  al,[bx+si]
</pre>

  <center>
    <table border="1">
      <tr>
        <td>
          <a href="05-05.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="06-02.html">Next</a>
        </td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
