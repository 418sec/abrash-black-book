<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Pentium Rules</title><!-- HEADER -->
  <!-- Empty Reference Subhead -->
  <!--ISBN=1576101746//-->
  <!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
  <!--AUTHOR=Michael Abrash//-->
  <!--PUBLISHER=The Coriolis Group, Inc.//-->
  <!--CHAPTER=20//-->
  <!--PAGES=393-396//-->
  <!--UNASSIGNED1//-->
  <!--UNASSIGNED2//-->
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="20-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="21-01.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p>However, this beneficial pairing does not extend to non-<b>MOV</b> instructions with explicit memory destination operands, such as <b>ADD [EBX],EAX</b>. The Pentium executes only one such memory instruction at a time; if two memory-destination complex instructions get paired, first the U-pipe instruction is executed, and then the V-pipe instruction, with only one cycle of overlap, as shown in Figure 20.6. I don&rsquo;t know for sure, but I&rsquo;d guess that this is to guarantee that the two pipes will never perform out-of-order access to any given memory location. Thus, even though <b>AND [EBX],AL</b> pairs with <b>AND [ECX],DL</b>, the two instructions take 5 cycles in all to execute, and 4 cycles of idle time&mdash;2 in the U-pipe and 2 in the V-pipe, out of 10 cycles in all&mdash;are incurred in the process.</p>

  <p><a id="Fig6"><!-- </A><A HREF="javascript:displayWindow('images/20-06.jpg',407,306 )"> --><img src="images/20-06.jpg" /><br />
  <!-- </A>
<BR><A HREF="javascript:displayWindow('images/20-06.jpg',407,306)"> --><b>Figure 20.6</b></a>&nbsp;&nbsp;<i>Non-overlapped lockstep execution.</i></p>

  <p><a id="Fig7"><!-- </A><A HREF="javascript:displayWindow('images/20-07.jpg',411,287 )"> --><img src="images/20-07.jpg" /><br />
  <!-- </A>
<BR><A HREF="javascript:displayWindow('images/20-07.jpg',411,287)"> --><b>Figure 20.7</b></a>&nbsp;&nbsp;<i>Interleaving simple instructions for maximum performance.</i></p>

  <p>The solution is to break the instructions into simple instructions and interleave them, as shown in Figure 20.7, which accomplishes the same task in 3 cycles, with no idle cycles whatsoever. Figure 20.7 is a good example of what optimized Pentium code generally looks like: mostly one-cycle instructions, mixed together so that at least two operations are in progress at once. It&rsquo;s not the easiest code to read or write, but it&rsquo;s the only way to get both pipes running at capacity.</p>

  <h3><a id="Heading6"></a>Superscalar Notes</h3>

  <p>You may well ask why it&rsquo;s necessary to interleave operations, as is done in Figure 20.7. It seems simpler just to turn</p><!-- CODE SNIP //-->
  <pre>
and [ebx],al
</pre><!-- END CODE SNIP //-->

  <p>into</p><!-- CODE SNIP //-->
  <pre>
mov   dl,[ebx]
and   dl,al
mov   [ebx],dl
</pre><!-- END CODE SNIP //-->

  <p>and be done with it. The problem here is one of dependency. Before the Pentium can execute <b>AND DL,AL,</b>, it must first know what is in DL, and it can&rsquo;t know that until it loads DL from the address pointed to by EBX. Therefore, <b>AND DL,AL</b> can&rsquo;t happen until the cycle after <b>MOV DL,[EBX]</b> executes. Likewise, the result can&rsquo;t be stored until the cycle after <b>AND DL,AL</b> has finished. This means that these instructions, as written, can&rsquo;t possibly pair, so the sequence takes the same three cycles as <b>AND [EBX],AL</b>. (Now it should be clear why <b>AND [EBX]</b>, AL takes 3 cycles.) Consequently, it&rsquo;s necessary to interleave these instructions with instructions that use other registers, so this set of operations can execute in one pipe while the other, unrelated set executes in the other pipe, as is done in Figure 20.7.</p>

  <p>What we&rsquo;ve just seen is the read-after-write form of the superscalar hazard known as <i>register contention</i>. I&rsquo;ll return to the subject of register contention in the next chapter; in the remainder of this chapter I&rsquo;d like to cover a few short items about superscalar execution.</p>

  <h4 align="left"><a id="Heading7"></a>Register Starvation</h4>

  <p>The above examples should make it pretty clear that effective superscalar programming puts a lot of strain on the Pentium&rsquo;s relatively small register set. There are only seven general-purpose registers (I strongly suggest using EBP in critical loops), and it does not help to have to sacrifice one of those registers for temporary storage on each complex memory operation; in pre-superscalar days, we used to employ those handy CISC memory instructions to do all that stuff without using any extra registers.</p>

  <table width="100%">
    <tr>
      <td valign="top" align="left" width="5%"><img src="images/i.jpg" /></td>

      <td valign="top" align="left" width="95%"><small><i>More problematic still is that for maximum pairing, you&rsquo;ll typically have two operations proceeding at once, one in each pipe, and trying to keep two operations in registers at once is difficult indeed. There&rsquo;s not much to be done about this, other than clever and Spartan register usage, but be aware that it&rsquo;s a major element of Pentium performance programming.</i></small></td>
    </tr>
  </table>

  <p>Also be aware that prefixes of every sort, with the sole exception of the 0FH prefix on non-short conditional jumps, always execute in the U-pipe, and that Intel&rsquo;s documentation indicates that no pairing can happen while a prefix byte executes. (As I&rsquo;ll discuss in the next chapter, my experiments indicate that this rule doesn&rsquo;t always apply to multiple-cycle instructions, but you still won&rsquo;t go far wrong by assuming that the above rule is correct and trying to eliminate prefix bytes.) A prefix byte takes one cycle to execute; after that cycle, the actual prefixed instruction itself will go through the U-pipe, and if it and the following instruction are mutually pairable, then they will pair. Nonetheless, prefix bytes are very expensive, effectively taking at least as long as two normal instructions, and possibly, if a prefixed instruction could otherwise have paired in the V-pipe with the previous instruction, taking as long as three normal instructions, as shown in Figure 20.8.</p>

  <p>Finally, bear in mind that if the instructions being executed have not already been executed at least once since they were loaded into the internal cache, they can pair only if the first (U-pipe) instruction is not only pairable but also exactly 1 byte long, a category that includes only <b>INC <i>reg</i>, DEC <i>reg</i>, PUSH <i>reg</i></b>, and <b>POP <i>reg</i></b>. Knowing this can help you understand why sometimes, timing reveals that your code runs slower than it seems it should, although this will generally occur only when the cache working set for the code you&rsquo;re timing is on the order of 8K or more&mdash;an awful lot of code to try to optimize.</p>

  <p>It should be excruciatingly clear by this point that you <i>must</i> time your Pentium-optimized code if you&rsquo;re to have any hope of knowing if your optimizations are working as well as you think they are; there are just too many details involved for you to be sure your optimizations are working properly without checking. My most basic optimization rule has always been to grab the Zen timer and <i>measure actual performance</i>&mdash;and nowhere is this more true than on the Pentium. Don&rsquo;t believe it until you measure it!</p>

  <p><a id="Fig8"><!-- </A><A HREF="javascript:displayWindow('images/20-08.jpg',410,247 )"> --><img src="images/20-08.jpg" /><br />
  <!-- </A>
<BR><A HREF="javascript:displayWindow('images/20-08.jpg',410,247)"> --><b>Figure 20.8</b></a>&nbsp;&nbsp;<i>Prefix delays.</i></p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="20-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="21-01.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div><!-- all of the reference materials (books) have the footer and subfoot reveresed -->
  <!-- reference_subfoot = footer -->
  <!-- reference_footer = subfoot -->
  <!-- BEGIN SUB FOOTER -->
  <!-- END FOOTER -->
</body>
</html>
