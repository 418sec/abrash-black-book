<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: Assume Nothing</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=03//-->
<!--PAGES=031-035//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><BODY LINK=#0000FF ALINK=#000099 VLINK=#0000FF BGCOLOR=#FFFFFF>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="02-03.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="03-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H2><A NAME="Heading1"></A><FONT COLOR="#000077">Chapter 3<BR>Assume Nothing
</FONT></H2>
<H3><A NAME="Heading2"></A><FONT COLOR="#000077">Understanding and Using the Zen Timer</FONT></H3>
<P>When you&#146;re pushing the envelope in writing optimized PC code, you&#146;re likely to become more than a little compulsive about finding approaches that let you wring more speed from your computer. In the process, you&#146;re bound to make mistakes, which is fine&#151;as long as you watch for those mistakes and <I>learn</I> from them.</P>
<P>A case in point: A few years back, I came across an article about 8088 assembly language called &#147;Optimizing for Speed.&#148; Now, &#147;optimize&#148; is not a word to be used lightly; <I>Webster&#146;s Ninth New Collegiate Dictionary</I> defines optimize as &#147;to make as perfect, effective, or functional as possible,&#148; which certainly leaves little room for error. The author had, however, chosen a small, well-defined 8088 assembly language routine to refine, consisting of about 30 instructions that did nothing more than expand 8 bits to 16 bits by duplicating each bit.</P>
<P>The author of &#147;Optimizing&#148; had clearly fine-tuned the code with care, examining alternative instruction sequences and adding up cycles until he arrived at an implementation he calculated to be nearly 50 percent faster than the original routine. In short, he had used all the information at his disposal to improve his code, and had, as a result, saved cycles by the bushel. There was, in fact, only one slight problem with the optimized version of the routine....</P>
<P>It ran slower than the original version!</P>
<H3><A NAME="Heading3"></A><FONT COLOR="#000077">The Costs of Ignorance</FONT></H3>
<P>As diligent as the author had been, he had nonetheless committed a cardinal sin of x86 assembly language programming: He had assumed that the information available to him was both correct and complete. While the execution times provided by Intel for its processors are indeed correct, they are incomplete; the other&#151;and often more important&#151;part of code performance is instruction <I>fetch</I> time, a topic to which I will return in later chapters.</P>
<P>Had the author taken the time to measure the true performance of his code, he wouldn&#146;t have put his reputation on the line with relatively low-performance code. What&#146;s more, had he actually measured the performance of his code and found it to be unexpectedly slow, curiosity might well have led him to experiment further and thereby add to his store of reliable information about the CPU.</P>
<TABLE WIDTH="100%"><TD WIDTH="5%" VALIGN="TOP"><IMG SRC="images/03-01i.jpg"><TD WIDTH="95%" VALIGN="TOP"><I><SMALL>There you have an important tenet of assembly language optimization: After crafting the best code possible, check it in action to see if it&#146;s really doing what you think it is. If it&#146;s not behaving as expected, that&#146;s all to the good, since solving mysteries is the path to knowledge. You&#146;ll learn more in this way, I assure you, than from any manual or book on assembly language.</I></SMALL>
</TABLE>
<P><I>Assume nothing</I>. I cannot emphasize this strongly enough&#151;when you care about performance, do your best to improve the code and then <I>measure</I> the improvement. If you don&#146;t measure performance, you&#146;re just guessing, and if you&#146;re guessing, you&#146;re not very likely to write top-notch code.</P>
<P>Ignorance about true performance can be costly. When I wrote video games for a living, I spent days at a time trying to wring more performance from my graphics drivers. I rewrote whole sections of code just to save a few cycles, juggled registers, and relied heavily on blurry-fast register-to-register shifts and adds. As I was writing my last game, I discovered that the program ran perceptibly faster if I used look-up tables instead of shifts and adds for my calculations. It <I>shouldn&#146;t</I> have run faster, according to my cycle counting, but it did. In truth, instruction fetching was rearing its head again, as it often does, and the fetching of the shifts and adds was taking as much as four times the nominal execution time of those instructions.</P>
<P>Ignorance can also be responsible for considerable wasted effort. I recall a debate in the letters column of one computer magazine about exactly how quickly text can be drawn on a Color/Graphics Adapter (CGA) screen without causing snow. The letter-writers counted every cycle in their timing loops, just as the author in the story that started this chapter had. Like that author, the letter-writers had failed to take the prefetch queue into account. In fact, they had neglected the effects of video wait states as well, so the code they discussed was actually <I>much</I> slower than their estimates. The proper test would, of course, have been to run the code to see if snow resulted, since the only true measure of code performance is observing it in action.</P>
<H3><A NAME="Heading4"></A><FONT COLOR="#000077">The Zen Timer</FONT></H3>
<P>Clearly, one key to mastering Zen-class optimization is a tool with which to measure code performance. The most accurate way to measure performance is with expensive hardware, but reasonable measurements at no cost can be made with the PC&#146;s 8253 timer chip, which counts at a rate of slightly over 1,000,000 times per second. The 8253 can be started at the beginning of a block of code of interest and stopped at the end of that code, with the resulting count indicating how long the code took to execute with an accuracy of about 1 microsecond. (A microsecond is one millionth of a second, and is abbreviated &#181;s). To be precise, the 8253 counts once every 838.1 nanoseconds. (A nanosecond is one billionth of a second, and is abbreviated ns.)
</P>
<P>Listing 3.1 shows 8253-based timer software, consisting of three subroutines: <B>ZTimerOn, ZTimerOff</B>, and <B>ZTimerReport</B>. For the remainder of this book, I&#146;ll refer to these routines collectively as the &#147;Zen timer.&#148; C-callable versions of the two precision Zen timers are presented in Chapter K on the companion CD-ROM.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="02-03.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="03-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Graphics Programming Black Book &copy; 2001 Michael Abrash</font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


