<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: The Game of Life</title><!-- HEADER -->
  <!-- Empty Reference Subhead -->
  <!--ISBN=1576101746//-->
  <!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
  <!--AUTHOR=Michael Abrash//-->
  <!--PUBLISHER=The Coriolis Group, Inc.//-->
  <meta name="chapter" content="17" />
  <meta name="pages" content="345-346" />
  <!--UNASSIGNED1//-->
  <!--UNASSIGNED2//-->
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="17-07.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="18-01.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p>The large model is actually not necessary for the 96x96 cellmap in Listing 17.5. However, I was actually more interested in seeing a fast 200x200 cellmap, and two 200x200 cellmaps can&rsquo;t fit in a single segment. (This can easily be worked around in assembly language for cellmaps up to a segment in size; beyond that size, cellmap scanning becomes pretty complex, although it can still be efficiently implemented with some clever programming.)</p>

  <p>Anyway, using the large model helps illustrate that it&rsquo;s the data representation and the data processing approach you choose that matter most. Optimization details like memory models and segments and in-line functions and assembly language are important but secondary. Let your mind roam creatively before you start coding. Otherwise, you may find you&rsquo;re writing well-tuned slow code, which is by no means the same thing as fast code.</p>

  <p>Take a close look at Listing 17.5. You will see that it&rsquo;s quite a bit simpler than Listing 17.4. To some extent, that&rsquo;s because I decided to hard-wire the program to wrap around from one edge of the cellmap to the other (it&rsquo;s much more interesting that way), but the main reason is that it&rsquo;s a lot easier to work with the neighbor-count model. There&rsquo;s no complex mask and pointer management, and the only thing that <i>really</i> needs to be optimized is scanning for zero bytes. (And, in fact, I haven&rsquo;t optimized even that because it&rsquo;s done in a C<small>++</small> loop; it should really be <b>REPZ SCASB.</b>)</p>

  <p>In truth, none of the code in Listing 17.5 is particularly well-optimized, and, as I noted, the program must be compiled with the large model for large cellmaps. Also, of course, the entire program is still in C<small>++</small>; note well that there&rsquo;s not a whit of assembly here.</p>

  <table width="100%">
    <tr>
      <td valign="top" align="left" width="5%"><img src="images/i.jpg" /></td>

      <td valign="top" align="left" width="95%"><i><small>We&rsquo;ve gotten more than a 30-times speedup simply by removing a little of the abstraction that C<small>++</small> encourages, and by storing and processing the data in a manner appropriate for the typical nature of the data itself. In other words, we&rsquo;ve done some linear, left-brained optimization (using pointers and reducing calls) and some non-linear, right-brained optimization (understanding the real problem and listening for the creative whisper of non-obvious solutions).</small></i></td>
    </tr>
  </table>

  <p>No doubt we could get another two to five times improvement with good assembly code&mdash;but that&rsquo;s dwarfed by a 30-times improvement, so optimization at a conceptual level <i>must</i> come first.</p>

  <h4 align="left"><a id="Heading11"></a>The Challenge That Ate My Life</h4>

  <p>The most recent optimization challenge I laid my community of readers was to write the fastest possible Game of Life generation engine. By &ldquo;engine&rdquo; I meant that I didn&rsquo;t care about time spent in input or output, only time consumed by the call to <b>next-generation.</b> The time spent updating the cellmap was what I wanted people to concentrate on.</p>

  <p>Here are the rules I laid down for the challenge:</p>

  <ul>
    <li>Readers could modify any code in Listing 17.5, except the main loop, as well as change the cell map representation any way they liked. However, the code had to produce exactly the same output as Listing 17.5 under all circumstances in order to be eligible to win.</li>

    <li>Engine code had to be less than 400 lines long <i>in total,</i> excluding the video-related code shown in Listing 17.2.</li>

    <li>Submissions had to compile/assemble with Borland C<small>++</small> (in either C<small>++</small> or C mode, as desired) and/or TASM.</li>

    <li>All submissions had to handle cellmaps at least 200x200 in size.</li>

    <li>Assembly language could of course be used to speed up any part of the program. C rather than C<small>++</small> was legal as well, so long as entered implementations produced the same results as Listing 17.5 and 17.2 together and were less than 400 lines long.</li>

    <li>All entries would be timed on the same 33 MHz 486 with a 256K external cache.</li>
  </ul>

  <p>That was the challenge I put to the readers. Little did I realize the challenge it would lay on <i>me:</i> Entries poured in from the four corners of the globe. Some were plain, some were brilliant, some were, well, berserk. Many didn&rsquo;t even work. But all had to be gone through, examined for adherence to the rules, read, compiled, linked, run, and judged. I learned a lot&mdash;about a lot of things, not the least of which was the process (or maybe the wisdom) of laying down challenges to readers.</p>

  <p>Who won? What did I learn? To find out, read on.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="17-07.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="18-01.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div><!-- all of the reference materials (books) have the footer and subfoot reveresed -->
  <!-- reference_subfoot = footer -->
  <!-- reference_footer = subfoot -->
  <!-- BEGIN SUB FOOTER -->
  <!-- END FOOTER -->
</body>
</html>
