<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: The Good, the Bad, and the Run-Sliced</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=36//-->
<!--PAGES=679-683//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><BODY LINK=#0000FF ALINK=#000099 VLINK=#0000FF BGCOLOR=#FFFFFF>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="35-07.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="36-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H2><A NAME="Heading1"></A><FONT COLOR="#000077">Chapter 36<BR>The Good, the Bad, and the Run-Sliced
</FONT></H2>
<H3><A NAME="Heading2"></A><FONT COLOR="#000077">Faster Bresenham Lines with Run-Length Slice Line Drawing</FONT></H3>
<P>Years ago, I worked at a company that asked me to write blazingly fast line-drawing code for an AutoCAD driver. I implemented the basic Bresenham&rsquo;s line-drawing algorithm; streamlined it as much as possible; special-cased horizontal, diagonal, and vertical lines; broke out separate, optimized routines for lines in each octant; and massively unrolled the loops. When I was done, I had line drawing down to a mere five or six instructions per pixel, and I handed the code over to the AutoCAD driver person, content in the knowledge that I had pushed the theoretical limits of the Bresenham&rsquo;s algorithm on the 80x86 architecture, and that this was as fast as line drawing could get on a PC. That feeling lasted for about a week, until Dave Miller, who these days is a Windows display-driver whiz at Engenious Solutions, casually mentioned Bresenham&rsquo;s faster run-length slice line-drawing algorithm.
</P>
<P>Remember Bill Murray&rsquo;s safety tip in <I>Ghostbusters</I>? It goes something like this. Harold Ramis tells the Ghostbusters not to cross the beams of the antighost guns. &ldquo;Why?&rdquo; Murray asks.</P>
<P>&ldquo;It would be bad,&rdquo; Ramis says.</P>
<P>Murray says, &ldquo;I&rsquo;m fuzzy on the whole good/bad thing. What exactly do you mean by &lsquo;bad&rsquo;?&rdquo; It turns out that what Ramis means by bad is basically the destruction of the universe.</P>
<P>&ldquo;Important safety tip,&rdquo; Murray comments dryly.</P>
<P>I learned two important safety tips from my line-drawing experience; neither involves the possible destruction of the universe, so far as I know, but they are nonetheless worth keeping in mind. First, never, never, never think you&rsquo;ve written the fastest possible code. Odds are, you haven&rsquo;t. Run your code past another good programmer, and he or she will probably say, &ldquo;But why don&rsquo;t you do this?&rdquo; and you&rsquo;ll realize that you could indeed do that, and your code would then be faster. Or relax and come back to your code later, and you may well see another, faster approach. There are a million ways to implement code for any task, and you can almost always find a faster way if you need to.</P>
<P>Second, when performance matters, never have your code perform the same calculation more than once. This sounds obvious, but it&rsquo;s astonishing how often it&rsquo;s ignored. For example, consider this snippet of code:</P>
<!-- CODE //-->
<PRE>
for (i=0; i&ltRunLength; i++)
{
   *WorkingScreenPtr = Color;
   if (XDelta &gt 0)
   {
      WorkingScreenPtr++;
   }
   else
   {
      WorkingScreenPtr--;
   }
}

</PRE>
<!-- END CODE //-->
<P>Here, the programmer knows which way the line is going before the main loop begins&mdash;but nonetheless performs that test every time through the loop, when calculating the address of the next pixel. Far better to perform the test only once, outside the loop, as shown here:
</P>
<!-- CODE //-->
<PRE>
if (XDelta &gt 0)
{
   for (i=0; i&ltRunLength; i++)
   {
      *WorkingScreenPtr++ = Color;
   }
}
else
{
   for (i=0; i&ltRunLength; i++)
   {
      *WorkingScreenPtr-- = Color;
   }
}

</PRE>
<!-- END CODE //-->
<P>Think of it this way: A program is a state machine. It takes a set of inputs and produces a corresponding set of outputs by passing through a set of states. Your primary job as a programmer is to implement the desired state machine. Your additional job as a performance programmer is to minimize the lengths of the paths through the state machine. This means performing as many tests and calculations as possible outside the loops, so that the loops themselves can do as little work&mdash;that is, pass through as few states&mdash;as possible.
</P>
<P>Which brings us full circle to Bresenham&rsquo;s run-length slice line-drawing algorithm, which just happens to be an excellent example of a minimized state machine. In case you&rsquo;re fuzzy on the good/bad performance thing, that&rsquo;s &ldquo;good&rdquo;&mdash;as in <I>fast</I>.</P>
<H3><A NAME="Heading3"></A><FONT COLOR="#000077">Run-Length Slice Fundamentals</FONT></H3>
<P>First off, I have a confession to make: I&rsquo;m not sure that the algorithm I&rsquo;ll discuss is actually, precisely Bresenham&rsquo;s run-length slice algorithm. It&rsquo;s been a long time since I read about this algorithm; in the intervening years, I&rsquo;ve misplaced Bresenham&rsquo;s article, and have been unable to unearth it. As a result, I had to derive the algorithm from scratch, which was admittedly more fun than reading about it, and also ensured that I understood it inside and out. The upshot is that what I discuss may or may not be Bresenham&rsquo;s run-length slice algorithm&mdash;but it surely is fast.
</P>
<P>The place to begin understanding the run-length slice algorithm is the standard Bresenham&rsquo;s line-drawing algorithm. (I discussed the standard Bresenham&rsquo;s line-drawing algorithm at length in the previous chapter.) The basis of the standard approach is stepping one pixel at a time along the major axis (the longer dimension of the line), while maintaining an integer error term that indicates at each major-axis step how close the line is to advancing halfway to the next pixel along the minor axis. Figure 36.1 illustrates standard Bresenham&rsquo;s line drawing. The key point here is that a calculation and a test are performed once for each step along the major axis.</P>
<P><A NAME="Fig1"><!-- </A><A HREF="javascript:displayWindow('images/36-01.jpg',408,194 )"> --><IMG SRC="images/36-01.jpg"><BR><!-- </A>
<BR><A HREF="javascript:displayWindow('images/36-01.jpg',408,194)"> --><FONT COLOR="#000077"><B>Figure 36.1</B></FONT></A>&nbsp;&nbsp;<I>Standard Bresenham&rsquo;s line drawing.</I>
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="35-07.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="36-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Graphics Programming Black Book &copy; 2001 Michael Abrash</font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


