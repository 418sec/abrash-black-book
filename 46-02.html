<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Who Was that Masked Image?</title><!-- HEADER -->
  <!-- Empty Reference Subhead -->
  <!--ISBN=1576101746//-->
  <!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
  <!--AUTHOR=Michael Abrash//-->
  <!--PUBLISHER=The Coriolis Group, Inc.//-->
  <meta name="chapter" content="46" />
  <meta name="pages" content="863-871" />
  <!--UNASSIGNED1//-->
  <!--UNASSIGNED2//-->
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="46-01.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="46-03.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p><b>LISTING 46.1 L46-1.C</b></p><!-- CODE //-->
  <pre>
/* Sample simple dirty-rectangle animation program, partially optimized and
   featuring internal animation, masked images (sprites), and nonoverlapping dirty
   rectangle copying. Tested with Borland C++ in the small model. */

#include &lt;stdlib.h&gt;
#include &lt;conio.h&gt;
#include &lt;alloc.h&gt;
#include &lt;memory.h&gt;
#include &lt;dos.h&gt;

/* Comment out to disable overlap elimination in the dirty rectangle list. */
#define CHECK-OVERLAP 1
#define SCREEN-WIDTH  320
#define SCREEN-HEIGHT 200
#define SCREEN-SEGMENT 0xA000

/* Describes a dirty rectangle */
typedef struct {
   void *Next;    /* pointer to next node in linked dirty rect list */
   int Top;
   int Left;
   int Right;
   int Bottom;
} DirtyRectangle;
/* Describes an animated object */
typedef struct {
   int X;            /* upper left corner in virtual bitmap */
   int Y;
   int XDirection;   /* direction and distance of movement */
   int YDirection;
   int InternalAnimateCount; /* tracking internal animation state */
   int InternalAnimateMax;   /* maximum internal animation state */
} Entity;
/* storage used for dirty rectangles */
#define MAX-DIRTY-RECTANGLES  100
int NumDirtyRectangles;
DirtyRectangle DirtyRectangles[MAX-DIRTY-RECTANGLES];
/* head/tail of dirty rectangle list */
DirtyRectangle DirtyHead;
/* If set to 1, ignore dirty rectangle list and copy the whole screen. */
int DrawWholeScreen = 0;
/* pixels and masks for the two internally animated versions of the image
   we&rsquo;ll animate */
#define IMAGE-WIDTH  13
#define IMAGE-HEIGHT 11
char ImagePixels0[] = {
   0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0,
   0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
   0, 9, 9, 0, 0,14,14,14, 9, 9, 0, 0, 0,
   9, 9, 0, 0, 0, 0,14,14,14, 9, 9, 0, 0,
   9, 9, 0, 0, 0, 0,14,14,14, 9, 9, 0, 0,
   9, 9,14, 0, 0,14,14,14,14, 9, 9, 0, 0,
   9, 9,14,14,14,14,14,14,14, 9, 9, 0, 0,
   9, 9,14,14,14,14,14,14,14, 9, 9, 0, 0,
   0, 9, 9,14,14,14,14,14, 9, 9, 0, 0, 0,
   0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
   0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0,
};
char ImageMask0[] = {
   0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
   0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
   0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0,
   1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
   1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
   1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
   0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,
   0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
   0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
};
char ImagePixels1[] = {
   0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 9,
   0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 9, 9, 9,
   0, 9, 9, 0, 0,14,14,14, 9, 9, 9, 9, 0,
   9, 9, 0, 0, 0, 0,14,14,14, 0, 0, 0, 0,
   9, 9, 0, 0, 0, 0,14,14, 0, 0, 0, 0, 0,
   9, 9,14, 0, 0,14,14,14, 0, 0, 0, 0, 0,
   9, 9,14,14,14,14,14,14, 0, 0, 0, 0, 0,
   9, 9,14,14,14,14,14,14,14, 0, 0, 0, 0,
   0, 9, 9,14,14,14,14,14, 9, 9, 9, 9, 0,
   0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 9, 9, 9,
   0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 9, 9,
};
char ImageMask1[] = {
   0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,
   0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1,
   0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0,
   1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
   1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
   1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,
   1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
   0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
   0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1,
   0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
};
/* Pointers to pixel and mask data for various internally animated
   versions of our animated image. */
char * ImagePixelArray[] = {ImagePixels0, ImagePixels1};
char * ImageMaskArray[] = {ImageMask0, ImageMask1};
/* Animated entities */
#define NUM-ENTITIES 15
Entity Entities[NUM-ENTITIES];
/* pointer to system buffer into which we&rsquo;ll draw */
char far *SystemBufferPtr;
/* pointer to screen */
char far *ScreenPtr;
void EraseEntities(void);
void CopyDirtyRectanglesToScreen(void);
void DrawEntities(void);
void AddDirtyRect(Entity *, int, int);
void DrawMasked(char far *, char *, char *, int, int, int);
void FillRect(char far *, int, int, int, int);
void CopyRect(char far *, char far *, int, int, int, int);

void main()
{
   int i, XTemp, YTemp;
   unsigned int TempCount;
   char far *TempPtr;
   union REGS regs;
   /* Allocate memory for the system buffer into which we&rsquo;ll draw */
   if (!(SystemBufferPtr = farmalloc((unsigned int)SCREEN-WIDTH*
         SCREEN-HEIGHT))) {
      printf(&rdquo;Couldn&rsquo;t get memory\n&rdquo;);
      exit(1);
   }
   /* Clear the system buffer */
   TempPtr = SystemBufferPtr;
   for (TempCount = ((unsigned)SCREEN-WIDTH*SCREEN-HEIGHT); TempCount--; ) {
      *TempPtr++ = 0;
   }
   /* Point to the screen */
   ScreenPtr = MK-FP(SCREEN-SEGMENT, 0);
   /* Set up the entities we&rsquo;ll animate, at random locations */
   randomize();
   for (= 0; &lt; NUM-ENTITIES; i++) {
      Entities[i].X = random(SCREEN-WIDTH - IMAGE-WIDTH);
      Entities[i].Y = random(SCREEN-HEIGHT - IMAGE-HEIGHT);
      Entities[i].XDirection = 1;
      Entities[i].YDirection = -1;
      Entities[i].InternalAnimateCount = &amp; 1;
      Entities[i].InternalAnimateMax = 2;
   }
   /* Set the dirty rectangle list to empty, and set up the head/tail node
      as a sentinel */
   NumDirtyRectangles = 0;
   DirtyHead.Next = &amp;DirtyHead;
   DirtyHead.Top = 0x7FFF;
   DirtyHead.Left= 0x7FFF;
   DirtyHead.Bottom = 0x7FFF;
   DirtyHead.Right = 0x7FFF;
   /* Set 320x200 256-color graphics mode */
   regs.x.ax = 0x0013;
   int86(0x10, &amp;regs, &amp;regs);
   /* Loop and draw until a key is pressed */
   do {
      /* Draw the entities to the system buffer at their current locations,
         updating the dirty rectangle list */
      DrawEntities();
      /* Draw the dirty rectangles, or the whole system buffer if
         appropriate */
      CopyDirtyRectanglesToScreen();
      /* Reset the dirty rectangle list to empty */
      NumDirtyRectangles = 0;
      DirtyHead.Next = &amp;DirtyHead;
      /* Erase the entities in the system buffer at their old locations,
         updating the dirty rectangle list */
      EraseEntities();
      /* Move the entities, bouncing off the edges of the screen */
      for (= 0; &lt; NUM-ENTITIES; i++) {
         XTemp = Entities[i].X + Entities[i].XDirection;
         YTemp = Entities[i].Y + Entities[i].YDirection;
         if ((XTemp &lt; 0) || ((XTemp + IMAGE-WIDTH) &gt; SCREEN-WIDTH)) {
            Entities[i].XDirection = -Entities[i].XDirection;
            XTemp = Entities[i].X + Entities[i].XDirection;
         }
         if ((YTemp &lt; 0) || ((YTemp + IMAGE-HEIGHT) &gt; SCREEN-HEIGHT)) {
            Entities[i].YDirection = -Entities[i].YDirection;
            YTemp = Entities[i].Y + Entities[i].YDirection;
         }
         Entities[i].X = XTemp;
         Entities[i].Y = YTemp;
      }
   } while (!kbhit());
   getch();    /* clear the keypress */

   /* Return back to text mode */
   regs.x.ax = 0x0003;
   int86(0x10, &amp;regs, &amp;regs);
}
/* Draw entities at their current locations, updating dirty rectangle list. */
void DrawEntities()
{
   int i;
   char far *RowPtrBuffer;
   char *TempPtrImage;
   char *TempPtrMask;
   Entity *EntityPtr;

   for (= 0, EntityPtr = Entities; &lt; NUM-ENTITIES; i++, EntityPtr++) {
      /* Remember the dirty rectangle info for this entity */
      AddDirtyRect(EntityPtr, IMAGE-HEIGHT, IMAGE-WIDTH);
      /* Point to the destination in the system buffer */
      RowPtrBuffer = SystemBufferPtr + (EntityPtr-&gt;Y * SCREEN-WIDTH) +
            EntityPtr-&gt;X;
      /* Advance the image animation pointer */
      if (++EntityPtr-&gt;InternalAnimateCount &gt;=
            EntityPtr-&gt;InternalAnimateMax) {
         EntityPtr-&gt;InternalAnimateCount = 0;
      }
      /* Point to the image and mask to draw */
      TempPtrImage = ImagePixelArray[EntityPtr-&gt;InternalAnimateCount];
      TempPtrMask = ImageMaskArray[EntityPtr-&gt;InternalAnimateCount];
      DrawMasked(RowPtrBuffer, TempPtrImage, TempPtrMask, IMAGE-HEIGHT,
               IMAGE-WIDTH, SCREEN-WIDTH);
   }
}
/* Copy the dirty rectangles, or the whole system buffer if appropriate,
   to the screen. */
void CopyDirtyRectanglesToScreen()
{
   int i, RectWidth, RectHeight;
   unsigned int Offset;
   DirtyRectangle * DirtyPtr;
   if (DrawWholeScreen) {
      /* Just copy the whole buffer to the screen */
      DrawWholeScreen = 0;
      CopyRect(ScreenPtr, SystemBufferPtr, SCREEN-HEIGHT, SCREEN-WIDTH,
               SCREEN-WIDTH, SCREEN-WIDTH);
   } else {
      /* Copy only the dirty rectangles, in the YX-sorted order in which
         they&rsquo;re linked */
      DirtyPtr = DirtyHead.Next;
      for (= 0; &lt; NumDirtyRectangles; i++) {
         /* Offset in both system buffer and screen of image */
         Offset = (unsigned int) (DirtyPtr-&gt;Top * SCREEN-WIDTH) +
               DirtyPtr-&gt;Left;
         /* Dimensions of dirty rectangle */
         RectWidth = DirtyPtr-&gt;Right - DirtyPtr-&gt;Left;
         RectHeight = DirtyPtr-&gt;Bottom - DirtyPtr-&gt;Top;
         /* Copy a dirty rectangle */
         CopyRect(ScreenPtr + Offset, SystemBufferPtr + Offset,
               RectHeight, RectWidth, SCREEN-WIDTH, SCREEN-WIDTH);
         /* Point to the next dirty rectangle */
         DirtyPtr = DirtyPtr-&gt;Next;
      }
   }
}
/* Erase the entities in the system buffer at their current locations,
   updating the dirty rectangle list. */
void EraseEntities()
{
   int i;
   char far *RowPtr;
   
   for (= 0; &lt; NUM-ENTITIES; i++) {
      /* Remember the dirty rectangle info for this entity */
      AddDirtyRect(&amp;Entities[i], IMAGE-HEIGHT, IMAGE-WIDTH);
      /* Point to the destination in the system buffer */
      RowPtr = SystemBufferPtr + (Entities[i].Y * SCREEN-WIDTH) +
            Entities[i].X;
      /* Clear the rectangle */
      FillRect(RowPtr, IMAGE-HEIGHT, IMAGE-WIDTH, SCREEN-WIDTH, 0);
   }
}
/* Add a dirty rectangle to the list. The list is maintained in top-to-bottom,
   left-to-right (YX sorted) order, with no pixel ever included twice, to minimize
   the number of display memory accesses and to avoid screen artifacts resulting 
   from a large time interval between erasure and redraw for a given object or for
   adjacent objects. The technique used is to check for overlap between the 
   rectangle and all rectangles already in the list. If no overlap is found, the 
   rectangle is added to the list. If overlap is found, the rectangle is broken 
   into nonoverlapping pieces, and the pieces are added to the list by recursive 
   calls to this function. */
   void AddDirtyRect(Entity * pEntity, int ImageHeight, int ImageWidth)
{
   DirtyRectangle * DirtyPtr;
   DirtyRectangle * TempPtr;
   Entity TempEntity;
   int i;
   if (NumDirtyRectangles &gt;= MAX-DIRTY-RECTANGLES) {
      /* Too many dirty rectangles; just redraw the whole screen */
      DrawWholeScreen = 1;
      return;
   }
   /* Remember this dirty rectangle. Break up if necessary to avoid
      overlap with rectangles already in the list, then add whatever
      rectangles are left, in YX sorted order */
#ifdef CHECK-OVERLAP
   /* Check for overlap with existing rectangles */
   TempPtr = DirtyHead.Next;
   for (= 0; &lt; NumDirtyRectangles; i++, TempPtr = TempPtr-&gt;Next) {
      if ((TempPtr-&gt;Left &lt; (pEntity-&gt;X + ImageWidth)) &amp;&amp;
          (TempPtr-&gt;Right &gt; pEntity-&gt;X) &amp;&amp;
          (TempPtr-&gt;Top &lt; (pEntity-&gt;Y + ImageHeight)) &amp;&amp;
          (TempPtr-&gt;Bottom &gt; pEntity-&gt;Y)) {

         /* We&rsquo;ve found an overlapping rectangle. Calculate the
            rectangles, if any, remaining after subtracting out the
            overlapped areas, and add them to the dirty list */
         /* Check for a nonoverlapped left portion */
         if (TempPtr-&gt;Left &gt; pEntity-&gt;X) {
            /* There&rsquo;s definitely a nonoverlapped portion at the left; add
               it, but only to at most the top and bottom of the overlapping
               rect; top and bottom strips are taken care of below */
            TempEntity.X = pEntity-&gt;X;
            TempEntity.Y = max(pEntity-&gt;Y, TempPtr-&gt;Top);
            AddDirtyRect(&amp;TempEntity,
                  min(pEntity-&gt;Y + ImageHeight, TempPtr-&gt;Bottom) -
                  TempEntity.Y,
                        TempPtr-&gt;Left - pEntity-&gt;X);
         }
         /* Check for a nonoverlapped right portion */
         if (TempPtr-&gt;Right &lt; (pEntity-&gt;X + ImageWidth)) {
            /* There&rsquo;s definitely a nonoverlapped portion at the right; add
               it, but only to at most the top and bottom of the overlapping
               rect; top and bottom strips are taken care of below */
            TempEntity.X = TempPtr-&gt;Right;
            TempEntity.Y = max(pEntity-&gt;Y, TempPtr-&gt;Top);
            AddDirtyRect(&amp;TempEntity,
                  min(pEntity-&gt;Y + ImageHeight, TempPtr-&gt;Bottom) -
                  TempEntity.Y,
                  (pEntity-&gt;X + ImageWidth) - TempPtr-&gt;Right);
         }
         /* Check for a nonoverlapped top portion */
         if (TempPtr-&gt;Top &gt; pEntity-&gt;Y) {
            /* There&rsquo;s a top portion that&rsquo;s not overlapped */
            TempEntity.X = pEntity-&gt;X;
            TempEntity.Y = pEntity-&gt;Y;
            AddDirtyRect(&amp;TempEntity, TempPtr-&gt;Top - pEntity-&gt;Y, ImageWidth);
         }
         /* Check for a nonoverlapped bottom portion */
         if (TempPtr-&gt;Bottom &lt; (pEntity-&gt;Y + ImageHeight)) {
            /* There&rsquo;s a bottom portion that&rsquo;s not overlapped */
            TempEntity.X = pEntity-&gt;X;
            TempEntity.Y = TempPtr-&gt;Bottom;
            AddDirtyRect(&amp;TempEntity,
                  (pEntity-&gt;Y + ImageHeight) - TempPtr-&gt;Bottom, ImageWidth);
         }
         /* We&rsquo;ve added all non-overlapped portions to the dirty list */
         return;
      }
   }
#endif /* CHECK-OVERLAP */
   /* There&rsquo;s no overlap with any existing rectangle, so we can just
      add this rectangle as-is */
   /* Find the YX-sorted insertion point. Searches will always terminate,
      because the head/tail rectangle is set to the maximum values */
   TempPtr = &amp;DirtyHead;
   while (((DirtyRectangle *)TempPtr-&gt;Next)-&gt;Top &lt; pEntity-&gt;Y) {
      TempPtr = TempPtr-&gt;Next;
   }
   while ((((DirtyRectangle *)TempPtr-&gt;Next)-&gt;Top == pEntity-&gt;Y) &amp;&amp;
           (((DirtyRectangle *)TempPtr-&gt;Next)-&gt;Left &lt; pEntity-&gt;X)) {
      TempPtr = TempPtr-&gt;Next;
   }
   /* Set the rectangle and actually add it to the dirty list */
   DirtyPtr = &amp;DirtyRectangles[NumDirtyRectangles++];
   DirtyPtr-&gt;Left = pEntity-&gt;X;
   DirtyPtr-&gt;Top = pEntity-&gt;Y;
   DirtyPtr-&gt;Right = pEntity-&gt;X + ImageWidth;
   DirtyPtr-&gt;Bottom = pEntity-&gt;Y + ImageHeight;
   DirtyPtr-&gt;Next = TempPtr-&gt;Next;
   TempPtr-&gt;Next = DirtyPtr;
}
</pre><!-- END CODE //-->

  <p><b>LISTING 46.2 L46-2.ASM</b></p><!-- CODE //-->
  <pre>
; Assembly language helper routines for dirty rectangle animation. Tested with
; TASM. 
; Fills a rectangle in the specified buffer. 
; C-callable as:  
;  void FillRect(char far * BufferPtr, int RectHeight, int RectWidth,
;                   int BufferWidth, int Color);
;
        .model  small
        .code
parms   struc
                dw      ?       ;pushed BP
                dw      ?       ;pushed return address
BufferPtr       dd      ?       ;far pointer to buffer in which to fill
RectHeight      dw      ?       ;height of rectangle to fill
RectWidth       dw      ?       ;width of rectangle to fill
BufferWidth     dw      ?       ;width of buffer in which to fill
Color           dw      ?       ;color with which to fill
parms   ends
        public  -FillRect
-FillRectproc  near
        cld
        push    bp
        mov     bp,sp
        push    di

        les     di,[bp+BufferPtr]
        mov     dx,[bp+RectHeight]
        mov     bx,[bp+BufferWidth]
        su    bx,[bp+RectWidth]         ;distance from end of one dest scan
                                        ; to start of next
        mov     al,byte ptr [bp+Color]
        mov     ah,al                   ;double the color for REP STOSW
RowLoop:
        mov     cx,[bp+RectWidth]
        shr     cx,1
        rep     stosw
        adc     cx,cx
        rep     stosb
        add     di,bx                   ;point to next scan to fill
        dec     dx                      ;count down rows to fill
        jnz     RowLoop

        pop     di
        pop     bp
        ret
-FillRect   endp

; Draws a masked image (a sprite) to the specified buffer. C-callable as:
;     void DrawMasked(char far * BufferPtr, char * Pixels, char * Mask,
;                   int ImageHeight, int ImageWidth, int BufferWidth);
parms2  struc
                dw      ?       ;pushed BP
                dw      ?       ;pushed return address
BufferPtr2      dd      ?       ;far pointer to buffer in which to draw
Pixels          dw      ?       ;pointer to image pixels
Mask            dw      ?       ;pointer to image mask
ImageHeight     dw      ?       ;height of image to draw
ImageWidth      dw      ?       ;width of image to draw
BufferWidth2    dw      ?       ;width of buffer in which to draw
parms2  ends
        public  -DrawMasked
-DrawMasked     proc    near
        cld
        push    bp
        mov     bp,sp
        push    si
        push    di

        les     di,[bp+BufferPtr2]
        mov     si,[bp+Mask]
        mov     bx,[bp+Pixels]
        mov     dx,[bp+ImageHeight]
        mov     ax,[bp+BufferWidth2]
        su    ax,[bp+ImageWidth]        ;distance from end of one dest scan
        mov     [bp+BufferWidth2],ax    ; to start of next
RowLoop2:
        mov     cx,[bp+ImageWidth]
ColumnLoop:
        lods                            ;get the next mask byte
        and     al,al                   ;draw this pixel?
        jz      SkipPixel               ;no
        mov     al,[bx]                 ;yes, draw the pixel
        mov     es:[di],al
SkipPixel:
        inc     bx                      ;point to next source pixel
        inc     d                       ;point to next dest pixel
        dec     cx
        jnz     ColumnLoop
        add     di,[bp+BufferWidth2]    ;point to next scan to fill
        dec     dx                      ;count down rows to fill
        jnz     RowLoop2

        pop     di
        pop     si
        pop     bp
        ret
-DrawMasked     endp

; Copies a rectangle from one buffer to another. C-callable as:
;     void CopyRect(DestBufferPtr, SrcBufferPtr, CopyHeight, CopyWidth,
;                   DestBufferWidth, SrcBufferWidth);

parms3  struc
                dw      ?       ;pushed BP
                dw      ?       ;pushed return address
DestBufferPtr   dd      ?       ;far pointer to buffer to which to copy
SrcBufferPtr    dd      ?       ;far pointer to buffer from which to copy
CopyHeight      dw      ?       ;height of rect to copy
CopyWidth       dw      ?       ;width of rect to copy
DestBufferWidth dw      ?       ;width of buffer to which to copy
SrcBufferWidth  dw      ?       ;width of buffer from which to copy
parms3  ends
        public  -CopyRect
-CopyRect       proc    near
        cld
        push    bp
        mov     bp,sp
        push    si
        push    di
        push    ds

        les     di,[bp+DestBufferPtr]
        lds     si,[bp+SrcBufferPtr]
        mov     dx,[bp+CopyHeight]
        mov     bx,[bp+DestBufferWidth] ;distance from end of one dest scan
        su    bx,[bp+CopyWidth]         ; of copy to the next
        mov     ax,[bp+SrcBufferWidth]  ;distance from end of one source scan
        su    ax,[bp+CopyWidth]         ; of copy to the next
RowLoop3:
        mov     cx,[bp+CopyWidth]       ;# of bytes to copy
        shr     cx,1
        rep     movsw                   ;copy as many words as possible
        adc     cx,cx
        rep     movs                    ;copy odd byte, if any
        add     si,ax                   ;point to next source scan line
        add     di,bx                   ;point to next dest scan line
        dec     dx                      ;count down rows to fill
        jnz     RowLoop3

        pop     ds
        pop     di
        pop     si
        pop     bp
        ret
-CopyRect       endp
        end
</pre><!-- END CODE //-->

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="46-01.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="46-03.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div><!-- all of the reference materials (books) have the footer and subfoot reveresed -->
  <!-- reference_subfoot = footer -->
  <!-- reference_footer = subfoot -->
  <!-- BEGIN SUB FOOTER -->
  <!-- END FOOTER -->
</body>
</html>
