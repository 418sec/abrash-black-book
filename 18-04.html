<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: It's a Wonderful Life</title>
  <meta name="chapter" content="18" />
  <meta name="pages" content="361-365" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td>
          <a href="18-03.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="18-05.html">Next</a>
        </td>
      </tr>
    </table>
  </center>

  <p><b>LISTING 18.3 MAIN.C</b></p>
  <pre>
// MAIN.C
//
// David Stafford
//

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;time.h&gt;
#include &lt;bios.h&gt;
#include &ldquo;life.h&rdquo;

// functions in VIDEO.C
void enter_display_mode( void );
void exit_display_mode( void );
void show_text( int x, int y, char *text );

void InitCellmap( void )
  {
  unsigned int i, j, t, x, y, init;

  for( init = (HEIGHT * WIDTH * 3) / 2; init; init&mdash; )
    {
    x = random( WIDTH * 3 );
    y = random( HEIGHT );

    CellMap[ (y * WIDTH) + x / 3 ] |= 0x1000 &lt;&lt; (2 - (x % 3));
    }

  for( i = j = 0; i &lt; WIDTH * HEIGHT; i++ )
    {
    if( CellMap[ i ] &amp; 0x7000 )
      {
      ChangeList1[ j++ ] = (short)&amp;CellMap[ i ];
      }
    }

  NextGen();   // Set cell states, prime the pump.
  }

void main( void )
  {
  unsigned long generation = 0;
  char gen_text[ 80 ];
  long start_time, end_time;
  unsigned int seed;

  printf( &ldquo;Seed (0 for random seed): &rdquo; );
  scanf( &ldquo;%d&rdquo;, &amp;seed );
  if( seed == 0 )  seed = (unsigned) time(NULL);
  srand( seed );

  #ifndef NODRAW
  enter_display_mode();
  show_text( 0, 10, &ldquo;Generation:&rdquo; );
  #endif

  InitCellmap();       // randomly initialize cell map

  _bios_timeofday( _TIME_GETCLOCK, &amp;start_time );

  do
    {
    NextGen();
    generation++;

    #ifndef NOCOUNTER
    sprintf( gen_text, &ldquo;%10lu&rdquo;, generation );
    show_text( 0, 12, gen_text );
    #endif
    }
  #ifdef GEN
  while( generation &lt; GEN );
  #else
  while( !kbhit() );
  #endif

  _bios_timeofday( _TIME_GETCLOCK, &amp;end_time );
  end_time -= start_time;

  #ifndef NODRAW
  getch();    // clear keypress
  exit_display_mode();
  #endif

  printf( &ldquo;Total generations: %ld\nSeed: %u\n&rdquo;, generation, seed );
  printf( &ldquo;%ld ticks\n&rdquo;, end_time );
  printf( &ldquo;Time: %f generations/second\n&rdquo;,
          (double)generation / (double)end_time * 18.2 );
  }
</pre>

  <p><b>LISTING 18.4 VIDEO.C</b></p>
  <pre>
/* VGA mode 13h functions for Game of Life.
   Tested with Borland C++. */
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;dos.h&gt;

#define TEXT_X_OFFSET   28
#define SCREEN_WIDTH_IN_BYTES 320

#define SCREEN_SEGMENT  0xA000

/* Mode 13h mode-set function. */
void enter_display_mode()
{
   union REGS regset;

   regset.x.ax = 0x0013;
   int86(0x10, &amp;regset, &amp;regset);
}

/* Text mode mode-set function. */
void exit_display_mode()
{
   union REGS regset;

   regset.x.ax = 0x0003;
   int86(0x10, &amp;regset, &amp;regset);
}

/* Text display function. Offsets text to non-graphics area of
   screen. */
void show_text(int x, int y, char *text)
{
   gotoxy(TEXT_X_OFFSET + x, y);
   puts(text);
}
</pre>

  <p><b>LISTING 18.5 LIFE.H</b></p>
  <pre>
void far NextGen( void );

extern unsigned short CellMap[];
extern unsigned short far ChangeList1[];

#define LEFT        (-2)
#define RIGHT       (+2)
#define UP          (WIDTH * LEFT)
#define DOWN        (WIDTH * RIGHT)
#define UPPERLEFT   (UP + LEFT)
#define UPPERRIGHT  (UP + RIGHT)
#define LOWERLEFT   (DOWN + LEFT)
#define LOWERRIGHT  (DOWN + RIGHT)
#define WRAPLEFT    (RIGHT * (WIDTH - 1))
#define WRAPRIGHT   (LEFT  * (WIDTH - 1))
#define WRAPUP      (DOWN  * (HEIGHT - 1))
#define WRAPDOWN    (UP    * (HEIGHT - 1))
</pre>

  <h3 id="Heading5">Keeping Track of Change with a Change List</h3>

  <p>In my earlier optimizations to the Game of Life, described in the last chapter, I noted that most cells in a Life cellmap are dead, and in most cases all the neighbors are dead as well. This observation enabled me to get a major speed-up by scanning the cellmap for the few non-zero bytes (cells that were either alive or have neighbors that are alive). Although that was a big improvement, it still required my code to touch every cell to check its state. David has improved on this by maintaining a <i>change list;</i> that is, a list of pointers to cells that change in the current generation. Only those cells and their neighbors need to be checked or touched in any way in order to create the next generation, saving a great many instructions and also a great many cache misses due to the fact that cellmaps are too big to fit into the 486&rsquo;s internal cache. During a given generation, David runs down the list of cells that changed from the previous generation to make the changes for this generation, and in the process generates the change list for the next generation.</p>

  <p>That&rsquo;s the overall approach, but this being David Stafford, it&rsquo;s not that simple, of course. I&rsquo;ll let him tell you how his implementation works in his own words. (I&rsquo;ve edited David&rsquo;s text a bit, and added my own comments in square brackets, so blame me for any errors.)</p>

  <p>&ldquo;Each three cells in the life grid are packed into two bytes, as shown in Figure 18.1. So, it is convenient if the width of the cell array is an even multiple of three. There&rsquo;s nothing in the algorithm that prevents it from supporting any arbitrary size, but the code is a bit simpler this way. So if you want a 200x200 grid, I recommend just using a 201x200 grid, and be happy with the extra free column. Otherwise the edge wrapping code gets more complex.</p>

  <p>&ldquo;Since every cell has from zero to eight neighbors, you may be wondering how I can manage to keep track of them with only three bits. Each cell really has only a maximum of seven neighbors since we only need to keep track of neighbors <i>outside</i> of the current cell word. That is, if cell &lsquo;B&rsquo; changes state then we don&rsquo;t need to reflect this in the neighbor counts of cells &lsquo;A&rsquo; and &lsquo;C.&rsquo; Updating is made a little faster. [In other words, when David picks up a word representing three cells, each of the three cells has at least one of the other cells in that word as a neighbor, and the state of that neighbor is stored right in that word, as shown in Figure 18.1. Therefore, the neighbor count for a given cell never needs to reflect more than seven neighbors, because at least one of the eight neighbors&rsquo; states is already encoded in the word.]</p>

  <p><a id="Fig1"><img src="images/18-01.jpg" /><br />
  <b>Figure 18.1</b></a>&nbsp;&nbsp;<i>Cell triplet storage.</i></p>

  <center>
    <table border="1">
      <tr>
        <td>
          <a href="18-03.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="18-05.html">Next</a>
        </td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
