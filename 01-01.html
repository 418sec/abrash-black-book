<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: The Best Optimizer Is between Your Ears</title>
  <meta name="chapter" content="01" />
  <meta name="pages" content="004-007" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="about_author.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="01-02.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <h2 align="center"><i>Part I</i></h2>

  <h2 id="Heading1">Chapter 1<br />
  The Best Optimizer Is between Your Ears</h2>

  <h3 id="Heading2">The Human Element of Code Optimization</h3>

  <p>This book is devoted to a topic near and dear to my heart: writing software that pushes PCs to the limit. Given run-of-the-mill software, PCs run like the 97-pound-weakling minicomputers they are. Give them the proper care, however, and those ugly boxes are capable of miracles. The key is this: Only on microcomputers do you have the run of the whole machine, without layers of operating systems, drivers, and the like getting in the way. You can do <i>anything</i> you want, and you can understand everything that&rsquo;s going on, if you so wish.</p>

  <p>As we&rsquo;ll see shortly, you should indeed so wish.</p>

  <p>Is performance still an issue in this era of cheap 486 computers and super-fast Pentium computers? You bet. How many programs that <i>you</i> use really run so fast that you wouldn&rsquo;t be happier if they ran faster? We&rsquo;re so used to slow software that when a compile-and-link sequence that took two minutes on a PC takes just ten seconds on a 486 computer, we&rsquo;re ecstatic&mdash;when in truth we should be settling for nothing less than instantaneous response.</p>

  <p>Impossible, you say? Not with the proper design, including incremental compilation and linking, use of extended and/or expanded memory, and well-crafted code. PCs can do just about anything you can imagine (with a few obvious exceptions, such as applications involving super-computer-class number-crunching) if you believe that it can be done, if you understand the computer inside and out, and if you&rsquo;re willing to think past the obvious solution to unconventional but potentially more fruitful approaches.</p>

  <p>My point is simply this: PCs can work wonders. It&rsquo;s not easy coaxing them into doing that, but it&rsquo;s rewarding&mdash;and it&rsquo;s sure as heck fun. In this book, we&rsquo;re going to work some of those wonders, starting...</p>

  <p>...now.</p>

  <h3 id="Heading3">Understanding High Performance</h3>

  <p>Before we can create high-performance code, we must understand what high performance is. The objective (not always attained) in creating high-performance software is to make the software able to carry out its appointed tasks so rapidly that it responds instantaneously, as far as the user is concerned. In other words, high-performance code should ideally run so fast that any further improvement in the code would be pointless.</p>

  <p>Notice that the above definition most emphatically does <i>not</i> say anything about making the software as fast as possible. It also does not say anything about using assembly language, or an optimizing compiler, or, for that matter, a compiler at all. It also doesn&rsquo;t say anything about how the code was designed and written. What it does say is that high-performance code shouldn&rsquo;t get in the user&rsquo;s way&mdash;and that&rsquo;s <i>all</i>.</p>

  <p>That&rsquo;s an important distinction, because all too many programmers think that assembly language, or the right compiler, or a particular high-level language, or a certain design approach is the answer to creating high-performance code. They&rsquo;re not, any more than choosing a certain set of tools is the key to building a house. You do indeed need tools to build a house, but any of many sets of tools will do. You also need a blueprint, an understanding of everything that goes into a house, and the ability to <i>use</i> the tools.</p>

  <p>Likewise, high-performance programming requires a clear understanding of the purpose of the software being built, an overall program design, algorithms for implementing particular tasks, an understanding of what the computer can do and of what all relevant software is doing&mdash;<i>and</i> solid programming skills, preferably using an optimizing compiler or assembly language. The optimization at the end is just the finishing touch, however.</p>

  <table width="100%">
    <tr>
      <td width="5%" valign="top"><img src="images/i.jpg" /></td>

      <td width="95%"><small><i>Without good design, good algorithms, and complete understanding of the program&rsquo;s operation, your carefully optimized code will amount to one of mankind&rsquo;s least fruitful creations&mdash;a fast slow program</i>.</small></td>
    </tr>
  </table>

  <p>&ldquo;What&rsquo;s a fast slow program?&rdquo; you ask. That&rsquo;s a good question, and a brief (true) story is perhaps the best answer.</p>

  <h4 align="left" id="Heading4">When Fast Isn&rsquo;t Fast</h4>

  <p>In the early 1970s, as the first hand-held calculators were hitting the market, I knew a fellow named Irwin. He was a good student, and was planning to be an engineer. Being an engineer back then meant knowing how to use a slide rule, and Irwin could jockey a slipstick with the best of them. In fact, he was so good that he challenged a fellow with a calculator to a duel&mdash;and won, becoming a local legend in the process.</p>

  <p>When you get right down to it, though, Irwin was spitting into the wind. In a few short years his hard-earned slipstick skills would be worthless, and the entire discipline would be essentially wiped from the face of the earth. What&rsquo;s more, anyone with half a brain could see that changeover coming. Irwin had basically wasted the considerable effort and time he had spent optimizing his soon-to-be-obsolete skills.</p>

  <p>What does all this have to do with programming? Plenty. When you spend time optimizing poorly-designed assembly code, or when you count on an optimizing compiler to make your code fast, you&rsquo;re wasting the optimization, much as Irwin did. Particularly in assembly, you&rsquo;ll find that without proper up-front design and everything else that goes into high-performance design, you&rsquo;ll waste considerable effort and time on making an inherently slow program as fast as possible&mdash;which is still slow&mdash;when you could easily have improved performance a great deal more with just a little thought. As we&rsquo;ll see, handcrafted assembly language and optimizing compilers matter, but less than you might think, in the grand scheme of things&mdash;and they scarcely matter at all unless they&rsquo;re used in the context of a good design and a thorough understanding of both the task at hand and the PC.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="about_author.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="01-02.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
