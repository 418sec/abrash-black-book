<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: In the Lair of the Cycle-Eaters</title><!-- HEADER -->
  <!-- Empty Reference Subhead -->
  <!--ISBN=1576101746//-->
  <!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
  <!--AUTHOR=Michael Abrash//-->
  <!--PUBLISHER=The Coriolis Group, Inc.//-->
  <!--CHAPTER=04//-->
  <!--PAGES=094-097//-->
  <!--UNASSIGNED1//-->
  <!--UNASSIGNED2//-->
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="04-05.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="04-07.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p>More than anything, the above rules mean using the registers as heavily as possible, both because register-only instructions are short and because they don&rsquo;t perform memory accesses to read or write operands. However, using the registers is a rule of thumb, not a commandment. In some circumstances, it may actually be <i>faster</i> to access memory. (The look-up table technique is one such case.) What&rsquo;s more, the performance of the prefetch queue (and hence the performance of each instruction) differs from one code sequence to the next, and can even differ during different executions of the <i>same</i> code sequence.</p>

  <p>All in all, writing good assembler code is as much an art as a science. As a result, you should follow the rules of thumb described here&mdash;and then time your code to see how fast it really is. You should experiment freely, but always remember that actual, measured performance is the bottom line.</p>

  <h4 align="left"><a id="Heading14"></a>Holding Up the 8088</h4>

  <p>In this chapter I&rsquo;ve taken you further and further into the depths of the PC, telling you again and again that you must understand the computer at the lowest possible level in order to write good code. At this point, you may well wonder, &ldquo;Have we gotten low enough?&rdquo;</p>

  <p>Not quite yet. The 8-bit bus and prefetch queue cycle-eaters are low-level indeed, but we&rsquo;ve one level yet to go. Dynamic RAM refresh and wait states&mdash;our next topics&mdash;together form the lowest level at which the hardware of the PC affects code performance. Below this level, the PC is of interest only to hardware engineers.</p>

  <p>Before we begin our discussion of dynamic RAM refresh, let&rsquo;s step back for a moment to take an overall look at this lowest level of cycle-eaters. In truth, the distinctions between wait states and dynamic RAM refresh don&rsquo;t much matter to a programmer. What is important is that you understand this: <i>Under certain circumstances, devices on the PC bus can stop the CPU for 1 or more cycles, making your code run more slowly than it seemingly should.</i></p>

  <p>Unlike all the cycle-eaters we&rsquo;ve encountered so far, wait states and dynamic RAM refresh are strictly external to the CPU, as was shown in Figure 4.1. Adapters on the PC&rsquo;s bus, such as video and memory cards, can insert wait states on any bus access, the idea being that they won&rsquo;t be able to complete the access properly unless the access is stretched out. Likewise, the channel of the DMA controller dedicated to dynamic RAM refresh can request control of the bus at any time, although the CPU must relinquish the bus before the DMA controller can take over. This means that your code can&rsquo;t directly control wait states or dynamic RAM refresh. However, code <i>can</i> sometimes be designed to minimize the effects of these cycle-eaters, and even when the cycle-eaters slow your code without there being a thing in the world you can do about it, you&rsquo;re still better off understanding that you&rsquo;re losing performance and knowing why your code doesn&rsquo;t run as fast as it&rsquo;s supposed to than you were programming in ignorance.</p>

  <p>Let&rsquo;s start with DRAM refresh, which affects the performance of every program that runs on the PC.</p>

  <h3><a id="Heading15"></a>Dynamic RAM Refresh: The Invisible Hand</h3>

  <p>Dynamic RAM (DRAM) refresh is sort of an act of God. By that I mean that DRAM refresh invisibly and inexorably steals a certain fraction of all available memory access time from your programs, when they are accessing memory for code and data. (When they are accessing cache on more recent processors, theoretically the DRAM refresh cycle-eater doesn&rsquo;t come into play, but there are other cycle-eaters waiting to prey on cache-bound programs.) While you <i>could</i> stop DRAM refresh, you wouldn&rsquo;t want to since that would be a sure prescription for crashing your computer. In the end, thanks to DRAM refresh, almost all code runs a bit slower on the PC than it otherwise would, and that&rsquo;s that.</p>

  <p>A bit of background: A static RAM (SRAM) chip is a memory chip that retains its contents indefinitely so long as power is maintained. By contrast, each of several blocks of bits in a dynamic RAM (DRAM) chip retains its contents for only a short time after it&rsquo;s accessed for a read or write. In order to get a DRAM chip to store data for an extended period, each of the blocks of bits in that chip must be accessed regularly, so that the chip&rsquo;s stored data is kept refreshed and valid. So long as this is done often enough, a DRAM chip will retain its contents indefinitely.</p>

  <p>All of the PC&rsquo;s system memory consists of DRAM chips. Each DRAM chip in the PC must be completely refreshed about once every four milliseconds in order to ensure the integrity of the data it stores. Obviously, it&rsquo;s highly desirable that the memory in the PC retain the correct data indefinitely, so each DRAM chip in the PC <i>must</i> always be refreshed within 4 &micro;s of the last refresh. Since there&rsquo;s no guarantee that a given program will access each and every DRAM block once every 4 &micro;s, the PC contains special circuitry and programming for providing DRAM refresh.</p>

  <h4 align="left"><a id="Heading16"></a>How DRAM Refresh Works in the PC</h4>

  <p>On the original 8088-based IBM PC, timer 1 of the 8253 timer chip is programmed at power-up to generate a signal once every 72 cycles, or once every 15.08&micro;s. That signal goes to channel 0 of the 8237 DMA controller, which requests the bus from the 8088 upon receiving the signal. (DMA stands for <i>direct memory access,</i> the ability of a device other than the 8088 to control the bus and access memory directly, without any help from the 8088.) As soon as the 8088 is between memory accesses, it gives control of the bus to the 8237, which in conjunction with special circuitry on the PC&rsquo;s motherboard then performs a single 4-cycle read access to 1 of 256 possible addresses, advancing to the next address on each successive access. (The read access is only for the purpose of refreshing the DRAM; the data that is read isn&rsquo;t used.)</p>

  <p>The 256 addresses accessed by the refresh DMA accesses are arranged so that taken together they properly refresh all the memory in the PC. By accessing one of the 256 addresses every 15.08 &micro;s, all of the PC&rsquo;s DRAM is refreshed in 256 x 15.08 &micro;s, or 3.86 &micro;s, which is just about the desired 4 &micro;s time I mentioned earlier. (Only the first 640K of memory is refreshed in the PC; video adapters and other adapters above 640K containing memory that requires refreshing must provide their own DRAM refresh in pre-AT systems.)</p>

  <p>Don&rsquo;t sweat the details here. The important point is this: For at least 4 out of every 72 cycles, the original PC&rsquo;s bus is given over to DRAM refresh and is not available to the 8088, as shown in Figure 4.5. That means that as much as 5.56 percent of the PC&rsquo;s already inadequate bus capacity is lost. However, DRAM refresh doesn&rsquo;t necessarily stop the 8088 in its tracks for 4 cycles. The Execution Unit of the 8088 can keep processing while DRAM refresh is occurring, unless the EU needs to access memory. Consequently, DRAM refresh can slow code performance anywhere from 0 percent to 5.56 percent (and actually a bit more, as we'll see shortly), depending on the extent to which DRAM refresh occupies cycles during which the 8088 would otherwise be accessing memory.</p>

  <p><a id="Fig5"><!-- </A><A HREF="javascript:displayWindow('images/04-05.jpg',407,339 )"> --><img src="images/04-05.jpg" /><br />
  <!-- </A>
<BR><A HREF="javascript:displayWindow('images/04-05.jpg',407,339)"> --><b>Figure 4.5</b></a>&nbsp;&nbsp;<i>The PC bus dynamic RAM (DRAM) refresh.</i></p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="04-05.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="04-07.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div><!-- all of the reference materials (books) have the footer and subfoot reveresed -->
  <!-- reference_subfoot = footer -->
  <!-- reference_footer = subfoot -->
  <!-- BEGIN SUB FOOTER -->
  <!-- END FOOTER -->
</body>
</html>
