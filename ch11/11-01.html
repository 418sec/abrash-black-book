<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: Pushing the 286 and 386</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=11//-->
<!--PAGES=205-210//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><BODY LINK=#0000FF ALINK=#000099 VLINK=#0000FF BGCOLOR=#FFFFFF>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="../ch10/10-04.html">Previous</A></TD>
<TD><A HREF="../index.html">Table of Contents</A></TD>
<TD><A HREF="11-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H2><A NAME="Heading1"></A><FONT COLOR="#000077">Chapter 11<BR>Pushing the 286 and 386
</FONT></H2>
<H3><A NAME="Heading2"></A><FONT COLOR="#000077">New Registers, New Instructions, New Timings, New Complications</FONT></H3>
<P>This chapter, adapted from my earlier book <I>Zen of Assembly Language</I> (1989; now out of print), provides an overview of the 286 and 386, often contrasting those processors with the 8088. At the time I originally wrote this, the 8088 was the king of processors, and the 286 and 386 were the new kids on the block. Today, of course, all three processors are past their primes, but many millions of each are still in use, and the 386 in particular is still well worth considering when optimizing software.</P>
<P>This chapter provides an interesting look at the evolution of the x86 architecture, to a greater degree than you might expect, for the x86 family came into full maturity with the 386; the 486 and the Pentium are really nothing more than faster 386s, with very little in the way of new functionality. In contrast, the 286 added a number of instructions, respectable performance, and protected mode to the 8088&#146;s capabilities, and the 386 added more instructions and a whole new set of addressing modes, and brought the x86 family into the 32-bit world that represents the future (and, increasingly, the present) of personal computing. This chapter also provides insight into the effects on optimization of the variations in processors and memory architectures that are common in the PC world. So, although the 286 and 386 no longer represent the mainstream of computing, this chapter is a useful mix of history lesson, x86 overview, and details on two workhorse processors that are still in wide use.</P>
<H4 ALIGN="LEFT"><A NAME="Heading3"></A><FONT COLOR="#000077">Family Matters</FONT></H4>
<P>While the x86 family is a large one, only a few members of the family&#151;which includes the 8088, 8086, 80188, 80186, 286, 386SX, 386DX, numerous permutations of the 486, and now the Pentium&#151;really matter.
</P>
<P>The 8088 is now all but extinct in the PC arena. The 8086 was used fairly widely for a while, but has now all but disappeared. The 80186 and 80188 never really caught on for use in PC and don&#146;t require further discussion.</P>
<P>That leaves us with the high-end chips: the 286, the 386SX, the 386, the 486, and the Pentium. At this writing, the 386SX is fast going the way of the 8088; people are realizing that its relatively small cost advantage over the 386 isn&#146;t enough to offset its relatively large performance disadvantage. After all, the 386SX suffers from the same debilitating problem that looms over the 8088&#151;a too-small bus. Internally, the 386SX is a 32-bit processor, but externally, it&#146;s a 16-bit processor, a non-optimal architecture, especially for 32-bit code.</P>
<P>I&#146;m not going to discuss the 386SX in detail. If you do find yourself programming for the 386SX, follow the same general rules you should follow for the 8088: use short instructions, use the registers as heavily as possible, and don&#146;t branch. In other words, avoid memory, since the 386SX is by definition better at processing data internally than it is at accessing memory.</P>
<P>The 486 is a world unto itself for the purposes of optimization, and the Pentium is a <I>universe</I> unto itself. We&#146;ll treat them separately in later chapters.</P>
<P>This leaves us with just two processors: the 286 and the 386. Each was <I>the</I> PC standard in its day. The 286 is no longer used in new systems, but there are millions of 286-based systems still in daily use. The 386 is still being used in new systems, although it&#146;s on the downhill leg of its lifespan, and it is in even wider use than the 286. The future clearly belongs to the 486 and Pentium, but the 286 and 386 are still very much a part of the present-day landscape.</P>
<H4 ALIGN="LEFT"><A NAME="Heading4"></A><FONT COLOR="#000077">Crossing the Gulf to the 286 and the 386</FONT></H4>
<P>Apart from vastly improved performance, the biggest difference between the 8088 and the 286 and 386 (as well as the later Intel CPUs) is that the 286 introduced protected mode, and the 386 greatly expanded the capabilities of protected mode. We&#146;re only going to talk about real-mode operation of the 286 and 386 in this book, however. Protected mode offers a whole new memory management scheme, one that isn&#146;t supported by the 8088. Only code specifically written for protected mode can run in that mode; it&#146;s an alien and hostile environment for MS-DOS programs.
</P>
<P>In particular, segments are different creatures in protected mode. They&#146;re <I>selectors</I>&#151;indexes into a table of segment descriptors&#151;rather than plain old registers, and can&#146;t be set to arbitrary values. That means that segments can&#146;t be used for temporary storage or as part of a fast indivisible 32-bit load from memory, as in</P>
<!-- CODE SNIP //-->
<PRE>
les  ax,dword ptr [LongVar]
mov  dx,es
</PRE>
<!-- END CODE SNIP //-->
<P>which loads <B>LongVar</B> into DX:AX faster than this:</P>
<!-- CODE SNIP //-->
<PRE>
mov  ax,word ptr [LongVar]
mov  dx,word ptr [LongVar&#43;2]
</PRE>
<!-- END CODE SNIP //-->
<P>Protected mode uses those altered segment registers to offer access to a great deal more memory than real mode: The 286 supports 16 megabytes of memory, while the 386 supports 4 gigabytes (4K megabytes) of physical memory and 64 <I>terabytes</I> (64K gigabytes!) of virtual memory.</P>
<P>In protected mode, your programs generally run under an operating system (OS/2, Unix, Windows NT or the like) that exerts much more control over the computer than does MS-DOS. Protected mode operating systems can generally run multiple programs simultaneously, and the performance of any one program may depend far less on code quality than on how efficiently the program uses operating system services and how often and under what circumstances the operating system preempts the program. Protected mode programs are often mostly collections of operating system calls, and the performance of whatever code <I>isn&#146;t</I> operating-system oriented may depend primarily on how large a time slice the operating system gives that code to run in.</P>
<P>In short, taken as a whole, protected mode programming is a different kettle of fish altogether from what I&#146;ve been describing in this book. There&#146;s certainly a knack to optimizing specifically for protected mode under a given operating system...but it&#146;s not what we&#146;ve been learning, and now is not the time to pursue it further. In general, though, the optimization strategies discussed in this book still hold true in protected mode; it&#146;s just issues specific to protected mode or a particular operating system that we won&#146;t discuss.</P>
<H4 ALIGN="LEFT"><A NAME="Heading5"></A><FONT COLOR="#000077">In the Lair of the Cycle-Eaters, Part II</FONT></H4>
<P>Under the programming interface, the 286 and 386 differ considerably from the 8088. Nonetheless, with one exception and one addition, the cycle-eaters remain much the same on computers built around the 286 and 386. Next, we&#146;ll review each of the familiar cycle-eaters I covered in Chapter 4 as they apply to the 286 and 386, and we&#146;ll look at the new member of the gang, the data alignment cycle-eater.
</P>
<P>The one cycle-eater that vanishes on the 286 and 386 is the 8-bit bus cycle-eater. The 286 is a 16-bit processor both internally and externally, and the 386 is a 32-bit processor both internally and externally, so the Execution Unit/Bus Interface Unit size mismatch that plagues the 8088 is eliminated. Consequently, there&#146;s no longer any need to use byte-sized memory variables in preference to word-sized variables, at least so long as word-sized variables start at even addresses, as we&#146;ll see shortly. On the other hand, access to byte-sized variables still isn&#146;t any <I>slower</I> than access to word-sized variables, so you can use whichever size suits a given task best.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="../ch10/10-04.html">Previous</A></TD>
<TD><A HREF="../index.html">Table of Contents</A></TD>
<TD><A HREF="11-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Graphics Programming Black Book &copy; 2001 Michael Abrash</font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


