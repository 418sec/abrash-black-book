<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: The Game of Life</title>
  <meta name="chapter" content="17" />
  <meta name="pages" content="322-325" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="16-08.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="17-02.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <h2 id="Heading1">Chapter 17<br />
  The Game of Life</h2>

  <h3 id="Heading2">The Triumph of Algorithmic Optimization in a Cellular Automata Game</h3>

  <p>I&rsquo;ve spent a lot of my life discussing assembly language optimization, which I consider to be an important and underappreciated topic. However, I&rsquo;d like to take this opportunity to point out that there is much, much more to optimization than assembly language. Assembly is essential for absolute maximum performance, but it&rsquo;s not the only ingredient; necessary but not sufficient, if you catch my drift&mdash;and not even necessary, if you&rsquo;re looking for improved but not maximum performance. You&rsquo;ve heard it a thousand times: Optimize your algorithm first. Devise new approaches. Or, as Knuth said, <i>Premature optimization is the root of all evil.</i></p>

  <p>This is, of course, old hat, stuff you know like the back of your hand. Or is it? As Jeff Duntemann pointed out to me the other day, performance programmers are made, not born. While I&rsquo;m merrily gallivanting around in this book optimizing 486 pipelining and turning simple tasks into horribly complicated and terrifyingly fast state machines, many of you are still developing your basic optimization skills. I don&rsquo;t want to shortchange those of you in the latter category, so in this chapter, we&rsquo;ll discuss some high-level language optimizations that can be applied by mere mortals within a reasonable period of time. We&rsquo;re going to examine a complete optimization process, from start to finish, and what we will find is that it&rsquo;s possible to get a 50-times speed-up without using <i>one byte of assembly!</i> It&rsquo;s all a matter of perspective&mdash;how you look at your code and data.</p>

  <h3 id="Heading3">Conway&rsquo;s Game</h3>

  <p>The program that we&rsquo;re going to optimize is Conway&rsquo;s famous Game of Life, long-ago favorite of the hackers at MIT&rsquo;s AI Lab. If you&rsquo;ve never seen it, let me assure you: Life is <i>neat,</i> and more than a little hypnotic. Fractals have been the hot graphics topic in recent years, but for eye-catching dazzle, Life is hard to beat.</p>

  <p>Of course, eye-catching dazzle requires real-time performance&mdash;lots of pixels help too&mdash;and there&rsquo;s the rub. When there are, say, 40,000 cells to process and display, a simple, straightforward implementation just doesn&rsquo;t cut it, even on a 33 MHz 486. Happily, though, there are many, many ways to speed up Life, and they illustrate a variety of important optimization principles, as this chapter will show.</p>

  <p>First, I&rsquo;ll describe the ground rules of Life, implement a very straightforward version in C<small>++</small>, and then speed that version up by about eight times without using any drastically different approaches or any assembly. This may be a little tame for some of you, but be patient; for after that, we&rsquo;ll haul out the big guns and move into the 30 to 40 times speed-up range. Then in the next chapter, I&rsquo;ll show you how several programmers <i>really</i> floored it in taking me up on my second Optimization Challenge, which involved the Game of Life.</p>

  <h4 align="left" id="Heading4">The Rules of the Game</h4>

  <p>The Game of Life is ridiculously simple. There is a cellmap, consisting of a rectangular matrix of cells, each of which may initially be either on or off. Each cell has eight neighbors: two horizontally, two vertically, and four diagonally. For each succeeding generation of cells, the game logic determines whether each cell will be on or off according to the following rules:</p>

  <ul>
    <li>If a cell is on and has either two or three neighbors that are on in the current generation, it stays on; otherwise, the cell turns off.</li>

    <li>If a cell is off and has exactly three &ldquo;on&rdquo; neighbors in the current generation, it turns on; otherwise, it stays off. That&rsquo;s all the rules there are&mdash;but they give rise to an astonishing variety of forms, including patterns that spin, march across the screen, and explode.</li>
  </ul>

  <p>It&rsquo;s only a little more complicated to implement the Game of Life than it is to describe it. Listing 17.1, together with the display functions in Listing 17.2, is a C<small>++</small> implementation of the Game of Life, and it&rsquo;s very straightforward. A cellmap is an object that&rsquo;s accessible through member functions to set, clear, and test cell states, and through a member function to calculate the next generation. Calculating the next generation involves nothing more than using the other member functions to set each cell to the appropriate state, given the number of neighboring on-cells and the cell&rsquo;s current state. The only complication is that it&rsquo;s necessary to place the next generation&rsquo;s cells in another cellmap, and then copy the final result back to the original cellmap. This keeps us from corrupting the current generation&rsquo;s cellmap before we&rsquo;re done using it to calculate the next generation.</p>

  <p>All in all, Listing 17.1 is a clean, compact, and elegant implementation of the Game of Life. Were it not that the code is as slow as molasses, we could stop right here.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="16-08.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="17-02.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
