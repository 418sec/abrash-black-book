<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: Changing Colors without Writing Pixels</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=34//-->
<!--PAGES=648-650//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><body>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="34-03.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="34-05.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>The big question is, How does Listing 34.1 cycle colors? Via the BIOS or directly? With interrupts enabled or disabled? <I>Et cetera?</I></P>
<P>However you like, actually. Four equates at the top of Listing 34.1 select the sort of color cycling performed; by changing these equates and <B>CYCLE_SIZE</B>, you can get a feel for how well various approaches to color cycling work with whatever combination of computer system and VGA you care to test.</P>
<P>The <B>USE_BIOS</B> equate is simple. Set <B>USE_BIOS</B> to 1 to load the DAC through the block-load-DAC BIOS function, or to 0 to load the DAC directly with <B>OUT</B>s.</P>
<P>If <B>USE_BIOS</B> is 1, the only other equate of interest is <B>WAIT_VSYNC</B>. If <B>WAIT_VSYNC</B> is 1, the program waits for the leading edge of vertical sync before loading the DAC; if <B>WAIT_VSYNC</B> is 0, the program doesn&rsquo;t wait before loading. The effect of setting or not setting <B>WAIT_VSYNC</B> depends on whether the BIOS of the VGA the program is running on waits for vertical sync before loading the DAC. You may end up with a double wait, causing color cycling to proceed at half speed, you may end up with no wait at all, causing cycling to occur far too rapidly (and almost certainly with hideous on-screen effects), or you may actually end up cycling at the proper one-cycle-per-frame rate.</P>
<P>If <B>USE_BIOS</B> is 0, <B>WAIT_VSYNC</B> still applies. However, you will always want to set <B>WAIT_VSYNC</B> to 1 when <B>USE_BIOS</B> is 0; otherwise, cycling will occur much too fast, and a good deal of continuous on-screen garbage is likely to make itself evident as the program loads the DAC non-stop.</P>
<P>If <B>USE_BIOS</B> is 0, <B>GUARD_AGAINST_INTS</B> determines whether the possibility of the DAC loading process being interrupted is guarded against by disabling interrupts and setting the write index once for every location loaded and whether the DAC&rsquo;s autoincrementing feature is relied upon or not.</P>
<P>If <B>GUARD_AGAINST_INTS</B> is 1, the following sequence is followed for the loading of each DAC location in turn: Interrupts are disabled, the DAC Write Index register is set appropriately, the RGB triplet for the location is written to the DAC Data register, and interrupts are enabled. This is the slow but safe approach described earlier.</P>
<P>Matters get still more interesting if <B>GUARD_AGAINST_INTS</B> is 0. In that case, if <B>NOT_8088</B> is 0, then an autoincrementing load is performed in a straightforward fashion; the DAC Write Index register is set to the index of the first location to load and the RGB triplet is sent to the DAC by way of three <B>LODSB/OUT DX,AL</B> pairs, with <B>LOOP</B> repeating the process for each of the locations in turn.</P>
<P>If, however, <B>NOT_8088</B> is 1, indicating that the processor is a 286 or better (perhaps <B>AT_LEAST_286</B> would have been a better name), then after the initial DAC Write Index value is set, all 768 DAC locations are loaded with a single <B>REP OUTSB</B>. This is clearly the fastest approach, but it runs the risk, albeit remote, that the loading sequence will be interrupted and the DAC registers will become garbled.</P>
<P>My own experience with Listing 34.1 indicates that it is sometimes possible to load all 256 locations cleanly but sometimes it is not; it all depends on the processor, the bus speed, the VGA, and the DAC, as well as whether autoincrementation and <B>REP OUTSB</B> are used. I&rsquo;m not going to bother to report how many DAC locations I <I>could</I> successfully load with each of the various approaches, for the simple reason that I don&rsquo;t have enough data points to make reliable suggestions, and I don&rsquo;t want you acting on my comments and running into trouble down the pike. You now have a versatile tool with which to probe the limitations of various DAC-loading approaches; use it to perform your own tests on a sampling of the slowest hardware configurations you expect your programs to run on, then leave a generous safety margin.</P>
<P>One thing&rsquo;s for sure, though&mdash;you&rsquo;re not going to be able to cycle all 256 DAC locations cleanly once per frame on a reliable basis across the current generation of PCs. That&rsquo;s why I said at the outset that brute force isn&rsquo;t appropriate to the task of color cycling. That doesn&rsquo;t mean that color cycling can&rsquo;t be used, just that subtler approaches must be employed. Let&rsquo;s look at some of those alternatives.</P>
<H3><A NAME="Heading8"></A>Color Cycling Approaches that Work</H3>
<P>First of all, I&rsquo;d like to point out that when color cycling does work, it&rsquo;s a thing of beauty. Assemble Listing 34.1 so that it doesn&rsquo;t use the BIOS to load the DAC, doesn&rsquo;t guard against interrupts, and uses 286-specific instructions if your computer supports them. Then tinker with <B>CYCLE_SIZE</B> until the color cycling is perfectly clean on your computer. Color cycling looks stunningly smooth, doesn&rsquo;t it? And this is crude color cycling, working with the default color set; switch over to a color set that gradually works its way through various hues and saturations, and you could get something that looks for all the world like true-color animation (albeit working with a small subset of the full spectrum at any one time).</P>
<P>Given that, how can we take advantage of color cycling within the limitations of loading the DAC? The simplest approach, and my personal favorite, is that of cycling a portion of the DAC while using the rest of the DAC locations for other, non-cycling purposes. For example, you might allocate 32 DAC locations to the aforementioned sunset, reserve 160 additional locations for use in drawing a static mountain scene, and employ the remaining 64 locations to draw images of planes, cars, and the like in the foreground. The 32 sunset colors could be cycled cleanly, and the other 224 colors would remain the same throughout the program, or would change only occasionally.</P>
<P>That suggests a second possibility: If you have several different color sets to be cycled, interleave the loading so that only one color set is cycled per frame. Suppose you are animating a night scene, with stars twinkling in the background, meteors streaking across the sky, and a spaceship moving across the screen with its jets flaring. One way to produce most of the necessary effects with little effort would be to draw the stars in several attributes and then cycle the colors for <I>those</I> attributes, draw the meteor paths in successive attributes, one for each pixel, and then cycle the colors for those attributes, and do much the same for the jets. The only remaining task would be to animate the spaceship across the screen, which is not a particularly difficult task.</P>
<TABLE WIDTH="100%"><TD VALIGN="TOP" ALIGN="LEFT" WIDTH="5%"><IMG SRC="images/i.jpg"><TD VALIGN="TOP" ALIGN="LEFT" WIDTH="95%"><SMALL><I>The key to getting all the color cycling to work in the above example, however, would be to assign each color cycling task a different part of the DAC, with each part cycled independently as needed. If, as is likely, the total number of DAC locations cycled proved to be too great to manage in one frame, you could simply cycle the colors of the stars after one frame, the colors of the meteors after the next, and the colors of the jets after yet another frame, then back around to cycling the colors of the stars. By splitting up the DAC in this manner and interleaving the cycling tasks, you can perform a great deal of seemingly complex color animation without loading very much of the DAC during any one frame.</I></SMALL>
</TABLE>
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="34-03.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="34-05.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
Graphics Programming Black Book &copy; 2001 Michael Abrash
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


