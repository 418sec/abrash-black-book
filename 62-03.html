<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: On Story, Two Rules, and a BSP Renderer</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=62//-->
<!--PAGES=1157-1160//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><body>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="62-02.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="62-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H4 ALIGN="LEFT"><A NAME="Heading4"></A>The Rendering Pipeline</H4>
<P>Conceptually rendering from a BSP tree really is that simple, but the implementation is a bit more complicated. The full rendering pipeline, as coordinated by <B>UpdateWorld()</B>, is this:</P>
<ul>
	<li>Update the current location.</li>
	<li>Transform all wall endpoints into viewspace (the world as seen from the current location with the current viewing angle).</li>
	<li>Clip all walls to the view pyramid.</li>
	<li>Project wall vertices to screen coordinates.</li>
	<li>Walk the walls back to front, and for each wall that lies at least partially in the view pyramid, perform backface culling (skip walls facing away from the viewer), and draw the wall if it&rsquo;s not culled.</li>
</ul>
<P>Next, we&rsquo;ll look at each part of the pipeline more closely. The pipeline is too complex for me to be able to discuss each part in complete detail. Some sources for further reading are <I>Computer Graphics</I>, by Foley and van Dam (ISBN 0-201-12110-7), and the <I>DDJ Essential Books on Graphics Programming</I> CD.</P>
<H3><A NAME="Heading5"></A>Moving the Viewer</H3>
<P>The sample BSP program performs first-person rendering; that is, it renders the world as seen from your eyes as you move about. The rate of movement is controlled by key-handling code that&rsquo;s not shown in Listing 62.1; however, the variables set by the key-handling code are used in <B>UpdateViewPos()</B> to bring the current location up to date.</P>
<P>Note that the view position can change not only in x and z (movement around the but only viewing horizontally. Although the BSP tree is only 2-D, it is quite possible to support looking up and down to at least some extent, particularly if the world dataset is restricted so that, for example, there are never two rooms stacked on top of each other, or any tilted walls. For simplicity&rsquo;s sake, I have chosen not to implement this in Listing 62.1, but you may find it educational to add it to the program yourself.</P>
<H3><A NAME="Heading6"></A>Transformation into Viewspace</H3>
<P>The viewing angle (which controls direction of movement as well as view direction) can sweep through the full 360 degrees around the viewpoint, so long as it remains horizontal. The viewing angle is controlled by the key handler, and is used to define a unit vector stored in <B>currentorientation</B> that explicitly defines the view direction (the z axis of viewspace), and implicitly defines the x axis of viewspace, because that axis is at right angles to the z axis, where x increases to the right of the viewer.</P>
<P>As I discussed in the previous chapter, rotation to a new coordinate system can be performed by using the dot product to project points onto the axes of the new coordinate system, and that&rsquo;s what <B>TransformVertices()</B> does, after first translating (moving) the coordinate system to have its origin at the viewpoint. (It&rsquo;s necessary to perform the translation first so that the viewing rotation is around the viewpoint.) Note that this operation can equivalently be viewed as a matrix math operation, and that this is in fact the more common way to handle transformations.</P>
<P>At the same time, the points are scaled in x according to <B>PROJECTION_RATIO</B> to provide the desired field of view. Larger scale values result in narrower fields of view.</P>
<P>When this is done the walls are in viewspace, ready to be clipped.</P>
<H3><A NAME="Heading7"></A>Clipping</H3>
<P>In viewspace, the walls may be anywhere relative to the viewpoint: in front, behind, off to the side. We only want to draw those parts of walls that properly belong on the screen; that is, those parts that lie in the view pyramid (view frustum), as shown in Figure 62.2. Unclipped walls&mdash;walls that lie entirely in the frustum&mdash;should be drawn in their entirety, fully clipped walls should not be drawn, and partially clipped walls must be trimmed before being drawn.
</P>
<P>In Listing 62.1, <B>ClipWalls()</B> does this in three steps for each wall in turn. First, the z coordinates of the two ends of the wall are calculated. (Remember, walls are vertical and their ends go straight up and down, so the top and bottom of each end have the same x and z coordinates.) If both ends are on the near side of the front clip plane, then the polygon is fully clipped, and we&rsquo;re done with it. If both ends are on the far side, then the polygon isn&rsquo;t z-clipped, and we leave it unchanged. If the polygon straddles the near clip plane, then the wall is trimmed to stop at the near clip plane by adjusting the t value of the nearest endpoint appropriately; this calculation is a simple matter of scaling by z, because the near clip plane is at a constant z distance. (The use of t values for parametric lines was discussed in Chapter 60.) The process is further simplified because the walls can be treated as lines viewed from above, so we can perform 2-D clipping in z; this would not be the case if walls sloped or had sloping edges.</P>
<P>After clipping in z, we clip by viewspace x coordinate, to ensure that we draw only wall portions that lie between the left and right edges of the screen. Like z-clipping, x-clipping can be done as a 2-D clip, because the walls and the left and right sides of the frustum are all vertical. We compare both the start and endpoint of each wall to the left and right sides of the frustum, and reject, accept, or clip each wall&rsquo;s t values accordingly. The test for x clipping is very simple, because the edges of the frustum are defined as the planes where x==z and -x==z.</P>
<P><A NAME="Fig2"><!-- </A><A HREF="javascript:displayWindow('images/62-02.jpg',389,241 )"> --><IMG SRC="images/62-02.jpg"><BR><!-- </A>
<BR><A HREF="javascript:displayWindow('images/62-02.jpg',389,241)"> --><B>Figure 62.2</B></A>&nbsp;&nbsp;<I>Clipping to the view pyramid.</I>
</P>
<P>The final clip stage is clipping by y coordinate, and this is the most complicated, because vertical walls can be clipped at an angle in y, as shown in Figure 62.3, so true 3-D clipping of all four wall vertices is involved. We handle this in <B>ClipWalls()</B> by detecting trivial rejection in y, using y==z and ==z as the y boundaries of the frustum. However, we leave partial clipping to be handled as a 2-D clipping problem; we are able to do this only because our earlier z-clip to the near clip plane guarantees that no remaining polygon point can have z&lt;=0, ensuring that when we project we&rsquo;ll always pass valid, y-clippable screenspace vertices to the polygon filler.</P>
<H3><A NAME="Heading8"></A>Projection to Screenspace</H3>
<P>At this point, we have viewspace vertices for each wall that&rsquo;s at least partially visible. All we have to do is project these vertices according to z distance&mdash;that is, perform perspective projection&mdash;and scale the results to the width of the screen, then we&rsquo;ll be ready to draw. Although this step is logically separate from clipping, it is performed as the last step for visible walls in <B>ClipWalls()</B>.</P>
<P><A NAME="Fig3"><!-- </A><A HREF="javascript:displayWindow('images/62-03.jpg',405,220 )"> --><IMG SRC="images/62-03.jpg"><BR><!-- </A>
<BR><A HREF="javascript:displayWindow('images/62-03.jpg',405,220)"> --><B>Figure 62.3</B></A>&nbsp;&nbsp;<I>Why y clipping is more complex than x or z clipping.</I>
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="62-02.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="62-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
Graphics Programming Black Book &copy; 2001 Michael Abrash
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


