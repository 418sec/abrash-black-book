<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Frames of Reference</title>
  <meta name="chapter" content="61" />
  <meta name="pages" content="1141-1144" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="61-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="62-01.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <h3 id="Heading9">Using the Dot Product for Projection</h3>

  <p>Consider Equation 3 again, but this time make one of the vectors, say <b>V</b>, a unit vector. Now the equation reduces to:</p>

  <p align="left"></p>

  <p align="center"><img src="images/61-08d.jpg" /></p>

  <p align="right">(eq. 8)</p>

  <p>In other words, the result is the cosine of the angle between the two vectors, scaled by the magnitude of the non-unit vector. Now, consider that cosine is really just the length of the adjacent leg of a right triangle, and think of the non-unit vector as the hypotenuse of a right triangle, and remember that all sides of similar triangles scale equally. What it all works out to is that the value of the dot product of any vector with a unit vector is the length of the first vector projected onto the unit vector, as shown in Figure 61.6.</p>

  <p><a id="Fig6"><img src="images/61-06.jpg" /><br />
  <b>Figure 61.6</b></a>&nbsp;&nbsp;<i>How the dot product with a unit vector performs a projection.</i></p>

  <p>This unlocks all sorts of neat stuff. Want to know the distance from a point to a plane? Just dot the vector from the point <b>P</b> to the plane origin <b>O</b><sub>p</sub> with the plane unit normal <b>N</b><sub>p</sub>, to project the vector onto the normal, then take the absolute value</p>
  <pre>
distance = |(<b>P</b> - <b>O</b><sub>p</sub>) &bull; <b>N</b><sub>p</sub>|
</pre>

  <p>as shown in Figure 61.7.</p>

  <p>Want to clip a line to a plane? Calculate the distance from one endpoint to the plane, as just described, and dot the whole line segment with the plane normal, to get the full length of the line along the plane normal. The ratio of the two dot products is then how far along the line from the endpoint the intersection point is; just move along the line segment by that distance from the endpoint, and you&rsquo;re at the intersection point, as shown in Listing 61.1.</p>

  <p><b>LISTING 61.1 L61_1.C</b></p>
  <pre>
// Given two line endpoints, a point on a plane, and a unit normal
// for the plane, returns the point of intersection of the line
// and the plane in intersectpoint.
#define DOT_PRODUCT(x,y)   (x[0]*y[0]+x[1]*y[1]+x[2]*y[2])
void LineIntersectPlane (float *linestart, float *lineend,
   float *planeorigin, float *planenormal, float *intersectpoint)
{
   float vec1[3], projectedlinelength, startdistfromplane, scale;
   vec1[0] = linestart[0] - planeorigin[0];
   vec1[1] = linestart[1] - planeorigin[1];
   vec1[2] = linestart[2] - planeorigin[2];
   startdistfromplane = DOT_PRODUCT(vec1, planenormal);
   if (startdistfromplane == 0)
   {
        // point is in plane
        intersectpoint[0] = linestart[0];
        intersectpoint[1] = linestart[1];
        intersectpoint[2] = linestart[1];
        return;
   }
   vec1[0] = linestart[0] - lineend[0];
   vec1[1] = linestart[1] - lineend[1];
   vec1[2] = linestart[2] - lineend[2];
   projectedlinelength = DOT_PRODUCT(vec1, planenormal);
   scale = startdistfromplane / projectedlinelength;
   intersectpoint[0] = linestart[0] - vec1[0] * scale;
   intersectpoint[1] = linestart[1] - vec1[1] * scale;
   intersectpoint[2] = linestart[1] - vec1[2] * scale;
}
</pre>

  <h3 id="Heading10">Rotation by Projection</h3>

  <p>We can use the dot product&rsquo;s projection capability to look at rotation in an interesting way. Typically, rotations are represented by matrices. This is certainly a workable representation that encapsulates all aspects of transformation in a single object, and is ideal for concatenations of rotations and translations. One problem with matrices, though, is that many people, myself included, have a hard time looking at a matrix of sines and cosines and visualizing what&rsquo;s actually going on. So when two 3-D experts, John Carmack and Billy Zelsnack, mentioned that they think of rotation differently, in a way that seemed more intuitive to me, I thought it was worth passing on.</p>

  <p><a id="Fig7"><img src="images/61-07.jpg" /><br />
  <b>Figure 61.7</b></a>&nbsp;&nbsp;<i>Using the dot product to get the distance from a point to a plane.</i></p>

  <p>Their approach is this: Think of rotation as projecting coordinates onto new axes. That is, given that you have points in, say, worldspace, define the new coordinate space (viewspace, for example) you want to rotate to by a set of three orthogonal unit vectors defining the new axes, and then project each point onto each of the three axes to get the coordinates in the new coordinate space, as shown for the 2-D case in Figure 61.8. In 3-D, this involves three dot products per point, one to project the point onto each axis. Translation can be done separately from rotation by simple addition.</p>

  <table width="100%">
    <tr>
      <td valign="top" align="left" width="5%"><img src="images/i.jpg" /></td>

      <td valign="top" align="left" width="95%"><small><i>Rotation by projection is exactly the same as rotation via matrix multiplication; in fact, the rows of a rotation matrix are the orthogonal unit vectors pointing along the new axes. Rotation by projection buys us no technical advantages, so that&rsquo;s not what&rsquo;s important here; the key is that the concept of rotation by projection, together with a separate translation step, gives us a new way to look at transformation that I, for one, find easier to visualize and experiment with. A new frame of reference for how we think about 3-D frames of reference, if you will.</i></small></td>
    </tr>
  </table>

  <p>Three things I&rsquo;ve learned over the years are that it never hurts to learn a new way of looking at things, that it helps to have a clearer, more intuitive model in your head of whatever it is you&rsquo;re working on, and that new tools, or new ways to use old tools, are Good Things. My experience has been that rotation by projection, and dot product tricks in general, offer those sorts of benefits for 3-D.</p>

  <p><a id="Fig8"><img src="images/61-08.jpg" /><br />
  <b>Figure 61.8</b></a>&nbsp;&nbsp;<i>Rotation to a new coordinate space by projection onto new axes.</i></p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="61-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="62-01.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
