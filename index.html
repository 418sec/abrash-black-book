<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Michael Abrash">
  <meta name="dcterms.date" content="1997-07-01">
  <title>Michael Abrash’s Graphics Programming Black Book, Special Edition</title>
  <link type="text/css" rel="stylesheet" href="book.css" />
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<header>
<h1 class="title">Michael Abrash’s Graphics Programming Black Book, Special Edition</h1>
<h2 class="author">Michael Abrash</h2>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#foreword">Foreword</a></li>
<li><a href="#acknowledgments">Acknowledgments</a></li>
<li><a href="#part-i">Part I</a><ul>
<li><a href="#chapter-1-the-best-optimizer-is-between-your-ears">Chapter 1 – The Best Optimizer Is between Your Ears</a><ul>
<li><a href="#the-human-element-of-code-optimization">The Human Element of Code Optimization</a></li>
<li><a href="#understanding-high-performance">Understanding High Performance</a></li>
<li><a href="#rules-for-building-high-performance-code">Rules for Building High-Performance Code</a></li>
<li><a href="#where-weve-been-what-weve-seen">Where We’ve Been, What We’ve Seen</a></li>
</ul></li>
<li><a href="#chapter-2-a-world-apart">Chapter 2 – A World Apart</a><ul>
<li><a href="#the-unique-nature-of-assembly-language-optimization">The Unique Nature of Assembly Language Optimization</a></li>
<li><a href="#instructions-the-individual-versus-the-collective">Instructions: The Individual versus the Collective</a></li>
<li><a href="#assembly-is-fundamentally-different">Assembly Is Fundamentally Different</a></li>
<li><a href="#the-flexible-mind">The Flexible Mind</a></li>
</ul></li>
<li><a href="#chapter-3-assume-nothing">Chapter 3 – Assume Nothing</a><ul>
<li><a href="#understanding-and-using-the-zen-timer">Understanding and Using the Zen Timer</a></li>
<li><a href="#the-costs-of-ignorance">The Costs of Ignorance</a></li>
<li><a href="#the-zen-timer">The Zen Timer</a></li>
<li><a href="#time-and-the-pc">Time and the PC</a></li>
<li><a href="#stopping-the-zen-timer">Stopping the Zen Timer</a></li>
<li><a href="#reporting-timing-results">Reporting Timing Results</a></li>
<li><a href="#notes-on-the-zen-timer">Notes on the Zen Timer</a></li>
<li><a href="#a-sample-use-of-the-zen-timer">A Sample Use of the Zen Timer</a></li>
<li><a href="#the-long-period-zen-timer">The Long-Period Zen Timer</a></li>
<li><a href="#example-use-of-the-long-period-zen-timer">Example Use of the Long-Period Zen Timer</a></li>
<li><a href="#using-the-zen-timer-from-c">Using the Zen Timer from C</a></li>
</ul></li>
<li><a href="#chapter-4-in-the-lair-of-the-cycle-eaters">Chapter 4 – In the Lair of the Cycle-Eaters</a><ul>
<li><a href="#how-the-pc-hardware-devours-code-performance">How the PC Hardware Devours Code Performance</a></li>
<li><a href="#cycle-eaters">Cycle-Eaters</a></li>
<li><a href="#the-nature-of-cycle-eaters">The Nature of Cycle-Eaters</a></li>
<li><a href="#the-8-bit-bus-cycle-eater">The 8-Bit Bus Cycle-Eater</a></li>
<li><a href="#the-prefetch-queue-cycle-eater">The Prefetch Queue Cycle-Eater</a></li>
<li><a href="#dynamic-ram-refresh-the-invisible-hand">Dynamic RAM Refresh: The Invisible Hand</a></li>
<li><a href="#wait-states">Wait States</a></li>
<li><a href="#the-display-adapter-cycle-eater">The Display Adapter Cycle-Eater</a></li>
</ul></li>
<li><a href="#chapter-5-crossing-the-border">Chapter 5 – Crossing the Border</a><ul>
<li><a href="#searching-files-with-restartable-blocks">Searching Files with Restartable Blocks</a></li>
<li><a href="#avoiding-the-string-trap">Avoiding the String Trap</a></li>
<li><a href="#brute-force-techniques">Brute-Force Techniques</a></li>
<li><a href="#using-memchr">Using memchr()</a></li>
<li><a href="#interpreting-where-the-cycles-go">Interpreting Where the Cycles Go</a></li>
<li><a href="#always-look-where-execution-is-going">Always Look Where Execution Is Going</a></li>
</ul></li>
<li><a href="#chapter-6-looking-past-face-value">Chapter 6 – Looking Past Face Value</a><ul>
<li><a href="#how-machine-instructions-may-do-more-than-you-think">How Machine Instructions May Do More Than You Think</a></li>
<li><a href="#math-via-memory-addressing">Math via Memory Addressing</a></li>
<li><a href="#multiplication-with-lea-using-non-powers-of-two">Multiplication with LEA Using Non-Powers of Two</a></li>
</ul></li>
<li><a href="#chapter-7-local-optimization">Chapter 7 – Local Optimization</a><ul>
<li><a href="#optimizing-halfway-between-algorithms-and-cycle-counting">Optimizing Halfway between Algorithms and Cycle Counting</a></li>
<li><a href="#the-lessons-of-loop-and-jcxz">The Lessons of LOOP and JCXZ</a></li>
<li><a href="#local-optimization">Local Optimization</a></li>
<li><a href="#unrolling-loops">Unrolling Loops</a></li>
</ul></li>
<li><a href="#chapter-8-speeding-up-c-with-assembly-language">Chapter 8 – Speeding Up C with Assembly Language</a><ul>
<li><a href="#jumping-languages-when-you-know-itll-help">Jumping Languages When You Know It’ll Help</a></li>
<li><a href="#dont-call-your-functions-on-me-baby">Don’t Call Your Functions on Me, Baby</a></li>
<li><a href="#stack-frames-slow-so-much">Stack Frames Slow So Much</a></li>
<li><a href="#torn-between-two-segments">Torn Between Two Segments</a></li>
<li><a href="#taking-it-to-the-limit">Taking It to the Limit</a></li>
</ul></li>
<li><a href="#chapter-9-hints-my-readers-gave-me">Chapter 9 – Hints My Readers Gave Me</a><ul>
<li><a href="#optimization-odds-and-ends-from-the-field">Optimization Odds and Ends from the Field</a></li>
</ul></li>
<li><a href="#chapter-10-patient-coding-faster-code">Chapter 10 – Patient Coding, Faster Code</a><ul>
<li><a href="#how-working-quickly-can-bring-execution-to-a-crawl">How Working Quickly Can Bring Execution to a Crawl</a></li>
<li><a href="#the-brute-force-syndrome">The Brute-Force Syndrome</a></li>
<li><a href="#recursion">Recursion</a></li>
</ul></li>
<li><a href="#chapter-11-pushing-the-286-and-386">Chapter 11 – Pushing the 286 and 386</a><ul>
<li><a href="#new-registers-new-instructions-new-timings-new-complications">New Registers, New Instructions, New Timings, New Complications</a></li>
</ul></li>
<li><a href="#chapter-12-pushing-the-486">Chapter 12 – Pushing the 486</a><ul>
<li><a href="#its-not-just-a-bigger-386">It’s Not Just a Bigger 386</a></li>
<li><a href="#rules-to-optimize-by">Rules to Optimize By</a></li>
<li><a href="#caveat-programmor">Caveat Programmor</a></li>
<li><a href="#the-story-continues">The Story Continues</a></li>
</ul></li>
<li><a href="#chapter-13-aiming-the-486">Chapter 13 – Aiming the 486</a><ul>
<li><a href="#pipelines-and-other-hazards-of-the-high-end">Pipelines and Other Hazards of the High End</a></li>
<li><a href="#bswap-more-useful-than-you-might-think">BSWAP: More Useful Than You Might Think</a></li>
<li><a href="#pushing-and-popping-memory">Pushing and Popping Memory</a></li>
<li><a href="#optimal-1-bit-shifts-and-rotates">Optimal 1-Bit Shifts and Rotates</a></li>
<li><a href="#bit-addressing-modes">32-Bit Addressing Modes</a></li>
</ul></li>
<li><a href="#chapter-14-boyer-moore-string-searching">Chapter 14 – Boyer-Moore String Searching</a><ul>
<li><a href="#optimizing-a-pretty-optimum-search-algorithm">Optimizing a Pretty Optimum Search Algorithm</a></li>
<li><a href="#string-searching-refresher">String Searching Refresher</a></li>
<li><a href="#the-boyer-moore-algorithm">The Boyer-Moore Algorithm</a></li>
<li><a href="#boyer-moore-the-good-and-the-bad">Boyer-Moore: The Good and the Bad</a></li>
<li><a href="#further-optimization-of-boyer-moore">Further Optimization of Boyer-Moore</a></li>
<li><a href="#know-what-you-know">Know What You Know</a></li>
</ul></li>
<li><a href="#chapter-15-linked-lists-and-plain-unintended-challenges">Chapter 15 – Linked Lists and plain Unintended Challenges</a><ul>
<li><a href="#unfamiliar-problems-with-familiar-data-structures">Unfamiliar Problems with Familiar Data Structures</a></li>
<li><a href="#linked-lists">Linked Lists</a></li>
<li><a href="#dummies-and-sentinels">Dummies and Sentinels</a></li>
<li><a href="#circular-lists">Circular Lists</a></li>
<li><a href="#hilo-in-24-bytes">Hi/Lo in 24 Bytes</a></li>
</ul></li>
<li><a href="#chapter-16-there-aint-no-such-thing-as-the-fastest-code">Chapter 16 – There Ain’t No Such Thing as the Fastest Code</a><ul>
<li><a href="#lessons-learned-in-the-pursuit-of-the-ultimate-word-counter">Lessons Learned in the Pursuit of the Ultimate Word Counter</a></li>
<li><a href="#counting-words-in-a-hurry">Counting Words in a Hurry</a></li>
<li><a href="#challenges-and-hazards">Challenges and Hazards</a></li>
<li><a href="#the-astonishment-of-right-brain-optimization">The Astonishment of Right-Brain Optimization</a></li>
<li><a href="#levels-of-optimization">Levels of Optimization</a></li>
<li><a href="#level-2-a-new-perspective">Level 2: A New Perspective</a></li>
</ul></li>
<li><a href="#chapter-17-the-game-of-life">Chapter 17 – The Game of Life</a><ul>
<li><a href="#the-triumph-of-algorithmic-optimization-in-a-cellular-automata-game">The Triumph of Algorithmic Optimization in a Cellular Automata Game</a></li>
<li><a href="#conways-game">Conway’s Game</a></li>
<li><a href="#where-does-the-time-go">Where Does the Time Go?</a></li>
<li><a href="#the-hazards-and-advantages-of-abstraction">The Hazards and Advantages of Abstraction</a></li>
<li><a href="#heavy-duty-c-optimization">Heavy-Duty C++ Optimization</a></li>
<li><a href="#bringing-in-the-right-brain">Bringing In the Right Brain</a></li>
</ul></li>
<li><a href="#chapter-18-its-a-plain-wonderful-life">Chapter 18 – It’s a plain Wonderful Life</a><ul>
<li><a href="#optimization-beyond-the-pale">Optimization beyond the Pale</a></li>
<li><a href="#breaking-the-rules">Breaking the Rules</a></li>
<li><a href="#table-driven-magic">Table-Driven Magic</a></li>
<li><a href="#keeping-track-of-change-with-a-change-list">Keeping Track of Change with a Change List</a></li>
</ul></li>
<li><a href="#chapter-19-pentium-not-the-same-old-song">Chapter 19 – Pentium: Not the Same Old Song</a><ul>
<li><a href="#learning-a-whole-different-set-of-optimization-rules">Learning a Whole Different Set of Optimization Rules</a></li>
<li><a href="#the-return-of-optimization-as-art">The Return of Optimization as Art</a></li>
<li><a href="#the-pentium-an-overview">The Pentium: An Overview</a></li>
<li><a href="#faster-addressing-and-more">Faster Addressing and More</a></li>
<li><a href="#branch-prediction">Branch Prediction</a></li>
<li><a href="#miscellaneous-pentium-topics">Miscellaneous Pentium Topics</a></li>
</ul></li>
<li><a href="#chapter-20-pentium-rules">Chapter 20 – Pentium Rules</a><ul>
<li><a href="#how-your-carbon-based-optimizer-can-put-the-super-in-superscalar">How Your Carbon-Based Optimizer Can Put the “Super” in Superscalar</a></li>
<li><a href="#an-instruction-in-every-pipe">An Instruction in Every Pipe</a></li>
<li><a href="#v-pipe-capable-instructions">V-Pipe-Capable Instructions</a></li>
<li><a href="#lockstep-execution">Lockstep Execution</a></li>
<li><a href="#superscalar-notes">Superscalar Notes</a></li>
</ul></li>
<li><a href="#chapter-21-unleashing-the-pentiums-v-pipe">Chapter 21 – Unleashing the Pentium’s V-Pipe</a><ul>
<li><a href="#focusing-on-keeping-both-pentium-pipes-full">Focusing on Keeping Both Pentium Pipes Full</a></li>
<li><a href="#address-generation-interlocks">Address Generation Interlocks</a></li>
<li><a href="#register-contention">Register Contention</a></li>
<li><a href="#whos-in-first">Who’s in First?</a></li>
<li><a href="#pentium-optimization-in-action">Pentium Optimization in Action</a></li>
</ul></li>
<li><a href="#chapter-22-zenning-and-the-flexible-mind">Chapter 22 – Zenning and the Flexible Mind</a><ul>
<li><a href="#taking-a-spin-through-what-youve-learned">Taking a Spin through What You’ve Learned</a></li>
<li><a href="#zenning">Zenning</a></li>
</ul></li>
</ul></li>
<li><a href="#part-ii">Part II</a><ul>
<li><a href="#chapter-23-bones-and-sinew">Chapter 23 – Bones and Sinew</a><ul>
<li><a href="#at-the-very-heart-of-standard-pc-graphics">At the Very Heart of Standard PC Graphics</a></li>
<li><a href="#the-vga">The VGA</a></li>
<li><a href="#an-introduction-to-vga-programming">An Introduction to VGA Programming</a></li>
<li><a href="#at-the-core">At the Core</a></li>
<li><a href="#the-hazards-of-vga-clones">The Hazards of VGA Clones</a></li>
<li><a href="#just-the-beginning">Just the Beginning</a></li>
<li><a href="#the-macro-assembler">The Macro Assembler</a></li>
</ul></li>
<li><a href="#chapter-24-parallel-processing-with-the-vga">Chapter 24 – Parallel Processing with the VGA</a><ul>
<li><a href="#taking-on-graphics-memory-four-bytes-at-a-time">Taking on Graphics Memory Four Bytes at a Time</a></li>
<li><a href="#vga-programming-alus-and-latches">VGA Programming: ALUs and Latches</a></li>
<li><a href="#notes-on-the-alulatch-demo-program">Notes on the ALU/Latch Demo Program</a></li>
</ul></li>
<li><a href="#chapter-25-vga-data-machinery">Chapter 25 – VGA Data Machinery</a><ul>
<li><a href="#the-barrel-shifter-bit-mask-and-setreset-mechanisms">The Barrel Shifter, Bit Mask, and Set/Reset Mechanisms</a></li>
<li><a href="#vga-data-rotation">VGA Data Rotation</a></li>
<li><a href="#the-bit-mask">The Bit Mask</a></li>
<li><a href="#the-vgas-setreset-circuitry">The VGA’s Set/Reset Circuitry</a></li>
<li><a href="#notes-on-setreset">Notes on Set/Reset</a></li>
<li><a href="#a-brief-note-on-word-outs">A Brief Note on Word OUTs</a></li>
</ul></li>
<li><a href="#chapter-26-vga-write-mode-3">Chapter 26 – VGA Write Mode 3</a><ul>
<li><a href="#the-write-mode-that-grows-on-you">The Write Mode That Grows on You</a></li>
<li><a href="#a-mode-born-in-strangeness">A Mode Born in Strangeness</a></li>
<li><a href="#a-note-on-preserving-register-bits">A Note on Preserving Register Bits</a></li>
</ul></li>
<li><a href="#chapter-27-yet-another-vga-write-mode">Chapter 27 – Yet Another VGA Write Mode</a><ul>
<li><a href="#write-mode-2-chunky-bitmapsand-text-graphics-coexistence">Write Mode 2, Chunky Bitmaps,and Text-Graphics Coexistence</a></li>
<li><a href="#write-mode-2-and-setreset">Write Mode 2 and Set/Reset</a></li>
<li><a href="#when-to-use-write-mode-2-and-when-to-use-setreset">When to Use Write Mode 2 and When to Use Set/Reset</a></li>
<li><a href="#mode-13h320x200-with-256-colors">Mode 13H—320x200 with 256 Colors</a></li>
<li><a href="#flipping-pages-from-text-to-graphics-and-back">Flipping Pages from Text to Graphics and Back</a></li>
</ul></li>
<li><a href="#chapter-28-reading-vga-memory">Chapter 28 – Reading VGA Memory</a><ul>
<li><a href="#read-modes-0-and-1-and-the-color-dont-care-register">Read Modes 0 and 1, and the Color Don’t Care Register</a></li>
<li><a href="#read-mode-0">Read Mode 0</a></li>
<li><a href="#read-mode-1">Read Mode 1</a></li>
<li><a href="#when-all-planes-dont-care">When all Planes “Don’t Care”</a></li>
</ul></li>
<li><a href="#chapter-29-saving-screens-and-other-vga-mysteries">Chapter 29 – Saving Screens and Other VGA Mysteries</a><ul>
<li><a href="#useful-nuggets-from-the-vga-zen-file">Useful Nuggets from the VGA Zen File</a></li>
<li><a href="#saving-and-restoring-ega-and-vga-screens">Saving and Restoring EGA and VGA Screens</a></li>
<li><a href="#colors-out-of-64">16 Colors out of 64</a></li>
<li><a href="#overscan">Overscan</a></li>
<li><a href="#a-bonus-blanker">A Bonus Blanker</a></li>
<li><a href="#modifying-vga-registers">Modifying VGA Registers</a></li>
</ul></li>
<li><a href="#chapter-30-video-est-omnis-divisa">Chapter 30 – Video Est Omnis Divisa</a><ul>
<li><a href="#the-joys-and-galling-problems-of-using-split-screens-on-the-ega-and-vga">The Joys and Galling Problems of Using Split Screens on the EGA and VGA</a></li>
<li><a href="#how-the-split-screen-works">How the Split Screen Works</a></li>
<li><a href="#setting-the-split-screen-related-registers">Setting the Split-Screen-Related Registers</a></li>
<li><a href="#the-problem-with-the-ega-split-screen">The Problem with the EGA Split Screen</a></li>
<li><a href="#split-screen-and-panning">Split Screen and Panning</a></li>
<li><a href="#notes-on-setting-and-reading-registers">Notes on Setting and Reading Registers</a></li>
<li><a href="#split-screens-in-other-modes">Split Screens in Other Modes</a></li>
<li><a href="#how-safe">How Safe?</a></li>
</ul></li>
<li><a href="#chapter-31-higher-256-color-resolution-on-the-vga">Chapter 31 – Higher 256-Color Resolution on the VGA</a><ul>
<li><a href="#when-is-320x200-really-320x400">When Is 320x200 Really 320x400?</a></li>
<li><a href="#why-320x200-only-ibm-knows-for-sure">Why 320x200? Only IBM Knows for Sure</a></li>
<li><a href="#x400-256-color-mode">320x400 256-Color Mode</a></li>
<li><a href="#two-256-color-pages">Two 256-Color Pages</a></li>
<li><a href="#something-to-think-about">Something to Think About</a></li>
</ul></li>
<li><a href="#chapter-32-be-it-resolved-360x480">Chapter 32 – Be It Resolved: 360x480</a><ul>
<li><a href="#taking-256-color-modes-about-as-far-as-the-standard-vga-can-take-them">Taking 256-Color Modes About as Far as the Standard VGA Can Take Them</a></li>
<li><a href="#extended-256-color-modes-whats-not-to-like">Extended 256-Color Modes: What’s Not to Like?</a></li>
<li><a href="#x480-256-color-mode">360x480 256-Color Mode</a></li>
<li><a href="#how-360x480-256-color-mode-works">How 360x480 256-Color Mode Works</a></li>
</ul></li>
<li><a href="#chapter-33-yogi-bear-and-eurythmics-confront-vga-colors">Chapter 33 – Yogi Bear and Eurythmics Confront VGA Colors</a><ul>
<li><a href="#the-basics-of-vga-color-generation">The Basics of VGA Color Generation</a></li>
<li><a href="#vga-color-basics">VGA Color Basics</a></li>
<li><a href="#if-you-cant-call-the-bios-who-ya-gonna-call">If You Can’t Call the BIOS, Who Ya Gonna Call?</a></li>
<li><a href="#an-example-of-setting-the-dac">An Example of Setting the DAC</a></li>
</ul></li>
<li><a href="#chapter-34-changing-colors-without-writing-pixels">Chapter 34 – Changing Colors without Writing Pixels</a><ul>
<li><a href="#special-effects-through-realtime-manipulation-of-dac-colors">Special Effects through Realtime Manipulation of DAC Colors</a></li>
<li><a href="#color-cycling">Color Cycling</a></li>
<li><a href="#the-heart-of-the-problem">The Heart of the Problem</a></li>
<li><a href="#a-test-program-for-color-cycling">A Test Program for Color Cycling</a></li>
<li><a href="#color-cycling-approaches-that-work">Color Cycling Approaches that Work</a></li>
<li><a href="#odds-and-ends">Odds and Ends</a></li>
</ul></li>
<li><a href="#chapter-35-bresenham-is-fast-and-fast-is-good">Chapter 35 – Bresenham Is Fast, and Fast Is Good</a><ul>
<li><a href="#implementing-and-optimizing-bresenhams-line-drawing-algorithm">Implementing and Optimizing Bresenham’s Line-Drawing Algorithm</a></li>
<li><a href="#the-task-at-hand">The Task at Hand</a></li>
<li><a href="#bresenhams-line-drawing-algorithm">Bresenham’s Line-Drawing Algorithm</a></li>
<li><a href="#an-implementation-in-c">An Implementation in C</a></li>
<li><a href="#comments-on-the-c-implementation">Comments on the C Implementation</a></li>
<li><a href="#bresenhams-algorithm-in-assembly">Bresenham’s Algorithm in Assembly</a></li>
</ul></li>
<li><a href="#chapter-36-the-good-the-bad-and-the-run-sliced">Chapter 36 – The Good, the Bad, and the Run-Sliced</a><ul>
<li><a href="#faster-bresenham-lines-with-run-length-slice-line-drawing">Faster Bresenham Lines with Run-Length Slice Line Drawing</a></li>
<li><a href="#run-length-slice-fundamentals">Run-Length Slice Fundamentals</a></li>
<li><a href="#run-length-slice-implementation">Run-Length Slice Implementation</a></li>
<li><a href="#run-length-slice-details">Run-Length Slice Details</a></li>
</ul></li>
<li><a href="#chapter-37-dead-cats-and-lightning-lines">Chapter 37 – Dead Cats and Lightning Lines</a><ul>
<li><a href="#optimizing-run-length-slice-line-drawing-in-a-major-way">Optimizing Run-Length Slice Line Drawing in a Major Way</a></li>
<li><a href="#fast-run-length-slice-line-drawing">Fast Run-Length Slice Line Drawing</a></li>
</ul></li>
<li><a href="#chapter-38-the-polygon-primeval">Chapter 38 – The Polygon Primeval</a><ul>
<li><a href="#drawing-polygons-efficiently-and-quickly">Drawing Polygons Efficiently and Quickly</a></li>
<li><a href="#filled-polygons">Filled Polygons</a></li>
<li><a href="#filling-non-overlapping-convex-polygons">Filling Non-Overlapping Convex Polygons</a></li>
<li><a href="#oddball-cases">Oddball Cases</a></li>
</ul></li>
<li><a href="#chapter-39-fast-convex-polygons">Chapter 39 – Fast Convex Polygons</a><ul>
<li><a href="#filling-polygons-in-a-hurry">Filling Polygons in a Hurry</a></li>
<li><a href="#fast-convex-polygon-filling">Fast Convex Polygon Filling</a></li>
<li><a href="#the-finishing-touch-assembly-language">The Finishing Touch: Assembly Language</a></li>
<li><a href="#faster-edge-tracing">Faster Edge Tracing</a></li>
</ul></li>
<li><a href="#chapter-40-of-songs-taxes-and-the-simplicity-of-complex-polygons">Chapter 40 – Of Songs, Taxes, and the Simplicity of Complex Polygons</a><ul>
<li><a href="#dealing-with-irregular-polygonal-areas">Dealing with Irregular Polygonal Areas</a></li>
<li><a href="#filling-arbitrary-polygons">Filling Arbitrary Polygons</a></li>
<li><a href="#complex-polygon-filling-an-implementation">Complex Polygon Filling: An Implementation</a></li>
<li><a href="#nonconvex-polygons">Nonconvex Polygons</a></li>
</ul></li>
<li><a href="#chapter-41-those-way-down-polygon-nomenclature-blues">Chapter 41 – Those Way-Down Polygon Nomenclature Blues</a><ul>
<li><a href="#names-do-matter-when-you-conceptualize-a-data-structure">Names Do Matter when You Conceptualize a Data Structure</a></li>
<li><a href="#nomenclature-in-action">Nomenclature in Action</a></li>
</ul></li>
<li><a href="#chapter-42-wued-in-haste-fried-stewed-at-leisure">Chapter 42 – Wu’ed in Haste; Fried, Stewed at Leisure</a><ul>
<li><a href="#fast-antialiased-lines-using-wus-algorithm">Fast Antialiased Lines Using Wu’s Algorithm</a></li>
<li><a href="#wu-antialiasing">Wu Antialiasing</a></li>
<li><a href="#tracing-and-intensity-in-one">Tracing and Intensity in One</a></li>
<li><a href="#sample-wu-antialiasing">Sample Wu Antialiasing</a></li>
</ul></li>
<li><a href="#chapter-43-bit-plane-animation">Chapter 43 – Bit-Plane Animation</a><ul>
<li><a href="#a-simple-and-extremely-fast-animation-method-for-limited-color">A Simple and Extremely Fast Animation Method for Limited Color</a></li>
<li><a href="#bit-planes-the-basics">Bit-Planes: The Basics</a></li>
<li><a href="#bit-plane-animation-in-action">Bit-Plane Animation in Action</a></li>
<li><a href="#limitations-of-bit-plane-animation">Limitations of Bit-Plane Animation</a></li>
<li><a href="#shearing-and-page-flipping">Shearing and Page Flipping</a></li>
<li><a href="#beating-the-odds-in-the-jaw-dropping-contest">Beating the Odds in the Jaw-Dropping Contest</a></li>
</ul></li>
<li><a href="#chapter-44-split-screens-save-the-page-flipped-day">Chapter 44 – Split Screens Save the Page Flipped Day</a><ul>
<li><a href="#x480-page-flipped-animation-in-64kalmost">640x480 Page Flipped Animation in 64K…Almost</a></li>
</ul></li>
<li><a href="#chapter-45-dog-hair-and-dirty-rectangles">Chapter 45 – Dog Hair and Dirty Rectangles</a><ul>
<li><a href="#different-angles-on-animation">Different Angles on Animation</a></li>
<li><a href="#plus-ça-change">Plus ça Change</a></li>
<li><a href="#vga-access-times">VGA Access Times</a></li>
<li><a href="#dirty-rectangle-animation">Dirty-Rectangle Animation</a></li>
<li><a href="#dirty-rectangles-in-action">Dirty Rectangles in Action</a></li>
<li><a href="#hi-res-vga-page-flipping">Hi-Res VGA Page Flipping</a></li>
<li><a href="#another-interesting-twist-on-page-flipping">Another Interesting Twist on Page Flipping</a></li>
</ul></li>
<li><a href="#chapter-46-who-was-that-masked-image">Chapter 46 – Who Was that Masked Image?</a><ul>
<li><a href="#optimizing-dirty-rectangle-animation">Optimizing Dirty-Rectangle Animation</a></li>
</ul></li>
<li><a href="#chapter-47-mode-x-256-color-vga-magic">Chapter 47 – Mode X: 256-Color VGA Magic</a><ul>
<li><a href="#introducing-the-vgas-undocumented-animation-optimal-mode">Introducing the VGA’s Undocumented “Animation-Optimal” Mode</a></li>
<li><a href="#what-makes-mode-x-special">What Makes Mode X Special?</a></li>
<li><a href="#selecting-320x240-256-color-mode">Selecting 320x240 256-Color Mode</a></li>
<li><a href="#designing-from-a-mode-x-perspective">Designing from a Mode X Perspective</a></li>
<li><a href="#hardware-assist-from-an-unexpected-quarter">Hardware Assist from an Unexpected Quarter</a></li>
</ul></li>
<li><a href="#chapter-48-mode-x-marks-the-latch">Chapter 48 – Mode X Marks the Latch</a><ul>
<li><a href="#the-internals-of-animations-best-video-display-mode">The Internals of Animation’s Best Video Display Mode</a></li>
<li><a href="#allocating-memory-in-mode-x">Allocating Memory in Mode X</a></li>
<li><a href="#copying-pixel-blocks-within-display-memory">Copying Pixel Blocks within Display Memory</a></li>
<li><a href="#who-was-that-masked-image-copier">Who Was that Masked Image Copier?</a></li>
</ul></li>
<li><a href="#chapter-49-mode-x-256-color-animation">Chapter 49 – Mode X 256-Color Animation</a><ul>
<li><a href="#how-to-make-the-vga-really-get-up-and-dance">How to Make the VGA Really Get up and Dance</a></li>
<li><a href="#masked-copying">Masked Copying</a></li>
<li><a href="#animation">Animation</a></li>
<li><a href="#mode-x-animation-in-action">Mode X Animation in Action</a></li>
<li><a href="#works-fast-looks-great">Works Fast, Looks Great</a></li>
</ul></li>
<li><a href="#chapter-50-adding-a-dimension">Chapter 50 – Adding a Dimension</a><ul>
<li><a href="#d-animation-using-mode-x">3-D Animation Using Mode X</a></li>
<li><a href="#references-on-3-d-drawing">References on 3-D Drawing</a></li>
<li><a href="#the-3-d-drawing-pipeline">The 3-D Drawing Pipeline</a></li>
<li><a href="#a-simple-3-d-example">A Simple 3-D Example</a></li>
<li><a href="#an-ongoing-journey">An Ongoing Journey</a></li>
</ul></li>
<li><a href="#chapter-51-sneakers-in-space">Chapter 51 – Sneakers in Space</a><ul>
<li><a href="#using-backface-removal-to-eliminate-hidden-surfaces">Using Backface Removal to Eliminate Hidden Surfaces</a></li>
<li><a href="#one-sided-polygons-backface-removal">One-sided Polygons: Backface Removal</a></li>
<li><a href="#incremental-transformation">Incremental Transformation</a></li>
<li><a href="#a-note-on-rounding-negative-numbers">A Note on Rounding Negative Numbers</a></li>
<li><a href="#object-representation">Object Representation</a></li>
</ul></li>
<li><a href="#chapter-52-fast-3-d-animation-meet-x-sharp">Chapter 52 – Fast 3-D Animation: Meet X-Sharp</a><ul>
<li><a href="#the-first-iteration-of-a-generalized-3-d-animation-package">The First Iteration of a Generalized 3-D Animation Package</a></li>
<li><a href="#this-chapters-demo-program">This Chapter’s Demo Program</a></li>
<li><a href="#a-new-animation-framework-x-sharp">A New Animation Framework: X-Sharp</a></li>
<li><a href="#three-keys-to-realtime-animation-performance">Three Keys to Realtime Animation Performance</a></li>
</ul></li>
<li><a href="#chapter-53-raw-speed-and-more">Chapter 53 – Raw Speed and More</a><ul>
<li><a href="#the-naked-truth-about-speed-in-3-d-animation">The Naked Truth About Speed in 3-D Animation</a></li>
<li><a href="#raw-speed-part-1-assembly-language">Raw Speed, Part 1: Assembly Language</a></li>
<li><a href="#raw-speed-part-ii-look-it-up">Raw Speed, Part II: Look it Up</a></li>
</ul></li>
<li><a href="#chapter-54-3-d-shading">Chapter 54 – 3-D Shading</a><ul>
<li><a href="#putting-realistic-surfaces-on-animated-3-d-objects">Putting Realistic Surfaces on Animated 3-D Objects</a></li>
<li><a href="#support-for-older-processors">Support for Older Processors</a></li>
</ul></li>
<li><a href="#chapter-55-color-modeling-in-256-color-mode">Chapter 55 – Color Modeling in 256-Color Mode</a><ul>
<li><a href="#pondering-x-sharps-color-model-in-an-rgb-state-of-mind">Pondering X-Sharp’s Color Model in an RGB State of Mind</a></li>
</ul></li>
<li><a href="#chapter-56-pooh-and-the-space-station">Chapter 56 – Pooh and the Space Station</a><ul>
<li><a href="#using-fast-texture-mapping-to-place-pooh-on-a-polygon">Using Fast Texture Mapping to Place Pooh on a Polygon</a></li>
<li><a href="#principles-of-quick-and-dirty-texture-mapping">Principles of Quick-and-Dirty Texture Mapping</a></li>
<li><a href="#fast-texture-mapping-an-implementation">Fast Texture Mapping: An Implementation</a></li>
</ul></li>
<li><a href="#chapter-57-10000-freshly-sheared-sheep-on-the-screen">Chapter 57 – 10,000 Freshly Sheared Sheep on the Screen</a><ul>
<li><a href="#the-critical-role-of-experience-in-implementing-fast-smooth-texture-mapping">The Critical Role of Experience in Implementing Fast, Smooth Texture Mapping</a></li>
</ul></li>
<li><a href="#chapter-58-heinleins-crystal-ball-spocks-brain-and-the-9-cycle-dare">Chapter 58 – Heinlein’s Crystal Ball, Spock’s Brain, and the 9-Cycle Dare</a><ul>
<li><a href="#using-the-whole-brain-approach-to-accelerate-texture-mapping">Using the Whole-Brain Approach to Accelerate Texture Mapping</a></li>
<li><a href="#texture-mapping-redux">Texture Mapping Redux</a></li>
<li><a href="#thats-nicebut-it-sure-as-heck-aint-9-cycles">That’s Nice—But it Sure as Heck Ain’t 9 Cycles</a></li>
<li><a href="#texture-mapping-notes">Texture Mapping Notes</a></li>
</ul></li>
<li><a href="#chapter-59-the-idea-of-bsp-trees">Chapter 59 – The Idea of BSP Trees</a><ul>
<li><a href="#what-bsp-trees-are-and-how-to-walk-them">What BSP Trees Are and How to Walk Them</a></li>
<li><a href="#bsp-trees">BSP Trees</a></li>
<li><a href="#building-a-bsp-tree">Building a BSP Tree</a></li>
<li><a href="#inorder-walks-of-bsp-trees">Inorder Walks of BSP Trees</a></li>
<li><a href="#surfing-amidst-the-trees">Surfing Amidst the Trees</a></li>
</ul></li>
<li><a href="#chapter-60-compiling-bsp-trees">Chapter 60 – Compiling BSP Trees</a><ul>
<li><a href="#taking-bsp-trees-from-concept-to-reality">Taking BSP Trees from Concept to Reality</a></li>
<li><a href="#compiling-bsp-trees">Compiling BSP Trees</a></li>
<li><a href="#optimizing-the-bsp-tree">Optimizing the BSP Tree</a></li>
<li><a href="#bsp-optimization-an-undiscovered-country">BSP Optimization: an Undiscovered Country</a></li>
</ul></li>
<li><a href="#chapter-61-frames-of-reference">Chapter 61 – Frames of Reference</a><ul>
<li><a href="#the-fundamentals-of-the-math-behind-3-d-graphics">The Fundamentals of the Math behind 3-D Graphics</a></li>
<li><a href="#the-dot-product">The Dot Product</a></li>
<li><a href="#cross-products-and-the-generation-of-polygon-normals">Cross Products and the Generation of Polygon Normals</a></li>
<li><a href="#using-the-sign-of-the-dot-product">Using the Sign of the Dot Product</a></li>
<li><a href="#using-the-dot-product-for-projection">Using the Dot Product for Projection</a></li>
<li><a href="#rotation-by-projection">Rotation by Projection</a></li>
</ul></li>
<li><a href="#chapter-62-one-story-two-rules-and-a-bsp-renderer">Chapter 62 – One Story, Two Rules, and a BSP Renderer</a><ul>
<li><a href="#taking-a-compiled-bsp-tree-from-logical-to-visual-reality">Taking a Compiled BSP Tree from Logical to Visual Reality</a></li>
<li><a href="#moving-the-viewer">Moving the Viewer</a></li>
<li><a href="#transformation-into-viewspace">Transformation into Viewspace</a></li>
<li><a href="#clipping">Clipping</a></li>
<li><a href="#projection-to-screenspace">Projection to Screenspace</a></li>
<li><a href="#walking-the-tree-backface-culling-and-drawing">Walking the Tree, Backface Culling and Drawing</a></li>
</ul></li>
<li><a href="#chapter-63-floating-point-for-real-time-3-d">Chapter 63 – Floating-Point for Real-Time 3-D</a><ul>
<li><a href="#knowing-when-to-hurl-conventional-math-wisdom-out-the-window">Knowing When to Hurl Conventional Math Wisdom Out the Window</a></li>
<li><a href="#not-your-fathers-floating-point">Not Your Father’s Floating-Point</a></li>
<li><a href="#pentium-floating-point-optimization">Pentium Floating-Point Optimization</a></li>
<li><a href="#the-dot-product-1">The Dot Product</a></li>
<li><a href="#the-cross-product">The Cross Product</a></li>
<li><a href="#transformation">Transformation</a></li>
<li><a href="#projection-1">Projection</a></li>
<li><a href="#rounding-control">Rounding Control</a></li>
<li><a href="#a-farewell-to-3-d-fixed-point">A Farewell to 3-D Fixed-Point</a></li>
</ul></li>
<li><a href="#chapter-64-quakes-visible-surface-determination">Chapter 64 – Quake’s Visible-Surface Determination</a><ul>
<li><a href="#the-challenge-of-separating-all-things-seen-from-all-things-unseen">The Challenge of Separating All Things Seen from All Things Unseen</a></li>
<li><a href="#vsd-the-toughest-3-d-challenge-of-all">VSD: The Toughest 3-D Challenge of All</a></li>
<li><a href="#the-structure-of-quake-levels">The Structure of Quake Levels</a></li>
<li><a href="#culling-and-visible-surface-determination">Culling and Visible Surface Determination</a></li>
<li><a href="#overdraw">Overdraw</a></li>
<li><a href="#the-beam-tree">The Beam Tree</a></li>
<li><a href="#d-engine-du-jour">3-D Engine du Jour</a></li>
<li><a href="#breakthrough">Breakthrough!</a></li>
<li><a href="#simplify-and-keep-on-trying-new-things">Simplify, and Keep on Trying New Things</a></li>
<li><a href="#learn-now-pay-forward">Learn Now, Pay Forward</a></li>
<li><a href="#references">References</a></li>
</ul></li>
<li><a href="#chapter-65-3-d-clipping-and-other-thoughts">Chapter 65 – 3-D Clipping and Other Thoughts</a><ul>
<li><a href="#determining-whats-inside-your-field-of-view">Determining What’s Inside Your Field of View</a></li>
<li><a href="#d-clipping-basics">3-D Clipping Basics</a></li>
<li><a href="#polygon-clipping">Polygon Clipping</a></li>
<li><a href="#advantages-of-viewspace-clipping">Advantages of Viewspace Clipping</a></li>
<li><a href="#further-reading-1">Further Reading</a></li>
</ul></li>
<li><a href="#chapter-66-quakes-hidden-surface-removal">Chapter 66 – Quake’s Hidden-Surface Removal</a><ul>
<li><a href="#struggling-with-z-order-solutions-to-the-hidden-surface-problem">Struggling with Z-Order Solutions to the Hidden Surface Problem</a></li>
<li><a href="#creative-flux-and-hidden-surfaces">Creative Flux and Hidden Surfaces</a></li>
<li><a href="#sorted-spans">Sorted Spans</a></li>
<li><a href="#edges-versus-spans">Edges versus Spans</a></li>
<li><a href="#edge-sorting-keys">Edge-Sorting Keys</a></li>
<li><a href="#decisions-deferred">Decisions Deferred</a></li>
</ul></li>
<li><a href="#chapter-67-sorted-spans-in-action">Chapter 67 – Sorted Spans in Action</a><ul>
<li><a href="#implementing-independent-span-sorting-for-rendering-without-overdraw">Implementing Independent Span Sorting for Rendering without Overdraw</a></li>
<li><a href="#quake-and-sorted-spans">Quake and Sorted Spans</a></li>
<li><a href="#types-of-1z-span-sorting">Types of 1/z Span Sorting</a></li>
<li><a href="#z-span-sorting-in-action">1/z Span Sorting in Action</a></li>
</ul></li>
<li><a href="#chapter-68-quakes-lighting-model">Chapter 68 – Quake’s Lighting Model</a><ul>
<li><a href="#a-radically-different-approach-to-lighting-polygons">A Radically Different Approach to Lighting Polygons</a></li>
<li><a href="#the-lighting-conundrum">The Lighting Conundrum</a></li>
<li><a href="#gouraud-shading">Gouraud Shading</a></li>
<li><a href="#the-quest-for-alternative-lighting">The Quest for Alternative Lighting</a></li>
<li><a href="#surface-caching">Surface Caching</a></li>
</ul></li>
<li><a href="#chapter-69-surface-caching-and-quakes-triangle-models">Chapter 69 – Surface Caching and Quake’s Triangle Models</a><ul>
<li><a href="#probing-hardware-assisted-surfaces-and-fast-model-animation-without-sprites">Probing Hardware-Assisted Surfaces and Fast Model Animation Without Sprites</a></li>
<li><a href="#surface-caching-with-hardware-assistance">Surface Caching with Hardware Assistance</a></li>
<li><a href="#drawing-triangle-models">Drawing Triangle Models</a></li>
</ul></li>
<li><a href="#chapter-70-quake-a-post-mortem-and-a-glimpse-into-the-future">Chapter 70 – Quake: A Post-Mortem and a Glimpse into the Future</a><ul>
<li><a href="#preprocessing-the-world">Preprocessing the World</a></li>
<li><a href="#the-potentially-visible-set-pvs">The Potentially Visible Set (PVS)</a></li>
<li><a href="#passages-the-last-minute-change-that-didnt-happen">Passages: The Last-Minute Change that Didn’t Happen</a></li>
<li><a href="#drawing-the-world">Drawing the World</a></li>
<li><a href="#rasterization">Rasterization</a></li>
<li><a href="#entities">Entities</a></li>
<li><a href="#how-we-spent-our-summer-vacation-after-shipping-quake">How We Spent Our Summer Vacation: After Shipping Quake</a></li>
<li><a href="#looking-forward">Looking Forward</a></li>
</ul></li>
</ul></li>
<li><a href="#afterword">Afterword</a></li>
<li><a href="#about-this-version">About this version</a></li>
</ul>
</nav>
<section id="introduction" class="level1">
<h1><a href="#introduction">Introduction</a></h1>
<p>What was it like working with John Carmack on Quake? Like being strapped onto a rocket during takeoff—in the middle of a hurricane. It seemed like the whole world was watching, waiting to see if id Software could top Doom; every casual e-mail tidbit or conversation with a visitor ended up posted on the Internet within hours. And meanwhile, we were pouring everything we had into Quake’s technology; I’d often come in in the morning to find John still there, working on a new idea so intriguing that he couldn’t bear to sleep until he had tried it out. Toward the end, when I spent most of my time speeding things up, I would spend the day in a trance writing optimized assembly code, stagger out of the Town East Tower into the blazing Texas heat, and somehow drive home on LBJ Freeway without smacking into any of the speeding pickups whizzing past me on both sides. At home, I’d fall into a fitful sleep, then come back the next day in a daze and do it again. Everything happened so fast, and under so much pressure, that sometimes I wonder how any of us made it through that without completely burning out.</p>
<p>At the same time, of course, it was tremendously exciting. John’s ideas were endless and brilliant, and Quake ended up establishing a new standard for Internet and first-person 3-D game technology. Happily, id has an enlightened attitude about sharing information, and was willing to let me write about the Quake technology—both how it worked and how it evolved. Over the two years I worked at id, I wrote a number of columns about Quake in <em>Dr. Dobb’s Sourcebook</em>, as well as a detailed overview for the 1997 Computer Game Developers Conference. You can find these in the latter part of this book; they represent a rare look into the development and inner workings of leading-edge software development, and I hope you enjoy reading them as much as I enjoyed developing the technology and writing about it.</p>
<p>The rest of this book is pretty much everything I’ve written over the past decade about graphics and performance programming that’s still relevant to programming today, and that covers a lot of ground. Most of <em>Zen of Graphics Programming, 2nd Edition</em> is in there (and the rest is on the CD); all of <em>Zen of Code Optimization</em> is there too, and even my 1989 book <em>Zen of Assembly Language</em>, with its long-dated 8088 cycle counts but a lot of useful perspectives, is on the CD. Add to that the most recent 20,000 words of Quake material, and you have most of what I’ve learned over the past decade in one neat package.</p>
<p>I’m delighted to have all this material in print in a single place, because over the past ten years I’ve run into a lot of people who have found my writings useful—and a lot more who would like to read them, but couldn’t find them. It’s hard to keep programming material (especially stuff that started out as columns) in print for very long, and I would like to thank The Coriolis Group, and particularly my good friend Jeff Duntemann (without whom not only this volume but pretty much my entire writing career wouldn’t exist), for helping me keep this material available.</p>
<p>I’d also like to thank Jon Erickson, editor of <em>Dr. Dobb’s</em>, both for encouragement and general good cheer and for giving me a place to write whatever I wanted about realtime 3-D. It still amazes me that I was able to find time to write a column every two months during Quake’s development, and if Jon hadn’t made it so easy and enjoyable, it could never have happened.</p>
<p>I’d also like to thank Chris Hecker and Jennifer Pahlka of the Computer Game Developers Conference, without whose encouragement, nudging, and occasional well-deserved nagging there is no chance I would ever have written a paper for the CGDC—a paper that ended up being the most comprehensive overview of the Quake technology that’s ever likely to be written, and which appears in these pages.</p>
<p>I don’t have much else to say that hasn’t already been said elsewhere in this book, in one of the introductions to the previous volumes or in one of the astonishingly large number of chapters. As you’ll see as you read, it’s been quite a decade for microcomputer programmers, and I have been extremely fortunate to not only be a part of it, but to be able to chronicle part of it as well.</p>
<p>And the next decade is shaping up to be just as exciting!</p>
<p>—<em>Michael Abrash</em><br /> Bellevue, Washington<br /> May 1997</p>
</section>
<section id="foreword" class="level1">
<h1><a href="#foreword">Foreword</a></h1>
<p>I got my start programming on Apple II computers at school, and almost all of my early work was on the Apple platform. After graduating, it quickly became obvious that I was going to have trouble paying my rent working in the Apple II market in the late eighties, so I was forced to make a very rapid move into the Intel PC environment.</p>
<p>What I was able to pick up over several years on the Apple, I needed to learn in the space of a few months on the PC.</p>
<p>The biggest benefit to me of actually making money as a programmer was the ability to buy all the books and magazines I wanted. I bought a lot. I was in territory that I new almost nothing about, so I read <em>everything</em> that I could get my hands on. Feature articles, editorials, even advertisements held information for me to assimilate.</p>
<p>John Romero clued me in early to the articles by Michael Abrash. The good stuff. Graphics hardware. Code optimization. Knowledge and wisdom for the aspiring developer. They were even fun to read. For a long time, my personal quest was to find a copy of Michael’s first book, <em>Zen of Assembly Language.</em> I looked in every bookstore I visited, but I never did find it. I made do with the articles I could dig up.</p>
<p>I learned the dark secrets of the EGA video controller there, and developed a few neat tricks of my own. Some of those tricks became the basis for the Commander Keen series of games, which launched id Software.</p>
<p>A year or two later, after Wolfenstein-3D, I bumped into Michael (in a virtual sense) for the first time. I was looking around on M&amp;T Online, a BBS run by the Dr. Dobb’s publishers before the Internet explosion, when I saw some posts from the man himself. We traded email, and for a couple months we played tag-team gurus on the graphics forum before Doom’s development took over my life.</p>
<p>A friend of Michael’s at his new job put us back in touch with each other after Doom began to make its impact, and I finally got a chance to meet up with him in person.</p>
<p>I talked myself hoarse that day, explaining all the ins and outs of Doom to Michael and an interested group of his coworkers. Every few days afterwards, I would get an email from Michael asking for an elaboration on one of my points, or discussing an aspect of the future of graphics.</p>
<p>Eventually, I popped the question—I offered him a job at id. “Just think: no reporting to anyone, an opportunity to code all day, starting with a clean sheet of paper. A chance to do <em>the right thing</em> as a programmer.” It didn’t work. I kept at it though, and about a year later I finally convinced him to come down and take a look at id. I was working on Quake.</p>
<p>Going from Doom to Quake was a tremendous step. I knew where I wanted to end up, but I wasn’t at all clear what the steps were to get there. I was trying a huge number of approaches, and even the failures were teaching me a lot. My enthusiasm must have been contagious, because he took the job.</p>
<p>Much heroic programming ensued. Several hundred thousand lines of code were written. And rewritten. And rewritten. And rewritten.</p>
<p>In hindsight, I have plenty of regrets about various aspects of Quake, but it is a rare person that doesn’t freely acknowledge the technical triumph of it. We nailed it. Sure, a year from now I will have probably found a new perspective that will make me cringe at the clunkiness of some part of Quake, but at the moment it still looks pretty damn good to me.</p>
<p>I was very happy to have Michael describe much of the Quake technology in his ongoing magazine articles. We learned a lot, and I hope we managed to teach a bit.</p>
<p>When a non-programmer hears about Michael’s articles or the source code I have released, I usually get a stunned “WTF would you do that for???” look.</p>
<p>They don’t get it.</p>
<p>Programming is not a zero-sum game. Teaching something to a fellow programmer doesn’t take it away from you. I’m happy to share what I can, because I’m in it for the love of programming. The Ferraris are just gravy, honest!</p>
<p>This book contains many of the original articles that helped launch my programming career. I hope my contribution to the contents of the later articles can provide similar stepping stones for others.</p>
<p>—<em>John Carmack</em><br /> id Software</p>
</section>
<section id="acknowledgments" class="level1">
<h1><a href="#acknowledgments">Acknowledgments</a></h1>
<p>There are many people to thank—because this book was written over many years, in many different settings, an unusually large number of people have played a part in making this book possible. Thanks to Dan Illowsky for not only contributing ideas and encouragement, but also getting me started writing articles long ago, when I lacked the confidence to do it on my own—and for teaching me how to handle the business end of things. Thanks to Will Fastie for giving me my first crack at writing for a large audience in the long-gone but still-missed <em>PC Tech Journal</em>, and for showing me how much fun it could be in his even longer-vanished but genuinely terrific column in <em>Creative Computing</em> (the most enjoyable single column I have ever read in a computer magazine; I used to haunt the mailbox around the beginning of the month just to see what Will had to say). Thanks to Robert Keller, Erin O’Connor, Liz Oakley, Steve Baker, and the rest of the cast of thousands that made <em>Programmer’s Journal</em> a uniquely fun magazine—especially Erin, who did more than anyone to teach me the proper use of the English language. (To this day, Erin will still patiently explain to me when one should use “that” and when one should use “which,” even though eight years of instruction on this and related topics have left no discernible imprint on my brain.) Thanks to Tami Zemel, Monica Berg, and the rest of the <em>Dr. Dobb’s Journal</em> crew for excellent, professional editing, and for just being great people. Thanks to the Coriolis gang for their tireless hard work: Jeff Duntemann, Kim Eoff, Jody Kent, Robert Clarfield, and Anthony Stock. Thanks to Jack Tseng for teaching me a lot about graphics hardware, and even more about how much difference hard work can make. Thanks to John Cockerham, David Stafford, Terje Mathisen, the BitMan, Chris Hecker, Jim Mackraz, Melvin Lafitte, John Navas, Phil Coleman, Anton Truenfels, John Carmack, John Miles, John Bridges, Jim Kent, Hal Hardenbergh, Dave Miller, Steve Levy, Jack Davis, Duane Strong, Daev Rohr, Bill Weber, Dan Gochnauer, Patrick Milligan, Tom Wilson, Peter Klerings, Dave Methvin, Mick Brown, the people in the ibm.pc/fast.code topic on Bix, and all the rest of you who have been so generous with your ideas and suggestions. I’ve done my best to acknowledge contributors by name in this book, but if your name is omitted, my apologies, and consider yourself thanked; this book could not have happened without you. And, of course, thanks to Shay and Emily for their generous patience with my passion for writing and computers.</p>
</section>
<section id="part-i" class="level1">
<h1><a href="#part-i">Part I</a></h1>
<section id="chapter-1-the-best-optimizer-is-between-your-ears" class="level2">
<h2><a href="#chapter-1-the-best-optimizer-is-between-your-ears">Chapter 1 – The Best Optimizer Is between Your Ears</a></h2>
<section id="the-human-element-of-code-optimization" class="level3">
<h3><a href="#the-human-element-of-code-optimization">The Human Element of Code Optimization</a></h3>
<p>This book is devoted to a topic near and dear to my heart: writing software that pushes PCs to the limit. Given run-of-the-mill software, PCs run like the 97-pound-weakling minicomputers they are. Give them the proper care, however, and those ugly boxes are capable of miracles. The key is this: Only on microcomputers do you have the run of the whole machine, without layers of operating systems, drivers, and the like getting in the way. You can do <em>anything</em> you want, and you can understand everything that’s going on, if you so wish.</p>
<p>As we’ll see shortly, you should indeed so wish.</p>
<p>Is performance still an issue in this era of cheap 486 computers and super-fast Pentium computers? You bet. How many programs that <em>you</em> use really run so fast that you wouldn’t be happier if they ran faster? We’re so used to slow software that when a compile-and-link sequence that took two minutes on a PC takes just ten seconds on a 486 computer, we’re ecstatic—when in truth we should be settling for nothing less than instantaneous response.</p>
<p>Impossible, you say? Not with the proper design, including incremental compilation and linking, use of extended and/or expanded memory, and well-crafted code. PCs can do just about anything you can imagine (with a few obvious exceptions, such as applications involving super-computer-class number-crunching) if you believe that it can be done, if you understand the computer inside and out, and if you’re willing to think past the obvious solution to unconventional but potentially more fruitful approaches.</p>
<p>My point is simply this: PCs can work wonders. It’s not easy coaxing them into doing that, but it’s rewarding—and it’s sure as heck fun. In this book, we’re going to work some of those wonders, starting…</p>
<p>…now.</p>
</section>
<section id="understanding-high-performance" class="level3">
<h3><a href="#understanding-high-performance">Understanding High Performance</a></h3>
<p>Before we can create high-performance code, we must understand what high performance is. The objective (not always attained) in creating high-performance software is to make the software able to carry out its appointed tasks so rapidly that it responds instantaneously, as far as the user is concerned. In other words, high-performance code should ideally run so fast that any further improvement in the code would be pointless.</p>
<p>Notice that the above definition most emphatically does <em>not</em> say anything about making the software as fast as possible. It also does not say anything about using assembly language, or an optimizing compiler, or, for that matter, a compiler at all. It also doesn’t say anything about how the code was designed and written. What it does say is that high-performance code shouldn’t get in the user’s way—and that’s <em>all</em>.</p>
<p>That’s an important distinction, because all too many programmers think that assembly language, or the right compiler, or a particular high-level language, or a certain design approach is the answer to creating high-performance code. They’re not, any more than choosing a certain set of tools is the key to building a house. You do indeed need tools to build a house, but any of many sets of tools will do. You also need a blueprint, an understanding of everything that goes into a house, and the ability to <em>use</em> the tools.</p>
<p>Likewise, high-performance programming requires a clear understanding of the purpose of the software being built, an overall program design, algorithms for implementing particular tasks, an understanding of what the computer can do and of what all relevant software is doing—<em>and</em> solid programming skills, preferably using an optimizing compiler or assembly language. The optimization at the end is just the finishing touch, however.</p>
<blockquote>
<p><img src="images/i.jpg" /> Without good design, good algorithms, and complete understanding of the program’s operation, your carefully optimized code will amount to one of mankind’s least fruitful creations—a fast slow program.</p>
</blockquote>
<p>“What’s a fast slow program?” you ask. That’s a good question, and a brief (true) story is perhaps the best answer.</p>
<section id="when-fast-isnt-fast" class="level4">
<h4><a href="#when-fast-isnt-fast">When Fast Isn’t Fast</a></h4>
<p>In the early 1970s, as the first hand-held calculators were hitting the market, I knew a fellow named Irwin. He was a good student, and was planning to be an engineer. Being an engineer back then meant knowing how to use a slide rule, and Irwin could jockey a slipstick with the best of them. In fact, he was so good that he challenged a fellow with a calculator to a duel—and won, becoming a local legend in the process.</p>
<p>When you get right down to it, though, Irwin was spitting into the wind. In a few short years his hard-earned slipstick skills would be worthless, and the entire discipline would be essentially wiped from the face of the earth. What’s more, anyone with half a brain could see that changeover coming. Irwin had basically wasted the considerable effort and time he had spent optimizing his soon-to-be-obsolete skills.</p>
<p>What does all this have to do with programming? Plenty. When you spend time optimizing poorly-designed assembly code, or when you count on an optimizing compiler to make your code fast, you’re wasting the optimization, much as Irwin did. Particularly in assembly, you’ll find that without proper up-front design and everything else that goes into high-performance design, you’ll waste considerable effort and time on making an inherently slow program as fast as possible—which is still slow—when you could easily have improved performance a great deal more with just a little thought. As we’ll see, handcrafted assembly language and optimizing compilers matter, but less than you might think, in the grand scheme of things—and they scarcely matter at all unless they’re used in the context of a good design and a thorough understanding of both the task at hand and the PC.</p>
</section>
</section>
<section id="rules-for-building-high-performance-code" class="level3">
<h3><a href="#rules-for-building-high-performance-code">Rules for Building High-Performance Code</a></h3>
<p>We’ve got the following rules for creating high-performance software:</p>
<ul>
<li>Know where you’re going (understand the objective of the software).</li>
<li>Make a big map (have an overall program design firmly in mind, so the various parts of the program and the data structures work well together).</li>
<li>Make lots of little maps (design an algorithm for each separate part of the overall design).</li>
<li>Know the territory (understand exactly how the computer carries out each task).</li>
<li>Know when it matters (identify the portions of your programs where performance matters, and don’t waste your time optimizing the rest).</li>
<li>Always consider the alternatives (don’t get stuck on a single approach; odds are there’s a better way, if you’re clever and inventive enough).</li>
<li>Know how to turn on the juice (optimize the code as best you know how when it <em>does</em> matter).</li>
</ul>
<p>Making rules is easy; the hard part is figuring out how to apply them in the real world. For my money, examining some actual working code is always a good way to get a handle on programming concepts, so let’s look at some of the performance rules in action.</p>
<section id="know-where-youre-going" class="level4">
<h4><a href="#know-where-youre-going">Know Where You’re Going</a></h4>
<p>If we’re going to create high-performance code, first we have to know what that code is going to do. As an example, let’s write a program that generates a 16-bit checksum of the bytes in a file. In other words, the program will add each byte in a specified file in turn into a 16-bit value. This checksum value might be used to make sure that a file hasn’t been corrupted, as might occur during transmission over a modem or if a Trojan horse virus rears its ugly head. We’re not going to do anything with the checksum value other than print it out, however; right now we’re only interested in generating that checksum value as rapidly as possible.</p>
</section>
<section id="make-a-big-map" class="level4">
<h4><a href="#make-a-big-map">Make a Big Map</a></h4>
<p>How are we going to generate a checksum value for a specified file? The logical approach is to get the file name, open the file, read the bytes out of the file, add them together, and print the result. Most of those actions are straightforward; the only tricky part lies in reading the bytes and adding them together.</p>
</section>
<section id="make-lots-of-little-maps" class="level4">
<h4><a href="#make-lots-of-little-maps">Make Lots of Little Maps</a></h4>
<p>Actually, we’re only going to make one little map, because we only have one program section that requires much thought—the section that reads the bytes and adds them up. What’s the best way to do this?</p>
<p>It would be convenient to load the entire file into memory and then sum the bytes in one loop. Unfortunately, there’s no guarantee that any particular file will fit in the available memory; in fact, it’s a sure thing that many files <em>won’t</em> fit into memory, so that approach is out.</p>
<p>Well, if the whole file won’t fit into memory, one byte surely will. If we read the file one byte at a time, adding each byte to the checksum value before reading the next byte, we’ll minimize memory requirements and be able to handle any size file at all.</p>
<p>Sounds good, eh? Listing 1.1 shows an implementation of this approach. Listing 1.1 uses C’s <code>read()</code> function to read a single byte, adds the byte into the checksum value, and loops back to handle the next byte until the end of the file is reached. The code is compact, easy to write, and functions perfectly—with one slight hitch:</p>
<p>It’s <em>slow</em>.</p>
<p><strong>LISTING 1.1 L1-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co">* Program to calculate the 16-bit checksum of all bytes in the</span>
<span class="co">* specified file. Obtains the bytes one at a time via read(),</span>
<span class="co">* letting DOS perform all data buffering.</span>
<span class="co">*/</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;fcntl.h&gt;</span>

main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]) {
     <span class="dt">int</span> Handle;
     <span class="dt">unsigned</span> <span class="dt">char</span> Byte;
     <span class="dt">unsigned</span> <span class="dt">int</span> Checksum;
     <span class="dt">int</span> ReadLength;

     <span class="kw">if</span> ( argc != <span class="dv">2</span> ) {
          printf(<span class="st">&quot;usage: checksum filename</span><span class="ch">\n</span><span class="st">&quot;</span>);
          exit(<span class="dv">1</span>);
     }
     <span class="kw">if</span> ( (Handle = open(argv[<span class="dv">1</span>], O_RDONLY | O_BINARY)) == -<span class="dv">1</span> ) {
          printf(<span class="st">&quot;Can&#39;t open file: %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
          exit(<span class="dv">1</span>);
     }

     <span class="co">/* Initialize the checksum accumulator */</span>
     Checksum = <span class="dv">0</span>;

     <span class="co">/* Add each byte in turn into the checksum accumulator */</span>
     <span class="kw">while</span> ( (ReadLength = read(Handle, &amp;Byte, <span class="kw">sizeof</span>(Byte))) &gt; <span class="dv">0</span> ) {
          Checksum += (<span class="dt">unsigned</span> <span class="dt">int</span>) Byte;
     }
     <span class="kw">if</span> ( ReadLength == -<span class="dv">1</span> ) {
          printf(<span class="st">&quot;Error reading file %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
          exit(<span class="dv">1</span>);
     }


     <span class="co">/* Report the result */</span>
     printf(<span class="st">&quot;The checksum is: %u</span><span class="ch">\n</span><span class="st">&quot;</span>, Checksum);
     exit(<span class="dv">0</span>);
}</code></pre>
<p>Table 1.1 shows the time taken for Listing 1.1 to generate a checksum of the WordPerfect version 4.2 thesaurus file, TH.WP (362,293 bytes in size), on a 10 MHz AT machine of no special parentage. Execution times are given for Listing 1.1 compiled with Borland and Microsoft compilers, with optimization both on and off; all four times are pretty much the same, however, and all are much too slow to be acceptable. Listing 1.1 requires over two and one-half minutes to checksum <em>one</em> file!</p>
<blockquote>
<p><img src="images/i.jpg" /> Listings 1.2 and 1.3 form the C/assembly equivalent to Listing 1.1, and Listings 1.6 and 1.7 form the C/assembly equivalent to Listing 1.5.</p>
</blockquote>
<p>These results make it clear that it’s folly to rely on your compiler’s optimization to make your programs fast. Listing 1.1 is simply poorly designed, and no amount of compiler optimization will compensate for that failing. To drive home the point, conListings 1.2 and 1.3, which together are equivalent to Listing 1.1 except that the entire checksum loop is written in tight assembly code. The assembly language implementation is indeed faster than any of the C versions, as shown in Table 1.1, but it’s less than 10 percent faster, and it’s still unacceptably slow.</p>
<table>
<caption>Table 1.1 Execution Times for WordPerfect Checksum.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Listing</th>
<th style="text-align: left;">Borland</th>
<th style="text-align: left;">Microsoft</th>
<th style="text-align: left;">Borland</th>
<th style="text-align: left;">Microsoft</th>
<th style="text-align: left;">Assembly</th>
<th style="text-align: left;">Optimization Ratio</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">(no opt)</td>
<td style="text-align: left;">(no opt)</td>
<td style="text-align: left;">(opt)</td>
<td style="text-align: left;">(opt)</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">166.9</td>
<td style="text-align: left;">166.8</td>
<td style="text-align: left;">167.0</td>
<td style="text-align: left;">165.8</td>
<td style="text-align: left;">155.1</td>
<td style="text-align: left;">1.08</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;">13.5</td>
<td style="text-align: left;">13.6</td>
<td style="text-align: left;">13.5</td>
<td style="text-align: left;">13.5</td>
<td style="text-align: left;">…</td>
<td style="text-align: left;">1.01</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td style="text-align: left;">4.7</td>
<td style="text-align: left;">5.5</td>
<td style="text-align: left;">3.8</td>
<td style="text-align: left;">3.4</td>
<td style="text-align: left;">2.7</td>
<td style="text-align: left;">2.04</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Ratio best designed to worst designed</td>
<td style="text-align: left;">35.51</td>
<td style="text-align: left;">30.33</td>
<td style="text-align: left;">43.95</td>
<td style="text-align: left;">48.76</td>
<td style="text-align: left;">57.44</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> The execution times (in seconds) for this chapter’s listings were timed when the compiled listings were run on the WordPerfect 4.2 thesaurus file TH.WP (362,293 bytes in size), as compiled in the small model with Borland and Microsoft compilers with optimization on (opt) and off (no opt). All times were measured with Paradigm Systems’ TIMER program on a 10 MHz 1-wait-state AT clone with a 28-ms hard disk, with disk caching turned off.</p>
<p><strong>LISTING 1.2 L1-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co">* Program to calculate the 16-bit checksum of the stream of bytes</span>
<span class="co">* from the specified file. Obtains the bytes one at a time in</span>
<span class="co">* assembler, via direct calls to DOS.</span>
<span class="co">*/</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;fcntl.h&gt;</span>

main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]) {
      <span class="dt">int</span> Handle;
      <span class="dt">unsigned</span> <span class="dt">char</span> Byte;
      <span class="dt">unsigned</span> <span class="dt">int</span> Checksum;
      <span class="dt">int</span> ReadLength;

      <span class="kw">if</span> ( argc != <span class="dv">2</span> ) {
            printf(<span class="st">&quot;usage: checksum filename</span><span class="ch">\n</span><span class="st">&quot;</span>);
            exit(<span class="dv">1</span>);
      }
      <span class="kw">if</span> ( (Handle = open(argv[<span class="dv">1</span>], O_RDONLY | O_BINARY)) == -<span class="dv">1</span> ) {
            printf(<span class="st">&quot;Can&#39;t open file: %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
            exit(<span class="dv">1</span>);
      }
      <span class="kw">if</span> ( !ChecksumFile(Handle, &amp;Checksum) ) {
            printf(<span class="st">&quot;Error reading file %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
            exit(<span class="dv">1</span>);
      }

      <span class="co">/* Report the result */</span>
      printf(<span class="st">&quot;The checksum is: %u</span><span class="ch">\n</span><span class="st">&quot;</span>, Checksum);
      exit(<span class="dv">0</span>);
}</code></pre>
<p><strong>LISTING 1.3 L1-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Assembler subroutine to perform a 16-bit checksum on the file</span>
<span class="co">; opened on the passed-in handle. Stores the result in the</span>
<span class="co">; passed-in checksum variable. Returns 1 for success, 0 for error.</span>
<span class="co">;</span>
<span class="co">; Call as:</span>
<span class="co">;           int ChecksumFile(unsigned int Handle, unsigned int *Checksum);</span>
<span class="co">;</span>
<span class="co">; where:</span>
<span class="co">;           Handle = handle # under which file to checksum is open</span>
<span class="co">;           Checksum = pointer to unsigned int variable checksum is</span>
<span class="co">;           to be stored in</span>
<span class="co">;</span>
<span class="co">; Parameter structure:</span>
<span class="co">;</span>
Parms      <span class="kw">struc</span>
                 <span class="dt">dw</span>        ?       <span class="co">;pushed BP</span>
                 <span class="dt">dw</span>        ?       <span class="co">;return address</span>
Handle           <span class="dt">dw</span>        ?
Checksum         <span class="dt">dw</span>        ?
Parms      ends
<span class="co">;</span>
                 .model small
                 .data
TempWord label   <span class="dt">word</span>
TempByte         <span class="dt">db</span>        ?       <span class="co">;each byte read by DOS will be stored here</span>
                 <span class="dt">db</span>        <span class="dv">0</span>       <span class="co">;high byte of TempWord is always 0</span>
                                   <span class="co">;for 16-bit adds</span>
<span class="co">;</span>
                 .code
                 public _ChecksumFile
_ChecksumFile    proc near
                 <span class="kw">push</span>      <span class="kw">bp</span>
                 <span class="kw">mov</span>       <span class="kw">bp</span>,<span class="kw">sp</span>
                 <span class="kw">push</span>      <span class="kw">si</span>                  <span class="co">;save C&#39;s register variable</span>
<span class="co">;</span>
                 <span class="kw">mov</span>       <span class="kw">bx</span>,[<span class="kw">bp</span>+Handle]       <span class="co">;get file handle</span>
                 <span class="kw">sub</span>       <span class="kw">si</span>,<span class="kw">si</span>                <span class="co">;zero the checksum ;accumulator</span>
                 <span class="kw">mov</span>       <span class="kw">cx</span>,<span class="dv">1</span>                 <span class="co">;request one byte on each ;read</span>
                 <span class="kw">mov</span>       <span class="kw">dx</span>,offset TempByte   <span class="co">;point DX to the byte in</span>
                                                <span class="co">;which DOS should store</span>
                                                <span class="co">;each byte read</span>
<span class="fu">ChecksumLoop:</span>
                 <span class="kw">mov</span>       <span class="kw">ah</span><span class="bn">,3fh               </span><span class="co">;DOS read file function #</span>
                 <span class="kw">int</span><span class="bn">       21h                  </span><span class="co">;read the byte</span>
<span class="kw">jc</span>ErrorEnd<span class="co">;an error occurred</span>
                 <span class="kw">and</span>       <span class="kw">ax</span>,<span class="kw">ax</span>                <span class="co">;any bytes read?</span>
                 <span class="kw">jz</span>        Success              <span class="co">;no-end of file reached-we&#39;re done</span>
                 <span class="kw">add</span>       <span class="kw">si</span>,[TempWord]        <span class="co">;add the byte into the</span>
                                                <span class="co">;checksum total</span>
jmpChecksumLoop
<span class="fu">ErrorEnd:</span>
                 <span class="kw">sub</span>       <span class="kw">ax</span>,<span class="kw">ax</span>                <span class="co">;error</span>
                 <span class="kw">jmp</span>       <span class="dt">short</span> Done
<span class="fu">Success:</span>
                 <span class="kw">mov</span>       <span class="kw">bx</span>,[<span class="kw">bp</span>+Checksum] <span class="co">;point to the checksum variable</span>
                 <span class="kw">mov</span>       [<span class="kw">bx</span>],<span class="kw">si</span>              <span class="co">;save the new checksum</span>
                 <span class="kw">mov</span>       <span class="kw">ax</span>,<span class="dv">1</span>                 <span class="co">;success</span>
<span class="co">;</span>
<span class="fu">Done:</span>
                 <span class="kw">pop</span>       <span class="kw">si</span>                   <span class="co">;restore C&#39;s register variable</span>
                 <span class="kw">pop</span>       <span class="kw">bp</span>
                 <span class="kw">ret</span>
_ChecksumFileendp
                 end</code></pre>
<p>The lesson is clear: Optimization makes code faster, but without proper design, optimization just creates fast slow code.</p>
<p>Well, then, how are we going to improve our design? Before we can do that, we have to understand what’s wrong with the current design.</p>
</section>
<section id="know-the-territory" class="level4">
<h4><a href="#know-the-territory">Know the Territory</a></h4>
<p>Just why is Listing 1.1 so slow? In a word: overhead. The C library implements the <code>read()</code> function by calling DOS to read the desired number of bytes. (I figured this out by watching the code execute with a debugger, but you can buy library source code from both Microsoft and Borland.) That means that Listing 1.1 (and Listing 1.3 as well) executes one DOS function per byte processed—and DOS functions, especially this one, come with a lot of overhead.</p>
<p>For starters, DOS functions are invoked with interrupts, and interrupts are among the slowest instructions of the x86 family CPUs. Then, DOS has to set up internally and branch to the desired function, expending more cycles in the process. Finally, DOS has to search its own buffers to see if the desired byte has already been read, read it from the disk if not, store the byte in the specified location, and return. All of that takes a <em>long</em> time—far, far longer than the rest of the main loop in Listing 1.1. In short, Listing 1.1 spends virtually all of its time executing <code>read()</code>, and most of that time is spent somewhere down in DOS.</p>
<p>You can verify this for yourself by watching the code with a debugger or using a code profiler, but take my word for it: There’s a great deal of overhead to DOS calls, and that’s what’s draining the life out of Listing 1.1.</p>
<p>How can we speed up Listing 1.1? It should be clear that we must somehow avoid invoking DOS for every byte in the file, and that means reading more than one byte at a time, then buffering the data and parceling it out for examination one byte at a time. By gosh, that’s a description of C’s stream I/O feature, whereby C reads files in chunks and buffers the bytes internally, doling them out to the application as needed by reading them from memory rather than calling DOS. Let’s try using stream I/O and see what happens.</p>
<p>Listing 1.4 is similar to Listing 1.1, but uses <code>fopen()</code> and <code>getc()</code> (rather than <code>open()</code> and <code>read()</code>) to access the file being checksummed. The results confirm our theories splendidly, and validate our new design. As shown in Table 1.1, Listing 1.4 runs more than an order of magnitude faster than even the assembly version of Listing 1.1, <em>even though Listing 1.1 and Listing 1.4 look almost the same</em>. To the casual observer, <code>read()</code> and <code>getc()</code> would seem slightly different but pretty much interchangeable, and yet in this application the performance difference between the two is about the same as that between a 4.77 MHz PC and a 16 MHz 386.</p>
<blockquote>
<p><img src="images/i.jpg" /> Make sure you understand what really goes on when you insert a seemingly-innocuous function call into the time-critical portions of your code.</p>
</blockquote>
<p>In this case that means knowing how DOS and the C/C++ file-access libraries do their work. In other words, <em>know the territory</em>!</p>
<p><strong>LISTING 1.4 L1-4.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co">* Program to calculate the 16-bit checksum of the stream of bytes</span>
<span class="co">* from the specified file. Obtains the bytes one at a time via</span>
<span class="co">* getc(), allowing C to perform data buffering.</span>
<span class="co">*/</span>
<span class="ot">#include &lt;stdio.h&gt;</span>

main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]) {
      FILE *CheckFile;
      <span class="dt">int</span> Byte;
      <span class="dt">unsigned</span> <span class="dt">int</span> Checksum;

      <span class="kw">if</span> ( argc != <span class="dv">2</span> ) {
            printf(<span class="st">&quot;usage: checksum filename</span><span class="ch">\n</span><span class="st">&quot;</span>);
            exit(<span class="dv">1</span>);
      }
      <span class="kw">if</span> ( (CheckFile = fopen(argv[<span class="dv">1</span>], <span class="st">&quot;rb&quot;</span>)) == NULL ) {
            printf(<span class="st">&quot;Can&#39;t open file: %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
            exit(<span class="dv">1</span>);
      }

      <span class="co">/* Initialize the checksum accumulator */</span>
      Checksum = <span class="dv">0</span>;

      <span class="co">/* Add each byte in turn into the checksum accumulator */</span>
      <span class="kw">while</span> ( (Byte = getc(CheckFile)) != EOF ) {
            Checksum += (<span class="dt">unsigned</span> <span class="dt">int</span>) Byte;
      }

      <span class="co">/* Report the result */</span>
      printf(<span class="st">&quot;The checksum is: %u</span><span class="ch">\n</span><span class="st">&quot;</span>, Checksum);
      exit(<span class="dv">0</span>);
}</code></pre>
</section>
<section id="know-when-it-matters" class="level4">
<h4><a href="#know-when-it-matters">Know When It Matters</a></h4>
<p>The last section contained a particularly interesting phrase: <em>the time-critical portions of your code</em>. Time-critical portions of your code are those portions in which the speed of the code makes a significant difference in the overall performance of your program—and by “significant,” I don’t mean that it makes the code 100 percent faster, or 200 percent, or any particular amount at all, but rather that it makes the program more responsive and/or usable <em>from the user’s perspective</em>.</p>
<p>Don’t waste time optimizing non-time-critical code: set-up code, initialization code, and the like. Spend your time improving the performance of the code inside heavily-used loops and in the portions of your programs that directly affect response time. Notice, for example, that I haven’t bothered to implement a version of the checksum program entirely in assembly; Listings 1.2 and 1.6 call assembly subroutines that handle the time-critical operations, but C is still used for checking command-line parameters, operning files, printing, and the like.</p>
<blockquote>
<p><img src="images/i.jpg" /> If you were to implement any of the listings in this chapter entirely in hand-optimized assembly, I suppose you might get a performance improvement of a few percent—but I rather doubt you’d get even that much, and you’d sure as heck spend an awful lot of time for whatever meager improvement does result. Let C do what it does well, and use assembly only when it makes a perceptible difference.</p>
</blockquote>
<p>Besides, we don’t want to optimize until the design is refined to our satisfaction, and that won’t be the case until we’ve thought about other approaches.</p>
</section>
<section id="always-consider-the-alternatives" class="level4">
<h4><a href="#always-consider-the-alternatives">Always Consider the Alternatives</a></h4>
<p>Listing 1.4 is good, but let’s see if there are other—perhaps less obvious—ways to get the same results faster. Let’s start by considering why Listing 1.4 is so much better than Listing 1.1. Like <code>read()</code>, <code>getc()</code> calls DOS to read from the file; the speed improvement of Listing 1.4 over Listing 1.1 occurs because <code>getc()</code> eads many bytes at once via DOS, then manages those bytes for us. That’s faster than reading them one at a time using <code>read()</code>—but there’s no reason to think that it’s faster than having our program read and manage blocks itself. Easier, yes, but not faster.</p>
<p>Consider this: Every invocation of <code>getc()</code> involves pushing a parameter, executing a call to the C library function, getting the parameter (in the C library code), looking up information about the desired stream, unbuffering the next byte from the stream, and returning to the calling code. That takes a considerable amount of time, especially by contrast with simply maintaining a pointer to a buffer and whizzing through the data in the buffer inside a single loop.</p>
<p>There are four reasons that many programmers would give for not trying to improve on Listing 1.4:</p>
<ol type="1">
<li><p>The code is already fast enough.</p></li>
<li><p>The code works, and some people are content with code that works, even when it’s slow enough to be annoying.</p></li>
<li><p>The C library is written in optimized assembly, and it’s likely to be faster than any code that the average programmer could write to perform essentially the same function.</p></li>
<li><p>The C library conveniently handles the buffering of file data, and it would be a nuisance to have to implement that capability.</p></li>
</ol>
<p>I’ll ignore the first reason, both because performance is no longer an issue if the code is fast enough and because the current application does <em>not</em> run fast enough—13 seconds is a long time. (Stop and wait for 13 seconds while you’re doing something intense, and you’ll see just how long it is.)</p>
<p>The second reason is the hallmark of the mediocre programmer. Know when optimization matters—and then optimize when it does!</p>
<p>The third reason is often fallacious. C library functions are not always written in assembly, nor are they always particularly well-optimized. (In fact, they’re often written for <em>portability</em>, which has nothing to do with optimization.) What’s more, they’re general-purpose functions, and often can be outperformed by well-but-not- brilliantly-written code that is well-matched to a specific task. As an example, consider Listing 1.5, which uses internal buffering to handle blocks of bytes at a time. Table 1.1 shows that Listing 1.5 is 2.5 to 4 times faster than Listing 1.4 (and as much as 49 times faster than Listing 1.1!), even though it uses no assembly at all.</p>
<blockquote>
<p><img src="images/i.jpg" /> Clearly, you can do well by using special-purpose C code in place of a C library function—if you have a thorough understanding of how the C library function operates and exactly what your application needs done. Otherwise, you’ll end up rewriting C library functions in C, which makes no sense at all.</p>
</blockquote>
<p><strong>LISTING 1.5 L1-5.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co">* Program to calculate the 16-bit checksum of the stream of bytes</span>
<span class="co">* from the specified file. Buffers the bytes internally, rather</span>
<span class="co">* than letting C or DOS do the work.</span>
<span class="co">*/</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;fcntl.h&gt;</span>
<span class="ot">#include &lt;alloc.h&gt;   </span><span class="co">/* alloc.h for Borland,</span>
<span class="co">                                malloc.h for Microsoft  */</span>

<span class="ot">#define BUFFER_SIZE  0x8000   </span><span class="co">/* 32Kb data buffer */</span>

main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]) {
      <span class="dt">int</span> Handle;
      <span class="dt">unsigned</span> <span class="dt">int</span> Checksum;
      <span class="dt">unsigned</span> <span class="dt">char</span> *WorkingBuffer, *WorkingPtr;
      <span class="dt">int</span> WorkingLength, LengthCount;

      <span class="kw">if</span> ( argc != <span class="dv">2</span> ) {
            printf(<span class="st">&quot;usage: checksum filename</span><span class="ch">\n</span><span class="st">&quot;</span>);
            exit(<span class="dv">1</span>);
      }
      <span class="kw">if</span> ( (Handle = open(argv[<span class="dv">1</span>], O_RDONLY | O_BINARY)) == -<span class="dv">1</span> ) {
            printf(<span class="st">&quot;Can&#39;t open file: %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
            exit(<span class="dv">1</span>);
      }

      <span class="co">/* Get memory in which to buffer the data */</span>
      <span class="kw">if</span> ( (WorkingBuffer = malloc(BUFFER_SIZE)) == NULL ) {
            printf(<span class="st">&quot;Can&#39;t get enough memory</span><span class="ch">\n</span><span class="st">&quot;</span>);
            exit(<span class="dv">1</span>);
      }

      <span class="co">/* Initialize the checksum accumulator */</span>
      Checksum = <span class="dv">0</span>;

      <span class="co">/* Process the file in BUFFER_SIZE chunks */</span>
      <span class="kw">do</span> {
            <span class="kw">if</span> ( (WorkingLength = read(Handle, WorkingBuffer,
                  BUFFER_SIZE)) == -<span class="dv">1</span> ) {
                  printf(<span class="st">&quot;Error reading file %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
                  exit(<span class="dv">1</span>);
            }
            <span class="co">/* Checksum this chunk */</span>
            WorkingPtr = WorkingBuffer;
            LengthCount = WorkingLength;
            <span class="kw">while</span> ( LengthCount-- ) {
            <span class="co">/* Add each byte in turn into the checksum accumulator */</span>
                  Checksum += (<span class="dt">unsigned</span> <span class="dt">int</span>) *WorkingPtr++;
      }
      } <span class="kw">while</span> ( WorkingLength );

      <span class="co">/* Report the result */</span>
      printf(<span class="st">&quot;The checksum is: %u</span><span class="ch">\n</span><span class="st">&quot;</span>, Checksum);
      exit(<span class="dv">0</span>);
}</code></pre>
<p>That brings us to the fourth reason: avoiding an internal-buffered implementation like Listing 1.5 because of the difficulty of coding such an approach. True, it is easier to let a C library function do the work, but it’s not all that hard to do the buffering internally. The key is the concept of handling data in <em>restartable blocks;</em> that is, reading a chunk of data, operating on the data until it runs out, suspending the operation while more data is read in, and then continuing as though nothing had happened.</p>
<p>In Listing 1.5 the restartable block implementation is pretty simple because checksumming works with one byte at a time, forgetting about each byte immediately after adding it into the total. Listing 1.5 reads in a block of bytes from the file, checksums the bytes in the block, and gets another block, repeating the process until the entire file has been processed. In Chapter 5, we’ll see a more complex restartable block implementation, involving searching for text strings.</p>
<p>At any rate, Listing 1.5 isn’t much more complicated than Listing 1.4—and it’s a <em>lot</em> faster. Always consider the alternatives; a bit of clever thinking and program redesign can go a long way.</p>
</section>
<section id="know-how-to-turn-on-the-juice" class="level4">
<h4><a href="#know-how-to-turn-on-the-juice">Know How to Turn On the Juice</a></h4>
<p>I have said time and again that optimization is pointless until the design is settled. When that time comes, however, optimization can indeed make a significant difference. Table 1.1 indicates that the optimized version of Listing 1.5 produced by Microsoft C outperforms an unoptimized version of the same code by more than 60 percent. What’s more, a mostly-assembly version of Listing 1.5, shown in Listings 1.6 and 1.7, outperforms even the best-optimized C version of List1.5 by 26 percent. These are considerable improvements, well worth pursuing—once the design has been maxed out.</p>
<p><strong>LISTING 1.6 L1-6.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co">* Program to calculate the 16-bit checksum of the stream of bytes</span>
<span class="co">* from the specified file. Buffers the bytes internally, rather</span>
<span class="co">* than letting C or DOS do the work, with the time-critical</span>
<span class="co">* portion of the code written in optimized assembler.</span>
<span class="co">*/</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;fcntl.h&gt;</span>
<span class="ot">#include &lt;alloc.h&gt;   </span><span class="co">/* alloc.h for Borland,</span>
<span class="co">                         malloc.h for Microsoft  */</span>

<span class="ot">#define BUFFER_SIZE  0x8000   </span><span class="co">/* 32K data buffer */</span>

main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]) {
      <span class="dt">int</span> Handle;
      <span class="dt">unsigned</span> <span class="dt">int</span> Checksum;
      <span class="dt">unsigned</span> <span class="dt">char</span> *WorkingBuffer;
      <span class="dt">int</span> WorkingLength;

      <span class="kw">if</span> ( argc != <span class="dv">2</span> ) {
            printf(<span class="st">&quot;usage: checksum filename</span><span class="ch">\n</span><span class="st">&quot;</span>);
            exit(<span class="dv">1</span>);
      }
      <span class="kw">if</span> ( (Handle = open(argv[<span class="dv">1</span>], O_RDONLY | O_BINARY)) == -<span class="dv">1</span> ) {
            printf(<span class="st">&quot;Can&#39;t open file: %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
            exit(<span class="dv">1</span>);
      }

      <span class="co">/* Get memory in which to buffer the data */</span>
      <span class="kw">if</span> ( (WorkingBuffer = malloc(BUFFER_SIZE)) == NULL ) {
            printf(<span class="st">&quot;Can&#39;t get enough memory</span><span class="ch">\n</span><span class="st">&quot;</span>);
            exit(<span class="dv">1</span>);
      }

      <span class="co">/* Initialize the checksum accumulator */</span>
      Checksum = <span class="dv">0</span>;

      <span class="co">/* Process the file in 32K chunks */</span>
      <span class="kw">do</span> {
            <span class="kw">if</span> ( (WorkingLength = read(Handle, WorkingBuffer,
            BUFFER_SIZE)) == -<span class="dv">1</span> ) {
                  printf(<span class="st">&quot;Error reading file %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
                  exit(<span class="dv">1</span>);
            }
            <span class="co">/* Checksum this chunk if there&#39;s anything in it */</span>
            <span class="kw">if</span> ( WorkingLength )
                  ChecksumChunk(WorkingBuffer, WorkingLength, &amp;Checksum);
            } <span class="kw">while</span> ( WorkingLength );

            <span class="co">/* Report the result */</span>
            printf(<span class="st">&quot;The checksum is: %u</span><span class="ch">\n</span><span class="st">&quot;</span>, Checksum);
            exit(<span class="dv">0</span>);
}</code></pre>
<p><strong>LISTING 1.7 L1-7.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Assembler subroutine to perform a 16-bit checksum on a block of</span>
<span class="co">; bytes 1 to 64K in size. Adds checksum for block into passed-in</span>
<span class="co">; checksum.</span>
<span class="co">;</span>
<span class="co">; Call as:</span>
<span class="co">;     void ChecksumChunk(unsigned char *Buffer,</span>
<span class="co">;     unsigned int BufferLength, unsigned int *Checksum);</span>
<span class="co">;</span>
<span class="co">; where:</span>
<span class="co">;     Buffer = pointer to start of block of bytes to checksum</span>
<span class="co">;     BufferLength = # of bytes to checksum (0 means 64K, not 0)</span>
<span class="co">;     Checksum = pointer to unsigned int variable checksum is</span>
<span class="co">;stored in</span>
<span class="co">;</span>
<span class="co">; Parameter structure:</span>
<span class="co">;</span>
Parms <span class="kw">struc</span>
                    <span class="dt">dw</span>    ?    <span class="co">;pushed BP</span>
                    <span class="dt">dw</span>    ?    <span class="co">;return address</span>
Buffer              <span class="dt">dw</span>    ?
BufferLength        <span class="dt">dw</span>    ?
Checksum            <span class="dt">dw</span>    ?
Parmsends
<span class="co">;</span>
     .model small
     .code
     public _ChecksumChunk
_ChecksumChunkprocnear
     <span class="kw">push</span>  <span class="kw">bp</span>
     <span class="kw">mov</span>   <span class="kw">bp</span>,<span class="kw">sp</span>
     <span class="kw">push</span>  <span class="kw">si</span>                        <span class="co">;save C&#39;s register variable</span>
<span class="co">;</span>
     <span class="kw">cld</span>                             <span class="co">;make LODSB increment SI</span>
      <span class="kw">mov</span>  <span class="kw">si</span>,[<span class="kw">bp</span>+Buffer]            <span class="co">;point to buffer</span>
      <span class="kw">mov</span>  <span class="kw">cx</span>,[<span class="kw">bp</span>+BufferLength]      <span class="co">;get buffer length</span>
      <span class="kw">mov</span>  <span class="kw">bx</span>,[<span class="kw">bp</span>+Checksum]          <span class="co">;point to checksum variable</span>
      <span class="kw">mov</span>  <span class="kw">dx</span>,[<span class="kw">bx</span>]                   <span class="co">;get the current checksum</span>
      <span class="kw">sub</span>  <span class="kw">ah</span>,<span class="kw">ah</span>                     <span class="co">;so AX will be a 16-bit value after LODSB</span>
<span class="fu">ChecksumLoop:</span>
      <span class="kw">lodsb</span>                  <span class="co">;get the next byte</span>
      <span class="kw">add</span>  <span class="kw">dx</span>,<span class="kw">ax</span>             <span class="co">;add it into the checksum total</span>
      <span class="kw">loop</span> ChecksumLoop      <span class="co">;continue for all bytes in block</span>
      <span class="kw">mov</span>  [<span class="kw">bx</span>],<span class="kw">dx</span>           <span class="co">;save the new checksum</span>
<span class="co">;</span>
      <span class="kw">pop</span>  <span class="kw">si</span>                <span class="co">;restore C&#39;s register variable</span>
      <span class="kw">pop</span>  <span class="kw">bp</span>
      <span class="kw">ret</span>
_ChecksumChunkendp
      end</code></pre>
<p>Note that in Table 1.1, optimization makes little difference except in the case of Listing 1.5, where the design has been refined considerably. Execution time in the other cases is dominated by time spent in DOS and/or the C library, so optimization of the code you write is pretty much irrelevant. What’s more, while the approximately two-times improvement we got by optimizing is not to be sneezed at, it pales against the up-to-50-times improvement we got by redesigning.</p>
<p>By the way, the execution times even of Listings 1.6 and 1.7 are dominated by DOS disk access times. If a disk cache is enabled and the file to be checksummed is already in the cache, the assembly version is three times as fast as the C version. In other words, the inherent nature of this application limits the performance improvement that can be obtained via assembly. In applications that are more CPU-intensive and less disk-bound, particularly those applications in which string instructions and/or unrolled loops can be used effectively, assembly tends to be considerably faster relative to C than it is in this very specific case.</p>
<blockquote>
<p><img src="images/i.jpg" /> Don’t get hung up on optimizing compilers or assembly language—the best optimizer is between your ears.</p>
</blockquote>
<p>All this is basically a way of saying: Know where you’re going, know the territory, and know when it matters.</p>
</section>
</section>
<section id="where-weve-been-what-weve-seen" class="level3">
<h3><a href="#where-weve-been-what-weve-seen">Where We’ve Been, What We’ve Seen</a></h3>
<p>What have we learned? Don’t let other people’s code—even DOS—do the work for you when speed matters, at least not without knowing what that code does and how well it performs.</p>
<p>Optimization only matters after you’ve done your part on the program design end. Consider the ratios on the vertical axis of Table 1.1, which show that optimization is almost totally wasted in the checksumming application without an efficient design. Optimization is no panacea. Table 1.1 shows a two-times improvement from optimization—and a 50-times-plus improvement from redesign. The longstanding debate about which C compiler optimizes code best doesn’t matter quite so much in light of Table 1.1, does it? Your organic optimizer matters much more than your compiler’s optimizer, and there’s always assembly for those usually small sections of code where performance really matters.</p>
<section id="where-were-going" class="level4">
<h4><a href="#where-were-going">Where We’re Going</a></h4>
<p>This chapter has presented a quick step-by-step overview of the design process. I’m not claiming that this is the only way to create high-performance code; it’s just an approach that works for me. Create code however you want, but never forget that design matters more than detailed optimization. Never stop looking for inventive ways to boost performance—and never waste time speeding up code that doesn’t need to be sped up.</p>
<p>I’m going to focus on specific ways to create high-performance code from now on. In Chapter 5, we’ll continue to look at restartable blocks and internal buffering, in the form of a program that searches files for text strings.</p>
</section>
</section>
</section>
<section id="chapter-2-a-world-apart" class="level2">
<h2><a href="#chapter-2-a-world-apart">Chapter 2 – A World Apart</a></h2>
<section id="the-unique-nature-of-assembly-language-optimization" class="level3">
<h3><a href="#the-unique-nature-of-assembly-language-optimization">The Unique Nature of Assembly Language Optimization</a></h3>
<p>As I showed in the previous chapter, optimization is by no means always a matter of “dropping into assembly.” In fact, in performance tuning high-level language code, assembly should be used rarely, and then only after you’ve made sure a badly chosen or clumsily implemented algorithm isn’t eating you alive. Certainly if you use assembly at all, make absolutely sure you use it <em>right</em>. The potential of assembly code to run <em>slowly</em> is poorly understood by a lot of people, but that potential is great, especially in the hands of the ignorant.</p>
<p>Truly great optimization, however, happens <em>only</em> at the assembly level, and it happens in response to a set of dynamics that is totally different from that governing C/C++ or Pascal optimization. I’ll be speaking of assembly-level optimization time and again in this book, but when I do, I think it will be helpful if you have a grasp of those assembly specific dynamics.</p>
<p>As usual, the best way to wade in is to present a real-world example.</p>
</section>
<section id="instructions-the-individual-versus-the-collective" class="level3">
<h3><a href="#instructions-the-individual-versus-the-collective">Instructions: The Individual versus the Collective</a></h3>
<p>Some time ago, I was asked to work over a critical assembly subroutine in order to make it run as fast as possible. The task of the subroutine was to construct a nibble out of four bits read from different bytes, rotating and combining the bits so that they ultimately ended up neatly aligned in bits 3-0 of a single byte. (In case you’re curious, the object was to construct a 16-color pixel from bits scattered over 4 bytes.) I examined the subroutine line by line, saving a cycle here and a cycle there, until the code truly seemed to be optimized. When I was done, the key part of the code looked something like this:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="fu">LoopTop:</span>
      <span class="kw">lodsb</span>            <span class="co">;get the next byte to extract a bit from</span>
      <span class="kw">and</span>   <span class="kw">al</span>,<span class="kw">ah</span>      <span class="co">;isolate the bit we want</span>
      <span class="kw">rol</span>   <span class="kw">al</span>,<span class="kw">cl</span>      <span class="co">;rotate the bit into the desired position</span>
      <span class="kw">or</span>    <span class="kw">bl</span>,<span class="kw">al</span>      <span class="co">;insert the bit into the final nibble</span>
      <span class="kw">dec</span>   <span class="kw">cx</span>         <span class="co">;the next bit goes 1 place to the right</span>
      <span class="kw">dec</span>   <span class="kw">dx</span>         <span class="co">;count down the number of bits</span>
      <span class="kw">jnz</span>   LoopTop    <span class="co">;process the next bit, if any</span></code></pre>
<p>Now, it’s hard to write code that’s much faster than seven instructions, only one of which accesses memory, and most programmers would have called it a day at this point. Still, something bothered me, so I spent a bit of time going over the code again. Suddenly, the answer struck me—the code was rotating each bit into place separately, so that a multibit rotation was being performed every time through the loop, for a total of four separate time-consuming multibit rotations!</p>
<blockquote>
<p><img src="images/i.jpg" /> While the instructions themselves were individually optimized, the overall approach did not make the best possible use of the instructions.</p>
</blockquote>
<p>I changed the code to the following:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="fu">LoopTop:</span>
      <span class="kw">lodsb</span>            <span class="co">;get the next byte to extract a bit from</span>
      <span class="kw">and</span>   <span class="kw">al</span>,<span class="kw">ah</span>      <span class="co">;isolate the bit we want</span>
      <span class="kw">or</span>    <span class="kw">bl</span>,<span class="kw">al</span>      <span class="co">;insert the bit into the final nibble</span>
      <span class="kw">rol</span>   <span class="kw">bl</span>,<span class="dv">1</span>       <span class="co">;make room for the next bit</span>
      <span class="kw">dec</span>   <span class="kw">dx</span>         <span class="co">;count down the number of bits</span>
      <span class="kw">jnz</span>   LoopTop    <span class="co">;process the next bit, if any</span>
      <span class="kw">rol</span>   <span class="kw">bl</span>,<span class="kw">cl</span>      <span class="co">;rotate all four bits into their final</span>
                       <span class="co">; positions at the same time</span></code></pre>
<p>This moved the costly multibit rotation out of the loop so that it was performed just once, rather than four times. While the code may not look much different from the original, and in fact still contains exactly the same number of instructions, the performance of the entire subroutine improved by about 10 percent from just this one change. (Incidentally, that wasn’t the end of the optimization; I eliminated the <code>DEC</code> and <code>JNJ</code> instructions by expanding the four iterations of the loop—but that’s a tale for another chapter.)</p>
<p>The point is this: To write truly superior assembly programs, you need to know what the various instructions do and which instructions execute fastest…and more. You must also learn to look at your programming problems from a variety of perspectives so that you can put those fast instructions to work in the most effective ways.</p>
</section>
<section id="assembly-is-fundamentally-different" class="level3">
<h3><a href="#assembly-is-fundamentally-different">Assembly Is Fundamentally Different</a></h3>
<p>Is it really so hard as all that to write good assembly code for the PC? Yes! Thanks to the decidedly quirky nature of the x86 family CPUs, assembly language differs fundamentally from other languages, and is undeniably harder to work with. On the other hand, the potential of assembly code is much greater than that of other languages, as well.</p>
<p>To understand why this is so, consider how a program gets written. A programmer examines the requirements of an application, designs a solution at some level of abstraction, and then makes that design come alive in a code implementation. If not handled properly, the transformation that takes place between conception and implementation can reduce performance tremendously; for example, a programmer who implements a routine to search a list of 100,000 sorted items with a linear rather than binary search will end up with a disappointingly slow program.</p>
<section id="transformation-inefficiencies" class="level4">
<h4><a href="#transformation-inefficiencies">Transformation Inefficiencies</a></h4>
<p>No matter how well an implementation is derived from the corresponding design, however, high-level languages like C/C++ and Pascal inevitably introduce additional transformation inefficiencies, as shown in Figure 2.1.</p>
<p>The process of turning a design into executable code by way of a high-level language involves two transformations: one performed by the programmer to generate source code, and another performed by the compiler to turn source code into machine language instructions. Consequently, the machine language code generated by compilers is usually less than optimal given the requirements of the original design.</p>
<p>High-level languages provide artificial environments that lend themselves relatively well to human programming skills, in order to ease the transition from design to implementation. The price for this ease of implementation is a considerable loss of efficiency in transforming source code into machine language. This is particularly true given that the x86 family in real and 16-bit protected mode, with its specialized memory-addressing instructions and segmented memory architecture, does not lend itself particularly well to compiler design. Even the 32-bit mode of the 386 and its successors, with their more powerful addressing modes, offer fewer registers than compilers would like.</p>
<figure>
<img src="images/02-01.jpg" alt="Figure 2.1 The high-level language transformation inefficiencies." /><figcaption><strong>Figure 2.1</strong> <em>The high-level language transformation inefficiencies.</em></figcaption>
</figure>
<p>Assembly, on the other hand, is simply a human-oriented representation of machine language. As a result, assembly provides a difficult programming environment—the bare hardware and systems software of the computer—<em>but properly constructed assembly programs suffer no transformation loss</em>, as shown in Figure 2.2.</p>
<p>Only one transformation is required when creating an assembler program, and that single transformation is completely under the programmer’s control. Assemblers perform no transformation from source code to machine language; instead, they merely map assembler instructions to machine language instructions on a one-to-one basis. As a result, the programmer is able to produce machine language code that’s precisely tailored to the needs of each task a given application requires.</p>
<figure>
<img src="images/02-02.jpg" alt="Figure 2.2  Properly constructed assembly programs suffer no transformation loss." /><figcaption><strong>Figure 2.2</strong>  <em>Properly constructed assembly programs suffer no transformation loss.</em></figcaption>
</figure>
<p>The key, of course, is the programmer, since in assembly the programmer must essentially perform the transformation from the application specification to machine language entirely on his or her own. (The assembler merely handles the <em>direct</em> translation from assembly to machine language.)</p>
</section>
<section id="self-reliance" class="level4">
<h4><a href="#self-reliance">Self-Reliance</a></h4>
<p>The first part of assembly language optimization, then, is self. An assembler is nothing more than a tool to let you design machine-language programs without having to think in hexadecimal codes. So assembly language programmers—unlike all other programmers—must take full responsibility for the quality of their code. Since assemblers provide little help at any level higher than the generation of machine language, the assembly programmer must be capable both of coding any programming construct directly and of controlling the PC at the lowest practical level—the operating system, the BIOS, even the hardware where necessary. High-level languages handle most of this transparently to the programmer, but in assembly everything is fair—and necessary—game, which brings us to another aspect of assembly optimization: knowledge.</p>
</section>
<section id="knowledge" class="level4">
<h4><a href="#knowledge">Knowledge</a></h4>
<p>In the PC world, you can never have enough knowledge, and every item you add to your store will make your programs better. Thorough familiarity with both the operating system APIs and BIOS interfaces is important; since those interfaces are well-documented and reasonably straightforward, my advice is to get a good book or two and bring yourself up to speed. Similarly, familiarity with the PC hardware is required. While that topic covers a lot of ground—display adapters, keyboards, serial ports, printer ports, timer and DMA channels, memory organization, and more—most of the hardware is well-documented, and articles about programming major hardware components appear frequently in the literature, so this sort of knowledge can be acquired readily enough.</p>
<p>The single most critical aspect of the hardware, and the one about which it is hardest to learn, is the CPU. The x86 family CPUs have a complex, irregular instruction set, and, unlike most processors, they are neither straightforward nor wellregarding true code performance. What’s more, assembly is so difficult to learn that most articles and books that present assembly code settle for code that just works, rather than code that pushes the CPU to its limits. In fact, since most articles and books are written for inexperienced assembly programmers, there is very little information of any sort available about how to generate high-quality assembly code for the x86 family CPUs. As a result, knowledge about programming them effectively is by far the hardest knowledge to gather. A good portion of this book is devoted to seeking out such knowledge.</p>
<blockquote>
<p><img src="images/i.jpg" /> Be forewarned, though: No matter how much you learn about programming the PC in assembly, there’s always more to discover.</p>
</blockquote>
</section>
</section>
<section id="the-flexible-mind" class="level3">
<h3><a href="#the-flexible-mind">The Flexible Mind</a></h3>
<p>Is the never-ending collection of information all there is to the assembly optimization, then? Hardly. Knowledge is simply a necessary base on which to build. Let’s take a moment to examine the objectives of good assembly programming, and the remainder of the forces that act on assembly optimization will fall into place.</p>
<p>Basically, there are only two possible objectives to high-performance assembly programming: Given the requirements of the application, keep to a minimum either the number of processor cycles the program takes to run, or the number of bytes in the program, or some combination of both. We’ll look at ways to achieve both objectives, but we’ll more often be concerned with saving cycles than saving bytes, for the PC generally offers relatively more memory than it does processing horsepower. In fact, we’ll find that two-to-three times performance improvements <em>over already tight assembly code</em> are often possible if we’re willing to spend additional bytes in order to save cycles. It’s not always desirable to use such techniques to speed up code, due to the heavy memory requirements—but it is almost always <em>possible</em>.</p>
<p>You will notice that my short list of objectives for high-performance assembly programming does not include traditional objectives such as easy maintenance and speed of development. Those are indeed important considerations—to persons and companies that develop and distribute software. People who actually <em>buy</em> software, on the other hand, care only about how well that software performs, not how it was developed nor how it is maintained. These days, developers spend so much time focusing on such admittedly important issues as code maintainability and reusability, source code control, choice of development environment, and the like that they often forget rule #1: From the user’s perspective, <em>performance is fundamental</em>.</p>
<blockquote>
<p><img src="images/i.jpg" /> Comment your code, design it carefully, and write non-time-critical portions in a high-level language, if you wish—but when you write the portions that interact with the user and/or affect response time, performance must be your paramount objective, and assembly is the path to that goal.</p>
</blockquote>
<p>Knowledge of the sort described earlier is absolutely essential to fulfilling either of the objectives of assembly programming. What that knowledge doesn’t do by itself is meet the need to write code that both performs to the requirements of the application at hand and also operates as efficiently as possible in the PC environment. Knowledge makes that possible, but your programming instincts make it happen. And it is that intuitive, on-the-fly integration of a program specification and a sea of facts about the PC that is the heart of the Zen-class assembly optimization.</p>
<p>As with Zen of any sort, mastering that Zen of assembly language is more a matter of learning than of being taught. You will have to find your own path of learning, although I will start you on your way with this book. The subtle facts and examples I provide will help you gain the necessary experience, but you must continue the journey on your own. Each program you create will expand your programming horizons and increase the options available to you in meeting the next challenge. The ability of your mind to find surprising new and better ways to craft superior code from a concept—the flexible mind, if you will—is the linchpin of good assembler code, and you will develop this skill only by doing.</p>
<p>Never underestimate the importance of the flexible mind. Good assembly code is better than good compiled code. Many people would have you believe otherwise, but they’re wrong. That doesn’t mean that high-level languages are useless; far from it. High-level languages are the best choice for the majority of programmers, and for the bulk of the code of most applications. When the <em>best</em> code—the fastest or smallest code possible—is needed, though, assembly is the only way to go.</p>
<p>Simple logic dictates that no compiler can know as much about what a piece of code needs to do or adapt as well to those needs as the person who wrote the code. Given that superior information and adaptability, an assembly language programmer can generate better code than a compiler, all the more so given that compilers are constrained by the limitations of high-level languages and by the process of transformation from high-level to machine language. Consequently, carefully optimized assembly is not just the language of choice but the <em>only</em> choice for the 1percent to 10 percent of code—usually consisting of small, well-defined subroutines—that determines overall program performance, and it is the only choice for code that must be as compact as possible, as well. In the run-of-the-mill, non-time-critical portions of your programs, it makes no sense to waste time and effort on writing optimized assembly code—concentrate your efforts on loops and the like instead; but in those areas where you need the finest code quality, accept no substitutes.</p>
<p>Note that I said that an assembly programmer <em>can</em> generate better code than a compiler, not <em>will</em> generate better code. While it is true that good assembly code is better than good compiled code, it is also true that bad assembly code is often much worse than bad compiled code; since the assembly programmer has so much control over the program, he or she has virtually unlimited opportunities to waste cycles and bytes. The sword cuts both ways, and good assembly code requires more, not less, forethought and planning than good code written in a high-level language.</p>
<p>The gist of all this is simply that good assembly programming is done in the context of a solid overall framework unique to each program, and the flexible mind is the key to creating that framework and holding it together.</p>
<section id="where-to-begin" class="level4">
<h4><a href="#where-to-begin">Where to Begin?</a></h4>
<p>To summarize, the skill of assembly language optimization is a combination of knowledge, perspective, and a way of thought that makes possible the genesis of absolutely the fastest or the smallest code. With that in mind, what should the first step be? Development of the flexible mind is an obvious step. Still, the flexible mind is no better than the knowledge at its disposal. The first step in the journey toward mastering optimization at that exalted level, then, would seem to be learning how to learn.</p>
</section>
</section>
</section>
<section id="chapter-3-assume-nothing" class="level2">
<h2><a href="#chapter-3-assume-nothing">Chapter 3 – Assume Nothing</a></h2>
<section id="understanding-and-using-the-zen-timer" class="level3">
<h3><a href="#understanding-and-using-the-zen-timer">Understanding and Using the Zen Timer</a></h3>
<p>When you’re pushing the envelope in writing optimized PC code, you’re likely to become more than a little compulsive about finding approaches that let you wring more speed from your computer. In the process, you’re bound to make mistakes, which is fine—as long as you watch for those mistakes and <em>learn</em> from them.</p>
<p>A case in point: A few years back, I came across an article about 8088 assembly language called “Optimizing for Speed.” Now, “optimize” is not a word to be used lightly; <em>Webster’s Ninth New Collegiate Dictionary</em> defines optimize as “to make as perfect, effective, or functional as possible,” which certainly leaves little room for error. The author had, however, chosen a small, well-defined 8088 assembly language routine to refine, consisting of about 30 instructions that did nothing more than expand 8 bits to 16 bits by duplicating each bit.</p>
<p>The author of “Optimizing” had clearly fine-tuned the code with care, examining alternative instruction sequences and adding up cycles until he arrived at an implementation he calculated to be nearly 50 percent faster than the original routine. In short, he had used all the information at his disposal to improve his code, and had, as a result, saved cycles by the bushel. There was, in fact, only one slight problem with the optimized version of the routine….</p>
<p>It ran slower than the original version!</p>
</section>
<section id="the-costs-of-ignorance" class="level3">
<h3><a href="#the-costs-of-ignorance">The Costs of Ignorance</a></h3>
<p>As diligent as the author had been, he had nonetheless committed a cardinal sin of x86 assembly language programming: He had assumed that the information available to him was both correct and complete. While the execution times provided by Intel for its processors are indeed correct, they are incomplete; the other—and often more important—part of code performance is instruction <em>fetch</em> time, a topic to which I will return in later chapters.</p>
<p>Had the author taken the time to measure the true performance of his code, he wouldn’t have put his reputation on the line with relatively low-performance code. What’s more, had he actually measured the performance of his code and found it to be unexpectedly slow, curiosity might well have led him to experiment further and thereby add to his store of reliable information about the CPU.</p>
<blockquote>
<p><img src="images/i.jpg" /> There you have an important tenet of assembly language optimization: After crafting the best code possible, check it in action to see if it’s really doing what you think it is. If it’s not behaving as expected, that’s all to the good, since solving mysteries is the path to knowledge. You’ll learn more in this way, I assure you, than from any manual or book on assembly language.</p>
</blockquote>
<p><em>Assume nothing</em>. I cannot emphasize this strongly enough—when you care about performance, do your best to improve the code and then <em>measure</em> the improvement. If you don’t measure performance, you’re just guessing, and if you’re guessing, you’re not very likely to write top-notch code.</p>
<p>Ignorance about true performance can be costly. When I wrote video games for a living, I spent days at a time trying to wring more performance from my graphics drivers. I rewrote whole sections of code just to save a few cycles, juggled registers, and relied heavily on blurry-fast register-to-register shifts and adds. As I was writing my last game, I discovered that the program ran perceptibly faster if I used look-up tables instead of shifts and adds for my calculations. It <em>shouldn’t</em> have run faster, according to my cycle counting, but it did. In truth, instruction fetching was rearing its head again, as it often does, and the fetching of the shifts and adds was taking as much as four times the nominal execution time of those instructions.</p>
<p>Ignorance can also be responsible for considerable wasted effort. I recall a debate in the letters column of one computer magazine about exactly how quickly text can be drawn on a Color/Graphics Adapter (CGA) screen without causing snow. The letter-writers counted every cycle in their timing loops, just as the author in the story that started this chapter had. Like that author, the letter-writers had failed to take the prefetch queue into account. In fact, they had neglected the effects of video wait states as well, so the code they discussed was actually <em>much</em> slower than their estimates. The proper test would, of course, have been to run the code to see if snow resulted, since the only true measure of code performance is observing it in action.</p>
</section>
<section id="the-zen-timer" class="level3">
<h3><a href="#the-zen-timer">The Zen Timer</a></h3>
<p>Clearly, one key to mastering Zen-class optimization is a tool with which to measure code performance. The most accurate way to measure performance is with expensive hardware, but reasonable measurements at no cost can be made with the PC’s 8253 timer chip, which counts at a rate of slightly over 1,000,000 times per second. The 8253 can be started at the beginning of a block of code of interest and stopped at the end of that code, with the resulting count indicating how long the code took to execute with an accuracy of about 1 microsecond. (A microsecond is one millionth of a second, and is abbreviated µs). To be precise, the 8253 counts once every 838.1 nanoseconds. (A nanosecond is one billionth of a second, and is abbreviated ns.)</p>
<p>Listing 3.1 shows 8253-based timer software, consisting of three subroutines: <code>ZTimerOn</code>, <code>ZTimerOff</code>, and <code>ZTimerReport</code>. For the remainder of this book, I’ll refer to these routines collectively as the “Zen timer.” C-callable versions of the two precision Zen timers are presented in Chapter K on the companion CD-ROM.</p>
<p><strong>LISTING 3.1 PZTIMER.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; The precision Zen timer (PZTIMER.ASM)</span>
<span class="co">;</span>
<span class="co">; Uses the 8253 timer to time the performance of code that takes</span>
<span class="co">; less than about 54 milliseconds to execute, with a resolution</span>
<span class="co">; of better than 10 microseconds.</span>
<span class="co">;</span>
<span class="co">; By Michael Abrash</span>
<span class="co">;</span>
<span class="co">; Externally callable routines:</span>
<span class="co">;</span>
<span class="co">;  ZTimerOn: Starts the Zen timer, with interrupts disabled.</span>
<span class="co">;</span>
<span class="co">;  ZTimerOff: Stops the Zen timer, saves the timer count,</span>
<span class="co">;    times the overhead code, and restores interrupts to the</span>
<span class="co">;    state they were in when ZTimerOn was called.</span>
<span class="co">;</span>
<span class="co">;  ZTimerReport: Prints the net time that passed between starting</span>
<span class="co">;    and stopping the timer.</span>
<span class="co">;</span>
<span class="co">; Note: If longer than about 54 ms passes between ZTimerOn and</span>
<span class="co">;    ZTimerOff calls, the timer turns over and the count is</span>
<span class="co">;    inaccurate. When this happens, an error message is displayed</span>
<span class="co">;    instead of a count. The long-period Zen timer should be used</span>
<span class="co">;    in such cases.</span>
<span class="co">;</span>
<span class="co">; Note: Interrupts *MUST* be left off between calls to ZTimerOn</span>
<span class="co">;    and ZTimerOff for accurate timing and for detection of</span>
<span class="co">;    timer overflow.</span>
<span class="co">;</span>
<span class="co">; Note: These routines can introduce slight inaccuracies into the</span>
<span class="co">;    system clock count for each code section timed even if</span>
<span class="co">;    timer 0 doesn&#39;t overflow. If timer 0 does overflow, the</span>
<span class="co">;    system clock can become slow by virtually any amount of</span>
<span class="co">;    time, since the system clock can&#39;t advance while the</span>
<span class="co">;    precison timer is timing. Consequently, it&#39;s a good idea</span>
<span class="co">;    to reboot at the end of each timing session. (The</span>
<span class="co">;    battery-backed clock, if any, is not affected by the Zen</span>
<span class="co">;    timer.)</span>
<span class="co">;</span>
<span class="co">; All registers, and all flags except the interrupt flag, are</span>
<span class="co">; preserved by all routines. Interrupts are enabled and then disabled</span>
<span class="co">; by ZTimerOn, and are restored by ZTimerOff to the state they were</span>
<span class="co">; in when ZTimerOn was called.</span>
<span class="co">;</span>

Code <span class="kw">segment</span> <span class="dt">word</span> public ‘CODE<span class="st">&#39;</span>
<span class="fu">     assumecs:</span>    Code, <span class="kw">ds</span>:nothing
     public       ZTimerOn, ZTimerOff, ZTimerReport

<span class="co">;</span>
<span class="co">; Base address of the 8253 timer chip.</span>
<span class="co">;</span>
BASE_8253equ40h
<span class="co">;</span>
<span class="co">; The address of the timer 0 count registers in the 8253.</span>
<span class="co">;</span>
TIMER_0_8253     equBASE_8253 + <span class="dv">0</span>
<span class="co">;</span>
<span class="co">; The address of the mode register in the 8253.</span>
<span class="co">;</span>
MODE_8253        equBASE_8253 + <span class="dv">3</span>
<span class="co">;</span>
<span class="co">; The address of Operation Command Word 3 in the 8259 Programmable</span>
<span class="co">; Interrupt Controller (PIC) (write only, and writable only when</span>
<span class="co">; bit 4 of the byte written to this address is 0 and bit 3 is 1).</span>
<span class="co">;</span>
OCW3              equ20h
<span class="co">;</span>
<span class="co">; The address of the Interrupt Request register in the 8259 PIC</span>
<span class="co">; (read only, and readable only when bit 1 of OCW3 = 1 and bit 0</span>
<span class="co">; of OCW3 = 0).</span>
<span class="co">;</span>
IRR               equ20h
<span class="co">;</span>
<span class="co">; Macro to emulate a POPF instruction in order to fix the bug in some</span>
<span class="co">; 80286 chips which allows interrupts to occur during a POPF even when</span>
<span class="co">; interrupts remain disabled.</span>
<span class="co">;</span>
MPOPF macro
      local p1, p2
      <span class="kw">jmp</span> <span class="dt">short</span> p2
<span class="fu">p1:</span>   <span class="kw">iret</span>             <span class="co">; jump to pushed address &amp; pop flags</span>
<span class="fu">p2:</span>   <span class="kw">push</span> <span class="kw">cs</span>          <span class="co">; construct far return address to</span>
      <span class="kw">call</span> p1          <span class="co">; the next instruction</span>
      endm

<span class="co">;</span>
<span class="co">; Macro to delay briefly to ensure that enough time has elapsed</span>
<span class="co">; between successive I/O accesses so that the device being accessed</span>
<span class="co">; can respond to both accesses even on a very fast PC.</span>
<span class="co">;</span>
DELAY macro
      <span class="kw">jmp</span>     <span class="dv">$</span>+<span class="dv">2</span>
      <span class="kw">jmp</span>     <span class="dv">$</span>+<span class="dv">2</span>
      <span class="kw">jmp</span>     <span class="dv">$</span>+<span class="dv">2</span>
      endm

OriginalFlags   <span class="dt">db</span>    ?    <span class="co">; storage for upper byte of</span>
                           <span class="co">; FLAGS register when</span>
                           <span class="co">; ZTimerOn called</span>
TimedCount      <span class="dt">dw</span>    ?    <span class="co">; timer 0 count when the timer</span>
                           <span class="co">; is stopped</span>
ReferenceCount  <span class="dt">dw</span>         <span class="co">; number of counts required to</span>
                           <span class="co">; execute timer overhead code</span>
OverflowFlag    <span class="dt">db</span>    ?    <span class="co">; used to indicate whether the</span>
                           <span class="co">; timer overflowed during the</span>
                           <span class="co">; timing interval</span>
<span class="co">;</span>
<span class="co">; String printed to report results.</span>
<span class="co">;</span>
OutputStr  label <span class="dt">byte</span>
           <span class="dt">db</span><span class="bn">    0dh, </span>0ah, ‘Timed count: ‘, <span class="dv">5</span> dup (?)
ASCIICountEnd    labelbyte
           <span class="dt">db</span>    ‘ microseconds<span class="st">&#39;, 0dh, 0ah</span>
           <span class="dt">db</span>    ‘<span class="dv">$</span><span class="st">&#39;</span>
<span class="co">;</span>
<span class="co">; String printed to report timer overflow.</span>
<span class="co">;</span>
OverflowStr label <span class="dt">byte</span>
      <span class="dt">db</span><span class="bn">    0dh, </span>0ah
      <span class="dt">db</span>    ‘****************************************************<span class="st">&#39;</span>
      <span class="dt">db</span><span class="bn">    0dh, </span>0ah
      <span class="dt">db</span>    ‘* The timer overflowed, so the interval timed was  *<span class="st">&#39;</span>
      <span class="dt">db</span><span class="bn">    0dh, </span>0ah
      <span class="dt">db</span>    ‘* too long for the precision timer to measure.     *<span class="st">&#39;</span>
      <span class="dt">db</span><span class="bn">    0dh, </span>0ah
      <span class="dt">db</span>    ‘* Please perform the timing <span class="kw">test</span> again with the    *<span class="st">&#39;</span>
db0dh<span class="bn">, 0ah</span>
      <span class="dt">db</span>    ‘* long-period timer.                               *<span class="st">&#39;    </span>
      <span class="dt">db</span><span class="bn">    0dh, </span>0ah
      <span class="dt">db</span>    ‘****************************************************<span class="st">&#39;</span>
      <span class="dt">db</span><span class="bn">    0dh, </span>0ah
      <span class="dt">db</span>    ‘<span class="dv">$</span><span class="st">&#39;</span>

<span class="co">; ********************************************************************</span>
<span class="co">; * Routine called to start timing.                                  *</span>
<span class="co">; ********************************************************************</span>

ZTimerOn    proc   near

<span class="co">;</span>
<span class="co">; Save the context of the program being timed.</span>
<span class="co">;</span>
   <span class="kw">push</span>   <span class="kw">ax</span>
   <span class="kw">pushf</span>
   <span class="kw">pop</span>    <span class="kw">ax</span>                       <span class="co">; get flags so we can keep</span>
                                   <span class="co">; interrupts off when leaving</span>
                                   <span class="co">; this routine</span>
   <span class="kw">mov</span>    <span class="kw">cs</span>:[OriginalFlags],<span class="kw">ah</span>    <span class="co">; remember the state of the</span>
                                   <span class="co">; Interrupt flag</span>
   <span class="kw">and</span>    <span class="kw">ah</span><span class="bn">,0fdh                  </span><span class="co">; set pushed interrupt flag</span>
                                   <span class="co">; to 0</span>
   <span class="kw">push</span>   <span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Turn on interrupts, so the timer interrupt can occur if it&#39;s</span>
<span class="co">; pending.</span>
<span class="co">;</span>
     <span class="kw">sti</span>
<span class="co">;</span>
<span class="co">; Set timer 0 of the 8253 to mode 2 (divide-by-N), to cause</span>
<span class="co">; linear counting rather than count-by-two counting. Also</span>
<span class="co">; leaves the 8253 waiting for the initial timer 0 count to</span>
<span class="co">; be loaded.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">al</span><span class="bn">,00110100b               </span><span class="co">;mode 2</span>
     <span class="kw">out</span>  MODE_8253,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Set the timer count to 0, so we know we won&#39;t get another</span>
<span class="co">; timer interrupt right away.</span>
<span class="co">; Note: this introduces an inaccuracy of up to 54 ms in the system</span>
<span class="co">; clock count each time it is executed.</span>
<span class="co">;</span>
     DELAY
     <span class="kw">sub</span>     <span class="kw">al</span>,<span class="kw">al</span>
     <span class="kw">out</span>     TIMER_0_8253,<span class="kw">al</span>     <span class="co">;lsb</span>
     DELAY
     <span class="kw">out</span>     TIMER_0_8253,<span class="kw">al</span>     <span class="co">;msb</span>
<span class="co">;</span>
<span class="co">; Wait before clearing interrupts to allow the interrupt generated</span>
<span class="co">; when switching from mode 3 to mode 2 to be recognized. The delay</span>
<span class="co">; must be at least 210 ns long to allow time for that interrupt to</span>
<span class="co">; occur. Here, 10 jumps are used for the delay to ensure that the</span>
<span class="co">; delay time will be more than long enough even on a very fast PC.</span>
<span class="co">;</span>
    rept <span class="dv">10</span>
    <span class="kw">jmp</span>   <span class="dv">$</span>+<span class="dv">2</span>
    endm
<span class="co">;</span>
<span class="co">; Disable interrupts to get an accurate count.</span>
<span class="co">;</span>
     <span class="kw">cli</span>
<span class="co">;</span>
<span class="co">; Set the timer count to 0 again to start the timing interval.</span>
<span class="co">;</span>
      <span class="kw">mov</span>  <span class="kw">al</span><span class="bn">,00110100b        </span><span class="co">; set up to load initial</span>
      <span class="kw">out</span>  MODE_8253,<span class="kw">al</span>        <span class="co">; timer count</span>
      DELAY
      <span class="kw">sub</span>  <span class="kw">al</span>,<span class="kw">al</span>
      <span class="kw">out</span>  TIMER_0_8253,<span class="kw">al</span>     <span class="co">; load count lsb</span>
      DELAY
      <span class="kw">out</span>  TIMER_0_8253,<span class="kw">al</span><span class="co">; load count msb</span>
<span class="co">;</span>
<span class="co">; Restore the context and return.</span>
<span class="co">;</span>
     MPOPF                   <span class="co">; keeps interrupts off</span>
     <span class="kw">pop</span>   <span class="kw">ax</span>
     <span class="kw">ret</span>

ZTimerOn     endp

<span class="co">;********************************************************************</span>
<span class="co">;* Routine called to stop timing and get count.                     *</span>
<span class="co">;********************************************************************</span>

ZTimerOff proc     near

<span class="co">;</span>
<span class="co">; Save the context of the program being timed.</span>
<span class="co">;</span>
     <span class="kw">push</span>    <span class="kw">ax</span>
     <span class="kw">push</span>    <span class="kw">cx</span>
     <span class="kw">pushf</span>
<span class="co">;</span>
<span class="co">; Latch the count.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">al</span><span class="bn">,00000000b     </span><span class="co">; latch timer 0</span>
     <span class="kw">out</span>  MODE_8253,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; See if the timer has overflowed by checking the 8259 for a pending</span>
<span class="co">; timer interrupt.</span>
<span class="co">;</span>
     <span class="kw">mov</span>   <span class="kw">al</span><span class="bn">,00001010b        </span><span class="co">; OCW3, set up to read</span>
     <span class="kw">out</span>   OCW3,<span class="kw">al</span><span class="co">; Int        errupt Request register</span>
     DELAY
     ina   l,IRR<span class="co">; read         Interrupt Request</span>
                               <span class="co">; register</span>
     <span class="kw">and</span>   <span class="kw">al</span>,<span class="dv">1</span>                <span class="co">; set AL to 1 if IRQ0 (the</span>
                               <span class="co">; timer interrupt) is pending</span>
     <span class="kw">mov</span>   <span class="kw">cs</span>:[OverflowFlag],<span class="kw">al</span><span class="co">; store the timer overflow</span>
                               <span class="co">; status</span>
<span class="co">;</span>
<span class="co">; Allow interrupts to happen again.</span>
<span class="co">;</span>
      <span class="kw">sti</span>
<span class="co">;</span>
<span class="co">; Read out the count we latched earlier.</span>
<span class="co">;</span>
     <span class="kw">in</span>     <span class="kw">al</span>,TIMER_0_8253   <span class="co">; least significant byte</span>
     DELAY
     <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="kw">al</span>
     <span class="kw">in</span>     <span class="kw">al</span>,TIMER_0_8253   <span class="co">; most significant byte</span>
     <span class="kw">xchg</span>   <span class="kw">ah</span>,<span class="kw">al</span>
     <span class="kw">neg</span>    <span class="kw">ax</span>                <span class="co">; convert from countdown</span>
                              <span class="co">; remaining to elapsed</span>
                              <span class="co">; count</span>
     <span class="kw">mov</span>    <span class="kw">cs</span>:[TimedCount],<span class="kw">ax</span>
<span class="co">; Time a zero-length code fragment, to get a reference for how</span>
<span class="co">; much overhead this routine has. Time it 16 times and average it,</span>
<span class="co">; for accuracy, rounding the result.</span>
<span class="co">;</span>
     <span class="kw">mov</span>   <span class="kw">cs</span>:[ReferenceCount],<span class="dv">0</span>
     <span class="kw">mov</span>   <span class="kw">cx</span>,<span class="dv">16</span>
     <span class="kw">cli</span>                <span class="co">; interrupts off to allow a</span>
                        <span class="co">; precise reference count</span>
<span class="fu"> RefLoop:</span>
     <span class="kw">call</span>   ReferenceZTimerOn
     <span class="kw">call</span>   ReferenceZTimerOff
     <span class="kw">loop</span>   RefLoop
     <span class="kw">sti</span>
     <span class="kw">add</span>    <span class="kw">cs</span>:[ReferenceCount],<span class="dv">8</span><span class="co">; total + (0.5 * 16)</span>
     <span class="kw">mov</span>    <span class="kw">cl</span>,<span class="dv">4</span>
     <span class="kw">shr</span>    <span class="kw">cs</span>:[ReferenceCount],<span class="kw">cl</span><span class="co">; (total) / 16 + 0.5</span>
<span class="co">;</span>
<span class="co">; Restore original interrupt state.</span>
<span class="co">;</span>
     <span class="kw">pop</span>    <span class="kw">ax</span>                    <span class="co">; retrieve flags when called</span>
     <span class="kw">mov</span>    <span class="kw">ch</span>,<span class="kw">cs</span>:[OriginalFlags] <span class="co">; get back the original upper</span>
                                  <span class="co">; byte of the FLAGS register</span>
     <span class="kw">and</span>    <span class="kw">ch</span>,<span class="kw">not</span><span class="bn"> 0fdh           </span><span class="co">; only care about original</span>
                                  <span class="co">; interrupt flag...</span>
     <span class="kw">and</span>    <span class="kw">ah</span><span class="bn">,0fdh               </span><span class="co">; ...keep all other flags in</span>
                                  <span class="co">; their current condition</span>
     <span class="kw">or</span>     <span class="kw">ah</span>,<span class="kw">ch</span>                 <span class="co">; make flags word with original</span>
                                  <span class="co">; interrupt flag</span>
     <span class="kw">push</span>   <span class="kw">ax</span>                    <span class="co">; prepare flags to be popped</span>
<span class="co">;</span>
<span class="co">; Restore the context of the program being timed and return to it.</span>
<span class="co">;</span>
    MPOPF                      <span class="co">; restore the flags with the</span>
                               <span class="co">; original interrupt state</span>
    <span class="kw">pop</span>    <span class="kw">cx</span>
    <span class="kw">pop</span>    <span class="kw">ax</span>
    <span class="kw">ret</span>

ZTimerOff  endp

<span class="co">;</span>
<span class="co">; Called by ZTimerOff to start timer for overhead measurements.</span>
<span class="co">;</span>

ReferenceZTimerOnproc   near
<span class="co">;</span>
<span class="co">; Save the context of the program being timed.</span>
<span class="co">;</span>
      <span class="kw">push</span>  <span class="kw">ax</span>
      <span class="kw">pushf</span>     <span class="co">; interrupts are already off</span>
<span class="co">;</span>
<span class="co">; Set timer 0 of the 8253 to mode 2 (divide-by-N), to cause</span>
<span class="co">; linear counting rather than count-by-two counting.</span>
<span class="co">;</span>
   <span class="kw">mov</span>    <span class="kw">al</span><span class="bn">,00110100b    </span><span class="co">; set up to load</span>
   <span class="kw">out</span>    MODE_8253,<span class="kw">al</span>    <span class="co">; initial timer count</span>
   DELAY
<span class="co">;</span>
<span class="co">; Set the timer count to 0.</span>
<span class="co">;</span>
     <span class="kw">sub</span>    <span class="kw">al</span>,<span class="kw">al</span>
     <span class="kw">out</span>    TIMER_0_8253,<span class="kw">al</span><span class="co">; load count lsb</span>
     DELAY
     <span class="kw">out</span>    TIMER_0_8253,<span class="kw">al</span><span class="co">; load count msb</span>
<span class="co">;</span>
<span class="co">; Restore the context of the program being timed and return to it.</span>
<span class="co">;</span>
     MPOPF
     <span class="kw">pop</span>    <span class="kw">ax</span>
     <span class="kw">ret</span>

ReferenceZTimerOnendp

<span class="co">;</span>
<span class="co">; Called by ZTimerOff to stop timer and add result to ReferenceCount</span>
<span class="co">; for overhead measurements.</span>
<span class="co">;</span>

ReferenceZTimerOff proc     near
<span class="co">;</span>
<span class="co">; Save the context of the program being timed.</span>
<span class="co">;</span>
      <span class="kw">push</span>   <span class="kw">ax</span>
      <span class="kw">push</span>   <span class="kw">cx</span>
      <span class="kw">pushf</span>
<span class="co">;</span>
<span class="co">; Latch the count and read it.</span>
<span class="co">;</span>
     <span class="kw">mov</span>   <span class="kw">al</span><span class="bn">,00000000b        </span><span class="co">; latch timer 0</span>
     <span class="kw">out</span>   MODE_8253,<span class="kw">al</span>
     DELAY
     <span class="kw">in</span>    <span class="kw">al</span>,TIMER_0_8253     <span class="co">; lsb</span>
     DELAY
     <span class="kw">mov</span>   <span class="kw">ah</span>,<span class="kw">al</span>
     <span class="kw">in</span>    <span class="kw">al</span>,TIMER_0_8253     <span class="co">; msb</span>
     <span class="kw">xchg</span>  <span class="kw">ah</span>,<span class="kw">al</span>
     <span class="kw">neg</span>   <span class="kw">ax</span>                  <span class="co">; convert from countdown</span>
                               <span class="co">; remaining to amount</span>
                               <span class="co">; counted down</span>
     <span class="kw">add</span>   <span class="kw">cs</span>:[ReferenceCount],<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Restore the context of the program being timed and return to it.</span>
<span class="co">;</span>
    MPOPF
    <span class="kw">pop</span>    <span class="kw">cx</span>
    <span class="kw">pop</span>    <span class="kw">ax</span>
    <span class="kw">ret</span>

ReferenceZTimerOff endp

<span class="co">; ********************************************************************</span>
<span class="co">; * Routine called to report timing results.                         *</span>
<span class="co">; ********************************************************************</span>

ZTimerReport procnear

       <span class="kw">pushf</span>
       <span class="kw">push</span>  <span class="kw">ax</span>
       <span class="kw">push</span>  <span class="kw">bx</span>
       <span class="kw">push</span>  <span class="kw">cx</span>
       <span class="kw">push</span>  <span class="kw">dx</span>
       <span class="kw">push</span>  <span class="kw">si</span>
       <span class="kw">push</span>  <span class="kw">ds</span>
<span class="co">;</span>
       <span class="kw">push</span>       <span class="kw">cs</span>     <span class="co">; DOS functions require that DS point</span>
       <span class="kw">pop</span>        <span class="kw">ds</span>     <span class="co">; to text to be displayed on the screen</span>
       assume     <span class="kw">ds</span>     :Code
<span class="co">;</span>
<span class="co">; Check for timer 0 overflow.</span>
<span class="co">;</span>
     <span class="kw">cmp</span>  [OverflowFlag],<span class="dv">0</span>
     <span class="kw">jz</span>   PrintGoodCount
     <span class="kw">mov</span>  <span class="kw">dx</span>,offset OverflowStr
     <span class="kw">mov</span>  <span class="kw">ah</span>,<span class="dv">9</span>
     <span class="kw">int</span><span class="bn">  21h</span>
     <span class="kw">jmp</span>  <span class="dt">short</span> EndZTimerReport
<span class="co">;</span>
<span class="co">; Convert net count to decimal ASCII in microseconds.</span>
<span class="co">;</span>
<span class="fu">PrintGoodCount:</span>
     <span class="kw">mov</span>   <span class="kw">ax</span>,[TimedCount]
     <span class="kw">sub</span>   <span class="kw">ax</span>,[ReferenceCount]
     <span class="kw">mov</span>   <span class="kw">si</span>,offset ASCIICountEnd - <span class="dv">1</span>
<span class="co">;</span>
<span class="co">; Convert count to microseconds by multiplying by .8381.</span>
<span class="co">;</span>
     <span class="kw">mov</span>   <span class="kw">dx</span>, <span class="dv">8381</span>
     <span class="kw">mul</span>   <span class="kw">dx</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>, <span class="dv">10000</span>
     <span class="kw">div</span>   <span class="kw">bx</span>                <span class="co">;* .8381 = * 8381 / 10000</span>
<span class="co">;</span>
<span class="co">; Convert time in microseconds to 5 decimal ASCII digits.</span>
<span class="co">;</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>, <span class="dv">10</span>
     <span class="kw">mov</span>   <span class="kw">cx</span>, <span class="dv">5</span>
<span class="fu">CTSLoop:</span>
     <span class="kw">sub</span>   <span class="kw">dx</span>, <span class="kw">dx</span>
     <span class="kw">div</span>   <span class="kw">bx</span>
      <span class="kw">add</span>  <span class="kw">dl</span>,<span class="st">&#39;0&#39;</span>
     <span class="kw">mov</span>   [<span class="kw">si</span>],<span class="kw">dl</span>
     <span class="kw">dec</span>   <span class="kw">si</span>
     <span class="kw">loop</span>  CTSLoop
<span class="co">;</span>
<span class="co">; Print the results.</span>
<span class="co">;</span>
     <span class="kw">mov</span>   <span class="kw">ah</span>, <span class="dv">9</span>
     <span class="kw">mov</span>   <span class="kw">dx</span>, offset OutputStr
     <span class="kw">int</span><span class="bn">   21h </span>
<span class="co">;</span>
<span class="fu">EndZTimerReport:</span>
     <span class="kw">pop</span>   <span class="kw">ds</span>
     <span class="kw">pop</span>   <span class="kw">si</span>
     <span class="kw">pop</span>   <span class="kw">dx</span>
     <span class="kw">pop</span>   <span class="kw">cx</span>
     <span class="kw">pop</span>   <span class="kw">bx</span>
     <span class="kw">pop</span>   <span class="kw">ax</span>
     MPOPF
     <span class="kw">ret</span>

ZTimerReport  endp

Code   ends
       end</code></pre>
<section id="the-zen-timer-is-a-means-not-an-end" class="level4">
<h4><a href="#the-zen-timer-is-a-means-not-an-end">The Zen Timer Is a Means, Not an End</a></h4>
<p>We’re going to spend the rest of this chapter seeing what the Zen timer can do, examining how it works, and learning how to use it. I’ll be using the Zen timer again and again over the course of this book, so it’s essential that you learn what the Zen timer can do and how to use it. On the other hand, it is by no means essential that you understand exactly how the Zen timer works. (Interesting, yes; essential, no.)</p>
<p>In other words, the Zen timer isn’t really part of the knowledge we seek; rather, it’s one tool with which we’ll acquire that knowledge. Consequently, you shouldn’t worry if you don’t fully grasp the inner workings of the Zen timer. Instead, focus on learning how to <em>use</em> it, and you’ll be on the right road.</p>
</section>
<section id="starting-the-zen-timer" class="level4">
<h4><a href="#starting-the-zen-timer">Starting the Zen Timer</a></h4>
<p><code>ZTimerOn</code> is called at the start of a segment of code to be timed. <code>ZTimerOn</code> saves the context of the calling code, disables interrupts, sets timer 0 of the 8253 to mode 2 (divide-by-N mode), sets the initial timer count to 0, restores the context of the calling code, and returns. (I’d like to note that while Intel’s documentation for the 8253 seems to indicate that a timer won’t reset to 0 until it finishes counting down, in actual practice, timers seem to reset to 0 as soon as they’re loaded.)</p>
<p>Two aspects of <code>ZTimerOn</code> are worth discussing further. One point of interest is that <code>ZTimerOn</code> disables interrupts. (<code>ZTimerOff</code> later restores interrupts to the state they were in when <code>ZTimerOn</code> was called.) Were interrupts not disabled by <code>ZTimerOn</code>, keyboard, mouse, timer, and other interrupts could occur during the timing interval, and the time required to service those interrupts would incorrectly and erratically appear to be part of the execution time of the code being measured. As a result, code timed with the Zen timer should not expect any hardware interrupts to occur during the interval between any call to <code>ZTimerOn</code> and the corresponding call to <code>ZTimerOff</code>, and should not enable interrupts during that time.</p>
</section>
</section>
<section id="time-and-the-pc" class="level3">
<h3><a href="#time-and-the-pc">Time and the PC</a></h3>
<p>A second interesting point about <code>ZTimerOn</code> is that it may introduce some small inaccuracy into the system clock time whenever it is called. To understand why this is so, we need to examine the way in which both the 8253 and the PC’s system clock (which keeps the current time) work.</p>
<p>The 8253 actually contains three timers, as shown in Figure 3.1. All three timers are driven by the system board’s 14.31818 MHz crystal, divided by 12 to yield a 1.19318 MHz clock to the timers, so the timers count once every 838.1 ns. Each of the three timers counts down in a programmable way, generating a signal on its output pin when it counts down to 0. Each timer is capable of being halted at any time via a 0 level on its gate input; when a timer’s gate input is 1, that timer counts constantly. All in all, the 8253’s timers are inherently very flexible timing devices; unfortunately, much of that flexibility depends on how the timers are connected to external circuitry, and in the PC the timers are connected with specific purposes in mind.</p>
<p>Timer 2 drives the speaker, although it can be used for other timing purposes when the speaker is not in use. As shown in Figure 3.1, timer 2 is the only timer with a programmable gate input in the PC; that is, timer 2 is the only timer that can be started and stopped under program control in the manner specified by Intel. On the other hand, the <em>output</em> of timer 2 is connected to nothing other than the speaker. In particular, timer 2 cannot generate an interrupt to get the 8088’s attention.</p>
<p>Timer 1 is dedicated to providing dynamic RAM refresh, and should not be tampered with lest system crashes result.</p>
<figure>
<img src="images/03-01.jpg" alt="Figure 3.1  The configuration of the 8253 timer chip in the PC." /><figcaption><strong>Figure 3.1</strong>  <em>The configuration of the 8253 timer chip in the PC.</em></figcaption>
</figure>
<p>Finally, timer 0 is used to drive the system clock. As programmed by the BIOS at power-up, every 65,536 (64K) counts, or 54.925 milliseconds, timer 0 generates a rising edge on its output line. (A millisecond is one-thousandth of a second, and is abbreviated ms.) This line is connected to the hardware interrupt 0 (IRQ0) line on the system board, so every 54.925 ms, timer 0 causes hardware interrupt 0 to occur.</p>
<p>The interrupt vector for IRQ0 is set by the BIOS at power-up time to point to a BIOS routine, <code>TIMER_INT</code>, that maintains a time-of-day count. <code>TIMER_INT</code> keeps a 16-bit count of IRQ0 interrupts in the BIOS data area at address 0000:046C (all addresses in this book are given in segment:offset hexadecimal pairs); this count turns over once an hour (less a few microseconds), and when it does, <code>TIMER_INT</code> updates a 16-bit hour count at address 0000:046E in the BIOS data area. This count is the basis for the current time and date that DOS supports via functions 2AH (2A hexadecimal) through 2DH and by way of the DATE and TIME commands.</p>
<p>Each timer channel of the 8253 can operate in any of six modes. Timer 0 normally operates in mode 3: <em>square wave mode</em>. In square wave mode, the initial count is counted down two at a time; when the count reaches zero, the output state is changed. The initial count is again counted down two at a time, and the output state is toggled back when the count reaches zero. The result is a square wave that changes state more slowly than the input clock by a factor of the initial count. In its normal mode of operation, timer 0 generates an output pulse that is low for about 27.5 ms and high for about 27.5 ms; this pulse is sent to the 8259 interrupt controller, and its rising edge generates a timer interrupt once every 54.925 ms.</p>
<p>Square wave mode is not very useful for precision timing because it counts down by two twice per timer interrupt, thereby rendering exact timings impossible. Fortunately, the 8253 offers another timer mode, mode 2 (divide-by-N mode), which is both a good substitute for square wave mode and a perfect mode for precision timing.</p>
<p>Divide-by-N mode counts down by one from the initial count. When the count reaches zero, the timer turns over and starts counting down again without stopping, and a pulse is generated for a single clock period. While the pulse is not held for nearly as long as in square wave mode, it doesn’t matter, since the 8259 interrupt controller is configured in the PC to be edgeand hence cares only about the existence of a pulse from timer 0, not the duration of the pulse. As a result, timer 0 continues to generate timer interrupts in divide-by-N mode, and the system clock continues to maintain good time.</p>
<p>Why not use timer 2 instead of timer 0 for precision timing? After all, timer 2 has a programmable gate input and isn’t used for anything but sound generation. The problem with timer 2 is that its output can’t generate an interrupt; in fact, timer 2 can’t do anything but drive the speaker. We need the interrupt generated by the output of timer 0 to tell us when the count has overflowed, and we will see shortly that the timer interrupt also makes it possible to time much longer periods than the Zen timer shown in Listing 3.1 supports.</p>
<p>In fact, the Zen timer shown in Listing 3.1 can only time intervals of up to about 54 ms in length, since that is the period of time that can be measured by timer 0 before its count turns over and repeats. fifty-four ms may not seem like a very long time, but even a CPU as slow as the 8088 can perform more than 1,000 divides in 54 ms, and division is the single instruction that the 8088 performs most slowly. If a measured period turns out to be longer than 54 ms (that is, if timer 0 has counted down and turned over), the Zen timer will display a message to that effect. A long-period Zen timer for use in such cases will be presented later in this chapter.</p>
<p>The Zen timer determines whether timer 0 has turned over by checking to see whether an IRQ0 interrupt is pending. (Remember, interrupts are off while the Zen timer runs, so the timer interrupt cannot be recognized until the Zen timer stops and enables interrupts.) If an IRQ0 interrupt is pending, then timer 0 has turned over and generated a timer interrupt. Recall that <code>ZTimerOn</code> initially sets timer 0 to 0, in order to allow for the longest possible period—about 54 ms—before timer 0 reaches 0 and generates the timer interrupt.</p>
<p>Now we’re ready to look at the ways in which the Zen timer can introduce inaccuracy into the system clock. Since timer 0 is initially set to 0 by the Zen timer, and since the system clock ticks only when timer 0 counts off 54.925 ms and reaches 0 again, an average inaccuracy of one-half of 54.925 ms, or about 27.5 ms, is incurred each time the Zen timer is started. In addition, a timer interrupt is generated when timer 0 is switched from mode 3 to mode 2, advancing the system clock by up to 54.925 ms, although this only happens the first time the Zen timer is run after a warm or cold boot. Finally, up to 54.925 ms can again be lost when <code>ZTimerOff</code> is called, since that routine again sets the timer count to zero. Net result: The system clock will run up to 110 ms (about a ninth of a second) slow each time the Zen timer is used.</p>
<p>Potentially far greater inaccuracy can be incurred by timing code that takes longer than about 110 ms to execute. Recall that all interrupts, including the timer interrupt, are disabled while timing code with the Zen timer. The 8259 interrupt controller is capable of remembering at most one pending timer interrupt, so all timer interrupts after the first one during any given Zen timing interval are ignored. Consequently, if a timing interval exceeds 54.9 ms, the system clock effectively stops 54.9 ms after the timing interval starts and doesn’t restart until the timing interval ends, losing time all the while.</p>
<p>The effects on the system time of the Zen timer aren’t a matter for great concern, as they are temporary, lasting only until the next warm or cold boot. System that have batteryclocks, (AT-style machines; that is, virtually all machines in common use) automatically reset the correct time whenever the computer is booted, and systems without battery-clocks prompt for the correct date and time when booted. Also,repeated use of the Zen timer usually makes the system clock slow by at most a total of a few seconds, unless code that takes much longer than 54 ms to run is timed (in which case the Zen timer will notify you that the code is too long to time).</p>
<p>Nonetheless, it’s a good idea to reboot your computer at the end of each session with the Zen timer in order to make sure that the system clock is correct.</p>
</section>
<section id="stopping-the-zen-timer" class="level3">
<h3><a href="#stopping-the-zen-timer">Stopping the Zen Timer</a></h3>
<p>At some point after <code>ZTimerOn</code> is called, <code>ZTimerOff</code> must always be called to mark the end of the timing interval. <code>ZTimerOff</code> saves the context of the calling program, latches and reads the timer 0 count, converts that count from the countdown value that the timer maintains to the number of counts elapsed since <code>ZTimerOn</code> was called, and stores the result. Immediately after latching the timer 0 count—and before enabling interrupts—<code>ZTimerOff</code> checks the 8259 interrupt controller to see if there is a pending timer interrupt, setting a flag to mark that the timer overflowed if there is indeed a pending timer interrupt.</p>
<p>After that, <code>ZTimerOff</code> executes just the overhead code of <code>ZTimerOn</code> and <code>ZTimerOff</code> 16 times, and averages and saves the results in order to determine how many of the counts in the timing result just obtained were incurred by the overhead of the Zen timer rather than by the code being timed.</p>
<p>Finally, <code>ZTimerOff</code> restores the context of the calling program, including the state of the interrupt flag that was in effect when <code>ZTimerOn</code> was called to start timing, and returns.</p>
<p>One interesting aspect of <code>ZTimerOff</code> is the manner in which timer 0 is stopped in order to read the timer count. We don’t actually have to stop timer 0 to read the count; the 8253 provides a special latched read feature for the specific purpose of reading the count while a time is running. (That’s a good thing, too; we’ve no documented way to stop timer 0 if we wanted to, since its gate input isn’t connected. Later in this chapter, though, we’ll see that timer 0 can be stopped after all.) We simply tell the 8253 to latch the current count, and the 8253 does so without breaking stride.</p>
</section>
<section id="reporting-timing-results" class="level3">
<h3><a href="#reporting-timing-results">Reporting Timing Results</a></h3>
<p><code>ZTimerReport</code> may be called to display timing results at any time after both <code>ZTimerOn</code> and <code>ZTimerOff</code> have been called. <code>ZTimerReport</code> first checks to see whether the timer overflowed (counted down to 0 and turned over) before <code>ZTimerOff</code> was called; if overflow did occur, <code>ZTimerOff</code> prints a message to that effect and returns. Otherwise, <code>ZTimerReport</code> subtracts the reference count (representing the overhead of the Zen timer) from the count measured between the calls to <code>ZTimerOn</code> and <code>ZTimerOff</code>, converts the result from timer counts to microseconds, and prints the resulting time in microseconds to the standard output.</p>
<p>Note that <code>ZTimerReport</code> need not be called immediately after <code>ZTimerOff</code>. In fact, after a given call to <code>ZTimerOff, ZTimerReport</code> can be called at any time right up until the next call to <code>ZTimerOn</code>.</p>
<p>You may want to use the Zen timer to measure several portions of a program while it executes normally, in which case it may not be desirable to have the text printed by <code>ZTimerReport</code> interfere with the program’s normal display. There are many ways to deal with this. One approach is removal of the invocations of the DOS print string function (INT 21H with AH equal to 9) from <code>ZTimerReport</code>, instead running the program under a debugger that supports screen flipping (such as Turbo Debugger or CodeView), placing a breakpoint at the start of <code>ZTimerReport</code>, and directly observing the count in microseconds as <code>ZTimerReport</code> calculates it.</p>
<p>A second approach is modification of <code>ZTimerReport</code> to place the result at some safe location in memory, such as an unused portion of the BIOS data area.</p>
<p>A third approach is alteration of <code>ZTimerReport</code> to print the result over a serial port to a terminal or to another PC acting as a terminal. Similarly, many debuggers can be run from a remote terminal via a serial link.</p>
<p>Yet another approach is modification of <code>ZTimerReport</code> to send the result to the printer via either DOS function 5 or BIOS interrupt 17H.</p>
<p>A final approach is to modify <code>ZTimerReport</code> to print the result to the auxiliary output via DOS function 4, and to then write and load a special device driver named <code>AUX</code>, to which DOS function 4 output would automatically be directed. This device driver could send the result anywhere you might desire. The result might go to the secondary display adapter, over a serial port, or to the printer, or could simply be stored in a buffer within the driver, to be dumped at a later time. (Credit for this final approach goes to Michael Geary, and thanks go to David Miller for passing the idea on to me.)</p>
<p>You may well want to devise still other approaches better suited to your needs than those I’ve presented. Go to it! I’ve just thrown out a few possibilities to get you started.</p>
</section>
<section id="notes-on-the-zen-timer" class="level3">
<h3><a href="#notes-on-the-zen-timer">Notes on the Zen Timer</a></h3>
<p>The Zen timer subroutines are designed to be near-called from assembly language code running in the public segment <code>Code</code>. The Zen timer subroutines can, however, be called from any assembly or high-level language code that generates OBJ files that are compatible with the Microsoft linker, simply by modifying the segment that the timer code runs in to match the segment used by the code being timed, or by changing the Zen timer routines to far procedures and making far calls to the Zen timer code from the code being timed, as discussed at the end of this chapter. All three subroutines preserve all registers and all flags except the interrupt flag, so calls to these routines are transparent to the calling code.</p>
<p>If you do change the Zen timer routines to far procedures in order to call them from code running in another segment, be sure to make <em>all</em> the Zen timer routines far, including <code>ReferenceZTimerOn</code> and <code>ReferenceZTimerOff</code>. (You’ll have to put <code>FAR PTR</code> overrides on the calls from <code>ZTimerOff</code> to the latter two routines if you do make them far.) If the reference routines aren’t the same type—near or far—as the other routines, they won’t reflect the true overhead incurred by starting and stopping the Zen timer.</p>
<p>Please be aware that the inaccuracy that the Zen timer can introduce into the system clock time does not affect the accuracy of the performance measurements reported by the Zen timer itself. The 8253 counts once every 838 ns, giving us a count resolution of about 1µs, although factors such as the prefetch queue (as discussed below), dynamic RAM refresh, and internal timing variations in the 8253 make it perhaps more accurate to describe the Zen timer as measuring code performance with an accuracy of better than 10µs. In fact, the Zen timer is actually most accurate in assessing code performance when timing intervals longer than about 100 µs. At any rate, we’re most interested in using the Zen timer to assess the relative performance of various code sequences—that is, using it to compare and tweak code—and the timer is more than accurate enough for that purpose.</p>
<p>The Zen timer works on all PC-compatible computers I’ve tested it on, including XTs, ATs, PS/2 computers, and 386, 486, and Pentium-based machines. Of course, I haven’t been able to test it on <em>all</em> PC-compatibles, but I don’t expect any problems; computers on which the Zen timer doesn’t run can’t truly be called “PC-compatible.”</p>
<p>On the other hand, there is certainly no guarantee that code performance as measured by the Zen timer will be the same on compatible computers as on genuine IBM machines, or that either absolute or relative code performance will be similar even on different IBM models; in fact, quite the opposite is true. For example, every PS/2 computer, even the relatively slow Model 30, executes code much faster than does a PC or XT. As another example, I set out to do the timings for my earlier book <em>Zen of Assembly Language</em> on an XTcomputer, only to find that the computer wasn’t quite IBM-compatible regarding code performance. The differences were minor, mind you, but my experience illustrates the risk of assuming that a specific make of computer will perform in a certain way without actually checking.</p>
<p>Not that this variation between models makes the Zen timer one whit less useful—quite the contrary. The Zen timer is an excellent tool for evaluating code performance over the entire spectrum of PC-compatible computers.</p>
</section>
<section id="a-sample-use-of-the-zen-timer" class="level3">
<h3><a href="#a-sample-use-of-the-zen-timer">A Sample Use of the Zen Timer</a></h3>
<p>Listing 3.2 shows a test-bed program for measuring code performance with the Zen timer. This program sets DS equal to CS (for reasons we’ll discuss shortly), includes the code to be measured from the file TESTCODE, and calls <code>ZTimerReport</code> to display the timing results. Consequently, the code being measured should be in the file TESTCODE, and should contain calls to <code>ZTimerOn</code> and <code>ZTimerOff</code> .</p>
<p><strong>LISTING 3.2 PZTEST.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to measure performance of code that takes less than</span>
<span class="co">; 54 ms to execute. (PZTEST.ASM)</span>
<span class="co">;</span>
<span class="co">; Link with PZTIMER.ASM (Listing 3.1). PZTEST.BAT (Listing 3.4)</span>
<span class="co">; can be used to assemble and link both files. Code to be</span>
<span class="co">; measured must be in the file TESTCODE; Listing 3.3 shows</span>
<span class="co">; a sample TESTCODE file.</span>
<span class="co">;</span>
<span class="co">; By Michael Abrash</span>
<span class="co">;</span>
mystack   <span class="kw">segment</span>  para stack ‘STACK<span class="st">&#39;</span>
      <span class="dt">db</span>  <span class="dv">512</span> dup(?)
mystack   ends
<span class="co">;</span>
Code  <span class="kw">segment</span>   para public ‘CODE<span class="st">&#39;</span>
      assume    <span class="kw">cs</span>:Code, <span class="kw">ds</span>:Code
<span class="fu">      extrnZTimerOn:</span>near, ZTimerOff:near, ZTimerReport:near
Start proc near
      <span class="kw">push</span> <span class="kw">cs</span>
      <span class="kw">pop</span>  <span class="kw">ds</span>    <span class="co">; set DS to point to the code segment,</span>
                 <span class="co">; so data as well as code can easily</span>
                 <span class="co">; be included in TESTCODE</span>
<span class="co">;</span>
      include    TESTCODE <span class="co">;code to be measured, including</span>
                 <span class="co">; calls to ZTimerOn and ZTimerOff</span>
<span class="co">;</span>
<span class="co">; Display the results.</span>
<span class="co">;</span>
    <span class="kw">call</span>   ZTimerReport
<span class="co">;</span>
<span class="co">; Terminate the program.</span>
<span class="co">;</span>
       <span class="kw">mov</span>   <span class="kw">ah</span><span class="bn">,4ch</span>
       <span class="kw">int</span><span class="bn">   21h</span>
Start endp
Code  ends
      end  Start</code></pre>
<p>Listing 3.3 shows some sample code to be timed. This listing measures the time required to execute 1,000 loads of AL from the memory variable <code>MemVar</code> . Note that Listing 3.3 calls <code>ZTimerOn</code> to start timing, performs 1,000 <code>MOV</code> instructions in a row, and calls <code>ZTimerOff</code> to end timing. When Listing 3.2 is named TESTCODE and included by Listing 3.3, Listing 3.2 calls <code>ZTimerReport</code> to display the execution time after the code in Listing 3.3 has been run.</p>
<p><strong>LISTING 3.3 LST3-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Test file;</span>
<span class="co">; Measures the performance of 1,000 loads of AL from</span>
<span class="co">; memory. (Use by renaming to TESTCODE, which is</span>
<span class="co">; included by PZTEST.ASM (Listing 3.2). PZTIME.BAT</span>
<span class="co">; (Listing 3.4) does this, along with all assembly</span>
<span class="co">; and linking.)</span>
<span class="co">;</span>
<span class="kw">jmp</span>   Skip     <span class="co">;jump around defined data</span>
<span class="co">;</span>
MemVar <span class="dt">db</span>      ?
<span class="co">;</span>
<span class="fu">Skip:</span>
<span class="co">;</span>
<span class="co">; Start timing.</span>
<span class="co">;</span>
      <span class="kw">call</span>  ZTimerOn
<span class="co">;</span>
      rept  <span class="dv">1000</span>
      <span class="kw">mov</span> <span class="kw">al</span>,[MemVar]
      endm
<span class="co">;</span>
<span class="co">; Stop timing.</span>
<span class="co">;</span>
    <span class="kw">call</span>  ZTimerOff</code></pre>
<p>It’s worth noting that Listing 3.3 begins by jumping around the memory variable <code>MemVar</code>. This approach lets us avoid reproducing Listing 3.2 in its entirety for each code fragment we want to measure; by defining any needed data right in the code segment and jumping around that data, each listing becomes self-contained and can be plugged directly into Listing 3.2 as TESTCODE. Listing 3.2 sets DS equal to CS before doing anything else precisely so that data can be embedded in code fragments being timed. Note that only after the initial jump is performed in Listing 3.3 is the Zen timer started, since we don’t want to include the execution time of start-up code in the timing interval. That’s why the calls to <code>ZTimerOn</code> and <code>ZTimerOff</code> are in TESTCODE, not in PZTEST.ASM; this way, we have full control over which portion of TESTCODE is timed, and we can keep set-up code and the like out of the timing interval.</p>
<p>Listing 3.3 is used by naming it TESTCODE, assembling both Listing 3.2 (which includes TESTCODE) and Listing 3.1 with TASM or MASM, and linking the two resulting OBJ files together by way of the Borland orMicrosoft linker. Listing 3.4 shows a batch file, PZTIME.BAT, which does all that; when run, this batch file generates and runs the executable file PZTEST.EXE. PZTIME.BAT (Listing 3.4) assumes that the file PZTIMER.ASM contains Listing 3.1, and the file PZTEST.ASM contains Listing 3.2. The command-line parameter to PZTIME.BAT is the name of the file to be copied to TESTCODE and included into PZTEST.ASM. (Note that Turbo Assembler can be substituted for MASM by replacing “masm” with “tasm” and “link” with “tlink” in Listing 3.4. The same is true of Listing 3.7.)</p>
<p><strong>LISTING 3.4 PZTIME.BAT</strong></p>
<pre class="bat"><code>echo off
rem
rem *** Listing 3.4 ***
rem
rem ***************************************************************
rem * Batch file PZTIME.BAT, which builds and runs the precision  *
rem * Zen timer program PZTEST.EXE to time the code named as the  *
rem * command-line parameter. Listing 3.1 must be named           *
rem * PZTIMER.ASM, and Listing 3.2 must be named PZTEST.ASM. To   *
rem * time the code in LST3-3, you&#39;d type the DOS command:        *
rem *                                                             *
rem * pztime lst3-3                                               *
rem *                                                             *
rem * Note that MASM and LINK must be in the current directory or *
rem * on the current path in order for this batch file to work.   *
rem *                                                             *
rem * This batch file can be speeded up by assembling PZTIMER.ASM *
rem * once, then removing the lines:                              *
rem *                                                             *
rem * masm pztimer;                                               *
rem * if errorlevel 1 goto errorend                               *
rem *                                                             *
rem * from this file.                                             *
rem *                                                             *
rem * By Michael Abrash                                           *
rem ***************************************************************
rem
rem Make sure a file to test was specified.
rem
if not x%1==x goto ckexist
echo ***************************************************************
echo * Please specify a file to test.                              *
echo ***************************************************************
goto end
rem
rem Make sure the file exists.
rem
:ckexist
if exist %1 goto docopy
echo ***************************************************************
echo * The specified file, &quot;%1,&quot; doesn&#39;t exist.                    *
echo ***************************************************************
goto end
rem
rem copy the file to measure to TESTCODE.
rem
:docopy
copy %1 testcode
masm pztest;
if errorlevel 1 goto errorend
masm pztimer;
if errorlevel 1 goto errorend
link pztest+pztimer;
if errorlevel 1 goto errorend
pztest
goto end
:errorend
echo ***************************************************************
echo * An error occurred while building the precision Zen timer.   *
echo ***************************************************************
:end</code></pre>
<p>Assuming that Listing 3.3 is named LST3-3.ASM and Listing 3.4 is named PZTIME.BAT, the code in Listing 3.3 would be timed with the command:</p>
<pre class="sh"><code>pztime LST3-3.ASM</code></pre>
<p>which performs all assembly and linking, and reports the execution time of the code in Listing 3.3.</p>
<p>When the above command is executed on an original 4.77 MHz IBM PC, the time reported by the Zen timer is 3619 µs, or about 3.62 µs per load of AL from memory. (While the exact number is 3.619 µs per load of AL, I’m going to round off that last digit from now on. No matter how many repetitions of a given instruction are timed, there’s just too much noise in the timing process—between dynamic RAM refresh, the prefetch queue, and the internal state of the processor at the start of timing—for that last digit to have any significance.) Given the test PC’s 4.77 MHz clock, this works out to about 17 cycles per <code>MOV</code>, which is actually a good bit longer than Intel’s specified 10-cycle execution time for this instruction. (See the MASM or TASM documentation, or Intel’s processor reference manuals, for official execution times.) Fear not, the Zen timer is right—<strong>MOV AL,[MEMVAR]</strong> really does take 17 cycles as used in Listing 3.3. Exactly why that is so is just what this book is all about.</p>
<p>In order to perform any of the timing tests in this book, enter Listing 3.1 and name it PZTIMER.ASM, enter Listing 3.2 and name it PZTEST.ASM, and enter Listing 3.4 and name it PZTIME.BAT. Then simply enter the listing you wish to run into the file <em>filename</em> and enter the command:</p>
<pre class="sh"><code>pztime &lt;filename&gt;</code></pre>
<p>In fact, that’s exactly how I timed each of the listings in this book. Code fragments you write yourself can be timed in just the same way. If you wish to time code directly in place in your programs, rather than in the test-bed program of Listing 3.2, simply insert calls to <code>ZTimerOn, ZTimerOff</code>, and <code>ZTimerReport</code> in the appropriate places and link PZTIMER to your program.</p>
</section>
<section id="the-long-period-zen-timer" class="level3">
<h3><a href="#the-long-period-zen-timer">The Long-Period Zen Timer</a></h3>
<p>With a few exceptions, the Zen timer presented above will serve us well for the remainder of this book since we’ll be focusing on relatively short code sequences that generally take much less than 54 ms to execute. Occasionally, however, we will need to time longer intervals. What’s more, it is very likely that you will want to time code sequences longer than 54 ms at some point in your programming career. Accordingly, I’ve also developed a Zen timer for periods longer than 54 ms. The long-period Zen timer (so named by contrast with the precision Zen timer just presented) shown in Listing 3.5 can measure periods up to one hour in length.</p>
<p>The key difference between the long-period Zen timer and the precision Zen timer is that the long-period timer leaves interrupts enabled during the timing period. As a result, timer interrupts are recognized by the PC, allowing the BIOS to maintain an accurate system clock time over the timing period. Theoretically, this enables measurement of arbitrarily long periods. Practically speaking, however, there is no need for a timer that can measure more than a few minutes, since the DOS time of day and date functions (or, indeed, the DATE and TIME commands in a batch file) serve perfectly well for longer intervals. Since very long timing intervals aren’t needed, the long-period Zen timer uses a simplified means of calculating elapsed time that is limited to measuring intervals of an hour or less. If a period longer than an hour is timed, the long-period Zen timer prints a message to the effect that it is unable to time an interval of that length.</p>
<p>For implementation reasons, the long-period Zen timer is also incapable of timing code that starts before midnight and ends after midnight; if that eventuality occurs, the long-period Zen timer reports that it was unable to time the code because midnight was crossed. If this happens to you, just time the code again, secure in the knowledge that at least you won’t run into the problem again for 23-odd hours.</p>
<p>You should not use the long-period Zen timer to time code that requires interrupts to be disabled for more than 54 ms at a stretch during the timing interval, since when interrupts are disabled the long-period Zen timer is subject to the same 54 ms maximum measurement time as the precision Zen timer.</p>
<p>While permitting the timer interrupt to occur allows long intervals to be timed, that same interrupt makes the long-period Zen timer less accurate than the precision Zen timer, since the time the BIOS spends handling timer interrupts during the timing interval is included in the time measured by the long-period timer. Likewise, any other interrupts that occur during the timing interval, most notably keyboard and mouse interrupts, will increase the measured time.</p>
<p>The long-period Zen timer has some of the same effects on the system time as does the precision Zen timer, so it’s a good idea to reboot the system after a session with the long-period Zen timer. The long-period Zen timer does not, however, have the same potential for introducing major inaccuracy into the system clock time during a single timing run since it leaves interrupts enabled and therefore allows the system clock to update normally.</p>
<section id="stopping-the-clock" class="level4">
<h4><a href="#stopping-the-clock">Stopping the Clock</a></h4>
<p>There’s a potential problem with the long-period Zen timer. The problem is this: In order to measure times longer than 54 ms, we must maintain not one but two timing components, the timer 0 count and the BIOS time-of-day count. The time-of-day count measures the passage of 54.9 ms intervals, while the timer 0 count measures time within those 54.9 ms intervals. We need to read the two time components simultaneously in order to get a clean reading. Otherwise, we may read the timer count just before it turns over and generates an interrupt, then read the BIOS time-of-day count just after the interrupt has occurred and caused the time-of-day count to turn over, with a resulting 54 ms measurement inaccuracy. (The opposite sequence—reading the time-of-day count and then the timer count—can result in a 54 ms inaccuracy in the other direction.)</p>
<p>The only way to avoid this problem is to stop timer 0, read both the timer and time-of-day counts while the timer is stopped, and then restart the timer. Alas, the gate input to timer 0 isn’t program-controllable in the PC, so there’s no documented way to stop the timer. (The latched read feature we used in Listing 3.1 doesn’t stop the timer; it latches a count, but the timer keeps running.) What should we do?</p>
<p>As it turns out, an undocumented feature of the 8253 makes it possible to stop the timer dead in its tracks. Setting the timer to a new mode and waiting for an initial count to be loaded causes the timer to stop until the count is loaded. Surprisingly, the timer count remains readable and correct while the timer is waiting for the initial load.</p>
<p>In my experience, this approach works beautifully with fully 8253-compatible chips. However, there’s no guarantee that it will always work, since it programs the 8253 in an undocumented way. What’s more, IBM chose not to implement compatibility with this particular 8253 feature in the custom chips used in PS/2 computers. On PS/2 computers, we have no choice but to latch the timer 0 count and then stop the BIOS count (by disabling interrupts) as quickly as possible. We’ll just have to accept the fact that on PS/2 computers we may occasionally get a reading that’s off by 54 ms, and leave it at that.</p>
<p>I’ve set up Listing 3.5 so that it can assemble to either use or not use the undocumented timer-stopping feature, as you please. The <code>PS2</code> equate selects between the two modes of operation. If <code>PS2</code> is 1 (as it is in Listing 3.5), then the latch-and-read method is used; if <code>PS2</code> is 0, then the undocumented timer-stop approach is used. The latch-and-read method will work on all PC-compatible computers, but may occasionally produce results that are incorrect by 54 ms. The timer-stop approach avoids synchronization problems, but doesn’t work on all computers.</p>
<p><strong>LISTING 3.5 LZTIMER.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">;</span>
<span class="co">; The long-period Zen timer. (LZTIMER.ASM)</span>
<span class="co">; Uses the 8253 timer and the BIOS time-of-day count to time the</span>
<span class="co">; performance of code that takes less than an hour to execute.</span>
<span class="co">; Because interrupts are left on (in order to allow the timer</span>
<span class="co">; interrupt to be recognized), this is less accurate than the</span>
<span class="co">; precision Zen timer, so it is best used only to time code that takes</span>
<span class="co">; more than about 54 milliseconds to execute (code that the precision</span>
<span class="co">; Zen timer reports overflow on). Resolution is limited by the</span>
<span class="co">; occurrence of timer interrupts.</span>
<span class="co">;</span>
<span class="co">; By Michael Abrash</span>
<span class="co">;</span>
<span class="co">; Externally callable routines:</span>
<span class="co">;</span>
<span class="co">;  ZTimerOn: Saves the BIOS time of day count and starts the</span>
<span class="co">;    long-period Zen timer.</span>
<span class="co">;</span>
<span class="co">;  ZTimerOff: Stops the long-period Zen timer and saves the timer</span>
<span class="co">;    count and the BIOS time-of-day count.</span>
<span class="co">;</span>
<span class="co">;  ZTimerReport: Prints the time that passed between starting and</span>
<span class="co">;    stopping the timer.</span>
<span class="co">;</span>
<span class="co">; Note: If either more than an hour passes or midnight falls between</span>
<span class="co">;     calls to ZTimerOn and ZTimerOff, an error is reported. For</span>
<span class="co">;     timing code that takes more than a few minutes to execute,</span>
<span class="co">;     either the DOS TIME command in a batch file before and after</span>
<span class="co">;     execution of the code to time or the use of the DOS</span>
<span class="co">;     time-of-day function in place of the long-period Zen timer is</span>
<span class="co">;     more than adequate.</span>
<span class="co">;</span>
<span class="co">; Note: The PS/2 version is assembled by setting the symbol PS2 to 1.</span>
<span class="co">;     PS2 must be set to 1 on PS/2 computers because the PS/2&#39;s</span>
<span class="co">;     timers are not compatible with an undocumented timer-stopping</span>
<span class="co">;     feature of the 8253; the alternative timing approach that</span>
<span class="co">;     must be used on PS/2 computers leaves a short window</span>
<span class="co">;     during which the timer 0 count and the BIOS timer count may</span>
<span class="co">;     not be synchronized. You should also set the PS2 symbol to</span>
<span class="co">;     1 if you&#39;re getting erratic or obviously incorrect results.</span>
<span class="co">;</span>
<span class="co">; Note: When PS2 is 0, the code relies on an undocumented 8253</span>
<span class="co">;     feature to get more reliable readings. It is possible that</span>
<span class="co">;     the 8253 (or whatever chip is emulating the 8253) may be put</span>
<span class="co">;     into an undefined or incorrect state when this feature is</span>
<span class="co">;     used.</span>
<span class="co">;</span>
<span class="co">;     ******************************************************************</span>
<span class="co">;     * If your computer displays any hint of erratic behavior         *</span>
<span class="co">;      *    after the long-period Zen timer is used, such as the floppy*</span>
<span class="co">;     *    drive failing to operate properly, reboot the system, set   *</span>
<span class="co">;     *    PS2 to 1 and leave it that way!                             *</span>
<span class="co">;     ******************************************************************</span>
<span class="co">;</span>
<span class="co">; Note: Each block of code being timed should ideally be run several</span>
<span class="co">;     times, with at least two similar readings required to</span>
<span class="co">;     establish a true measurement, in order to eliminate any</span>
<span class="co">;     variability caused by interrupts.</span>
<span class="co">;</span>
<span class="co">; Note: Interrupts must not be disabled for more than 54 ms at a</span>
<span class="co">;     stretch during the timing interval. Because interrupts</span>
<span class="co">;     are enabled, keys, mice, and other devices that generate</span>
<span class="co">;     interrupts should not be used during the timing interval.</span>
<span class="co">;</span>
<span class="co">; Note: Any extra code running off the timer interrupt (such as</span>
<span class="co">;     some memory-resident utilities) will increase the time</span>
<span class="co">;     measured by the Zen timer.</span>
<span class="co">;</span>
<span class="co">; Note: These routines can introduce inaccuracies of up to a few</span>
<span class="co">;     tenths of a second into the system clock count for each</span>
<span class="co">;     code section timed. Consequently, it&#39;s a good idea to</span>
<span class="co">;     reboot at the conclusion of timing sessions. (The</span>
<span class="co">;     battery-backed clock, if any, is not affected by the Zen</span>
<span class="co">;     timer.)</span>
<span class="co">;</span>
<span class="co">; All registers and all flags are preserved by all routines.</span>
<span class="co">;</span>

Code <span class="kw">segment</span> <span class="dt">word</span> public ‘CODE<span class="st">&#39;</span>
     assume <span class="kw">cs</span>:  Code, <span class="kw">ds</span>:nothing
     public      ZTimerOn, ZTimerOff, ZTimerReport

<span class="co">;</span>
<span class="co">; Set PS2 to 0 to assemble for use on a fully 8253-compatible</span>
<span class="co">; system; when PS2 is 0, the readings are more reliable if the</span>
<span class="co">; computer supports the undocumented timer-stopping feature,</span>
<span class="co">; but may be badly off if that feature is not supported. In</span>
<span class="co">; fact, timer-stopping may interfere with your computer&#39;s</span>
<span class="co">; overall operation by putting the 8253 into an undefined or</span>
<span class="co">; incorrect state. Use with caution!!!</span>
<span class="co">;</span>
<span class="co">; Set PS2 to 1 to assemble for use on non-8253-compatible</span>
<span class="co">; systems, including PS/2 computers; when PS2 is 1, readings</span>
<span class="co">; may occasionally be off by 54 ms, but the code will work</span>
<span class="co">; properly on all systems.</span>
<span class="co">;</span>
<span class="co">; A setting of 1 is safer and will work on more systems,</span>
<span class="co">; while a setting of 0 produces more reliable results in systems</span>
<span class="co">; which support the undocumented timer-stopping feature of the</span>
<span class="co">; 8253. The choice is yours.</span>
<span class="co">;</span>
PS2                  equ1
<span class="co">;</span>
<span class="co">; Base address of the 8253 timer chip.</span>
<span class="co">;</span>
BASE_8253            equ40h
<span class="co">;</span>
<span class="co">; The address of the timer 0 count registers in the 8253.</span>
<span class="co">;</span>
TIMER_0_8253         equBASE_8253 + <span class="dv">0</span>
<span class="co">;</span>
<span class="co">; The address of the mode register in the 8253.</span>
<span class="co">;</span>
MODE_8253            equBASE_8253 + <span class="dv">3</span>
<span class="co">;</span>
<span class="co">; The address of the BIOS timer count variable in the BIOS</span>
<span class="co">; data segment.</span>
<span class="co">;</span>
TIMER_COUNT           equ46ch
<span class="co">;</span>
<span class="co">; Macro to emulate a POPF instruction in order to fix the bug in some</span>
<span class="co">; 80286 chips which allows interrupts to occur during a POPF even when</span>
<span class="co">; interrupts remain disabled.</span>
<span class="co">;</span>
MPOPF macro
      local p1, p2
      <span class="kw">jmp</span> <span class="dt">short</span> p2
<span class="fu">p1:</span>   <span class="kw">iret</span>        <span class="co">;jump to pushed address &amp; pop flags</span>
<span class="fu">p2:</span>   pushcs      <span class="co">;construct far return address to</span>
      <span class="kw">call</span> p1     <span class="co">; the next instruction</span>
endm

<span class="co">;</span>
<span class="co">; Macro to delay briefly to ensure that enough time has elapsed</span>
<span class="co">; between successive I/O accesses so that the device being accessed</span>
<span class="co">; can respond to both accesses even on a very fast PC.</span>
<span class="co">;</span>
DELAY macro
     <span class="kw">jmp</span> <span class="dv">$</span>+<span class="dv">2</span>
     <span class="kw">jmp</span> <span class="dv">$</span>+<span class="dv">2</span>
     <span class="kw">jmp</span> <span class="dv">$</span>+<span class="dv">2</span>
     endm

StartBIOSCountLow     <span class="dt">dw</span>   ?       <span class="co">;BIOS count low word at the</span>
                                   <span class="co">; start of the timing period</span>
StartBIOSCountHigh    <span class="dt">dw</span>   ?       <span class="co">;BIOS count high word at the</span>
                                   <span class="co">; start of the timing period</span>
EndBIOSCountLow       <span class="dt">dw</span>   ?       <span class="co">;BIOS count low word at the</span>
                                   <span class="co">; end of the timing period</span>
EndBIOSCountHigh      <span class="dt">dw</span>   ?       <span class="co">;BIOS count high word at the</span>
                                   <span class="co">; end of the timing period</span>
EndTimedCount         <span class="dt">dw</span>   ?       <span class="co">;timer 0 count at the end of</span>
                                   <span class="co">; the timing period</span>
ReferenceCount        <span class="dt">dw</span>   ?       <span class="co">;number of counts required to</span>
                                   <span class="co">; execute timer overhead code</span>
<span class="co">;</span>
<span class="co">; String printed to report results.</span>
<span class="co">;</span>
OutputStr labelbyte
          <span class="dt">db</span><span class="bn">     0dh, </span>0ah, ‘Timed count: ‘
TimedCountStr    db10 dup (?)
          db<span class="st">&#39;    microseconds&#39;</span><span class="bn">, 0dh, </span>0ah
          <span class="dt">db</span>     ‘<span class="dv">$</span><span class="st">&#39;</span>
<span class="co">;</span>
<span class="co">; Temporary storage for timed count as it&#39;s divided down by powers</span>
<span class="co">; of ten when converting from doubleword binary to ASCII.</span>
<span class="co">;</span>
CurrentCountLow       <span class="dt">dw</span>    ?
CurrentCountHigh  <span class="dt">dw</span>  ?
<span class="co">;</span>
<span class="co">; Powers of ten table used to perform division by 10 when doing</span>
<span class="co">; doubleword conversion from binary to ASCII.</span>
<span class="co">;</span>
PowersOfTenlabelword
     <span class="dt">dd</span>   <span class="dv">1</span>
     <span class="dt">dd</span>   <span class="dv">10</span>
     <span class="dt">dd</span>   <span class="dv">100</span>
     <span class="dt">dd</span>   <span class="dv">1000</span>
     <span class="dt">dd</span>   <span class="dv">10000</span>
     <span class="dt">dd</span>   <span class="dv">100000</span>
     <span class="dt">dd</span>   <span class="dv">1000000</span>
     <span class="dt">dd</span>   <span class="dv">10000000</span>
     <span class="dt">dd</span>   <span class="dv">100000000</span>
     <span class="dt">dd</span>   <span class="dv">1000000000</span>
PowersOfTenEnd   labelword
<span class="co">;</span>
<span class="co">; String printed to report that the high word of the BIOS count</span>
<span class="co">; changed while timing (an hour elapsed or midnight was crossed),</span>
<span class="co">; and so the count is invalid and the test needs to be rerun.</span>
<span class="co">;</span>
TurnOverStrlabelbyte
     <span class="dt">db</span><span class="bn">  0dh, </span>0ah
     <span class="dt">db</span> ‘****************************************************<span class="st">&#39;</span>
     <span class="dt">db</span><span class="bn"> 0dh, </span>0ah
     db<span class="st">&#39;*   Either midnight passed or an hour or more passed *&#39;</span>
     <span class="dt">db</span><span class="bn"> 0dh, </span>0ah
     db<span class="st">&#39;*  while timing was in progress. If the former was  *&#39;</span>
     <span class="dt">db</span><span class="bn"> 0dh, </span>0ah
     db<span class="st">&#39;*  the case, please rerun the test; if the latter   *&#39;</span>
     <span class="dt">db</span><span class="bn"> 0dh, </span>0ah
     db<span class="st">&#39;* was the case, the test code takes too long to    *&#39;</span>
     <span class="dt">db</span><span class="bn"> 0dh, </span>0ah
     db<span class="st">&#39;* run to be timed by the long-period Zen timer.    *&#39;</span>
     <span class="dt">db</span><span class="bn"> 0dh, </span>0ah
     <span class="dt">db</span> ‘* Suggestions: use the DOS TIME command, the DOS   *<span class="st">&#39;</span>
     <span class="dt">db</span><span class="bn"> 0dh, </span>0ah
     <span class="dt">db</span> ‘* time function, <span class="kw">or</span> a watch.                       *<span class="st">&#39;</span>
     <span class="dt">db</span><span class="bn"> 0dh, </span>0ah
     <span class="dt">db</span> ‘****************************************************<span class="st">&#39;</span>
     <span class="dt">db</span><span class="bn"> 0dh, </span>0ah
     db<span class="st">&#39;$&#39;</span>

<span class="co">;********************************************************************</span>
<span class="co">;* Routine called to start timing.         *</span>
<span class="co">;********************************************************************</span>

ZTimerOn  proc near

<span class="co">;</span>
<span class="co">; Save the context of the program being timed.</span>
<span class="co">;</span>
     <span class="kw">push</span> <span class="kw">ax</span>
     pus  hf
<span class="co">;</span>
<span class="co">; Set timer 0 of the 8253 to mode 2 (divide-by-N), to cause</span>
<span class="co">; linear counting rather than count-by-two counting. Also stops</span>
<span class="co">; timer 0 until the timer count is loaded, except on PS/2</span>
<span class="co">; computers.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">al</span><span class="bn">,00110100b      </span><span class="co">;mode 2</span>
     <span class="kw">out</span>  MODE_8253,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Set the timer count to 0, so we know we won&#39;t get another</span>
<span class="co">; timer interrupt right away.</span>
<span class="co">; Note: this introduces an inaccuracy of up to 54 ms in the system</span>
<span class="co">; clock count each time it is executed.</span>
<span class="co">;</span>
     DELAY
     subal,<span class="kw">al</span>
     outTIMER_0_8253,<span class="kw">al</span>       <span class="co">;lsb</span>
     DELAY
     outTIMER_0_8253,<span class="kw">al</span>       <span class="co">;msb</span>
<span class="co">;</span>
<span class="co">; In case interrupts are disabled, enable interrupts briefly to allow</span>
<span class="co">; the interrupt generated when switching from mode 3 to mode 2 to be</span>
<span class="co">; recognized. Interrupts must be enabled for at least 210 ns to allow</span>
<span class="co">; time for that interrupt to occur. Here, 10 jumps are used for the</span>
<span class="co">; delay to ensure that the delay time will be more than long enough</span>
<span class="co">; even on a very fast PC.</span>
<span class="co">;</span>
     <span class="kw">pushf</span>
     <span class="kw">sti</span>
     rept <span class="dv">10</span>
     <span class="kw">jmp</span>  <span class="dv">$</span>+<span class="dv">2</span>
     endm
     MPOPF
<span class="co">;</span>
<span class="co">; Store the timing start BIOS count.</span>
<span class="co">; (Since the timer count was just set to 0, the BIOS count will</span>
<span class="co">; stay the same for the next 54 ms, so we don&#39;t need to disable</span>
<span class="co">; interrupts in order to avoid getting a half-changed count.)</span>
<span class="co">;</span>
     <span class="kw">push</span>   <span class="kw">ds</span>
     subax, <span class="kw">ax</span>
     movds, <span class="kw">ax</span>
     movax, <span class="kw">ds</span>:[TIMER_COUNT<span class="dv">+2</span>]
<span class="fu">     movcs:</span> [StartBIOSCountHigh],<span class="kw">ax</span>
     movax, <span class="kw">ds</span>:[TIMER_COUNT]
<span class="fu">     movcs:</span> [StartBIOSCountLow],<span class="kw">ax</span>
     <span class="kw">pop</span>    <span class="kw">ds</span>
<span class="co">;</span>
<span class="co">; Set the timer count to 0 again to start the timing interval.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">al</span><span class="bn">,00110100b        </span><span class="co">;set up to load initial</span>
     <span class="kw">out</span>    MODE_8253,<span class="kw">al</span>        <span class="co">; timer count</span>
     DELAY
     subal, <span class="kw">al</span>
     <span class="kw">out</span>    TIMER_0_8253,<span class="kw">al</span><span class="co">;    load count lsb</span>
     DELAY
     <span class="kw">out</span>   TIMER_0_8253,<span class="kw">al</span><span class="co">;     load count msb</span>
<span class="co">;</span>
<span class="co">; Restore the context of the program being timed and return to it.</span>
<span class="co">;</span>
     MPOPF
     popax
     <span class="kw">ret</span>

ZTimerOnendp

<span class="co">;********************************************************************</span>
<span class="co">;* Routine called to stop timing and get count.                     *</span>
<span class="co">;********************************************************************</span>

ZTimerOff procnear

<span class="co">;</span>
<span class="co">; Save the context of the program being timed.</span>
<span class="co">;</span>
     <span class="kw">pushf</span>
     pushax
     pushcx
<span class="co">;</span>
<span class="co">; In case interrupts are disabled, enable interrupts briefly to allow</span>
<span class="co">; any pending timer interrupt to be handled. Interrupts must be</span>
<span class="co">; enabled for at least 210 ns to allow time for that interrupt to</span>
<span class="co">; occur. Here, 10 jumps are used for the delay to ensure that the</span>
<span class="co">; delay time will be more than long enough even on a very fast PC.</span>
<span class="co">;</span>
     <span class="kw">sti</span>
     rept <span class="dv">10</span>
     <span class="kw">jmp</span>  <span class="dv">$</span>+<span class="dv">2</span>
     endm

<span class="co">;</span>
<span class="co">; Latch the timer count.</span>
<span class="co">;</span>

if PS2

     <span class="kw">mov</span>  <span class="kw">al</span><span class="bn">,00000000b</span>
     <span class="kw">out</span>  MODE_8253,<span class="kw">al</span>     <span class="co">;latch timer 0 count</span>
<span class="co">;</span>
<span class="co">; This is where a one-instruction-long window exists on the PS/2.</span>
<span class="co">; The timer count and the BIOS count can lose synchronization;</span>
<span class="co">; since the timer keeps counting after it&#39;s latched, it can turn</span>
<span class="co">; over right after it&#39;s latched and cause the BIOS count to turn</span>
<span class="co">; over before interrupts are disabled, leaving us with the timer</span>
<span class="co">; count from before the timer turned over coupled with the BIOS</span>
<span class="co">; count from after the timer turned over. The result is a count</span>
<span class="co">; that&#39;s 54 ms too long.</span>
<span class="co">;</span>

else

<span class="co">;</span>
<span class="co">; Set timer 0 to mode 2 (divide-by-N), waiting for a 2-byte count</span>
<span class="co">; load, which stops timer 0 until the count is loaded. (Only works</span>
<span class="co">; on fully 8253-compatible chips.)</span>
<span class="co">;</span>
     <span class="kw">mov</span>   <span class="kw">al</span>,00110100b<span class="co">;     mode 2</span>
     <span class="kw">out</span>   MODE_8253,<span class="kw">al</span>
     DELAY
     <span class="kw">mov</span>   <span class="kw">al</span><span class="bn">,00000000b      </span><span class="co">;latch timer 0 count</span>
     <span class="kw">out</span>   MODE_8253,<span class="kw">al</span>

endif

     <span class="kw">cli</span>                     <span class="co">;stop the BIOS count</span>
<span class="co">;</span>
<span class="co">; Read the BIOS count. (Since interrupts are disabled, the BIOS</span>
<span class="co">; count won&#39;t change.)</span>
<span class="co">;</span>
     <span class="kw">push</span> <span class="kw">ds</span>
     <span class="kw">sub</span>  <span class="kw">ax</span>,<span class="kw">ax</span>
     <span class="kw">mov</span>  <span class="kw">ds</span>,<span class="kw">ax</span>
     <span class="kw">mov</span>  <span class="kw">ax</span>,<span class="kw">ds</span>:[TIMER_COUNT<span class="dv">+2</span>]
     <span class="kw">mov</span>  <span class="kw">cs</span>:[EndBIOSCountHigh],<span class="kw">ax</span>
     <span class="kw">mov</span>  <span class="kw">ax</span>,<span class="kw">ds</span>:[TIMER_COUNT]
     <span class="kw">mov</span>  <span class="kw">cs</span>:[EndBIOSCountLow],<span class="kw">ax</span>
     <span class="kw">pop</span>  <span class="kw">ds</span>
<span class="co">;</span>
<span class="co">; Read the timer count and save it.</span>
<span class="co">;</span>
     <span class="kw">in</span>   <span class="kw">al</span>,TIMER_0_8253        <span class="co">;lsb</span>
     DELAY
     <span class="kw">mov</span>  <span class="kw">ah</span>,<span class="kw">al</span>
     <span class="kw">in</span>   <span class="kw">al</span>,TIMER_0_8253        <span class="co">;msb</span>
     <span class="kw">xchg</span> <span class="kw">ah</span>,<span class="kw">al</span>
     <span class="kw">neg</span>  <span class="kw">ax</span>                     <span class="co">;convert from countdown</span>
                                 <span class="co">; remaining to elapsed</span>
                                 <span class="co">; count</span>
     <span class="kw">mov</span>  <span class="kw">cs</span>:[EndTimedCount],<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Restart timer 0, which is still waiting for an initial count</span>
<span class="co">; to be loaded.</span>
<span class="co">;</span>

ife PS2

     DELAY
     <span class="kw">mov</span>  <span class="kw">al</span><span class="bn">,00110100b        </span><span class="co">;mode 2, waiting to load a</span>
                              <span class="co">; 2-byte count</span>
     <span class="kw">out</span>  MODE_8253,<span class="kw">al</span>
     DELAY
     <span class="kw">sub</span>  <span class="kw">al</span>,<span class="kw">al</span>
     <span class="kw">out</span>  TIMER_0_8253,<span class="kw">al</span>     <span class="co">;lsb</span>
     DELAY
     <span class="kw">mov</span>  <span class="kw">al</span>,<span class="kw">ah</span>
     <span class="kw">out</span>  TIMER_0_8253,<span class="kw">al</span>     <span class="co">;msb</span>
     DELAY

endif

<span class="kw">sti</span><span class="co">;let the BIOS count continue</span>
<span class="co">;</span>
<span class="co">; Time a zero-length code fragment, to get a reference for how</span>
<span class="co">; much overhead this routine has. Time it 16 times and average it,</span>
<span class="co">; for accuracy, rounding the result.</span>
<span class="co">;</span>
     <span class="kw">mov</span>   <span class="kw">cs</span>:[ReferenceCount],<span class="dv">0</span>
     <span class="kw">mov</span>   <span class="kw">cx</span>,<span class="dv">16</span>
     <span class="kw">cli</span>                         <span class="co">;interrupts off to allow a</span>
                                 <span class="co">; precise reference count</span>
<span class="fu">RefLoop:</span>
     <span class="kw">call</span>  ReferenceZTimerOn
     <span class="kw">call</span>  ReferenceZTimerOff
     <span class="kw">loop</span>  RefLoop
     <span class="kw">sti</span>
     <span class="kw">add</span>   <span class="kw">cs</span>:[ReferenceCount],<span class="dv">8</span><span class="co">;     total + (0.5 * 16)</span>
     <span class="kw">mov</span>   <span class="kw">cl</span>,<span class="dv">4</span>
     <span class="kw">shr</span>   <span class="kw">cs</span>:[ReferenceCount],<span class="kw">cl</span><span class="co">;(total) / 16 + 0.5</span>
<span class="co">;</span>
<span class="co">; Restore the context of the program being timed and return to it.</span>
<span class="co">;</span>
     popcx
     popax
     MPOPF
     <span class="kw">ret</span>

ZTimerOff endp

<span class="co">;</span>
<span class="co">; Called by ZTimerOff to start the timer for overhead measurements.</span>
<span class="co">;</span>

ReferenceZTimerOnprocnear
<span class="co">;</span>
<span class="co">; Save the context of the program being timed.</span>
<span class="co">;</span>
     pushax
     <span class="kw">pushf</span>
<span class="co">;</span>
<span class="co">; Set timer 0 of the 8253 to mode 2 (divide-by-N), to cause</span>
<span class="co">; linear counting rather than count-by-two counting.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">al</span><span class="bn">,00110100b     </span><span class="co">;mode 2</span>
     <span class="kw">out</span>    MODE_8253,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Set the timer count to 0.</span>
<span class="co">;</span>
     DELAY
     <span class="kw">sub</span>     <span class="kw">al</span>,<span class="kw">al</span>
     <span class="kw">out</span>     TIMER_0_8253,<span class="kw">al</span>     <span class="co">;lsb</span>
     DELAY
     <span class="kw">out</span>     TIMER_0_8253,<span class="kw">al</span>     <span class="co">;msb</span>
<span class="co">;</span>
<span class="co">; Restore the context of the program being timed and return to it.</span>
<span class="co">;</span>
     MPOPF
     popax
     <span class="kw">ret</span>

ReferenceZTimerOnendp

<span class="co">;</span>
<span class="co">; Called by ZTimerOff to stop the timer and add the result to</span>
<span class="co">; ReferenceCount for overhead measurements. Doesn&#39;t need to look</span>
<span class="co">; at the BIOS count because timing a zero-length code fragment</span>
<span class="co">; isn&#39;t going to take anywhere near 54 ms.</span>
<span class="co">;</span>

ReferenceZTimerOff procnear
<span class="co">;</span>
<span class="co">; Save the context of the program being timed.</span>
<span class="co">;</span>
     <span class="kw">pushf</span>
     pushax
     pushcx

<span class="co">;</span>
<span class="co">; Match the interrupt-window delay in ZTimerOff.</span>
<span class="co">;</span>
     <span class="kw">sti</span>
     rept10
     jmp<span class="dv">$</span>+<span class="dv">2</span>
     endm

     <span class="kw">mov</span>    <span class="kw">al</span><span class="bn">,00000000b</span>
     <span class="kw">out</span>    MODE_8253,<span class="kw">al</span>     <span class="co">;latch timer</span>
<span class="co">;</span>
<span class="co">; Read the count and save it.</span>
<span class="co">;</span>
     DELAY
     <span class="kw">in</span>    <span class="kw">al</span>,TIMER_0_8253     <span class="co">;lsb</span>
     DELAY
     <span class="kw">mov</span>   <span class="kw">ah</span>,<span class="kw">al</span>
     <span class="kw">in</span>    <span class="kw">al</span>,TIMER_0_8253     <span class="co">;msb</span>
     <span class="kw">xchg</span>  <span class="kw">ah</span>,<span class="kw">al</span>
     <span class="kw">neg</span>   <span class="kw">ax</span>                  <span class="co">;convert from countdown</span>
                               <span class="co">; remaining to elapsed</span>
                               <span class="co">; count</span>
     <span class="kw">add</span>   <span class="kw">cs</span>:[ReferenceCount],<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Restore the context and return.</span>
<span class="co">;</span>
     popcx
     popax
     MPOPF
     <span class="kw">ret</span>

ReferenceZTimerOff endp

<span class="co">;********************************************************************</span>
<span class="co">;* Routine called to report timing results.                           *</span>
<span class="co">;********************************************************************</span>

ZTimerReportprocnear

     <span class="kw">pushf</span>
     <span class="kw">push</span>    <span class="kw">ax</span>
     <span class="kw">push</span>    <span class="kw">bx</span>
     <span class="kw">push</span>    <span class="kw">cx</span>
     <span class="kw">push</span>    <span class="kw">dx</span>
     <span class="kw">push</span>    <span class="kw">si</span>
     <span class="kw">push</span>    <span class="kw">di</span>
     <span class="kw">push</span>    <span class="kw">ds</span>
     <span class="co">;</span>
     <span class="kw">push</span>    <span class="kw">cs</span>     <span class="co">;DOS functions require that DS point</span>
     <span class="kw">pop</span>     <span class="kw">ds</span>     <span class="co">; to text to be displayed on the screen</span>
     assume  <span class="kw">ds</span>     :Code
<span class="co">;</span>
<span class="co">; See if midnight or more than an hour passed during timing. If so,</span>
<span class="co">; notify the user.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">ax</span>,[StartBIOSCountHigh]
     <span class="kw">cmp</span>    <span class="kw">ax</span>,[EndBIOSCountHigh]
     <span class="kw">jz</span>     CalcBIOSTime     <span class="co">;hour count didn&#39;t change,</span>
                             <span class="co">; so everything&#39;s fine</span>
     <span class="kw">inc</span>    <span class="kw">ax</span>
     <span class="kw">cmp</span>    <span class="kw">ax</span>,[EndBIOSCountHigh]
     <span class="kw">jnz</span>    TestTooLong      <span class="co">;midnight or two hour</span>
                             <span class="co">; boundaries passed, so the</span>
                             <span class="co">; results are no good</span>
     <span class="kw">mov</span>    <span class="kw">ax</span>,[EndBIOSCountLow]
     <span class="kw">cmp</span>    <span class="kw">ax</span>,[StartBIOSCountLow]
     <span class="kw">jb</span>     CalcBIOSTime     <span class="co">;a single hour boundary</span>
                             <span class="co">; passed--that&#39;s OK, so long as</span>
                             <span class="co">; the total time wasn&#39;t more</span>
                             <span class="co">; than an hour</span>

<span class="co">;</span>
<span class="co">; Over an hour elapsed or midnight passed during timing, which</span>
<span class="co">; renders the results invalid. Notify the user. This misses the</span>
<span class="co">; case where a multiple of 24 hours has passed, but we&#39;ll rely</span>
<span class="co">; on the perspicacity of the user to detect that case.</span>
<span class="co">;</span>
<span class="fu">TestTooLong:</span>
     <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="dv">9</span>
     <span class="kw">mov</span>    <span class="kw">dx</span>,offset TurnOverStr
     <span class="kw">int</span><span class="bn">    21h</span>
     <span class="kw">jmp</span>    <span class="dt">short</span> ZTimerReportDone
<span class="co">;</span>
<span class="co">; Convert the BIOS time to microseconds.</span>
<span class="co">;</span>
<span class="fu">CalcBIOSTime:</span>
     <span class="kw">mov</span>     <span class="kw">ax</span>,[EndBIOSCountLow]
     <span class="kw">sub</span>    <span class="kw">ax</span>,[StartBIOSCountLow]
     <span class="kw">mov</span>    <span class="kw">dx</span>,<span class="dv">54925</span>          <span class="co">;number of microseconds each</span>
                              <span class="co">; BIOS count represents</span>
     <span class="kw">mul</span>    <span class="kw">dx</span>
     <span class="kw">mov</span>    <span class="kw">bx</span>,<span class="kw">ax</span>             <span class="co">;set aside BIOS count in</span>
     <span class="kw">mov</span>    <span class="kw">cx</span>,<span class="kw">dx</span>             <span class="co">; microseconds</span>
<span class="co">;</span>
<span class="co">; Convert timer count to microseconds.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">ax</span>,[EndTimedCount]
     <span class="kw">mov</span>    <span class="kw">si</span>,<span class="dv">8381</span>
     <span class="kw">mul</span>    <span class="kw">si</span>
     <span class="kw">mov</span>    <span class="kw">si</span>,<span class="dv">10000</span>
     <span class="kw">div</span>    <span class="kw">si</span>               <span class="co">;* .8381 = * 8381 / 10000</span>
<span class="co">;</span>
<span class="co">; Add timer and BIOS counts together to get an overall time in</span>
<span class="co">; microseconds.</span>
<span class="co">;</span>
     <span class="kw">add</span>    <span class="kw">bx</span>,<span class="kw">ax</span>
     <span class="kw">adc</span>    <span class="kw">cx</span>,<span class="dv">0</span>
<span class="co">;</span>
<span class="co">; Subtract the timer overhead and save the result.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">ax</span>,[ReferenceCount]
     <span class="kw">mov</span>    <span class="kw">si</span>,<span class="dv">8381</span>          <span class="co">;convert the reference count</span>
     <span class="kw">mul</span>    <span class="kw">si</span>               <span class="co">; to microseconds</span>
     <span class="kw">mov</span>    <span class="kw">si</span>,<span class="dv">10000</span>
     <span class="kw">div</span>    <span class="kw">si</span><span class="co">;* .8381 = * 8381 / 10000</span>
     <span class="kw">sub</span>    <span class="kw">bx</span>,<span class="kw">ax</span>
     <span class="kw">sbb</span>    <span class="kw">cx</span>,<span class="dv">0</span>
     <span class="kw">mov</span>    [CurrentCountLow],<span class="kw">bx</span>
     <span class="kw">mov</span>    [CurrentCountHigh],<span class="kw">cx</span>
<span class="co">;</span>
<span class="co">; Convert the result to an ASCII string by trial subtractions of</span>
<span class="co">; powers of 10.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">di</span>,offset PowersOfTenEnd - offset PowersOfTen - <span class="dv">4</span>
     <span class="kw">mov</span>    <span class="kw">si</span>,offset TimedCountStr
<span class="fu">CTSNextDigit:</span>
     <span class="kw">mov</span>    <span class="kw">bl</span>,<span class="st">&#39;0&#39;</span>
<span class="fu">CTSLoop:</span>
     <span class="kw">mov</span>    <span class="kw">ax</span>,[CurrentCountLow]
     <span class="kw">mov</span>    <span class="kw">dx</span>,[CurrentCountHigh]
     <span class="kw">sub</span>    <span class="kw">ax</span>,PowersOfTen[<span class="kw">di</span>]
     <span class="kw">sbb</span>    <span class="kw">dx</span>,PowersOfTen[<span class="kw">di</span><span class="dv">+2</span>]
     <span class="kw">jc</span>     CTSNextPowerDown
     <span class="kw">inc</span>    <span class="kw">bl</span>
     <span class="kw">mov</span>    [CurrentCountLow],<span class="kw">ax</span>
     <span class="kw">mov</span>    [CurrentCountHigh],<span class="kw">dx</span>
     <span class="kw">jmp</span>    CTSLoop
<span class="fu">CTSNextPowerDown:</span>
     <span class="kw">mov</span>    [<span class="kw">si</span>],<span class="kw">bl</span>
     <span class="kw">inc</span>    <span class="kw">si</span>
     <span class="kw">sub</span>    <span class="kw">di</span>,<span class="dv">4</span>
     <span class="kw">jns</span>    CTSNextDigit
<span class="co">;</span>
<span class="co">;</span>
<span class="co">; Print the results.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="dv">9</span>
     <span class="kw">mov</span>    <span class="kw">dx</span>,offset OutputStr
     <span class="kw">int</span><span class="bn">    21h</span>
<span class="co">;</span>
<span class="fu">ZTimerReportDone:</span>
     <span class="kw">pop</span>    <span class="kw">ds</span>
     <span class="kw">pop</span>    <span class="kw">di</span>
     <span class="kw">pop</span>    <span class="kw">si</span>
     <span class="kw">pop</span>    <span class="kw">dx</span>
     <span class="kw">pop</span>    <span class="kw">cx</span>
     <span class="kw">pop</span>    <span class="kw">bx</span>
     <span class="kw">pop</span>    <span class="kw">ax</span>
     MPOPF
     <span class="kw">ret</span>

ZTimerReport    endp

Code   ends
       end</code></pre>
<p>Moreover, because it uses an undocumented feature, the timer-stop approach could conceivably cause erratic 8253 operation, which could in turn seriously affect your computer’s operation until the next reboot. In non-8253-compatible systems, I’ve observed not only wildly incorrect timing results, but also failure of a diskette drive to operate properly after the long-period Zen timer with <code>PS2</code> set to 0 has run, so be alert for signs of trouble if you do set <code>PS2</code> to 0.</p>
<p>Rebooting should clear up any timer-related problems of the sort described above. (This gives us another reason to reboot at the end of each code-timing session.) You should <em>immediately</em> reboot and set the <code>PS2</code> equate to 1 if you get erratic or obviously incorrect results with the long-period Zen timer when <code>PS2</code> is set to 0. If you want to set <code>PS2</code> to 0, it would be a good idea to time a few of the listings in this book with <code>PS2</code> set first to 1 and then to 0, to make sure that the results match. If they’re consistently different, you should set <code>PS2</code> to 1.</p>
<p>While the the non-PS/2 version is more dangerous than the PS/2 version, it also produces more accurate results when it does work. If you have a non-PS/2 PC-compatible computer, the choice between the two timing approaches is yours.</p>
<p>If you do leave the <code>PS2</code> equate at 1 in Listing 3.5, you should repeat each code-timing run several times before relying on the results to be accurate to more than 54 ms, since variations may result from the possible lack of synchronization between the timer 0 count and the BIOS time-of-day count. In fact, it’s a good idea to time code more than once no matter which version of the long-period Zen timer you’re using, since interrupts, which must be enabled in order for the long-period timer to work properly, may occur at any time and can alter execution time substantially.</p>
<p>Finally, please note that the <em>precision</em> Zen timer works perfectly well on both PS/2 and non-PS/2 computers. The PS/2 and 8253 considerations we’ve just discussed apply <em>only</em> to the longZen timer.</p>
</section>
</section>
<section id="example-use-of-the-long-period-zen-timer" class="level3">
<h3><a href="#example-use-of-the-long-period-zen-timer">Example Use of the Long-Period Zen Timer</a></h3>
<p>The long-period Zen timer has exactly the same calling interface as the precision Zen timer, and can be used in place of the precision Zen timer simply by linking it to the code to be timed in place of linking the precision timer code. Whenever the precision Zen timer informs you that the code being timed takes too long for the precision timer to handle, all you have to do is link in the long-period timer instead.</p>
<p>Listing 3.6 shows a test-bed program for the long-period Zen timer. While this program is similar to Listing 3.2, it’s worth noting that Listing 3.6 waits for a few seconds before calling <code>ZTimerOn</code>, thereby allowing any pending keyboard interrupts to be processed. Since interrupts must be left on in order to time periods longer than 54 ms, the interrupts generated by keystrokes (including the upstroke of the Enter key press that starts the program)—or any other interrupts, for that matter—could incorrectly inflate the time recorded by the long-period Zen timer. In light of this, resist the temptation to type ahead, move the mouse, or the like while the long-period Zen timer is timing.</p>
<p><strong>LISTING 3.6 LZTEST.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to measure performance of code that takes longer than</span>
<span class="co">; 54 ms to execute. (LZTEST.ASM)</span>
<span class="co">;</span>
<span class="co">; Link with LZTIMER.ASM (Listing 3.5). LZTIME.BAT (Listing 3.7)</span>
<span class="co">; can be used to assemble and link both files. Code to be</span>
<span class="co">; measured must be in the file TESTCODE; Listing 3.8 shows</span>
<span class="co">; a sample file (LST3-8.ASM) which should be named TESTCODE.</span>
<span class="co">;</span>
<span class="co">; By Michael Abrash</span>
<span class="co">;</span>
mystack   <span class="kw">segment</span>    para stack ‘STACK<span class="st">&#39;</span>
     <span class="dt">db</span>         <span class="dv">512</span> dup(?)
mystack    ends
<span class="co">;</span>
Code  <span class="kw">segment</span>   para public ‘CODE<span class="st">&#39;</span>
      assume    <span class="kw">cs</span>:Code, <span class="kw">ds</span>:Code
      extrn ZTimerOn:near, ZTimerOff:near, ZTimerReport:near
Startproc   near
      <span class="kw">push</span>  <span class="kw">cs</span>
     <span class="kw">pop</span>    <span class="kw">ds</span>     <span class="co">;point DS to the code segment,</span>
                   <span class="co">; so data as well as code can easily</span>
                   <span class="co">; be included in TESTCODE</span>
<span class="co">;</span>
<span class="co">; Delay for 6-7 seconds, to let the Enter keystroke that started the</span>
<span class="co">; program come back up.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">ah</span><span class="bn">,2ch</span>
     <span class="kw">int</span><span class="bn">  21h        </span><span class="co">;get the current time</span>
     <span class="kw">mov</span>  <span class="kw">bh</span>,<span class="kw">dh</span>      <span class="co">;set the current time aside</span>
<span class="fu">DelayLoop:</span>
     <span class="kw">mov</span>   <span class="kw">ah</span><span class="bn">,2ch</span>
     <span class="kw">push</span>  <span class="kw">bx</span>                 <span class="co">;preserve start time</span>
     <span class="kw">int</span><span class="bn">   21h                </span><span class="co">;get time</span>
     <span class="kw">pop</span>   <span class="kw">bx</span>                 <span class="co">;retrieve start time</span>
     <span class="kw">cmp</span>   <span class="kw">dh</span>,<span class="kw">bh</span>              <span class="co">;is the new seconds count less than</span>
                              <span class="co">; the start seconds count?</span>
     <span class="kw">jnb</span>   CheckDelayTime     <span class="co">;no</span>
     <span class="kw">add</span>   <span class="kw">dh</span>,<span class="dv">60</span>              <span class="co">;yes, a minute must have turned over,</span>
                              <span class="co">; so add one minute</span>
<span class="fu">CheckDelayTime:</span>
     <span class="kw">sub</span>   <span class="kw">dh</span>,<span class="kw">bh</span>                 <span class="co">;get time that&#39;s passed</span>
     <span class="kw">cmp</span>   <span class="kw">dh</span>,<span class="dv">7</span>                  <span class="co">;has it been more than 6 seconds yet?</span>
     <span class="kw">jb</span>    DelayLoop             <span class="co">;not yet</span>
<span class="co">;</span>
     include   TESTCODE          <span class="co">;code to be measured, including calls</span>
                                 <span class="co">; to ZTimerOn and ZTimerOff</span>
<span class="co">;</span>
<span class="co">; Display the results.</span>
<span class="co">;</span>
     <span class="kw">call</span>  ZTimerReport
<span class="co">;</span>
<span class="co">; Terminate the program.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">ah</span><span class="bn">,4ch</span>
     <span class="kw">int</span><span class="bn">  21h</span>
Start endp
Code  ends
      end     Start</code></pre>
<p>As with the precision Zen timer, the program in Listing 3.6 is used by naming the file containing the code to be timed TESTCODE, then assembling both Listing 3.6 and Listing 3.5 with MASM or TASM and linking the two files together by way of the Microsoft or Borland linker. Listing 3.7 shows a batch file, named LZTIME.BAT, which does all of the above, generating and running the executable file LZTEST.EXE. LZTIME.BAT assumes that the file LZTIMER.ASM contains Listing 3.5 and the file LZTEST.ASM contains Listing 3.6.</p>
<p><strong>LISTING 3.7 LZTIME.BAT</strong></p>
<pre class="bat"><code>echo off
rem
rem *** Listing 3.7 ***
rem
rem ***************************************************************
rem * Batch file LZTIME.BAT, which builds and runs the            *
rem * long-period Zen timer program LZTEST.EXE to time the code   *
rem * named as the command-line parameter. Listing 3.5 must be    *
rem * named LZTIMER.ASM, and Listing 3.6 must be named            *
rem * LZTEST.ASM. To time the code in LST3-8, you&#39;d type the      *
rem * DOS command:                                                *
rem *                                                             *
rem * lztime lst3-8                                               *
rem *                                                             *
rem * Note that MASM and LINK must be in the current directory or *
rem * on the current path in order for this batch file to work.   *
rem *                                                             *
rem * This batch file can be speeded up by assembling LZTIMER.ASM *
rem * once, then removing the lines:                              *
rem *                                                             *
rem * masm lztimer;                                               *
rem * if errorlevel 1 goto errorend                               *
rem *                                                             *
rem * from this file.                                             *
rem *                                                             *
rem * By Michael Abrash                                           *
rem ***************************************************************
rem
rem Make sure a file to test was specified.
rem
if not x%1==x goto ckexist
echo ***************************************************************
echo * Please specify a file to test.                              *
echo ***************************************************************
goto end
rem
rem Make sure the file exists.
rem
:ckexist
if exist %1 goto docopy
echo ***************************************************************
echo * The specified file, &quot;%1,&quot; doesn&#39;t exist.                    *
echo ***************************************************************
goto end
rem
rem copy the file to measure to TESTCODE.
:docopy
copy %1 testcode
masm lztest;
if errorlevel 1 goto errorend
masm lztimer;
if errorlevel 1 goto errorend
link lztest+lztimer;
if errorlevel 1 goto errorend
lztest
goto end
:errorend
echo ***************************************************************
echo * An error occurred while building the long-period Zen timer. *
echo ***************************************************************
:end</code></pre>
<p>Listing 3.8 shows sample code that can be timed with the test-bed program of Listing 3.6. Listing 3.8 measures the time required to execute 20,000 loads of AL from memory, a length of time too long for the precision Zen timer to handle on the 8088.</p>
<p><strong>LISTING 3.8 LST3-8.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">;</span>
<span class="co">; Measures the performance of 20,000 loads of AL from</span>
<span class="co">; memory. (Use by renaming to TESTCODE, which is</span>
<span class="co">; included by LZTEST.ASM (Listing 3.6). LZTIME.BAT</span>
<span class="co">; (Listing 3.7) does this, along with all assembly</span>
<span class="co">; and linking.)</span>
<span class="co">;</span>
<span class="co">; Note: takes about ten minutes to assemble on a slow PC if</span>
<span class="co">;you are using MASM</span>
<span class="co">;</span>
jmpSkip<span class="co">;jump around defined data</span>
<span class="co">;</span>
MemVardb?
<span class="co">;</span>
<span class="fu">Skip:</span>
<span class="co">;</span>
<span class="co">; Start timing.</span>
<span class="co">;</span>
callZTimerOn
<span class="co">;</span>
rept20000
moval,[MemVar]
endm
<span class="co">;</span>
<span class="co">; Stop timing.</span>
<span class="co">;</span>
callZTimerOff</code></pre>
<p>When LZTIME.BAT is run on a PC with the following command line (assuming the code in Listing 3.8 is the file LST3-8.ASM)</p>
<pre class="sh"><code>lztime lst3-8.asm</code></pre>
<p>the result is 72,544 µs, or about 3.63 µs per load of AL from memory. This is just slightly longer than the time per load of AL measured by the precision Zen timer, as we would expect given that interrupts are left enabled by the long-period Zen timer. The extra fraction of a microsecond measured per <code>MOV</code> reflects the time required to execute the BIOS code that handles the 18.2 timer interrupts that occur each second.</p>
<p>Note that the command can take as much as 10 minutes to finish on a slow PC if you are using MASM, with most of that time spent assembling Listing 3.8. Why? Because MASM is notoriously slow at assembling <code>REPT</code> blocks, and the block in Listing 3.8 is repeated 20,000 times.</p>
</section>
<section id="using-the-zen-timer-from-c" class="level3">
<h3><a href="#using-the-zen-timer-from-c">Using the Zen Timer from C</a></h3>
<p>The Zen timer can be used to measure code performance when programming in C—but not right out of the box. As presented earlier, the timer is designed to be called from assembly language; some relatively minor modifications are required before the <code>ZTimerOn</code> (start timer), <code>ZTimerOff</code> (stop timer), and <code>ZTimerReport</code> (display timing results) routines can be called from C. There are two separate cases to be dealt with here: small code model and large; I’ll tackle the simpler one, the small code model, first.</p>
<p>Altering the Zen timer for linking to a small code model C program involves the following steps: <code>C</code> hange <code>ZTimerOn</code> to <code>_ZTimerOn</code>, change <code>ZTimerOff</code> to <code>_ZTimerOff</code>, change <code>ZTimerReport</code> to <code>_ZTimerReport</code>, and change <code>Code</code> to <code>_TEXT</code> . Figure 3.2 shows the line numbers and new states of all lines from Listing 3.1 that must be changed. These changes convert the code to use C-style external label names and the small model C code segment. (In C++, use the “C” specifier, as in</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">extern</span> <span class="st">&quot;C&quot;</span> ZTimerOn(<span class="dt">void</span>);</code></pre>
<p>when declaring the timer routines <code>extern</code>, so that name-mangling doesn’t occur, and the linker can find the routines’ C-style names.)</p>
<p>That’s all it takes; after doing this, you’ll be able to use the Zen timer from C, as, for example, in:</p>
<pre class="sourceCode c"><code class="sourceCode c">ZTimerOn():
<span class="kw">for</span> (i=<span class="dv">0</span>, x=<span class="dv">0</span>; i&lt;<span class="dv">100</span>; i++)
     x += i;
ZTimerOff();
ZTimerReport();</code></pre>
<p>(I’m talking about the precision timer here. The long-period timer—Listing 3.5—requires the same modifications, but to different lines.)</p>
<figure>
<img src="images/03-02.jpg" alt="Figure 3.2  Changes for use with small code model C." /><figcaption><strong>Figure 3.2</strong>  <em>Changes for use with small code model C.</em></figcaption>
</figure>
<p>Altering the Zen timer for use in C’s large code model is a tad more complex, because in addition to the above changes, all functions, including the internal reference timing routines that are used to calculate overhead so it can be subtracted out, must be converted to far. Figure 3.3 shows the line numbers and new states of all lines from Listing 3.1 that must be changed in order to call the Zen timer from large code model C. Again, the line numbers are specific to the precision timer, but the long-period timer is very similar.</p>
<p>The full listings for the C-callable Zen timers are presented in Chapter K on the companion CD-ROM.</p>
<section id="watch-out-for-optimizing-assemblers" class="level4">
<h4><a href="#watch-out-for-optimizing-assemblers">Watch Out for Optimizing Assemblers!</a></h4>
<p>One important safety tip when modifying the Zen timer for use with large code model C code: Watch out for optimizing assemblers! TASM actually replaces</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">call</span>     far <span class="dt">ptr</span> ReferenceZTimerOn</code></pre>
<p>with</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">push</span>     <span class="kw">cs</span>
<span class="kw">call</span>     near <span class="dt">ptr</span> ReferenceZTimerOn</code></pre>
<p>(and likewise for <code>ReferenceZTimerOff</code> ), which works because <code>ReferenceZTimerOn</code> is in the same segment as the calling code. This is normally a great optimization, being both smaller and faster than a far call. However, it’s not so great for the Zen</p>
<figure>
<img src="images/03-03.jpg" alt="Figure 3.3  Changes for use with large code model C." /><figcaption><strong>Figure 3.3</strong>  <em>Changes for use with large code model C.</em></figcaption>
</figure>
<p>timer, because our purpose in calling the reference timing code is to determine exactly how much time is taken by overhead code—including the far calls to <code>ZTimerOn</code> and <code>ZTimerOf</code>f! By converting the far calls to push/near call pairs within the Zen timer module, TASM makes it impossible to emulate exactly the overhead of the Zen timer, and makes timings slightly (about 16 cycles on a 386) less accurate.</p>
<p>What’s the solution? Put the <code>NOSMART</code> directive at the start of the Zen timer code. This directive instructs TASM to turn off all optimizations, including converting far calls to push/near call pairs. By the way, there is, to the best of my knowledge, no such problem with MASM up through version 5.10A.</p>
<p>In my mind, the whole business of optimizing assemblers is a mixed blessing. In general, it’s nice to have the assembler shortening jumps and selecting sign-extended forms of instructions for you. On the other hand, the benefits of tricks like substituting push/near call pairs for far calls are relatively small, and those tricks can get in the way when complete control is needed. Sure, complete control is needed very rarely, but when it is, optimizing assemblers can cause subtle problems; I discovered TASM’s alteration of far calls only because I happened to view the code in the debugger, and you might want to do the same if you’re using a recent version of MASM.</p>
<p>I’ve tested the changes shown in Figures 3.2 and 3.3 with TASM and Borland C++ 4.0, and also with the latest MASM and Microsoft C/C++ compiler.</p>
</section>
<section id="further-reading" class="level4">
<h4><a href="#further-reading">Further Reading</a></h4>
<p>For those of you who wish to pursue the mechanics of code measurement further, one good article about measuring code performance with the 8253 timer is “Programming Insight: High-Performance Software Analysis on the IBM PC,” by Byron Sheppard, which appeared in the January, 1987 issue of <em>Byte</em>. For complete if somewhat cryptic information on the 8253 timer itself, I refer you to Intel’s <em>Microsystem Components Handbook</em>, which is also a useful reference for a number of other PC components, including the 8259 Programmable Interrupt Controller and the 8237 DMA Controller. For details about the way the 8253 is used in the PC, as well as a great deal of additional information about the PC’s hardware and BIOS resources, I suggest you consult IBM’s series of technical reference manuals for the PC, XT, AT, Model 30, and microchannel computers, such as the Models 50, 60, and 80.</p>
<p>For our purposes, however, it’s not critical that you understand exactly how the Zen timer works. All you really need to know is what the Zen timer can do and how to use it, and we’ve accomplished that in this chapter.</p>
</section>
<section id="armed-with-the-zen-timer-onward-and-upward" class="level4">
<h4><a href="#armed-with-the-zen-timer-onward-and-upward">Armed with the Zen Timer, Onward and Upward</a></h4>
<p>The Zen timer is not perfect. For one thing, the finest resolution to which it can measure an interval is at best about 1µs, a period of time in which a 66 MHz Pentium computer can execute as many as 132 instructions (although an 8088-based PC would be hard-pressed to manage two instructions in a microsecond). Another problem is that the timing code itself interferes with the state of the prefetch queue and processor cache at the start of the code being timed, because the timing code is not necessarily fetched and does not necessarily access memory in exactly the same time sequence as the code immediately preceding the code under measurement normally does. This prefetch effect can introduce as much as 3 to 4 µ of inaccuracy. Similarly, the state of the prefetch queue at the end of the code being timed affects how long the code that stops the timer takes to execute. Consequently, the Zen timer tends to be more accurate for longer code sequences, since the relative magnitude of the inaccuracy introduced by the Zen timer becomes less over longer periods.</p>
<p>Imperfections notwithstanding, the Zen timer is a good tool for exploring C code and x86 family assembly language, and it’s a tool we’ll use frequently for the remainder of this book.</p>
</section>
</section>
</section>
<section id="chapter-4-in-the-lair-of-the-cycle-eaters" class="level2">
<h2><a href="#chapter-4-in-the-lair-of-the-cycle-eaters">Chapter 4 – In the Lair of the Cycle-Eaters</a></h2>
<section id="how-the-pc-hardware-devours-code-performance" class="level3">
<h3><a href="#how-the-pc-hardware-devours-code-performance">How the PC Hardware Devours Code Performance</a></h3>
<p>This chapter, adapted from my earlier book, <em>Zen of Assembly Language</em> located on the companion CD-ROM, goes right to the heart of my philosophy of optimization: Understand where the time really goes when your code runs. That may sound ridiculously simple, but, as this chapter makes clear, it turns out to be a challenging task indeed, one that at times verges on black magic. This chapter is a long-time favorite of mine because it was the first—and to a large extent only—work that I know of that discussed this material, thereby introducing a generation of PC programmers to pedal-to-the-metal optimization.</p>
<p>This chapter focuses almost entirely on the first popular x86-family processor, the 8088. Some of the specific features and results that I cite in this chapter are no longer applicable to modern x86-family processors such as the 486 and Pentium, as I’ll point out later on when we discuss those processors. Nonetheless, the overall theme of this chapter—that understanding dimly-seen and poorly-documented code gremlins called cycle-eaters that lurk in your system is essential to performance programming—is every bit as valid today. Also, later chapters often refer back to the basic cycle-eaters described in this chapter, so this chapter is the foundation for the discussions of x86-family optimization to come. What’s more, the Zen timer remains an excellent tool with which to flush out and examine cycle-eaters, as we’ll see in later chapters, and this chapter is as good an illustration of how to use the Zen timer as you’re likely to find.</p>
<p>So, don’t take either the absolute or the relative execution times presented in this chapter as gospel for newer processors, and read on to later chapters to see how the cycle-eaters and optimization rules have changed over time, but do take the time to at least skim through this chapter to give yourself a good start on the material in the rest of this book.</p>
</section>
<section id="cycle-eaters" class="level3">
<h3><a href="#cycle-eaters">Cycle-Eaters</a></h3>
<p>Programming has many levels, ranging from the familiar (high-level languages, DOS calls, and the like) down to the esoteric things that lie on the shadowy edge of hardware-land. I call these <em>cycle-eaters</em> because, like the monsters in a bad 50s horror movie, they lurk in those shadows, taking their share of your program’s performance without regard to the forces of goodness or the U.S. Army. In this chapter, we’re going to jump right in at the lowest level by examining the cycle-eaters that live beneath the programming interface; that is, beneath your application, DOS, and BIOS—in fact, beneath the instruction set itself.</p>
<p>Why start at the lowest level? Simply because cycle-eaters affect the performance of all assembler code, and yet are almost unknown to most programmers. A full understanding of code optimization requires an understanding of cycle-eaters and their implications. That’s no simple task, and in fact it is in precisely that area that most books and articles about assembly programming fall short.</p>
<p>Nearly all literature on assembly programming discusses only the programming interface: the instruction set, the registers, the flags, and the BIOS and DOS calls. Those topics cover the functionality of assembly programs most thoroughly—but it’s performance above all else that we’re after. No one ever tells you about the raw stuff of performance, which lies <em>beneath</em> the programming interface, in the dimly-seen realm—populated by instruction prefetching, dynamic RAM refresh, and wait states—where software meets hardware. This area is the domain of hardware engineers, and is almost never discussed as it relates to code performance. And yet it is only by understanding the mechanisms operating at this level that we can fully understand and properly improve the performance of our code.</p>
<p>Which brings us to cycle-eaters.</p>
</section>
<section id="the-nature-of-cycle-eaters" class="level3">
<h3><a href="#the-nature-of-cycle-eaters">The Nature of Cycle-Eaters</a></h3>
<p>Cycle-eaters are gremlins that live on the bus or in peripherals (and sometimes within the CPU itself), slowing the performance of PC code so that it doesn’t execute at full speed. Most cycle-eaters (and all of those haunting the older Intel processors) live outside the CPU’s Execution Unit, where they can <em>only</em> affect the CPU when the CPU performs a bus access (a memory or I/O read or write). Once your code and data are already inside the CPU, those cycle-eaters can no longer be a problem. Only on the 486 and Pentium CPUs will you find cycle-eaters inside the chip, as we’ll see in later chapters.</p>
<p>The nature and severity of the cycle-eaters vary enormously from processor to processor, and (especially) from memory architecture to memory architecture. In order to understand them all, we need first to understand the simplest among them, those that haunted the original 8088-based IBM PC. Later on in this book, I’ll be better able to explain the newer generation of cycle-eaters in terms of those ancestral cycle-eaters—but we have to get the groundwork down first.</p>
<section id="the-8088s-ancestral-cycle-eaters" class="level4">
<h4><a href="#the-8088s-ancestral-cycle-eaters">The 8088’s Ancestral Cycle-Eaters</a></h4>
<p>Internally, the 8088 is a 16-bit processor, capable of running at full speed at all times—unless external data is required. External data must traverse the 8088’s external data bus and the PC’s data bus one byte at a time to and from peripherals, with cycle-eaters lurking along every step of the way. What’s more, external data includes not only memory operands <em>but also instruction bytes,</em> so even instructions with no memory operands can suffer from cycle-eaters. Since some of the 8088’s fastest instructions are register-only instructions, that’s important indeed.</p>
<p>The major cycle-eaters are:</p>
<ul>
<li>The 8088’s 8-bit external data bus.</li>
<li>The prefetch queue.</li>
<li>Dynamic RAM refresh.</li>
<li>Wait states, notably display memory wait states and, in the AT and 80386 computers, system memory wait states.</li>
</ul>
<p>The locations of these cycle-eaters in the primordial 8088-based PC are shown in Figure 4.1. We’ll cover each of the cycle-eaters in turn in this chapter. The material won’t be easy since cycle-eaters are among the most subtle aspects of assembly programming. By the same token, however, this will be one of the most important and rewarding chapters in this book. Don’t worry if you don’t catch everything in this chapter, but do read it all even if the going gets a bit tough. Cycle-eaters play a key role in later chapters, so some familiarity with them is highly desirable.</p>
</section>
</section>
<section id="the-8-bit-bus-cycle-eater" class="level3">
<h3><a href="#the-8-bit-bus-cycle-eater">The 8-Bit Bus Cycle-Eater</a></h3>
<p><em>Look! Down on the motherboard! It’s a 16-bit processor! It’s an 8-bit processor! It’s…</em></p>
<p>…an 8088!</p>
<p>Fans of the 8088 call it a 16-bit processor. Fans of other 16-bit processors call the 8088 an 8-bit processor. The truth of the matter is that the 8088 is a 16-bit processor that often performs like an 8-bit processor.</p>
<p>The 8088 is internally a full 16-bit processor, equivalent to an 8086. (In fact, the 8086 is identical to the 8088, except that it has a full 16-bit bus. The 8088 is basically the poor man’s 8086, because it allows a cheaper—albeit slower—system to be built, thanks to the half-sized bus.) In terms of the instruction set, the 8088 is clearly a 16-bit processor, capable of performing any given 16-bit operation—addition, subtraction, even multiplication or division—with a single instruction. Externally, however, the 8088 is unequivocally an 8-bit processor, since the external data bus is only 8 bits wide. In other words, the programming interface is 16 bits wide, but the hardware interface is only 8 bits wide, as shown in Figure 4.2. The result of this mismatch is simple: Word-sized data can be transferred between the 8088 and memory or peripherals at only one-half the maximum rate of the 8086, which is to say one-half the maximum rate for which the Execution Unit of the 8088 was designed.</p>
<figure>
<img src="images/04-01.jpg" alt="Figure 4.1  The location of the major cycle-eaters in the IBM PC." /><figcaption><strong>Figure 4.1</strong>  <em>The location of the major cycle-eaters in the IBM PC.</em></figcaption>
</figure>
<figure>
<img src="images/04-02.jpg" alt="Figure 4.2  Internal data bus widths of the 8088." /><figcaption><strong>Figure 4.2</strong>  <em>Internal data bus widths of the 8088.</em></figcaption>
</figure>
<p>As shown in Figure 4.1, the 8-bit bus cycle-eater lies squarely on the 8088’s external data bus. Technically, it might be more accurate to place this cycle-eater in the Bus Interface Unit, which breaks 16-bit memory accesses into paired 8-bit accesses, but it is really the limited width of the external data bus that constricts data flow into and out of the 8088. True, the original PC’s bus is also only 8 bits wide, but that’s just to match the 8088’s 8-bit bus; even if the PC’s bus were 16 bits wide, data could still pass into and out of the 8088 chip itself only 1 byte at a time.</p>
<p>Each bus access by the 8088 takes 4 clock cycles, or 0.838 µs in the 4.77 MHz PC, and transfers 1 byte. That means that the maximum rate at which data can be transferred into and out of the 8088 is 1 byte every 0.838 µs. While 8086 bus accesses also take 4 clock cycles, each 8086 bus access can transfer either 1 byte or 1 word, for a maximum transfer rate of 1 word every 0.838 µs. Consequently, for word-sized memory accesses, the 8086 has an effective transfer rate of 1 byte every 0.419 µs. By contrast, every word-sized access on the 8088 requires two 4-cycle-long bus accesses, one for the high byte of the word and one for the low byte of the word. As a result, the 8088 has an effective transfer rate for word-sized memory accesses of just 1 word every 1.676 µs—and that, in a nutshell, is the 8-bit bus cycle-eater.</p>
<p>A related cycle-eater lurks beneath the 386SX chip, which is a 32-bit processor internally with only a 16-bit path to system memory. The numbers are different, but the way the cycle-eater operates is exactly the same. AT-compatible systems have 16-bit data buses, which can access a full 16-bit word at a time. The 386SX can process 32 bits (a doubleword) at a time, however, and loses a lot of time fetching that doubleword from memory in two halves.</p>
<section id="the-impact-of-the-8-bit-bus-cycle-eater" class="level4">
<h4><a href="#the-impact-of-the-8-bit-bus-cycle-eater">The Impact of the 8-Bit Bus Cycle-Eater</a></h4>
<p>One obvious effect of the 8-bit bus cycle-eater is that word-sized accesses to memory operands on the 8088 take 4 cycles longer than byte-sized accesses. That’s why the official instruction timings indicate that for code running on an 8088 an additional 4 cycles are required for every word-sized access to a memory operand. For instance,</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [MemVar]</code></pre>
<p>takes 4 cycles longer to read the word at address <code>MemVar</code> than</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [MemVar]</code></pre>
<p>takes to read the byte at address <code>MemVar</code>. (Actually, the difference between the two isn’t very likely to be exactly 4 cycles, for reasons that will become clear once we discuss the prefetch queue and dynamic RAM refresh cycle-eaters later in this chapter.)</p>
<p>What’s more, in some cases one instruction can perform multiple word-sized accesses, incurring that 4-cycle penalty on each access. For example, adding a value to a word-sized memory variable requires two word-sized accesses—one to read the destination operand from memory prior to adding to it, and one to write the result of the addition back to the destination operand—and thus incurs not one but two 4-cycle penalties. As a result</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">add</span>  <span class="dt">word</span> <span class="dt">ptr</span> [MemVar],<span class="kw">ax</span></code></pre>
<p>takes about 8 cycles longer to execute than:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">add</span>  <span class="dt">byte</span> <span class="dt">ptr</span> [MemVar],<span class="kw">al</span></code></pre>
<p>String instructions can suffer from the 8-bit bus cycle-eater to a greater extent than other instructions. Believe it or not, a single <code>REP MOVSW</code> instruction can lose as much as 131,070 word-sized memory accesses x 4 cycles, or <em>524,280 cycles</em> to the 8-bit bus cycle-eater! In other words, one 8088 instruction (admittedly, an instruction that does a great deal) can take over one-tenth of a second longer on an 8088 than on an 8086, simply because of the 8-bit bus. <em>One-tenth of a second!</em> That’s a phenomenally long time in computer terms; in one-tenth of a second, the 8088 can perform more than 50,000 additions and subtractions.</p>
<p>The upshot of all this is simply that the 8088 can transfer word-sized data to and from memory at only half the speed of the 8086, which inevitably causes performance problems when coupled with an Execution Unit that can process word-sized data every bit as quickly as an 8086. These problems show up with any code that uses word-sized memory operands. More ominously, as we will see shortly, the 8-bit bus cycle-eater can cause performance problems with other sorts of code as well.</p>
</section>
<section id="what-to-do-about-the-8-bit-bus-cycle-eater" class="level4">
<h4><a href="#what-to-do-about-the-8-bit-bus-cycle-eater">What to Do about the 8-Bit Bus Cycle-Eater?</a></h4>
<p>The obvious implication of the 8-bit bus cycle-eater is that byte-sized memory variables should be used whenever possible. After all, the 8088 performs <em>byte-sized</em> memory accesses just as quickly as the 8086. For instance, Listing 4.1, which uses a byte-sized memory variable as a loop counter, runs in 10.03 s per loop. That’s 20 percent faster than the 12.05 µs per loop execution time of Listing 4.2, which uses a word-sized counter. Why the difference in execution times? Simply because each word-sized <code>DEC</code> performs 4 byte-sized memory accesses (two to read the word-sized operand and two to write the result back to memory), while each byte-sized <code>DEC</code> performs only 2 byte-sized memory accesses in all.</p>
<p><strong>LISTING 4.1 LST4-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Measures the performance of a loop which uses a</span>
<span class="co">; byte-sized memory variable as the loop counter.</span>
<span class="co">;</span>
      <span class="kw">jmp</span>  Skip
<span class="co">;</span>
Counter    <span class="dt">db</span>    <span class="dv">100</span>
<span class="co">;</span>
<span class="fu">Skip:</span>
      <span class="kw">call</span> ZTimerOn
<span class="fu">LoopTop:</span>
      <span class="kw">dec</span>  [Counter]
      <span class="kw">jnz</span>  LoopTop
      <span class="kw">call</span> ZTimerOff</code></pre>
<p><strong>LISTING 4.2 LST4-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Measures the performance of a loop which uses a</span>
<span class="co">; word-sized memory variable as the loop counter.</span>
<span class="co">;</span>
      <span class="kw">jmp</span>  Skip
<span class="co">;</span>
Counter    <span class="dt">dw</span>    <span class="dv">100</span>
<span class="co">;</span>
<span class="fu">Skip:</span>
      <span class="kw">call</span>  ZTimerOn
<span class="fu">LoopTop:</span>
      <span class="kw">dec</span>   [Counter]
      <span class="kw">jnz</span>   LoopTop
      <span class="kw">call</span>  ZTimerOff</code></pre>
<p>I’d like to make a brief aside concerning code optimization in the listings in this book. Throughout this book I’ve modeled the sample code after working code so that the timing results are applicable to real-world programming. In Listings 4.1 and 4.2, for example, I could have shown a still greater advantage for byte-sized operands simply by performing 1,000 <code>DEC</code> instructions in a row, with no branching at all. However, <code>DEC</code> instructions don’t exist in a vacuum, so in the listings I used code that both decremented the counter and tested the result. The difference is that between decrementing a memory location (simply an instruction) and using a loop counter (a functional instruction sequence). If you come across code in this book that seems less than optimal, it’s simply due to my desire to provide code that’s relevant to real programming problems. On the other hand, optimal code is an elusive thing indeed; by no means should you assume that the code in this book is ideal! Examine it, question it, and improve upon it, for an inquisitive, skeptical mind is an important part of the Zen of assembly optimization.</p>
<p>Back to the 8-bit bus cycle-eater. As I’ve said, in 8088 work you should strive to use byte-sized memory variables whenever possible. That does <em>not</em> mean that you should use 2 byte-sized memory accesses to manipulate a word-sized memory variable in preference to 1 word-sized memory access, as, for instance,</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">dl</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [MemVar]
<span class="kw">mov</span>  <span class="kw">dh</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [MemVar<span class="dv">+1</span>]</code></pre>
<p>versus:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">dx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [MemVar]</code></pre>
<p>Recall that every access to a memory byte takes at least 4 cycles; that limitation is built right into the 8088. The 8088 is also built so that the second byte-sized memory access to a 16-bit memory variable takes just those 4 cycles and no more. There’s no way you can manipulate the second byte of a word-sized memory variable faster with a second separate byte-sized instruction in less than 4 cycles. As a matter of fact, you’re bound to access that second byte much more slowly with a separate instruction, thanks to the overhead of instruction fetching and execution, address calculation, and the like.</p>
<p>For example, consider Listing 4.3, which performs 1,000 word-sized reads from memory. This code runs in 3.77 µs per word read on a 4.77 MHz 8088. That’s 45 percent faster than the 5.49 µs per word read of Listing 4.4, which reads the same 1,000 words as Listing 4.3 but does so with 2,000 byte-sized reads. Both listings perform exactly the same number of memory accesses—2,000 accesses, each byte-sized, as all 8088 memory accesses must be. (Remember that the Bus Interface Unit must perform two byte-sized memory accesses in order to handle a word-sized memory operand.) However, Listing 4.3 is considerably faster because it expends only 4 additional cycles to read the second byte of each word, while Listing 4.4 performs a second <code>LODSB</code>, requiring 13 cycles, to read the second byte of each word.</p>
<p><strong>LISTING 4.3 LST4-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Measures the performance of reading 1,000 words</span>
<span class="co">; from memory with 1,000 word-sized accesses.</span>
<span class="co">;</span>
     <span class="kw">sub</span>  <span class="kw">si</span>,<span class="kw">si</span>
     <span class="kw">mov</span>  <span class="kw">cx</span>,<span class="dv">1000</span>
     <span class="kw">call</span> ZTimerOn
     rep  <span class="kw">lodsw</span>
     <span class="kw">call</span> ZTimerOff</code></pre>
<p><strong>LISTING 4.4 LST4-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Measures the performance of reading 1000 words</span>
<span class="co">; from memory with 2,000 byte-sized accesses.</span>
<span class="co">;</span>
     <span class="kw">sub</span>  <span class="kw">si</span>,<span class="kw">si</span>
     <span class="kw">mov</span>  <span class="kw">cx</span>,<span class="dv">2000</span>
     <span class="kw">call</span> ZTimerOn
     rep  <span class="kw">lodsb</span>
     <span class="kw">call</span> ZTimerOff</code></pre>
<p>In short, if you must perform a 16-bit memory access, let the 8088 break the access into two byte-sized accesses for you. The 8088 is more efficient at that task than your code can possibly be.</p>
<p>Word-sized variables should be stored in registers to the greatest feasible extent, since registers are inside the 8088, where 16-bit operations are just as fast as 8-bit operations because the 8-bit cycle-eater can’t get at them. In fact, it’s a good idea to keep as many variables of all sorts in registers as you can. Instructions with register-only operands execute very rapidly, partially because they avoid both the time-consuming memory accesses and the lengthy address calculations associated with memory operands.</p>
<p>There is yet another reason why register operands are preferable to memory operands, and it’s an unexpected effect of the 8-bit bus cycle-eater. Instructions with only register operands tend to be shorter (in terms of bytes) than instructions with memory operands, and when it comes to performance, shorter is usually better. In order to explain why that is true and how it relates to the 8-bit bus cycle-eater, I must diverge for a moment.</p>
<p>For the last few pages, you may well have been thinking that the 8-bit bus cycle-eater, while a nuisance, doesn’t seem particularly subtle or difficult to quantify. After all, any instruction reference tells us exactly how many cycles each instruction loses to the 8-bit bus cycle-eater, doesn’t it?</p>
<p>Yes and no. It’s true that in general we know approximately how much longer a given instruction will take to execute with a word-sized memory operand than with a byte-sized operand, although the dynamic RAM refresh and wait state cycle-eaters (which I’ll cover a little later) can raise the cost of the 8-bit bus cycle-eater considerably. However, <em>all</em> word-sized memory accesses lose 4 cycles to the 8-bit bus cycle-eater, and there’s one sort of word-sized memory access we haven’t discussed yet: instruction fetching. The ugliest manifestation of the 8-bit bus cycle-eater is in fact the prefetch queue cycle-eater.</p>
</section>
</section>
<section id="the-prefetch-queue-cycle-eater" class="level3">
<h3><a href="#the-prefetch-queue-cycle-eater">The Prefetch Queue Cycle-Eater</a></h3>
<p>In an 8088 context, here’s the prefetch queue cycle-eater in a nutshell: The 8088’s 8-bit external data bus keeps the Bus Interface Unit from fetching instruction bytes as fast as the 16-bit Execution Unit can execute them, so the Execution Unit often lies idle while waiting for the next instruction byte to be fetched.</p>
<p>Exactly why does this happen? Recall that the 8088 is an 8086 internally, but accesses word-sized memory data at only one-half the maximum rate of the 8086 due to the 8088’s 8-bit external data bus. Unfortunately, instructions are among the word-sized data the 8086 fetches, meaning that the 8088 can fetch instructions at only one-half the speed of the 8086. On the other hand, the 8086-equivalent Execution Unit of the 8088 can <em>execute</em> instructions every bit as fast as the 8086. The net result is that the Execution Unit burns up instruction bytes much faster than the Bus Interface Unit can fetch them, and ends up idling while waiting for instructions bytes to arrive.</p>
<p>The BIU can fetch instruction bytes at a maximum rate of one byte every 4 cycles—<em>and that 4-cycle per instruction byte rate is the ultimate limit on overall instruction execution time, regardless of EU speed.</em> While the EU may execute a given instruction that’s already in the prefetch queue in less than 4 cycles per byte, over time the EU can’t execute instructions any faster than they can arrive—and they can’t arrive faster than 1 byte every 4 cycles.</p>
<p>Clearly, then, the prefetch queue cycle-eater is nothing more than one aspect of the 8-bit bus cycle-eater. 8088 code often runs at less than the Execution Unit’s maximum speed because the 8-bit data bus can’t keep up with the demand for instruction bytes. That’s straightforward enough—so why all the fuss about the prefetch queue cycle-eater?</p>
<p>What makes the prefetch queue cycle-eater tricky is that it’s undocumented and unpredictable. That is, with a word-sized memory access, such as</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  [<span class="kw">bx</span>],<span class="kw">ax</span></code></pre>
<p>it’s well-documented that an extra 4 cycles will always be required to write the upper byte of AX to memory. Not so with the prefetch queue cycle-eater lurking nearby. For instance, the instructions</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">shr</span>  <span class="kw">ax</span>,<span class="dv">1</span>
<span class="kw">shr</span>  <span class="kw">ax</span>,<span class="dv">1</span>
<span class="kw">shr</span>  <span class="kw">ax</span>,<span class="dv">1</span>
<span class="kw">shr</span>  <span class="kw">ax</span>,<span class="dv">1</span>
<span class="kw">shr</span>  <span class="kw">ax</span>,<span class="dv">1</span></code></pre>
<p>should execute in 10 cycles, since each <code>SHR</code> takes 2 cycles to execute, according to Intel’s specifications. Those specifications contain Intel’s official instruction execution times, but in this case—and in many others—the specifications are drastically wrong. Why? Because they describe execution time <em>once an instruction reaches the prefetch queue.</em> They say nothing about whether a given instruction will be in the prefetch queue when it’s time for that instruction to run, or how long it will take that instruction to reach the prefetch queue if it’s not there already. Thanks to the low performance of the 8088’s external data bus, that’s a glaring omission—but, alas, an unavoidable one. Let’s look at why the official execution times are wrong, and why that can’t be helped.</p>
<section id="official-execution-times-are-only-part-of-the-story" class="level4">
<h4><a href="#official-execution-times-are-only-part-of-the-story">Official Execution Times Are Only Part of the Story</a></h4>
<p>The sequence of 5 <code>SHR</code> instructions in the last example is 10 bytes long. That means that it can never execute in less than 24 cycles even if the 4-byte prefetch queue is full when it starts, since 6 instruction bytes would still remain to be fetched, at 4 cycles per fetch. If the prefetch queue is empty at the start, the sequence <em>could</em> take 40 cycles. In short, thanks to instruction fetching, the code won’t run at its documented speed, and could take up to four times longer than it is supposed to.</p>
<p>Why does Intel document Execution Unit execution time rather than overall instruction execution time, which includes both instruction fetch time and Execution Unit (EU) execution time? Well, instruction fetching isn’t performed as part of instruction execution by the Execution Unit, but instead is carried on in parallel by the Bus Interface Unit (BIU) whenever the external data bus isn’t in use or whenever the EU runs out of instruction bytes to execute. Sometimes the BIU is able to use spare bus cycles to prefetch instruction bytes before the EU needs them, so in those cases instruction fetching takes no time at all, practically speaking. At other times the EU executes instructions faster than the BIU can fetch them, and instruction fetching then becomes a significant part of overall execution time. As a result, <em>the effective fetch time for a given instruction varies greatly depending on the code mix preceding that instruction.</em> Similarly, the state in which a given instruction leaves the prefetch queue affects the overall execution time of the following instructions.</p>
<blockquote>
<p><img src="images/i.jpg" /> In other words, while the execution time for a given instruction is constant, the fetch time for that instruction depends heavily on the context in which the instruction is executing—the amount of prefetching the preceding instructions allowed—and can vary from a full 4 cycles per instruction byte to no time at all.</p>
</blockquote>
<p>As we’ll see later, other cycle-eaters, such as DRAM refresh and display memory wait states, can cause prefetching variations even during different executions of the same code sequence. Given that, it’s meaningless to talk about the prefetch time of a given instruction except in the context of a specific code sequence.</p>
<p>So now you know why the official instruction execution times are often wrong, and why Intel can’t provide better specifications. You also know now why it is that you must time your code if you want to know how fast it really is.</p>
</section>
<section id="there-is-no-such-beast-as-a-true-instruction-execution-time" class="level4">
<h4><a href="#there-is-no-such-beast-as-a-true-instruction-execution-time">There Is No Such Beast as a True Instruction Execution Time</a></h4>
<p>The effect of the code preceding an instruction on the execution time of that instruction makes the Zen timer trickier to use than you might expect, and complicates the interpretation of the results reported by the Zen timer. For one thing, the Zen timer is best used to time code sequences that are more than a few instructions long; below 10µs or so, prefetch queue effects and the limited resolution of the clock driving the timer can cause problems.</p>
<p>Some slight prefetch queue-induced inaccuracy usually exists even when the Zen timer is used to time longer code sequences, since the calls to the Zen timer usually alter the code’s prefetch queue from its normal state. (Branches—jumps, calls, returns and the like—empty the prefetch queue.) Ideally, the Zen timer is used to measure the performance of an entire subroutine, so the prefetch queue effects of the branches at the start and end of the subroutine are similar to the effects of the calls to the Zen timer when you’re measuring the subroutine’s performance.</p>
<p>Another way in which the prefetch queue cycle-eater complicates the use of the Zen timer involves the practice of timing the performance of a few instructions over and over. I’ll often repeat one or two instructions 100 or 1,000 times in a row in listings in this book in order to get timing intervals that are long enough to provide reliable measurements. However, as we just learned, the actual performance of any 8088 instruction depends on the code mix preceding any given use of that instruction, which in turn affects the state of the prefetch queue when the instruction starts executing. Alas, the execution time of an instruction preceded by dozens of identical instructions reflects just one of many possible prefetch states (and not a very likely state at that), and some of the other prefetch states may well produce distinctly different results.</p>
<p>For example, consider the code in Listings 4.5 and 4.6. Listing 4.5 shows our familiar <code>SHR</code> case. Here, because the prefetch queue is always empty, execution time should work out to about 4 cycles per byte, or 8 cycles per <code>SHR</code>, as shown in Figure 4.3. (Figure 4.3 illustrates the relationship between instruction fetching and execution in a simplified way, and is not intended to show the exact timings of 8088 operations.) That’s quite a contrast to the official 2-cycle execution time of <code>SHR</code>. In fact, the Zen timer reports that Listing 4.5 executes in 1.81µs per byte, or slightly <em>more</em> than 4 cycles per byte. (The extra time is the result of the dynamic RAM refresh cycle-eater, which we’ll discuss shortly.) Going by Listing 4.5, we would conclude that the “true” execution time of <code>SHR</code> is 8.64 cycles.</p>
<p><strong>LISTING 4.5 LST4-5.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Measures the performance of 1,000 SHR instructions</span>
<span class="co">; in a row. Since SHR executes in 2 cycles but is</span>
<span class="co">; 2 bytes long, the prefetch queue is always empty,</span>
<span class="co">; and prefetching time determines the overall</span>
<span class="co">; performance of the code.</span>
<span class="co">;</span>
      <span class="kw">call</span>  ZTimerOn
      rept  <span class="dv">1000</span>
      <span class="kw">shr</span>   <span class="kw">ax</span>,<span class="dv">1</span>
      endm
      <span class="kw">call</span>  ZTimerOff</code></pre>
<p><strong>LISTING 4.6 LST4-6.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Measures the performance of 1,000 MUL/SHR instruction</span>
<span class="co">; pairs in a row. The lengthy execution time of MUL</span>
<span class="co">; should keep the prefetch queue from ever emptying.</span>
<span class="co">;</span>
      <span class="kw">mov</span>   <span class="kw">cx</span>,<span class="dv">1000</span>
      <span class="kw">sub</span>   <span class="kw">ax</span>,<span class="kw">ax</span>
      <span class="kw">call</span>  ZTimerOn
      rept  <span class="dv">1000</span>
      <span class="kw">mul</span>   <span class="kw">ax</span>
      <span class="kw">shr</span>   <span class="kw">ax</span>,<span class="dv">1</span>
      endm
      <span class="kw">call</span>  ZTimerOff</code></pre>
<figure>
<img src="images/04-03.jpg" alt="Figure 4.3  Execution and instruction prefetching sequence for Listing 4.5." /><figcaption><strong>Figure 4.3</strong>  <em>Execution and instruction prefetching sequence for Listing 4.5.</em></figcaption>
</figure>
<p>Now let’s examine Listing 4.6. Here each <code>SHR</code> follows a <code>MUL</code> instruction. Since <code>MUL</code> instructions take so long to execute that the prefetch queue is always full when they finish, each <code>SHR</code> should be ready and waiting in the prefetch queue when the preceding <code>MUL</code> ends. As a result, we’d expect that each <code>SHR</code> would execute in 2 cycles; together with the 118-cycle execution time of multiplying 0 times 0, the total execution time should come to 120 cycles per <code>SHR/MUL</code> pair, as shown in Figure 4.4. And, by God, when we run Listing 4.6 we get an execution time of 25.14 µs per <code>SHR/MUL</code> pair, or <em>exactly</em> 120 cycles! According to these results, the “true” execution time of <code>SHR</code> would seem to be 2 cycles, quite a change from the conclusion we drew from Listing 4.5.</p>
<p>The key point is this: We’ve seen one code sequence in which <code>SHR</code> took 8-plus cycles to execute, and another in which it took only 2 cycles. Are we talking about two different forms of <code>SHR</code> here? Of course not—the difference is purely a reflection of the differing states in which the preceding code left the prefetch queue. In Listing 4.5, each <code>SHR</code> after the first few follows a slew of other <code>SHR</code> instructions which have sucked the prefetch queue dry, so overall performance reflects instruction fetch time. By contrast, each <code>SHR</code> in Listing 4.6 follows a <code>MUL</code> instruction which leaves the prefetch queue full, so overall performance reflects Execution Unit execution time.</p>
<p>Clearly, either instruction fetch time <em>or</em> Execution Unit execution time—or even a mix of the two, if an instruction is partially prefetched—can determine code performance. Some people operate under a rule of thumb by which they assume that the execution time of each instruction is 4 cycles times the number of bytes in the instruction. While that’s often true for register-only code, it frequently doesn’t hold for code that accesses memory. For one thing, the rule should be 4 cycles times the number of <em>memory accesses,</em> not instruction bytes, since all accesses take 4 cycles on the 8088-based PC. For another, memory-accessing instructions often have slower Execution Unit execution times than the 4 cycles per memory access rule would dictate, because the 8088 isn’t very fast at calculating memory addresses. Also, the 4 cycles per instruction byte rule isn’t true for register-only instructions that are already in the prefetch queue when the preceding instruction ends.</p>
<p>The truth is that it never hurts performance to reduce either the cycle count or the byte count of a given bit of code, but there’s no guarantee that one or the other will improve performance either. For example, consider Listing 4.7, which consists of a series of 4-cycle, 2-byte <code>MOV AL,0</code> instructions, and which executes at the rate of 1.81 µs per instruction. Now consider Listing 4.8, which replaces the 4-cycle <code>MOV AL,0</code> with the 3-cycle (but still 2-byte) <code>SUB AL,AL,</code> Despite its 1-cycle-per-instruction advantage, Listing 4.8 runs at exactly the same speed as Listing 4.7. The reason: Both instructions are 2 bytes long, and in both cases it is the 8-cycle instruction fetch time, not the 3 or 4-cycle Execution Unit execution time, that limits performance.</p>
<figure>
<img src="images/04-04.jpg" alt="Figure 4.4  Execution and instruction prefetching sequence for Listing 4.6." /><figcaption><strong>Figure 4.4</strong>  <em>Execution and instruction prefetching sequence for Listing 4.6.</em></figcaption>
</figure>
<p><strong>LISTING 4.7 LST4-7.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Measures the performance of repeated MOV AL,0 instructions,</span>
<span class="co">; which take 4 cycles each according to Intel&#39;s official</span>
<span class="co">; specifications.</span>
<span class="co">;</span>
     <span class="kw">sub</span>  <span class="kw">ax</span>,<span class="kw">ax</span>
     <span class="kw">call</span> ZTimerOn
     rept <span class="dv">1000</span>
     <span class="kw">mov</span>  <span class="kw">al</span>,<span class="dv">0</span>
     endm
     <span class="kw">call</span> ZTimerOff</code></pre>
<p><strong>LISTING 4.8 LST4-8.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Measures the performance of repeated SUB AL,AL instructions,</span>
<span class="co">; which take 3 cycles each according to Intel&#39;s official</span>
<span class="co">; specifications.</span>
<span class="co">;</span>
     <span class="kw">sub</span>  <span class="kw">ax</span>,<span class="kw">ax</span>
     <span class="kw">call</span> ZTimerOn
     rept <span class="dv">1000</span>
     <span class="kw">sub</span>  <span class="kw">al</span>,<span class="kw">al</span>
     endm
     <span class="kw">call</span> ZTimerOff</code></pre>
<p>As you can see, it’s easy to be drawn into thinking you’re saving cycles when you’re not. You can only improve the performance of a specific bit of code by reducing the factor—either instruction fetch time or execution time, or sometimes a mix of the two—that’s limiting the performance of that code.</p>
<p>In case you missed it in all the excitement, the variability of prefetching means that our method of testing performance by executing 1,000 instructions in a row by no means produces “true” instruction execution times, any more than the official execution times in the Intel manuals are “true” times. The fact of the matter is that a given instruction takes <em>at least</em> as long to execute as the time given for it in the Intel manuals, but may take as much as 4 cycles per byte longer, depending on the state of the prefetch queue when the preceding instruction ends.</p>
<blockquote>
<p><img src="images/i.jpg" /> The only true execution time for an instruction is a time measured in a certain context, and that time is meaningful only in that context.</p>
</blockquote>
<p>What we <em>really</em> want is to know how long useful working code takes to run, not how long a single instruction takes, and the Zen timer gives us the tool we need to gather that information. Granted, it would be easier if we could just add up neatly documented instruction execution times—but that’s not going to happen. Without actually measuring the performance of a given code sequence, you simply don’t know how fast it is. For crying out loud, even the people who <em>designed</em> the 8088 at Intel couldn’t tell you exactly how quickly a given 8088 code sequence executes on the PC just by looking at it! Get used to the idea that execution times are only meaningful in context, learn the rules of thumb in this book, and use the Zen timer to measure your code.</p>
</section>
<section id="approximating-overall-execution-times" class="level4">
<h4><a href="#approximating-overall-execution-times">Approximating Overall Execution Times</a></h4>
<p>Don’t think that because overall instruction execution time is determined by both instruction fetch time and Execution Unit execution time, the two times should be added together when estimating performance. For example, practically speaking, each <code>SHR</code> in Listing 4.5 does not take 8 cycles of instruction fetch time plus 2 cycles of Execution Unit execution time to execute. Figure 4.3 shows that while a given <code>SHR</code> is executing, the fetch of the next <code>SHR</code> is starting, and since the two operations are overlapped for 2 cycles, there’s no sense in charging the time to both instructions. You could think of the extra instruction fetch time for <code>SHR</code> in Listing 4.5 as being 6 cycles, which yields an overall execution time of 8 cycles when added to the 2 cycles of Execution Unit execution time.</p>
<p>Alternatively, you could think of each <code>SHR</code> in Listing 4.5 as taking 8 cycles to fetch, and then executing in effectively 0 cycles while the next <code>SHR</code> is being fetched. Whichever perspective you prefer is fine. The important point is that the time during which the execution of one instruction and the fetching of the next instruction overlap should only be counted toward the overall execution time of one of the instructions. For all intents and purposes, one of the two instructions runs at no performance cost whatsoever while the overlap exists.</p>
<p>As a working definition, we’ll consider the execution time of a given instruction in a particular context to start when the first byte of the instruction is sent to the Execution Unit and end when the first byte of the next instruction is sent to the EU.</p>
</section>
<section id="what-to-do-about-the-prefetch-queue-cycle-eater" class="level4">
<h4><a href="#what-to-do-about-the-prefetch-queue-cycle-eater">What to Do about the Prefetch Queue Cycle-Eater?</a></h4>
<p>Reducing the impact of the prefetch queue cycle-eater is one of the overriding principles of high-performance assembly code. How can you do this? One effective technique is to minimize access to memory operands, since such accesses compete with instruction fetching for precious memory accesses. You can also greatly reduce instruction fetch time simply by your choice of instructions: <em>Keep your instructions short.</em> Less time is required to fetch instructions that are 1 or 2 bytes long than instructions that are 5 or 6 bytes long. Reduced instruction fetching lowers minimum execution time (minimum execution time is 4 cycles times the number of instruction bytes) and often leads to faster overall execution.</p>
<p>While short instructions minimize overall prefetch time, ironically they actually often suffer more from the prefetch queue bottleneck than do long instructions. Short instructions generally have such fast execution times that they drain the prefetch queue despite their small size. For example, consider the <code>SHR</code> of Listing 4.5, which runs at only 25 percent of its Execution Unit execution time even though it’s only 2 bytes long, thanks to the prefetch queue bottleneck. Short instructions are nonetheless generally faster than long instructions, thanks to the combination of fewer instruction bytes and faster Execution Unit execution times, and should be used as much as possible—just don’t expect them to run at their “official” documented speeds.</p>
<p>More than anything, the above rules mean using the registers as heavily as possible, both because register-only instructions are short and because they don’t perform memory accesses to read or write operands. However, using the registers is a rule of thumb, not a commandment. In some circumstances, it may actually be <em>faster</em> to access memory. (The look-up table technique is one such case.) What’s more, the performance of the prefetch queue (and hence the performance of each instruction) differs from one code sequence to the next, and can even differ during different executions of the <em>same</em> code sequence.</p>
<p>All in all, writing good assembler code is as much an art as a science. As a result, you should follow the rules of thumb described here—and then time your code to see how fast it really is. You should experiment freely, but always remember that actual, measured performance is the bottom line.</p>
</section>
<section id="holding-up-the-8088" class="level4">
<h4><a href="#holding-up-the-8088">Holding Up the 8088</a></h4>
<p>In this chapter I’ve taken you further and further into the depths of the PC, telling you again and again that you must understand the computer at the lowest possible level in order to write good code. At this point, you may well wonder, “Have we gotten low enough?”</p>
<p>Not quite yet. The 8-bit bus and prefetch queue cycle-eaters are low-level indeed, but we’ve one level yet to go. Dynamic RAM refresh and wait states—our next topics—together form the lowest level at which the hardware of the PC affects code performance. Below this level, the PC is of interest only to hardware engineers.</p>
<p>Before we begin our discussion of dynamic RAM refresh, let’s step back for a moment to take an overall look at this lowest level of cycle-eaters. In truth, the distinctions between wait states and dynamic RAM refresh don’t much matter to a programmer. What is important is that you understand this: <em>Under certain circumstances, devices on the PC bus can stop the CPU for 1 or more cycles, making your code run more slowly than it seemingly should.</em></p>
<p>Unlike all the cycle-eaters we’ve encountered so far, wait states and dynamic RAM refresh are strictly external to the CPU, as was shown in Figure 4.1. Adapters on the PC’s bus, such as video and memory cards, can insert wait states on any bus access, the idea being that they won’t be able to complete the access properly unless the access is stretched out. Likewise, the channel of the DMA controller dedicated to dynamic RAM refresh can request control of the bus at any time, although the CPU must relinquish the bus before the DMA controller can take over. This means that your code can’t directly control wait states or dynamic RAM refresh. However, code <em>can</em> sometimes be designed to minimize the effects of these cycle-eaters, and even when the cycle-eaters slow your code without there being a thing in the world you can do about it, you’re still better off understanding that you’re losing performance and knowing why your code doesn’t run as fast as it’s supposed to than you were programming in ignorance.</p>
<p>Let’s start with DRAM refresh, which affects the performance of every program that runs on the PC.</p>
</section>
</section>
<section id="dynamic-ram-refresh-the-invisible-hand" class="level3">
<h3><a href="#dynamic-ram-refresh-the-invisible-hand">Dynamic RAM Refresh: The Invisible Hand</a></h3>
<p>Dynamic RAM (DRAM) refresh is sort of an act of God. By that I mean that DRAM refresh invisibly and inexorably steals a certain fraction of all available memory access time from your programs, when they are accessing memory for code and data. (When they are accessing cache on more recent processors, theoretically the DRAM refresh cycle-eater doesn’t come into play, but there are other cycle-eaters waiting to prey on cache-bound programs.) While you <em>could</em> stop DRAM refresh, you wouldn’t want to since that would be a sure prescription for crashing your computer. In the end, thanks to DRAM refresh, almost all code runs a bit slower on the PC than it otherwise would, and that’s that.</p>
<p>A bit of background: A static RAM (SRAM) chip is a memory chip that retains its contents indefinitely so long as power is maintained. By contrast, each of several blocks of bits in a dynamic RAM (DRAM) chip retains its contents for only a short time after it’s accessed for a read or write. In order to get a DRAM chip to store data for an extended period, each of the blocks of bits in that chip must be accessed regularly, so that the chip’s stored data is kept refreshed and valid. So long as this is done often enough, a DRAM chip will retain its contents indefinitely.</p>
<p>All of the PC’s system memory consists of DRAM chips. Each DRAM chip in the PC must be completely refreshed about once every four milliseconds in order to ensure the integrity of the data it stores. Obviously, it’s highly desirable that the memory in the PC retain the correct data indefinitely, so each DRAM chip in the PC <em>must</em> always be refreshed within 4 µs of the last refresh. Since there’s no guarantee that a given program will access each and every DRAM block once every 4 µs, the PC contains special circuitry and programming for providing DRAM refresh.</p>
<section id="how-dram-refresh-works-in-the-pc" class="level4">
<h4><a href="#how-dram-refresh-works-in-the-pc">How DRAM Refresh Works in the PC</a></h4>
<p>On the original 8088-based IBM PC, timer 1 of the 8253 timer chip is programmed at power-up to generate a signal once every 72 cycles, or once every 15.08µs. That signal goes to channel 0 of the 8237 DMA controller, which requests the bus from the 8088 upon receiving the signal. (DMA stands for <em>direct memory access,</em> the ability of a device other than the 8088 to control the bus and access memory directly, without any help from the 8088.) As soon as the 8088 is between memory accesses, it gives control of the bus to the 8237, which in conjunction with special circuitry on the PC’s motherboard then performs a single 4-cycle read access to 1 of 256 possible addresses, advancing to the next address on each successive access. (The read access is only for the purpose of refreshing the DRAM; the data that is read isn’t used.)</p>
<p>The 256 addresses accessed by the refresh DMA accesses are arranged so that taken together they properly refresh all the memory in the PC. By accessing one of the 256 addresses every 15.08 µs, all of the PC’s DRAM is refreshed in 256 x 15.08 µs, or 3.86 µs, which is just about the desired 4 µs time I mentioned earlier. (Only the first 640K of memory is refreshed in the PC; video adapters and other adapters above 640K containing memory that requires refreshing must provide their own DRAM refresh in pre-AT systems.)</p>
<p>Don’t sweat the details here. The important point is this: For at least 4 out of every 72 cycles, the original PC’s bus is given over to DRAM refresh and is not available to the 8088, as shown in Figure 4.5. That means that as much as 5.56 percent of the PC’s already inadequate bus capacity is lost. However, DRAM refresh doesn’t necessarily stop the 8088 in its tracks for 4 cycles. The Execution Unit of the 8088 can keep processing while DRAM refresh is occurring, unless the EU needs to access memory. Consequently, DRAM refresh can slow code performance anywhere from 0 percent to 5.56 percent (and actually a bit more, as we’ll see shortly), depending on the extent to which DRAM refresh occupies cycles during which the 8088 would otherwise be accessing memory.</p>
<figure>
<img src="images/04-05.jpg" alt="Figure 4.5  The PC bus dynamic RAM (DRAM) refresh." /><figcaption><strong>Figure 4.5</strong>  <em>The PC bus dynamic RAM (DRAM) refresh.</em></figcaption>
</figure>
</section>
<section id="the-impact-of-dram-refresh" class="level4">
<h4><a href="#the-impact-of-dram-refresh">The Impact of DRAM Refresh</a></h4>
<p>Let’s look at examples from opposite ends of the spectrum in terms of the impact of DRAM refresh on code performance. First, consider the series of <code>MUL</code> instructions in Listing 4.9. Since a 16-bit <code>MUL</code> on the 8088 executes in between 118 and 133 cycles and is only 2 bytes long, there should be plenty of time for the prefetch queue to fill after each instruction, even after DRAM refresh has taken its slice of memory access time. Consequently, the prefetch queue should be able to keep the Execution Unit well-supplied with instruction bytes at all times. Since Listing 4.9 uses no memory operands, the Execution Unit should never have to wait for data from memory, and DRAM refresh should have no impact on performance. (Remember that the Execution Unit can operate normally during DRAM refreshes so long as it doesn’t need to request a memory access from the Bus Interface Unit.)</p>
<p><strong>LISTING 4.9 LST4-9.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Measures the performance of repeated MUL instructions,</span>
<span class="co">; which allow the prefetch queue to be full at all times,</span>
<span class="co">; to demonstrate a case in which DRAM refresh has no impact</span>
<span class="co">; on code performance.</span>
<span class="co">;</span>
     <span class="kw">sub</span>  <span class="kw">ax</span>,<span class="kw">ax</span>
     <span class="kw">call</span> ZTimerOn
     rept <span class="dv">1000</span>
     <span class="kw">mul</span>  <span class="kw">ax</span>
     endm
     <span class="kw">call</span> ZTimerOff</code></pre>
<p>Running Listing 4.9, we find that each <code>MUL</code> executes in 24.72 µs, or exactly 118 cycles. Since that’s the shortest time in which <code>MUL</code> can execute, we can see that no performance is lost to DRAM refresh. Listing 4.9 clearly illustrates that DRAM refresh only affects code performance when a DRAM refresh forces the Execution Unit of the 8088 to wait for a memory access.</p>
<p>Now let’s look at the series of <code>SHR</code> instructions shown in Listing 4.10. Since <code>SHR</code> executes in 2 cycles but is 2 bytes long, the prefetch queue should be empty while Listing 4.10 executes, with the 8088 prefetching instruction bytes non-stop. As a result, the time per instruction of Listing 4.10 should precisely reflect the time required to fetch the instruction bytes.</p>
<p><strong>LISTING 4.10 LST4-10.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Measures the performance of repeated SHR instructions,</span>
<span class="co">; which empty the prefetch queue, to demonstrate the</span>
<span class="co">; worst-case impact of DRAM refresh on code performance.</span>
<span class="co">;</span>
     <span class="kw">call</span> ZTimerOn
     rept <span class="dv">1000</span>
     <span class="kw">shr</span>  <span class="kw">ax</span>,<span class="dv">1</span>
     endm
     <span class="kw">call</span> ZTimerOff</code></pre>
<p>Since 4 cycles are required to read each instruction byte, we’d expect each <code>SHR</code> to execute in 8 cycles, or 1.676 µs, if there were no DRAM refresh. In fact, each <code>SHR</code> in Listing 4.10 executes in 1.81 µs, indicating that DRAM refresh is taking 7.4 percent of the program’s execution time. That’s nearly 2 percent more than our worst-case estimate of the loss to DRAM refresh overhead! In fact, the result indicates that DRAM refresh is stealing not 4, but 5.33 cycles out of every 72 cycles. How can this be?</p>
<p>The answer is that a given DRAM refresh can actually hold up CPU memory accesses for as many as 6 cycles, depending on the timing of the DRAM refresh’s DMA request relative to the 8088’s internal instruction execution state. When the code in Listing 4.10 runs, each DRAM refresh holds up the CPU for either 5 or 6 cycles, depending on where the 8088 is in executing the current <code>SHR</code> instruction when the refresh request occurs. Now we see that things can get even worse than we thought: <em>DRAM refresh can steal as much as 8.33 percent of available memory access time—6 out of every 72 cycles—from the 8088.</em></p>
<p>Which of the two cases we’ve examined reflects reality? While either case <em>can</em> happen, the latter case—significant performance reduction, ranging as high as 8.33 percent—is far more likely to occur. This is especially true for high-performance assembly code, which uses fast instructions that tend to cause non-stop instruction fetching.</p>
</section>
<section id="what-to-do-about-the-dram-refresh-cycle-eater" class="level4">
<h4><a href="#what-to-do-about-the-dram-refresh-cycle-eater">What to Do About the DRAM Refresh Cycle-Eater?</a></h4>
<p><em>Hmmm.</em> When we discovered the prefetch queue cycle-eater, we learned to use short instructions. When we discovered the 8-bit bus cycle-eater, we learned to use byte-sized memory operands whenever possible, and to keep word-sized variables in registers. What can we do to work around the DRAM refresh cycle-eater?</p>
<p>Nothing.</p>
<p>As I’ve said before, DRAM refresh is an act of God. DRAM refresh is a fundamental, unchanging part of the PC’s operation, and there’s nothing you or I can do about it. If refresh were any less frequent, the reliability of the PC would be compromised, so tinkering with either timer 1 or DMA channel 0 to reduce DRAM refresh overhead is out. Nor is there any way to structure code to minimize the impact of DRAM refresh. Sure, some instructions are affected less by DRAM refresh than others, but how many multiplies and divides in a row can you really use? I suppose that code <em>could</em> conceivably be structured to leave a free memory access every 72 cycles, so DRAM refresh wouldn’t have any effect. In the old days when code size was measured in bytes, not K bytes, and processors were less powerful—and complex—programmers did in fact use similar tricks to eke every last bit of performance from their code. When programming the PC, however, the prefetch queue cycle-eater would make such careful code synchronization a difficult task indeed, and any modest performance improvement that did result could never justify the increase in programming complexity and the limits on creative programming that such an approach would entail. Besides, all that effort goes to waste on faster 8088s, 286s, and other computers with different execution speeds and refresh characteristics. There’s no way around it: Useful code accesses memory frequently and at irregular intervals, and over the long haul DRAM refresh always exacts its price.</p>
<p>If you’re still harboring thoughts of reducing the overhead of DRAM refresh, consider this. Instructions that tend not to suffer very much from DRAM refresh are those that have a high ratio of execution time to instruction fetch time, and those aren’t the fastest instructions of the PC. It certainly wouldn’t make sense to use slower instructions just to reduce DRAM refresh overhead, for it’s <em>total</em> execution time—DRAM refresh, instruction fetching, and all—that matters.</p>
<p>The important thing to understand about DRAM refresh is that it generally slows your code down, and that the extent of that performance reduction can vary considerably and unpredictably, depending on how the DRAM refreshes interact with your code’s pattern of memory accesses. When you use the Zen timer and get a fractional cycle count for the execution time of an instruction, that’s often the DRAM refresh cycle-eater at work. (The display adapter cycleis another possible culprit, and, on 386s and later processors, cache misses and pipeline execution hazards produce this sort of effect as well.) Whenever you get two timing results that differ less or more than they seemingly should, that’s usually DRAM refresh too. Thanks to DRAM refresh, variations of up to 8.33 percent in PC code performance are par for the course.</p>
</section>
</section>
<section id="wait-states" class="level3">
<h3><a href="#wait-states">Wait States</a></h3>
<p>Wait states are cycles during which a bus access by the CPU to a device on the PC’s bus is temporarily halted by that device while the device gets ready to complete the read or write. Wait states are well and truly the lowest level of code performance. Everything we have discussed (and will discuss)—even DMA accesses—can be affected by wait states.</p>
<p>Wait states exist because the CPU must to be able to coexist with any adapter, no matter how slow (within reason). The 8088 expects to be able to complete each bus access—a memory or I/O read or write—in 4 cycles, but adapters can’t always respond that quickly for a number of reasons. For example, display adapters must split access to display memory between the CPU and the circuitry that generates the video signal based on the contents of display memory, so they often can’t immediately fulfill a request by the CPU for a display memory read or write. To resolve this conflict, display adapters can tell the CPU to wait during bus accesses by inserting one or more wait states, as shown in Figure 4.6. The CPU simply sits and idles as long as wait states are inserted, then completes the access as soon as the display adapter indicates its readiness by no longer inserting wait states. The same would be true of any adapter that couldn’t keep up with the CPU.</p>
<p>Mind you, this is all transparent to executing code. An instruction that encounters wait states runs exactly as if there were no wait states, only slower. Wait states are nothing more or less than wasted time as far as the CPU and your program are concerned.</p>
<p>By understanding the circumstances in which wait states can occur, you can avoid them when possible. Even when it’s not possible to work around wait states, it’s still to your advantage to understand how they can cause your code to run more slowly.</p>
<p>First, let’s learn a bit more about wait states by contrast with DRAM refresh. Unlike DRAM refresh, wait states do not occur on any regularly scheduled basis, and are of no particular duration. Wait states can only occur when an instruction performs a memory or I/O read or write. Both the presence of wait states and the number of wait states inserted on any given bus access are entirely controlled by the device being accessed. When it comes to wait states, the CPU is passive, merely accepting whatever wait states the accessed device chooses to insert during the course of the access. All of this makes perfect sense given that the whole point of the wait state mechanism is to allow a device to stretch out any access to itself for however much time it needs to perform the access.</p>
<figure>
<img src="images/04-06.jpg" alt="Figure 4.6  Video wait states inserted by the display adapter." /><figcaption><strong>Figure 4.6</strong>  <em>Video wait states inserted by the display adapter.</em></figcaption>
</figure>
<p>As with DRAM refresh, wait states don’t stop the 8088 completely. The Execution Unit can continue processing while wait states are inserted, so long as the EU doesn’t need to perform a bus access. However, in the PC, wait states most often occur when an instruction accesses a memory operand, so in fact the Execution Unit usually is stopped by wait states. (Instruction fetches rarely wait in an 8088-based PC because system memory is zero-wait-state. AT-class memory systems routinely insert 1 or more wait states, however.)</p>
<p>As it turns out, wait states pose a serious problem in just one area in the PC. While any adapter <em>can</em> insert wait states, in the PC only display adapters do so to the extent that performance is seriously affected.</p>
</section>
<section id="the-display-adapter-cycle-eater" class="level3">
<h3><a href="#the-display-adapter-cycle-eater">The Display Adapter Cycle-Eater</a></h3>
<p>Display adapters must serve two masters, and that creates a fundamental performance problem. Master #1 is the circuitry that drives the display screen. This circuitry must constantly read display memory in order to obtain the information used to draw the characters or dots displayed on the screen. Since the screen must be redrawn between 50 and 70 times per second, and since each redraw of the screen can require as many as 36,000 reads of display memory (more in Super VGA modes), master #1 is a demanding master indeed. No matter how demanding master #1 gets, however, its needs must <em>always</em> be met—otherwise the quality of the picture on the screen would suffer.</p>
<p>Master #2 is the CPU, which reads from and writes to display memory in order to manipulate the bytes that the video circuitry reads to form the picture on the screen. Master #2 is less important than master #1, since the CPU affects display quality only indirectly. In other words, if the video circuitry has to wait for display memory accesses, the picture will develop holes, snow, and the like, but if the CPU has to wait for display memory accesses, the program will just run a bit slower—no big deal.</p>
<p>It matters a great deal which master is more important, for while both the CPU and the video circuitry must gain access to display memory, only one of the two masters can read or write display memory at any one time. Potential conflicts are resolved by flat-out guaranteeing the video circuitry however many accesses to display memory it needs, with the CPU waiting for whatever display memory accesses are left over.</p>
<p>It turns out that the 8088 CPU has to do a lot of waiting, for three reasons. First, the video circuitry can take as much as about 90 percent of the available display memory access time, as shown in Figure 4.7, leaving as little as about 10 percent of all display memory accesses for the 8088. (These percentages vary considerably among the many EGA and VGA clones.)</p>
<figure>
<img src="images/04-07.jpg" alt="Figure 4.7  Allocation of display memory access." /><figcaption><strong>Figure 4.7</strong>  <em>Allocation of display memory access.</em></figcaption>
</figure>
<p>Second, because the displayed dots (or <em>pixels,</em> short for “picture elements”) must be drawn on the screen at a constant speed, many display adapters provide memory accesses only at fixed intervals. As a result, time can be lost while the 8088 synchronizes with the start of the next display adapter memory access, even if the video circuitry isn’t accessing display memory at that time, as shown in Figure 4.8.</p>
<p>Finally, the time it takes a display adapter to complete a memory access is related to the speed of the clock which generates pixels on the screen rather than to the memory access speed of the 8088. Consequently, the time taken for display memory to complete an 8088 read or write access is often longer than the time taken for system memory to complete an access, even if the 8088 lucks into hitting a free display memory access just as it becomes available, again as shown in Figure 4.8. Any or all of the three factors I’ve described can result in wait states, slowing the 8088 and creating the display adapter cycle.</p>
<figure>
<img src="images/04-08.jpg" alt="Figure 4.8  Display memory access slots." /><figcaption><strong>Figure 4.8</strong>  <em>Display memory access slots.</em></figcaption>
</figure>
<p>If some of this is Greek to you, don’t worry. The important point is that display memory is not very fast compared to normal system memory. How slow is it? <em>Incredibly</em> slow. Remember how slow IBM’s ill-fated PC<em>jr</em>was? In case you’ve forgotten, I’ll refresh your memory: The PC<em>jr</em>was at best only half as fast as the PC. The PC<em>jr</em> had an 8088 running at 4.77 MHz, just like the PC—why do you suppose it was so much slower? I’ll tell you why: <em>All the memory in the PCjr was display memory.</em></p>
<p>Enough said. All the memory in the PC is <em>not</em> display memory, however, and unless you’re thickheaded enough to put code in display memory, the PC isn’t going to run as slowly as a PC<em>jr.</em> (Putting code or other non-video data in unused areas of display memory sounds like a neat idea—until you consider the effect on instruction prefetching of cutting the 8088’s already-poor memory access performance in half. Running your code from display memory is sort of like running on a hypothetical 8084—an 8086 with a <em>4-bit</em> bus. Not recommended!) Given that your code and data reside in normal system memory below the 640K mark, how great an impact does the display adapter cycle-eater have on performance?</p>
<p>The answer varies considerably depending on what display adapter and what display mode we’re talking about. The display adapter cycle-eater is worst with the Enhanced Graphics Adapter (EGA) and the original Video Graphics Array (VGA). (Many VGAs, especially newer ones, insert many fewer wait states than IBM’s original VGA. On the other hand, Super VGAs have more bytes of display memory to be accessed in high-resolution mode.) While the Color/Graphics Adapter (CGA), Monochrome Display Adapter (MDA), and Hercules Graphics Card (HGC) all suffer from the display adapter cycle-eater as well, they suffer to a lesser degree. Since the VGA represents the base standard for PC graphics now and for the foreseeable future, and since it is the hardest graphics adapter to wring performance from, we’ll restrict our discussion to the VGA (and its close relative, the EGA) for the remainder of this chapter.</p>
<section id="the-impact-of-the-display-adapter-cycle-eater" class="level4">
<h4><a href="#the-impact-of-the-display-adapter-cycle-eater">The Impact of the Display Adapter Cycle-Eater</a></h4>
<p>Even on the EGA and VGA, the effect of the display adapter cycle-eater depends on the display mode selected. In text mode, the display adapter cycle-eater is rarely a major factor. It’s not that the cycle-eater isn’t present; however, a mere 4,000 bytes control the entire text mode display, and even with the display adapter cycle-eater it just doesn’t take that long to manipulate 4,000 bytes. Even if the display adapter cycle-eater were to cause the 8088 to take as much as 5µs per display memory access—more than five times normal—it would still take only 4,000x 2x 5µs, or 40 µs, to read and write every byte of display memory. That’s a lot of time as measured in 8088 cycles, but it’s less than the blink of an eye in human time, and video performance only matters in human time. After all, the whole point of drawing graphics is to convey visual information, and if that information can be presented faster than the eye can see, that is by definition fast enough.</p>
<p>That’s not to say that the display adapter cycle-eater <em>can’t</em> matter in text mode. In Chapter 3, I recounted the story of a debate among letter-writers to a magazine about exactly how quickly characters could be written to display memory without causing snow. The writers carefully added up Intel’s instruction cycle times to see how many writes to display memory they could squeeze into a single horizontal retrace interval. (On a CGA, it’s only during the short horizontal retrace interval and the longer vertical retrace interval that display memory can be accessed in 80-column text mode without causing snow.) Of course, now we know that their cardinal sin was to ignore the prefetch queue; even if there were no wait states, their calculations would have been overly optimistic. There <em>are</em> display memory wait states as well, however, so the calculations were not just optimistic but wildly optimistic.</p>
<p>Text mode situations such as the above notwithstanding, where the display adapter cycle-eater really kicks in is in graphics mode, and most especially in the high-resolution graphics modes of the EGA and VGA. The problem here is not that there are necessarily more wait states per access in highgraphics modes (that varies from adapter to adapter and mode to mode). Rather, the problem is simply that are many more bytes of display memory per screen in these modes than in lower-resolution graphics modes and in text modes, so many more display memory accesses—each incurring its share of display memory wait states—are required in order to draw an image of a given size. When accessing the many thousands of bytes used in the high-resolution graphics modes, the cumulative effects of display memory wait states can seriously impact code performance, even as measured in human time.</p>
<p>For example, if we assume the same 5 µs per display memory access for the EGA’s high-resolution graphics mode that we assumed for text mode, it would take 26,000 x 2 x 5 µs, or 260 µs, to scroll the screen once in the EGA’s high-resolution graphics mode, mode 10H. That’s more than one-quarter of a second—noticeable by human standards, an eternity by computer standards.</p>
<p>That sounds pretty serious, but we did make an unfounded assumption about memory access speed. Let’s get some hard numbers. Listing 4.11 accesses display memory at the 8088’s maximum speed, by way of a <code>REP MOVSW</code> with display memory as both source and destination. The code in Listing 4.11 executes in 3.18 µs per access to display memory—not as long as we had assumed, but a long time nonetheless.</p>
<p><strong>LISTING 4.11 LST4-11.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Times speed of memory access to Enhanced Graphics</span>
<span class="co">; Adapter graphics mode display memory at A000:0000.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">ax</span><span class="bn">,0010h</span>
     <span class="kw">int</span>  10h<span class="co">;        select hi-res EGA graphics</span>
                      <span class="co">; mode 10 hex (AH=0 selects</span>
                      <span class="co">; BIOS set mode function,</span>
                      <span class="co">; with AL=mode to select)</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">ax</span><span class="bn">,0a000h</span>
     <span class="kw">mov</span>  <span class="kw">ds</span>,<span class="kw">ax</span>
     <span class="kw">mov</span>  <span class="kw">es</span>,<span class="kw">ax</span>       <span class="co">;move to &amp; from same segment</span>
     <span class="kw">sub</span>  <span class="kw">si</span>,<span class="kw">si</span>       <span class="co">;move to &amp; from same offset</span>
     <span class="kw">mov</span>  <span class="kw">di</span>,<span class="kw">si</span>
     <span class="kw">mov</span>  <span class="kw">cx</span><span class="bn">,800h     </span><span class="co">;move 2K words</span>
     <span class="kw">cld</span>
     <span class="kw">call</span> ZTimerOn
     rep  <span class="kw">movsw</span>       <span class="co">;simply read each of the first</span>
                      <span class="co">; 2K words of the destination segment,</span>
                      <span class="co">; writing each byte immediately back</span>
                      <span class="co">; to the same address. No memory</span>
                      <span class="co">; locations are actually altered; this</span>
                      <span class="co">; is just to measure memory access</span>
                      <span class="co">; times</span>
     <span class="kw">call</span> ZTimerOff
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">ax</span><span class="bn">,0003h</span>
     <span class="kw">int</span><span class="bn">  10h         </span><span class="co">;return to text mode</span></code></pre>
<p>For comparison, let’s see how long the same code takes when accessing normal system RAM instead of display memory. The code in Listing 4.12, which performs a <code>REP MOVSW</code> from the code segment to the code segment, executes in 1.39 µs per display memory access. That means that on average, 1.79 µs (more than 8 cycles!) are lost to the display adapter cycle-eater on each access. In other words, the display adapter cycle-eater can <em>more than double</em> the execution time of 8088 code!</p>
<p><strong>LISTING 4.12 LST4-12.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Times speed of memory access to normal system</span>
<span class="co">; memory.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">ax</span>,<span class="kw">ds</span>
     <span class="kw">mov</span>  <span class="kw">es</span>,<span class="kw">ax</span>       <span class="co">;move to &amp; from same segment</span>
     <span class="kw">sub</span>  <span class="kw">si</span>,<span class="kw">si</span>       <span class="co">;move to &amp; from same offset</span>
     <span class="kw">mov</span>  <span class="kw">di</span>,<span class="kw">si</span>
     <span class="kw">mov</span>  <span class="kw">cx</span><span class="bn">,800h     </span><span class="co">;move 2K words</span>
     <span class="kw">cld</span>
     <span class="kw">call</span> ZTimerOn
     rep  <span class="kw">movsw</span>       <span class="co">;simply read each of the first</span>
                      <span class="co">; 2K words of the destination segment,</span>
                      <span class="co">; writing each byte immediately back</span>
                      <span class="co">; to the same address. No memory</span>
                      <span class="co">; locations are actually altered; this</span>
                      <span class="co">; is just to measure memory access</span>
                      <span class="co">; times</span>
     <span class="kw">call</span> ZTimerOff</code></pre>
<p>Bear in mind that we’re talking about a worst case here; the impact of the display adapter cycle-eater is proportional to the percent of time a given code sequence spends accessing display memory.</p>
<blockquote>
<p><img src="images/i.jpg" /> A line-drawing subroutine, which executes perhaps a dozen instructions for each display memory access, generally loses less performance to the display adapter cycle-eater than does a block-copy or scrolling subroutine that uses <code>REP MOVS</code> instructions. Scaled and three-dimensional graphics, which spend a great deal of time performing calculations (often using very slow floating-point arithmetic), tend to suffer less.</p>
</blockquote>
<p>In addition, code that accesses display memory infrequently tends to suffer only about half of the maximum display memory wait states, because on average such code will access display memory halfway between one available display memory access slot and the next. As a result, code that accesses display memory less intensively than the code in Listing 4.11 will on average lose 4 or 5 rather than 8-plus cycles to the display adapter cycle-eater on each memory access.</p>
<p>Nonetheless, the display adapter cycle-eater always takes its toll on graphics code. Interestingly, that toll becomes much higher on ATs and 80386 machines because while those computers can execute many more instructions per microsecond than can the 8088-based PC, it takes just as long to access display memory on those computers as on the 8088-based PC. Remember, the limited speed of access to a graphics adapter is an inherent characteristic of the adapter, so the fastest computer around can’t access display memory one iota faster than the adapter will allow.</p>
</section>
<section id="what-to-do-about-the-display-adapter-cycle-eater" class="level4">
<h4><a href="#what-to-do-about-the-display-adapter-cycle-eater">What to Do about the Display Adapter Cycle-Eater?</a></h4>
<p>What can we do about the display adapter cycle-eater? Well, we can minimize display memory accesses whenever possible. In particular, we can try to avoid read/modify/write display memory operations of the sort used to mask individual pixels and clip images. Why? Because read/modify/write operations require two display memory accesses (one read and one write) each time display memory is manipulated. Instead, we should try to use writes of the sort that set all the pixels in a given byte of display memory at once, since such writes don’t require accompanying read accesses. The key here is that only half as many display memory accesses are required to write a byte to display memory as are required to read a byte from display memory, mask part of it off and alter the rest, and write the byte back to display memory. Half as many display memory accesses means half as many display memory wait states.</p>
<blockquote>
<p><img src="images/i.jpg" /> Moreover, 486s and Pentiums, as well as recent Super VGAs, employ write-caching schemes that make display memory writes considerably faster than display memory reads.</p>
</blockquote>
<p>Along the same line, the display adapter cycle-eater makes the popular exclusive-OR animation technique, which requires paired reads and writes of display memory, less-than-ideal for the PC. Exclusive-OR animation should be avoided in favor of simply writing images to display memory whenever possible.</p>
<p>Another principle for display adapter programming on the 8088 is to perform multiple accesses to display memory very rapidly, in order to make use of as many of the scarce accesses to display memory as possible. This is especially important when many large images need to be drawn quickly, since only by using virtually every available display memory access can many bytes be written to display memory in a short period of time. Repeated string instructions are ideal for making maximum use of display memory accesses; of course, repeated string instructions can only be used on whole bytes, so this is another point in favor of modifying display memory a byte at a time. (On faster processors, however, display memory is so slow that it often pays to do several instructions worth of work between display memory accesses, to take advantage of cycles that would otherwise be wasted on the wait states.)</p>
<p>It would be handy to explore the display adapter cycle-eater issue in depth, with lots of example code and execution timings, but alas, I don’t have the space for that right now. For the time being, all you really need to know about the display adapter cycle-eater is that on the 8088 you can lose more than 8 cycles of execution time on each access to display memory. For intensive access to display memory, the loss really can be as high as 8cycles (and up to 50, 100, or even more on 486s and Pentiums paired with slow VGAs), while for average graphics code the loss is closer to 4 cycles; in either case, the impact on performance is significant. There is only one way to discover just how significant the impact of the display adapter cycle-eater is for any particular graphics code, and that is of course to measure the performance of that code.</p>
</section>
<section id="cycle-eaters-a-summary" class="level4">
<h4><a href="#cycle-eaters-a-summary">Cycle-Eaters: A Summary</a></h4>
<p>We’ve covered a great deal of sophisticated material in this chapter, so don’t feel bad if you haven’t understood everything you’ve read; it will all become clear from further reading, especially once you study, time, and tune code that you have written yourself. What’s really important is that you come away from this chapter understanding that on the 8088:</p>
<ul>
<li>The 8-bit bus cycle-eater causes each access to a word-sized operand to be 4 cycles longer than an equivalent access to a byte-sized operand.</li>
<li>The prefetch queue cycle-eater can cause instruction execution times to be as much as four times longer than the officially documented cycle times.</li>
<li>The DRAM refresh cycle-eater slows most PC code, with performance reductions ranging as high as 8.33 percent.</li>
<li>The display adapter cycle-eater typically doubles and can more than triple the length of the standard 4-cycle access to display memory, with intensive display memory access suffering most.</li>
</ul>
<p>This basic knowledge about cycle-eaters puts you in a good position to understand the results reported by the Zen timer, and that means that you’re well on your way to writing high-performance assembler code.</p>
</section>
<section id="what-does-it-all-mean" class="level4">
<h4><a href="#what-does-it-all-mean">What Does It All Mean?</a></h4>
<p>There you have it: life under the programming interface. It’s not a particularly pretty picture for the inhabitants of that strange realm where hardware and software meet are little-known cycle-eaters that sap the speed from your unsuspecting code. Still, some of those cycle-eaters can be minimized by keeping instructions short, using the registers, using byte-sized memory operands, and accessing display memory as little as possible. None of the cycle-eaters can be eliminated, and dynamic RAM refresh can scarcely be addressed at all; still, aren’t you better off knowing how fast your code <em>really</em> runs—and why—than you were reading the official execution times and guessing? And while specific cycle-eaters vary in importance on later x86-family processors, with some cycle-eaters vanishing altogether and new ones appearing, the concept that understanding these obscure gremlins is a key to performance remains unchanged, as we’ll see again and again in later chapters.</p>
</section>
</section>
</section>
<section id="chapter-5-crossing-the-border" class="level2">
<h2><a href="#chapter-5-crossing-the-border">Chapter 5 – Crossing the Border</a></h2>
<section id="searching-files-with-restartable-blocks" class="level3">
<h3><a href="#searching-files-with-restartable-blocks">Searching Files with Restartable Blocks</a></h3>
<p><em>We just moved.</em> Those three little words should strike terror into the heart of anyone who owns more than a sleeping bag and a toothbrush. Our last move was the usual zoo—and then some. Because the distance from the old house to the new was only five miles, we used cars to move everything smaller than a washing machine. We have a sizable household—cats, dogs, kids, com, you name it—so the moving process took a number of car trips. A <em>large</em> number—33, to be exact. I personally spent about 15 hours just driving back and forth between the two houses. The move took days to complete.</p>
<p><em>Never again</em>.</p>
<p>You’re probably wondering two things: What does this have to do with high-performance programming, and why on earth didn’t I rent a truck and get the move over in one or two trips, saving hours of driving? As it happens, the second question answers the first. I didn’t rent a truck because it <em>seemed</em> easier and cheaper to use cars—no big truck to drive, no rentals, spread the work out more manageably, and so on.</p>
<p>It wasn’t easier, and wasn’t even much cheaper. (It costs quite a bit to drive a car 330 miles, to say nothing of the value of 15 hours of my time.) But, at the time, it seemed as though my approach would be easier and cheaper. In fact, I didn’t realize just how much time I had wasted driving back and forth until I sat down to write this chapter.</p>
<p>In Chapter 1, I briefly discussed using <em>restartable blocks</em>. This, you might remember, is the process of handling in chunks data sets too large to fit in memory so that they can be processed just about as fast as if they did fit in memory. The restartable block approach is very fast but is relatively difficult to program.</p>
<p>At the opposite end of the spectrum lies byte-by-byte processing, whereby DOS (or, in less extreme cases, a group of library functions) is allowed to do all the hard work, so that you only have to deal with one byte at a time. Byte-by-byte processing is easy to program but can be extremely slow, due to the vast overhead that results from invoking DOS each time a byte must be processed.</p>
<p>Sound familiar? It should. I moved via the byte-by-byte approach, and the overhead of driving back and forth made for miserable performance. Renting a truck (the restartable block approach) would have required more effort and forethought, but would have paid off handsomely.</p>
<blockquote>
<p><img src="images/i.jpg" /> The easy, familiar approach often has nothing in its favor except that it requires less thinking; not a great virtue when writing high-performance code—or when moving.</p>
</blockquote>
<p>And with that, let’s look at a fairly complex application of restartable blocks.</p>
<section id="searching-for-text" class="level4">
<h4><a href="#searching-for-text">Searching for Text</a></h4>
<p>The application we’re going to examine searches a file for a specified string. We’ll develop a program that will search the file specified on the command line for a string (also specified on the comline), then report whether the string was found or not. (Because the searched-for string is obtained via <code>argv</code>, it can’t contain any whitespace characters.)</p>
<p>This is a <em>very</em> limited subset of what search utilities such as grep can do, and isn’t really intended to be a generally useful application; the purpose is to provide insight into restartable blocks in particular and optimization in general in the course of developing a search engine. That search engine will, however, be easy to plug into any program, and there’s nothing preventing you from using it in a more fruitful context, like searching through a user-selectable file set.</p>
<p>The first point to address in designing our program involves the appropriate text-search approach to use. Literally dozens of workable ways exist to search a file. We can immediately discard all approaches that involve reading any byte of the file more than once, because disk access time is orders of magnitude slower than any data handling performed by our own code. Based on our experience in Chapter 1, we can also discard all approaches that get bytes either one at a time or in small sets from DOS. We want to read big “buffers-full” of bytes at a pop from the searched file, and the bigger the buffer the better—in order to minimize DOS’s overhead. A good rough cut is a buffer that will be between 16K and 64K, depending on the exact search approach, 64K being the maximum size because near pointers make for superior performance.</p>
<p>So we know we want to work with a large buffer, filling it as infrequently as possible. Now we have to figure out how to search through a file by loading it into that large buffer in chunks. To accomplish this, we have to know how we want to do our searching, and that’s not immediately obvious. Where do we begin?</p>
<p>Well, it might be instructive to consider how we would search if our search involved only one buffer, already resident in memory. In other words, suppose we don’t have to bother with file handling at all, and further suppose that we don’t have to deal with searching through multiple blocks. After all, that’s a good description of the all-important inner loop of our searching program, where the program will spend virtually all of its time (aside from the unavoidable disk access overhead).</p>
</section>
</section>
<section id="avoiding-the-string-trap" class="level3">
<h3><a href="#avoiding-the-string-trap">Avoiding the String Trap</a></h3>
<p>The easiest approach would be to use a C/C++ library function. The closest match to what we need is <code>strstr()</code>, which searches one string for the first occurrence of a second string. However, while <code>strstr()</code> would work, it isn’t ideal for our purposes. The problem is this: Where we want to search a fixed-length buffer for the first occurrence of a string, <code>strstr()</code> searches a <em>string</em> for the first occurrence of another string.</p>
<p>We could put a zero byte at the end of our buffer to allow <code>strstr()</code> to work, but why bother? The <code>strstr()</code> function must spend time either checking for the end of the string being searched or determining the length of that string—wasted effort given that we already know exactly how long our search buffer is. Even if a given <code>strstr()</code> implementation is well-written, its performance will suffer, at least for our application, from unnecessary overhead.</p>
<blockquote>
<p><img src="images/i.jpg" /> This illustrates why you shouldn’t think of C/C++ library functions as black boxes; understand what they do and try to figure out how they do it, and relate that to their performance in the context you’re interested in.</p>
</blockquote>
</section>
<section id="brute-force-techniques" class="level3">
<h3><a href="#brute-force-techniques">Brute-Force Techniques</a></h3>
<p>Given that no C/C++ library function meets our needs precisely, an obvious alternative approach is the brute-force technique that uses <code>memcmp()</code> to compare <em>every</em> potential matching location in the buffer to the string we’re searching for, as illustrated in Figure 5.1.</p>
<p>By the way, we could, of course, use our own code, working with pointers in a loop, to perform the comparison in place of <code>memcmp()</code>. But <code>memcmp()</code> will almost certainly use the very fast <code>REPZ CMPS</code> instruction. However, <em>never assume!</em> It wouldn’t hurt to use a debugger to check out the actual machine-code implementation of <code>memcmp()</code> from your compiler. If necessary, you could always write your own assembly language implementation of <code>memcmp()</code>.</p>
<figure>
<img src="images/05-01.jpg" alt="Figure 5.1  The brute-force searching technique." /><figcaption><strong>Figure 5.1</strong>  <em>The brute-force searching technique.</em></figcaption>
</figure>
<p>Invoking <code>memcmp()</code> for each potential match location works, but entails considerable overhead. Each comparison requires that parameters be pushed and that a call to and return from <code>memcmp()</code> be performed, along with a pass through the comparison loop. Surely there’s a better way!</p>
<p>Indeed there is. We can eliminate most calls to <code>memcmp()</code> by performing a simple test on each potential match location that will reject most such locations right off the bat. We’ll just check whether the first character of the potentially matching buffer location matches the first character of the string we’re searching for. We could make this check by using a pointer in a loop to scan the buffer for the next match for the first character, stopping to check for a match with the rest of the string <em>only</em> when the first character matches, as shown in Figure 5.2.</p>
</section>
<section id="using-memchr" class="level3">
<h3><a href="#using-memchr">Using memchr()</a></h3>
<p>There’s yet a better way to implement this approach, however. Use the <code>memchr()</code> function, which does nothing more or less than find the next occurrence of a specified character in a fixed-length buffer (presumably by using the extremely efficient <code>REPNZ SCASB</code> instruction, although again it wouldn’t hurt to check). By using <code>memchr()</code> to scan for potential matches that can then be fully tested with <code>memcmp()</code>, we can build a highly efficient search engine that takes good advantage of the information we have about the buffer being searched and the string we’re searching for. Our engine also relies heavily on repeated string instructions, assuming that the <code>memchr()</code> and <code>memcmp()</code> library functions are properly coded.</p>
<figure>
<img src="images/05-02.jpg" alt="Figure 5.2  The faster string-searching technique." /><figcaption><strong>Figure 5.2</strong>  <em>The faster string-searching technique.</em></figcaption>
</figure>
<p>We’re going to go with the this approach in our file-searching program; the only trick lies in deciding how to integrate this approach with restartable blocks in order to search through files larger than our buffer. This certainly isn’t the fastest-possible searching algorithm; as one example, the Boyer-Moore algorithm, which cleverly eliminates many buffer locations as potential matches in the process of checking preceding locations, can be considerably faster. However, the Boyer-Moore algorithm is quite complex to understand and implement, and would distract us from our main focus, restartable blocks, so we’ll save it for a later chapter (Chapter 14, to be precise). Besides, I suspect you’ll find the approach we’ll use to be fast enough for most purposes.</p>
<p>Now that we’ve selected a searching approach, let’s integrate it with file handling and searching through multiple blocks. In other words, let’s make it restartable.</p>
<section id="making-a-search-restartable" class="level4">
<h4><a href="#making-a-search-restartable">Making a Search Restartable</a></h4>
<p>As it happens, there’s no great trick to putting the pieces of this search program together. Basically, we’ll read in a buffer of data (we’ll work with 16K at a time to avoid signed overflow problems with integers), search it for a match with the <code>memchr()</code>/<code>memcmp()</code> engine described, and exit with a “string found” response if the desired string is found.</p>
<p>Otherwise, we’ll load in another buffer full of data from the file, search it, and so on. The only trick lies in handling potentially matching sequences in the file that start in one buffer and end in the next—that is, sequences that span buffers. We’ll handle this by copying the unchecked bytes at the end of one buffer to the start of the next and reading that many fewer bytes the next time we fill the buffer.</p>
<p>The exact number of bytes to be copied from the end of one buffer to the start of the next is the length of the searched-for string minus 1, since that’s how many bytes at the end of the buffer can’t be checked as possible matches (because the check would run off the end of the buffer).</p>
<p>That’s really all there is to it. Listing 5.1 shows the file-searching program. As you can see, it’s not particularly complex, although a few fairly opaque lines of code are required to handle merging the end of one block with the start of the next. The code that searches a single block—the function <code>SearchForString()</code>—is simple and compact (as it should be, given that it’s by far the most heavily-executed code in the listing).</p>
<p>Listing 5.1 nicely illustrates the core concept of restartable blocks: Organize your program so that you can do your processing within each block as fast as you could if there were only one block—which is to say at top speed—and make your blocks as large as possible in order to minimize the overhead associated with going from one block to the next.</p>
<p><strong>LISTING 5.1 SEARCH.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Program to search the file specified by the first command-line</span>
<span class="co"> * argument for the string specified by the second command-line</span>
<span class="co"> * argument. Performs the search by reading and searching blocks</span>
<span class="co"> * of size BLOCK_SIZE. */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;fcntl.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;alloc.h&gt;   </span><span class="co">/* alloc.h for Borland compilers,</span>
<span class="co">                        malloc.h for Microsoft compilers */</span>

<span class="ot">#define BLOCK_SIZE  0x4000   </span><span class="co">/* we&#39;ll process the file in 16K blocks */</span>

<span class="co">/* Searches the specified number of sequences in the specified</span>
<span class="co">   buffer for matches to SearchString of SearchStringLength. Note</span>
<span class="co">   that the calling code should already have shortened SearchLength</span>
<span class="co">   if necessary to compensate for the distance from the end of the</span>
<span class="co">   buffer to the last possible start of a matching sequence in the</span>
<span class="co">   buffer.</span>
<span class="co">*/</span>

<span class="dt">int</span> SearchForString(<span class="dt">unsigned</span> <span class="dt">char</span> *Buffer, <span class="dt">int</span> SearchLength,
   <span class="dt">unsigned</span> <span class="dt">char</span> *SearchString, <span class="dt">int</span> SearchStringLength)
{
   <span class="dt">unsigned</span> <span class="dt">char</span> *PotentialMatch;

   <span class="co">/* Search so long as there are potential-match locations</span>
<span class="co">      remaining */</span>
   <span class="kw">while</span> ( SearchLength ) {
     <span class="co">/* See if the first character of SearchString can be found */</span>
     <span class="kw">if</span> ( (PotentialMatch =
           memchr(Buffer, *SearchString, SearchLength)) == NULL ) {
        <span class="kw">break</span>;   <span class="co">/* No matches in this buffer */</span>
     }
      <span class="co">/* The first character matches; see if the rest of the string</span>
<span class="co">         also matches */</span>
      <span class="kw">if</span> ( SearchStringLength == <span class="dv">1</span> ) {
         <span class="kw">return</span>(<span class="dv">1</span>);  <span class="co">/* That one matching character was the whole</span>
<span class="co">                        search string, so we&#39;ve got a match */</span>
      }
      <span class="kw">else</span> {
         <span class="co">/* Check whether the remaining characters match */</span>
         <span class="kw">if</span> ( !memcmp(PotentialMatch + <span class="dv">1</span>, SearchString + <span class="dv">1</span>,
               SearchStringLength - <span class="dv">1</span>) ) {
            <span class="kw">return</span>(<span class="dv">1</span>);  <span class="co">/* We&#39;ve got a match */</span>
         }
      }
      <span class="co">/* The string doesn&#39;t match; keep going by pointing past the</span>
<span class="co">         potential match location we just rejected */</span>
      SearchLength -= PotentialMatch - Buffer + <span class="dv">1</span>;
      Buffer = PotentialMatch + <span class="dv">1</span>;
   }

   <span class="kw">return</span>(<span class="dv">0</span>);  <span class="co">/* No match found */</span>
}

main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]) {
   <span class="dt">int</span> Done;               <span class="co">/* Indicates whether search is done */</span>
   <span class="dt">int</span> Handle;             <span class="co">/* Handle of file being searched */</span>
   <span class="dt">int</span> WorkingLength;      <span class="co">/* Length of current block */</span>
   <span class="dt">int</span> SearchStringLength; <span class="co">/* Length of string to search for */</span>
   <span class="dt">int</span> BlockSearchLength;  <span class="co">/* Length to search in current block */</span>
   <span class="dt">int</span> Found;              <span class="co">/* Indicates final search completion</span>
<span class="co">                              status */</span>
   <span class="dt">int</span> NextLoadCount;      <span class="co">/* # of bytes to read into next block,</span>
<span class="co">                              accounting for bytes copied from the</span>
<span class="co">                              last block */</span>
   <span class="dt">unsigned</span> <span class="dt">char</span> *WorkingBlock; <span class="co">/* Block storage buffer */</span>
   <span class="dt">unsigned</span> <span class="dt">char</span> *SearchString; <span class="co">/* Pointer to the string to search for */</span>
   <span class="dt">unsigned</span> <span class="dt">char</span> *NextLoadPtr;  <span class="co">/* Offset at which to start loading</span>
<span class="co">                                   the next block, accounting for</span>
<span class="co">                                   bytes copied from the last block */</span>

   <span class="co">/* Check for the proper number of arguments */</span>
   <span class="kw">if</span> ( argc != <span class="dv">3</span> ) {
      printf(<span class="st">&quot;usage: search filename search-string</span><span class="ch">\n</span><span class="st">&quot;</span>);
      exit(<span class="dv">1</span>);
   }

   <span class="co">/* Try to open the file to be searched */</span>
   <span class="kw">if</span> ( (Handle = open(argv[<span class="dv">1</span>], O_RDONLY | O_BINARY)) == -<span class="dv">1</span> ) {
      printf(<span class="st">&quot;Can&#39;t open file: %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
      exit(<span class="dv">1</span>);
   }
   <span class="co">/* Calculate the length of text to search for */</span>
   SearchString = argv[<span class="dv">2</span>];
   SearchStringLength = strlen(SearchString);
   <span class="co">/* Try to get memory in which to buffer the data */</span>
   <span class="kw">if</span> ( (WorkingBlock = malloc(BLOCK_SIZE)) == NULL ) {
      printf(<span class="st">&quot;Can&#39;t get enough memory</span><span class="ch">\n</span><span class="st">&quot;</span>);
      exit(<span class="dv">1</span>);
   }

   <span class="co">/* Load the first block at the start of the buffer, and try to</span>
<span class="co">      fill the entire buffer */</span>
   NextLoadPtr = WorkingBlock;
   NextLoadCount = BLOCK_SIZE;
   Done = <span class="dv">0</span>;      <span class="co">/* Not done with search yet */</span>
   Found = <span class="dv">0</span>;     <span class="co">/* Assume we won&#39;t find a match */</span>
   <span class="co">/* Search the file in BLOCK_SIZE chunks */</span>
   <span class="kw">do</span> {
      <span class="co">/* Read in however many bytes are needed to fill out the block</span>
<span class="co">         (accounting for bytes copied over from the last block), or</span>
<span class="co">         the rest of the bytes in the file, whichever is less */</span>
      <span class="kw">if</span> ( (WorkingLength = read(Handle, NextLoadPtr,
            NextLoadCount)) == -<span class="dv">1</span> ) {
         printf(<span class="st">&quot;Error reading file %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
         exit(<span class="dv">1</span>);
      }
      <span class="co">/* If we didn&#39;t read all the bytes we requested, we&#39;re done</span>
<span class="co">         after this block, whether we find a match or not */</span>
      <span class="kw">if</span> ( WorkingLength != NextLoadCount ) {
         Done = <span class="dv">1</span>;
      }

      <span class="co">/* Account for any bytes we copied from the end of the last</span>
<span class="co">         block in the total length of this block */</span>
      WorkingLength += NextLoadPtr - WorkingBlock;
      <span class="co">/* Calculate the number of bytes in this block that could</span>
<span class="co">         possibly be the start of a matching sequence that lies</span>
<span class="co">         entirely in this block (sequences that run off the end of</span>
<span class="co">         the block will be transferred to the next block and found</span>
<span class="co">         when that block is searched)</span>
<span class="co">      */</span>
      <span class="kw">if</span> ( (BlockSearchLength =
               WorkingLength - SearchStringLength + <span class="dv">1</span>) &lt;= <span class="dv">0</span> ) {
            Done = <span class="dv">1</span>;  <span class="co">/* Too few characters in this block for</span>
<span class="co">                          there to be any possible matches, so this</span>
<span class="co">                          is the final block and we&#39;re done without</span>
<span class="co">                          finding a match</span>
<span class="co">                       */</span>
      }
      <span class="kw">else</span> {
         <span class="co">/* Search this block */</span>
         <span class="kw">if</span> ( SearchForString(WorkingBlock, BlockSearchLength,
               SearchString, SearchStringLength) ) {
            Found = <span class="dv">1</span>;     <span class="co">/* We&#39;ve found a match */</span>
            Done = <span class="dv">1</span>;
         }
         <span class="kw">else</span> {
            <span class="co">/* Copy any bytes from the end of the block that start</span>
<span class="co">               potentially-matching sequences that would run off</span>
<span class="co">               the end of the block over to the next block */</span>
            <span class="kw">if</span> ( SearchStringLength &gt; <span class="dv">1</span> ) {
               memcpy(WorkingBlock,
                  WorkingBlock+BLOCK_SIZE - SearchStringLength + <span class="dv">1</span>,
                  SearchStringLength - <span class="dv">1</span>);
            }
            <span class="co">/* Set up to load the next bytes from the file after the</span>
<span class="co">               bytes copied from the end of the current block */</span>
            NextLoadPtr = WorkingBlock + SearchStringLength - <span class="dv">1</span>;
            NextLoadCount = BLOCK_SIZE - SearchStringLength + <span class="dv">1</span>;
         }
      }
   } <span class="kw">while</span> ( !Done );

   <span class="co">/* Report the results */</span>
   <span class="kw">if</span> ( Found ) {
      printf(<span class="st">&quot;String found</span><span class="ch">\n</span><span class="st">&quot;</span>);
   } <span class="kw">else</span> {
      printf(<span class="st">&quot;String not found</span><span class="ch">\n</span><span class="st">&quot;</span>);
   }
   exit(Found);   <span class="co">/* Return the found/not found status as the</span>
<span class="co">                     DOS errorlevel */</span>
}</code></pre>
</section>
</section>
<section id="interpreting-where-the-cycles-go" class="level3">
<h3><a href="#interpreting-where-the-cycles-go">Interpreting Where the Cycles Go</a></h3>
<p>To boost the overall performance of Listing 5.1, I would normally convert <code>SearchForString()</code> to assembly language at this point. However, I’m not going to do that, and the reason is as important a lesson as any discussion of optimized assembly code is likely to be. Take a moment to examine some interesting performance aspects of the C implementation, and all should become much clearer.</p>
<p>As you’ll recall from Chapter 1, one of the important rules for optimization involves knowing when optimization is worth bothering with at all. Another rule involves understanding where most of a program’s execution time is going. That’s more true for Listing 5.1 than you might think.</p>
<p>When Listing 5.1 is run on a 1 MB assembly source file, it takes about three seconds to find the string “xxxend” (which is at the end of the file) on a 20 MHz 386 machine, with the entire file in a disk cache. If <code>BLOCK_SIZE</code> is trimmed from 16K to 4K, <em>execution time does not increase perceptibly!</em> At 2K, the program slows slightly; it’s not until the block size shrinks to 64 bytes that execution time becomes approximately double that of the 16K buffer.</p>
<p>So the first thing we’ve discovered is that, while bigger blocks do make for the best performance, the increment in performance may not be very large, and might not justify the extra memory required for those larger blocks. Our next discovery is that, even though we read the file in large chunks, most of the execution time of Listing 5.1 is nonetheless spent in executing the <code>read()</code> function.</p>
<p>When I replaced the <code>read()</code> function call in Listing 5.1 with code that simply fools the program into thinking that a 1 MB file is being read, the program ran almost instantaneously—in less than 1/2 second, even when the searched-for string wasn’t anywhere to be found. By contrast, Listing 5.1 requires three seconds to run even when searching for a single character that isn’t found anywhere in the file, the case in which a single call to <code>memchr()</code> (and thus a single <code>REPNZ SCASB</code>) can eliminate an entire block at a time.</p>
<p>All in all, the time required for DOS disk access calls is taking up at least 80 percent of execution time, and search time is less than 20 percent of overall execution time. In fact, search time is probably a good deal less than 20 percent of the total, given that the overhead of loading the program, running through the C startup code, opening the file, executing <code>printf()</code>, and exiting the program and returning to the DOS shell are also included in my timings. Given which, it should be apparent why converting to assembly language isn’t worth the trouble—the best we could do by speeding up the search is a 10 percent or so improvement, and that would require more than doubling the performance of code that already uses repeated string instructions to do most of the work.</p>
<p>Not likely.</p>
<section id="knowing-when-assembly-is-pointless" class="level4">
<h4><a href="#knowing-when-assembly-is-pointless">Knowing When Assembly Is Pointless</a></h4>
<p>So that’s why we’re not going to go to assembly language in this example—which is not to say it would never be worth converting the search engine in Listing 5.1 to assembly.</p>
<p>If, for example, your application will typically search buffers in which the first character of the search string occurs frequently as might be the case when searching a text buffer for a string starting with the space character an assembly implementation might be several times faster. Why? Because assembly code can switch from <code>REPNZ SCASB</code> to match the first character to <code>REPZ CMPS</code> to check the remaining characters in just a few instructions.</p>
<p>In contrast, Listing 5.1 must return from <code>memchr()</code>, set up parameters, and call <code>memcmp()</code> in order to do the same thing. Likewise, assembly can switch back to <code>REPNZ SCASB</code> after a non-match much more quickly than Listing 5.1. The switching overhead is high; when searching a file completely filled with the character z for the string “zy,” Listing 5.1 takes almost 1/2 minute, or nearly an order of magnitude longer than when searching a file filled with normal text.</p>
<p>It might also be worth converting the search engine to assembly for searches performed entirely in memory; with the overhead of file access eliminated, improvements in search-engine performance would translate directly into significantly faster overall performance. One such application that would have much the same structure as Listing 5.1 would be searching through expanded memory buffers, and another would be searching through huge (segment-spanning) buffers.</p>
<p>And so we find, as we so often will, that optimization is definitely not a cut-and-dried matter, and that there is no such thing as a single “best” approach.</p>
<blockquote>
<p><img src="images/i.jpg" /> You must know what your application will typically do, and you must know whether you’re more concerned with average or worst-case performance before you can decide how best to speed up your program—and, indeed, whether speeding it up is worth doing at all.</p>
</blockquote>
<p>By the way, don’t think that just because very large block sizes don’t much improve performance, it wasn’t worth using restartable blocks in Listing 5.1. Listing 5.1 runs more than three times more slowly with a block size of 32 bytes than with a block size of 4K, and any byte-by-byte approach would surely be slower still, due to the overhead of repeated calls to DOS and/or the C stream I/O library.</p>
<p>Restartable blocks do minimize the overhead of DOS file-access calls in Listing 5.1; it’s just that there’s no way to reduce that overhead to the point where it becomes worth attempting to further improve the performance of our relatively efficient search engine. Although the search engine is by no means fully optimized, it’s nonetheless as fast as there’s any reason for it to be, given the balance of performance among the components of this program.</p>
</section>
</section>
<section id="always-look-where-execution-is-going" class="level3">
<h3><a href="#always-look-where-execution-is-going">Always Look Where Execution Is Going</a></h3>
<p>I’ve explained two important lessons: Know when it’s worth optimizing further, and use restartable blocks to process large data sets as a series of blocks, with each block handled at high speed. The first lesson is less obvious than it seems.</p>
<p>When I set out to write this chapter, I fully intended to write an assembly language version of Listing 5.1, and I expected the assembly version to be much faster. When I actually looked at where execution time was going (which I did by modifying the program to remove the calls to the <code>read()</code> function, but a code profiler could be used to do the same thing much more easily), I found that the best code in the world wouldn’t make much difference.</p>
<blockquote>
<p><img src="images/i.jpg" /> When you try to speed up code, take a moment to identify the hot spots in your program so that you know where optimization is needed and whether it will make a significant difference before you invest your time.</p>
</blockquote>
<p>As for restartable blocks: Here we tackled a considerably more complex application of restartable blocks than we did in Chapter 1—which turned out not to be so difficult after all. Don’t let irregularities in the programming tasks you tackle, such as strings that span blocks, fluster you into settling for easy, general—and slow—solutions. Focus on making the inner loop—the code that handles each block—as efficient as possible, then structure the rest of your code to support the inner loop.</p>
<p>Programming with restartable blocks isn’t easy, but when speed is an issue, using restartable blocks in the right places more than pays for itself with greatly improved performance. And when speed is <em>not</em> an issue, of course, or in code that’s not time-critical, you wouldn’t dream of wasting your time on optimization.</p>
<p>Would you?</p>
</section>
</section>
<section id="chapter-6-looking-past-face-value" class="level2">
<h2><a href="#chapter-6-looking-past-face-value">Chapter 6 – Looking Past Face Value</a></h2>
<section id="how-machine-instructions-may-do-more-than-you-think" class="level3">
<h3><a href="#how-machine-instructions-may-do-more-than-you-think">How Machine Instructions May Do More Than You Think</a></h3>
<p>I first met Jeff Duntemann at an authors’ dinner hosted by <em>PC Tech Journal</em> at Fall Comdex, back in 1985. Jeff was already reasonably well-known as a computer editor and writer, although not as famous as <em>Complete Turbo Pascal</em>, editions 1 through 672 (or thereabouts), <em>TURBO TECHNIX</em>, and <em>PC TECHNIQUES</em> would soon make him. I was fortunate enough to be seated next to Jeff at the dinner table, and, not surprisingly, our often animated conversation revolved around computers, computer writing, and more computers (not necessarily in that order).</p>
<p>Although I was making a living at computer work and enjoying it at the time, I nonetheless harbored vague ambitions of being a science-fiction writer when I grew up. (I have since realized that this hardly puts me in elite company, especially in the computer world, where it seems that every other person has told me they plan to write science fiction “someday.” Given that probably fewer than 500—I’m guessing here—original science fiction and fantasy short stories, and perhaps a few more novels than that, are published each year in this country, I see a few mid-life crises coming.)</p>
<p>At any rate, I had accumulated a small collection of rejection slips, and fancied myself something of an old hand in the field. At the end of the dinner, as the other writers complained half-seriously about how little they were paid for writing for <em>Tech Journal</em>, I leaned over to Jeff and whispered, “You know, the pay isn’t so bad here. You should see what they pay for science fiction—even to the guys who win awards!”</p>
<p>To which Jeff replied, “I know. I’ve been nominated for two Hugos.”</p>
<p>Oh.</p>
<p>Had I known I was seated next to a real, live science-fiction writer—an <em>award-nominated</em> writer, by God!—I would have pumped him for all I was worth, but the possibility had never occurred to me. I was at a dinner put on by a computer magazine, seated next to an editor who had just finished a book about Turbo Pascal, and, gosh, it was <em>obvious</em> that the appropriate topic was computers.</p>
<p>For once, the moral is <em>not</em> “don’t judge a book by its cover.” Jeff is in fact what he appeared to be at face value: a computer writer and editor. However, he is more, too; face value wasn’t full value. You’ll similarly find that face value isn’t always full value in computer programming, and especially so when working in assembly language, where many instructions have talents above and beyond their obvious abilities.</p>
<p>On the other hand, there are also a number of instructions, such as <code>LOOP</code>, that are designed to perform specific functions but aren’t always the best instructions for those functions. So don’t judge a book by its cover, either.</p>
<p>Assembly language for the x86 family isn’t like any other language (for which we should, without hesitation, offer our profuse thanks). Assembly language reflects the design of the processor rather than the way we think, so it’s full of multiple instructions that perform similar functions, instructions with odd and often confusing side effects, and endless ways to string together different instructions to do much the same things, often with seemingly minuscule differences that can turn out to be surprisingly important.</p>
<p>To produce the best code, you must decide precisely what you need to accomplish, then put together the sequence of instructions that accomplishes that end most efficiently, regardless of what the instructions are usually used for. That’s why optimization for the PC is an art, and it’s why the best assembly language for the x86 family will almost always handily outperform compiled code. With that in mind, let’s look past face value—and while we’re at it, I’ll toss in a few examples of not judging a book by its cover.</p>
<p>The point to all this: You must come to regard the x86 family instructions for what they do, not what you’re used to thinking they do. Yes, <code>SHL</code> shifts a pattern left—but a look-up table can do the same thing, and can often do it faster. <code>ADD</code> can indeed add two operands, but it can’t put the result in a third register; <code>LEA</code> can. The instruction set is your raw material for writing high-performance code. By limiting yourself to thinking only in certain well-established ways about the various instructions, you’re putting yourself at a substantial disadvantage every time you sit down to program.</p>
<p>In short, the x86 family can do much more than you think—if you’ll use everything it has to offer. Give it a shot!</p>
<section id="memory-addressing-and-arithmetic" class="level4">
<h4><a href="#memory-addressing-and-arithmetic">Memory Addressing and Arithmetic</a></h4>
<p>Years ago, I saw a clip on the David Letterman show in which Letterman walked into a store by the name of “Just Lamps” and asked, “So what do you sell here?”</p>
<p>“Lamps,” he was told. “Just lamps. Can’t you read?”</p>
<p>“Lamps,” he said. “I see. And what else?”</p>
<p>From that bit of sublime idiocy we can learn much about divining the full value of an instruction. To wit:</p>
<p>Quick, what do the x86’s memory addressing modes do?</p>
<p>“Calculate memory addresses,” you no doubt replied. And you’re right, of course. But what <em>else</em> do they do?</p>
<p>They perform arithmetic, that’s what they do, and that’s a distinctly different and often useful perspective on memory address calculations.</p>
<p>For example, suppose you have an array base address in BX and an index into the array in SI. You could add the two registers together to address memory, like this:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">add</span>  <span class="kw">bx</span>,<span class="kw">si</span>
<span class="kw">mov</span>  <span class="kw">al</span>,[<span class="kw">bx</span>]</code></pre>
<p>Or you could let the processor do the arithmetic for you in a single instruction:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">al</span>,[<span class="kw">bx</span>+<span class="kw">si</span>]</code></pre>
<p>The two approaches are functionally interchangeable but <em>not</em> equivalent from a performance standpoint, and which is better depends on the particular context. If it’s a one-shot memory access, it’s best to let the processor perform the addition; it’s generally faster at doing this than a separate <code>ADD</code> instruction would be. If it’s a memory access within a loop, however, it’s advantageous on the 8088 CPU to perform the addition outside the loop, if possible, reducing effective address calculation time inside the loop, as in the following:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">      <span class="kw">add</span>   <span class="kw">bx</span>,<span class="kw">si</span>
<span class="fu">LoopTop:</span>
      <span class="kw">mov</span>   <span class="kw">al</span>,[<span class="kw">bx</span>]
      <span class="kw">inc</span>   <span class="kw">bx</span>
      <span class="kw">loop</span>  LoopTop</code></pre>
<p>Here, <code>MOV AL,[BX]</code> is two cycles faster than <code>MOV AL,[BX+SI]</code>.</p>
<p>On a 286 or 386, however, the balance shifts. <code>MOV AL,[BX+SI]</code> takes no longer than <code>MOV AL,[BX]</code> on these processors because effective address calculations generally take no extra time at all. (According to the MASM manual, one extra clock is required if three memory addressing components, as in <code>MOV AL,[BX+SI+1]</code>, are used. I have not been able to confirm this from Intel publications, but then I haven’t looked all that hard.) If you’re optimizing for the 286 or 386, then, you can take advantage of the processor’s ability to perform arithmetic as part of memory address calculations without taking a performance hit.</p>
<p>The 486 is an odd case, in which the use of an index register or the use of a base register that’s the destination of the previous instruction may slow things down, so it is generally but not always better to perform the addition outside the loop on the 486. All memory addressing calculations are free on the Pentium, however. I’ll discuss 486 performance issues in Chapters 12 and 13, and the Pentium in Chapters 19 through 21.</p>
</section>
</section>
<section id="math-via-memory-addressing" class="level3">
<h3><a href="#math-via-memory-addressing">Math via Memory Addressing</a></h3>
<p>You’re probably not particularly wowed to hear that you can use addressing modes to perform memory addressing arithmetic that would otherwise have to be performed with separate arithmetic instructions. You may, however, be a tad more interested to hear that you can also use addressing modes to perform arithmetic that has nothing to do with memory addressing, and with a couple of advantages over arithmetic instructions, at that.</p>
<p>How?</p>
<p>With <code>LEA</code>, the only instruction that performs memory addressing calculations but doesn’t actually address memory. <code>LEA</code> accepts a standard memory addressing operand, but does nothing more than store the calculated memory offset in the specified register, which may be any general-purpose register. The operation of <code>LEA</code> is illustrated in Figure 6.1, which also shows the operation of register-to-register <code>ADD</code>, for comparis on.</p>
<p>What does that give us? Two things that <code>ADD</code> doesn’t provide: the ability to perform addition with either two or three operands, and the ability to store the result in <em>any</em> register, not just in one of the source operands.</p>
<p>Imagine that we want to add BX to DI, add two to the result, and store the result in AX. The obvious solution is this:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">ax</span>,<span class="kw">bx</span>
<span class="kw">add</span>  <span class="kw">ax</span>,<span class="kw">di</span>
<span class="kw">add</span>  <span class="kw">ax</span>,<span class="dv">2</span></code></pre>
<p>(It would be more compact to increment AX twice than to add two to it, and would probably be faster on an 8088, but that’s not what we’re after at the moment.) An elegant alternative solution is simply:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">lea</span>  <span class="kw">ax</span>,[<span class="kw">bx</span>+<span class="kw">di</span><span class="dv">+2</span>]</code></pre>
<p>Likewise, either of the following would copy SI plus two to DI</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">di</span>,<span class="kw">si</span>
<span class="kw">add</span>  <span class="kw">di</span>,<span class="dv">2</span></code></pre>
<p>or:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">lea</span>  <span class="kw">di</span>,[<span class="kw">si</span><span class="dv">+2</span>]</code></pre>
<p>Mind you, the only components <code>LEA</code> can add are BX or BP, SI or DI, and a constant displacement, so it’s not going to replace <code>ADD</code> most of the time. Also, <code>LEA</code> is considerably slower than <code>ADD</code> on an 8088, although it is just as fast as <code>ADD</code> on a 286 or 386 when fewer than three memory addressing components are used. <code>LEA</code> is 1 cycle slower than <code>ADD</code> on a 486 if the sum of two registers is used to point to memory, but no slower than <code>ADD</code> on a Pentium. On both a 486 and Pentium, <code>LEA</code> can also be slowed down by addressing interlocks.</p>
<figure>
<img src="images/06-01.jpg" alt="Figure 6.1  Operation of ADD Reg,Reg vs. LEA Reg,{Addr}." /><figcaption><strong>Figure 6.1</strong>  <em>Operation of ADD Reg,Reg vs. LEA Reg,{Addr}.</em></figcaption>
</figure>
<section id="the-wonders-of-lea-on-the-386" class="level4">
<h4><a href="#the-wonders-of-lea-on-the-386">The Wonders of LEA on the 386</a></h4>
<p><code>LEA</code> really comes into its own as a “super-ADD” instruction on the 386, 486, and Pentium, where it can take advantage of the enhanced memory addressing modes of those processors. (The 486 and Pentium offer the same modes as the 386, so I’ll refer only to the 386 from now on.) The 386 can do two very interesting things: It can use <em>any</em> 32-bit register (EAX, EBX, and so on) as the memory addressing base register and/or the memory addressing index register, and it can multiply any 32-bit register used as an index by two, four, or eight in the process of calculating a memory address, as shown in Figure 6.2. Let’s see what that’s good for.</p>
<p>Well, the obvious advantage is that any two 32-bit registers, or any 32-bit register and any constant, or any two 32-bit registers and any constant, can be added together, with the result stored in any register. This makes the 32-bit <code>LEA</code> much more generally useful than the standard 16-bit <code>LEA</code> in the role of an <code>ADD</code> with an independent destination.</p>
<figure>
<img src="images/06-02.jpg" alt="Figure 6.2  Operation of the 32-bit LEA reg,[Addr]." /><figcaption><strong>Figure 6.2</strong>  <em>Operation of the 32-bit LEA reg,[Addr].</em></figcaption>
</figure>
<p>But what else can <code>LEA</code> do on a 386, besides add?</p>
<p>It can multiply any register used as an index. <code>LEA</code> can multiply only by the power-of-two values 2, 4, or 8, but that’s useful more often than you might imagine, especially when dealing with pointers into tables. Besides, multiplying by 2, 4, or 8 amounts to a left shift of 1, 2, or 3 bits, so we can now add up to two 32-bit registers and a constant, <em>and</em> shift (or multiply) one of the registers to some extent—all with a single instruction. For example,</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">lea</span>  <span class="kw">edi</span>,TableBase[<span class="kw">ecx</span>+<span class="kw">edx</span>*<span class="dv">4</span>]</code></pre>
<p>replaces all this</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">edi</span>,<span class="kw">edx</span>
<span class="kw">shl</span>  <span class="kw">edi</span>,<span class="dv">2</span>
<span class="kw">add</span>  <span class="kw">edi</span>,<span class="kw">ecx</span>
<span class="kw">add</span>  <span class="kw">edi</span>,offset TableBase</code></pre>
<p>when pointing to an entry in a doubly indexed table.</p>
</section>
</section>
<section id="multiplication-with-lea-using-non-powers-of-two" class="level3">
<h3><a href="#multiplication-with-lea-using-non-powers-of-two">Multiplication with LEA Using Non-Powers of Two</a></h3>
<p>Are you impressed yet with all that <code>LEA</code> can do on the 386? Believe it or not, one more feature still awaits us. <code>LEA</code> can actually perform a fast multiply of a 32-bit register by some values <em>other</em> than powers of two. You see, the same 32-bit register can be both base and index on the 386, and can be scaled as the index while being used unchanged as the base. That means that you can, for example, multiply EBX by 5 with:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">lea</span> <span class="kw">ebx</span>,[<span class="kw">ebx</span>+<span class="kw">ebx</span>*<span class="dv">4</span>]</code></pre>
<p>Without <code>LEA</code> and scaling, multiplication of EBX by 5 would require either a relatively slow <code>MUL</code>, along with a set-up instruction or two, or three separate instructions along the lines of the following</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">edx</span>,<span class="kw">ebx</span>
<span class="kw">shl</span>  <span class="kw">ebx</span>,<span class="dv">2</span>
<span class="kw">add</span>  <span class="kw">ebx</span>,<span class="kw">edx</span></code></pre>
<p>and would in either case require the destruction of the contents of another register.</p>
<p>Multiplying a 32-bit value by a non-power-of-two multiplier in just 2 cycles is a pretty neat trick, even though it works only on a 386 or 486.</p>
<blockquote>
<p><img src="images/i.jpg" /> The full list of values that <code>LEA</code> can multiply a register by on a 386 or 486 is: 2, 3, 4, 5, 8, and 9. That list doesn’t include every multiplier you might want, but it covers some commonly used ones, and the performance is hard to beat.</p>
</blockquote>
<p>I’d like to extend my thanks to Duane Strong of Metagraphics for his help in brainstorming uses for the 386 version of <code>LEA</code> and for pointing out the complications of 486 instruction timings.</p>
</section>
</section>
<section id="chapter-7-local-optimization" class="level2">
<h2><a href="#chapter-7-local-optimization">Chapter 7 – Local Optimization</a></h2>
<section id="optimizing-halfway-between-algorithms-and-cycle-counting" class="level3">
<h3><a href="#optimizing-halfway-between-algorithms-and-cycle-counting">Optimizing Halfway between Algorithms and Cycle Counting</a></h3>
<p>You might not think it, but there’s much to learn about performance programming from the Great Buffalo Sauna Fiasco. To wit:</p>
<p>The scene is Buffalo, New York, in the dead of winter, with the snow piled several feet deep. Four college students, living in typical student housing, are frozen to the bone. The third floor of their house, uninsulated and so cold that it’s uninhabitable, has an ancient bathroom. One fabulously cold day, inspiration strikes:</p>
<p>“Hey—we could make that bathroom into a <em>sauna!</em>”</p>
<p>Pandemonium ensues. Someone rushes out and buys a gas heater, and at considerable risk to life and limb hooks it up to an abandoned but still live gas pipe that once fed a stove on the third floor. Someone else gets sheets of plastic and lines the walls of the bathroom to keep the moisture in, and yet another student gets a bucket full of rocks. The remaining chap brings up some old wooden chairs and sets them up to make benches along the sides of the bathroom. <em>Voila</em>—instant sauna!</p>
<p>They crank up the gas heater, put the bucket of rocks in front of it, close the door, take off their clothes, and sit down to steam themselves. Mind you, it’s not yet 50 degrees Fahrenheit in this room, but the gas heater is roaring. Surely warmer times await.</p>
<p>Indeed they do. The temperature climbs to 55 degrees, then 60, then 63, then 65, and finally creeps up to 68 degrees.</p>
<p>And there it stops.</p>
<p>68 degrees is warm for an uninsulated third floor in Buffalo in the dead of winter. Damn warm. It is not, however, particularly warm for a sauna. Eventually someone acknowledges the obvious and allows that it might have been a stupid idea after all, and everyone agrees, and they shut off the heater and leave, each no doubt offering silent thanks that they had gotten out of this without any incidents requiring major surgery.</p>
<p>And so we see that the best idea in the world can fail for lack of either proper design or adequate horsepower. The primary cause of the Great Buffalo Sauna Fiasco was a lack of horsepower; the gas heater was flat-out undersized. This is analogous to trying to write programs that incorporate features like bitmapped text and searching of multisegment buffers without using high-performance assembly language. Any PC language can perform just about any function you can think of—eventually. That heater would eventually have heated the room to 110 degrees, too—along about the first of June or so.</p>
<p>The Great Buffalo Sauna Fiasco also suffered from fundamental design flaws. A more powerful heater would indeed have made the room hotter—and might well have burned the house down in the process. Likewise, proper algorithm selection and good design are fundamental to performance. The extra horsepower a superb assembly language implementation gives a program is worth bothering with only in the context of a good design.</p>
<blockquote>
<p><img src="images/i.jpg" /> Assembly language optimization is a small but crucial corner of the PC programming world. Use it sparingly and only within the framework of a good design—but ignore it and you may find various portions of your anatomy out in the cold.</p>
</blockquote>
<p>So, drawing fortitude from the knowledge that our quest is a pure and worthy one, let’s resume our exploration of assembly language instructions with hidden talents and instructions with well-known talents that are less than they appear to be. In the process, we’ll come to see that there is another, very important optimization level between the algorithm/design level and the cycle-counting/individual instruction level. I’ll call this middle level <em>local optimization;</em> it involves focusing on optimizing sequences of instructions rather than individual instructions, all with an eye to implementing designs as efficiently as possible given the capabilities of the x86 family instruction set.</p>
<p>And yes, in case you’re wondering, the above story is indeed true. Was I there? Let me put it this way: If I were, I’d never admit it!</p>
<section id="when-loop-is-a-bad-idea" class="level4">
<h4><a href="#when-loop-is-a-bad-idea">When LOOP Is a Bad Idea</a></h4>
<p>Let’s examine first an instruction that is less than it appears to be: <code>LOOP</code>. There’s no mystery about what <code>LOOP</code> does; it decrements CX and branches if CX doesn’t decrement to zero. It’s so beautifully suited to the task of counting down loops that any experienced x86 programmer instinctively stuffs the loop count in CX and reaches for <code>LOOP</code> when setting up a loop. That’s fine—<code>LOOP</code> does, of course, work as advertised—but there is one problem:</p>
<blockquote>
<p><img src="images/i.jpg" /> On half of the processors in the x86 family, <code>LOOP</code> is slower than <code>DEC CX</code> followed by <code>JNZ</code>. (Granted, <code>DEC CX/JNZ</code> isn’t precisely equivalent to <code>LOOP</code>, because <code>DEC</code> alters the flags and LOOP doesn’t, but in most situations they’re comparable.)</p>
</blockquote>
<p>How can this be? Don’t ask me, ask Intel. On the 8088 and 80286, <code>LOOP</code> is indeed faster than <code>DEC CX/JNZ</code> by a cycle, and <code>LOOP</code> is generally a little faster still because it’s a byte shorter and so can be fetched faster. On the 386, however, things change; <code>LOOP</code> is two cycles <em>slower</em> than <code>DEC/JNZ</code> and the fetch time for one extra byte on even an uncached 386 generally isn’t significant. (Remember that the 386 fetches four instruction bytes at a pop.) <code>LOOP</code> is three cycles slower than <code>DEC/JNZ</code> on the 486, and the 486 executes instructions in so few cycles that those three cycles mean that <code>DEC/JNZ</code> is nearly <em>twice</em> as fast as <code>LOOP</code>. Then, too, unlike <code>LOOP, DEC</code> doesn’t require that <code>CX</code> be used, so the <code>DEC/JNZ</code> solution is both faster and more flexible on the 386 and 486, and on the Pentium as well. (By the way, all this is not just theory; I’ve timed the relative performances of <code>LOOP</code> and <code>DEC CX/JNZ</code> on a cached 386, and LOOP really is slower.)</p>
<blockquote>
<p><img src="images/i.jpg" /> Things are stranger still for <code>LOOP</code>’s relative <code>JCXZ</code>, which branches if and only if CX is zero. <code>JCXZ</code> is faster than <code>AND CX,CX/JZ</code> on the 8088 and 80286, and equivalent on the 80386—but is about twice as slow on the 486!</p>
</blockquote>
<p>By the way, don’t fall victim to the lures of <code>JCXZ</code> and do something like this:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">and</span>     <span class="kw">cx</span>,ofh          <span class="co">;Isolate the desired field</span>
<span class="kw">jcxz</span>    SkipLoop        <span class="co">;If field is 0, don&#39;t bother</span></code></pre>
<p>The <code>AND</code> instruction has already set the Zero flag, so this</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">and</span>     <span class="kw">cx</span><span class="bn">,0fh           </span><span class="co">;Isolate the desired field</span>
<span class="kw">jz</span>      SkipLoop         <span class="co">;If field is 0, don&#39;t bother</span></code></pre>
<p>will do just fine and is faster on all processors. Use <code>JCXZ</code> only when the Zero flag isn’t already set to reflect the status of CX.</p>
</section>
</section>
<section id="the-lessons-of-loop-and-jcxz" class="level3">
<h3><a href="#the-lessons-of-loop-and-jcxz">The Lessons of LOOP and JCXZ</a></h3>
<p>What can we learn from <code>LOOP</code> and <code>JCXZ</code>? First, that a single instruction that is intended to do a complex task is not necessarily faster than several instructions that together do the same thing. Second, that the relative merits of instructions and optimization rules vary to a surprisingly large degree across the x86 family.</p>
<p>In particular, if you’re going to write 386 protected mode code, which will run only on the 386, 486, and Pentium, you’d be well advised to rethink your use of the more esoteric members of the x86 instruction set. <code>LOOP, JCXZ</code>, the various accumulator-specific instructions, and even the string instructions in many circumstances no longer offer the advantages they did on the 8088. Sometimes they’re just not any faster than more general instructions, so they’re not worth going out of your way to use; sometimes, as with <code>LOOP</code>, they’re actually slower, and you’d do well to avoid them altogether in the 386/486 world. Reviewing the instruction cycle times in the MASM or TASM manuals, or looking over the cycle times in Intel’s literature, is a good place to start; published cycle times are closer to actual execution times on the 386 and 486 than on the 8088, and are reasonably reliable indicators of the relative performance levels of x86 instructions.</p>
<section id="avoiding-loops-of-any-stripe" class="level4">
<h4><a href="#avoiding-loops-of-any-stripe">Avoiding LOOPS of Any Stripe</a></h4>
<p>Cycle counting and directly substituting instructions (<code>DEC CX/JNZ</code> for <code>LOOP</code>, for example) are techniques that belong at the lowest level of optimization. It’s an important level, but it’s fairly mechanical; once you’ve learned the capabilities and relative performance levels of the various instructions, you should be able to select the best instructions fairly easily. What’s more, this is a task at which compilers excel. What I’m saying is that you shouldn’t get too caught up in counting cycles because that’s a small (albeit important) part of the optimization picture, and not the area in which your greatest advantage lies.</p>
</section>
</section>
<section id="local-optimization" class="level3">
<h3><a href="#local-optimization">Local Optimization</a></h3>
<p>One level at which assembly language programming pays off handsomely is that of <em>local optimization;</em> that is, selecting the best <em>sequence</em> of instructions for a task. The key to local optimization is viewing the 80x86 instruction set as a set of building blocks, each with unique characteristics. Your job is to sequence those blocks so that they perform well. It doesn’t matter what the instructions are intended to do or what their names are; all that matters is what they <em>do.</em></p>
<p>Our discussion of <code>LOOP</code> versus <code>DEC/JNZ</code> is an excellent example of optimization by cycle counting. It’s worth knowing, but once you’ve learned it, you just routinely use <code>DEC/JNZ</code> at the bottom of loops in 386/486-specific code, and that’s that. Besides, you’ll save at most a few cycles each time, and while that helps a little, it’s not going to make all <em>that</em> much difference.</p>
<p>Now let’s step back for a moment, and with no preconceptions consider what the x86 instruction set can do for us. The bulk of the time with both <code>LOOP</code> and <code>DEC/JNZ</code> is taken up by branching, which just happens to be one of the slowest aspects of every processor in the x86 family, and the rest is taken up by decrementing the count register and checking whether it’s zero. There may be ways to perform those tasks a little faster by selecting different instructions, but they can get only so fast, and branching can’t even get all that fast.</p>
<blockquote>
<p><img src="images/i.jpg" /> The trick, then, is not to find the fastest way to decrement a count and branch conditionally, but rather to figure out how to accomplish the same result without decrementing or branching as often. Remember the Kobiyashi Maru problem in <em>Star Trek</em>? The same principle applies here: Redefine the problem to one that offers better solutions.</p>
</blockquote>
<p>Consider Listing 7.1, which searches a buffer until either the specified byte is found, a zero byte is found, or the specified number of characters have been checked. Such a function would be useful for scanning up to a maximum number of characters in a zero-terminated buffer. Listing 7.1, which uses <code>LOOP</code> in the main loop, performs a search of the sample string for a period (‘.’) in 170 µs on a 20 MHz cached 386.</p>
<p>When the <code>LOOP</code> in Listing 7.1 is replaced with <code>DEC CX/JNZ</code>, performance improves to 168 µs, less than 2 percent faster than Listing 7.1. Actually, instruction fetching, instruction alignment, cache characteristics, or something similar is affecting these results; I’d expect a slightly larger improvement—around 7 percent—but that’s the most that counting cycles could buy us in this case. (All right, already; <code>LOOPNZ</code> could be used at the bottom of the loop, and other optimizations are surely possible, but all that won’t add up to anywhere near the benefits we’re about to see from local optimization, and that’s the whole point.)</p>
<p><strong>LISTING 7.1 L7-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate searching through a buffer of a specified</span>
<span class="co">; length until either a specified byte or a zero byte is</span>
<span class="co">; encountered.</span>
<span class="co">; A standard loop terminated with LOOP is used.</span>

        .model      small
        .stack<span class="bn">      100h</span>
        .data
<span class="co">; Sample string to search through.</span>
SampleString        labelbyte
        <span class="dt">db</span>   ‘This is a sample string of a long enough length <span class="st">&#39;</span>
        <span class="dt">db</span>   ‘so that raw searching speed can outweigh any <span class="st">&#39;</span>
        <span class="dt">db</span>   ‘extra set-up time that may be required.<span class="st">&#39;,0</span>
SAMPLE_STRING_LENGTH  <span class="dt">equ</span>  <span class="dv">$</span>-SampleString

<span class="co">; User prompt.</span>
Prompt     <span class="dt">db</span>      ‘Enter character to search for:<span class="dv">$</span><span class="st">&#39;</span>

<span class="co">; Result status messages.</span>
ByteFoundMsg         <span class="dt">db</span><span class="bn">    0dh,</span>0ah
                     <span class="dt">db</span>    ‘Specified <span class="dt">byte</span> found.<span class="st">&#39;,0dh,0ah,‘$&#39;</span>
ZeroByteFoundMsg <span class="dt">db</span><span class="bn">  0dh, </span>0ah
                     <span class="dt">db</span>    ‘Zero <span class="dt">byte</span> encountered.<span class="st">&#39;,0dh,0ah,‘$&#39;</span>
NoByteFoundMsg       <span class="dt">db</span><span class="bn">    0dh,</span>0ah
                     <span class="dt">db</span>    ‘Buffer exhausted with no match.<span class="st">&#39;, 0dh, 0ah, ‘$&#39;</span>

    .code
Startprocnear
    <span class="kw">mov</span>  <span class="kw">ax</span>,@data    <span class="co">;point to standard data segment</span>
    <span class="kw">mov</span>  <span class="kw">ds</span>,<span class="kw">ax</span>
    <span class="kw">mov</span>  <span class="kw">dx</span>,offset Prompt
    <span class="kw">mov</span>  <span class="kw">ah</span>,<span class="dv">9</span>               <span class="co">;DOS print string function</span>
    <span class="kw">int</span><span class="bn">  21h                </span><span class="co">;prompt the user</span>
    <span class="kw">mov</span>  <span class="kw">ah</span>,<span class="dv">1</span>               <span class="co">;DOS get key function</span>
    <span class="kw">int</span><span class="bn">  21h                </span><span class="co">;get the key to search for</span>
    <span class="kw">mov</span>  <span class="kw">ah</span>,<span class="kw">al</span>              <span class="co">;put character to search for in AH</span>
    <span class="kw">mov</span>  <span class="kw">cx</span>,SAMPLE_STRING_LENGTH        <span class="co">;# of bytes to search</span>
    <span class="kw">mov</span>  <span class="kw">si</span>,offset SampleString         <span class="co">;point to buffer to search</span>
    <span class="kw">call</span> SearchMaxLength                <span class="co">;search the buffer</span>
    <span class="kw">mov</span>  <span class="kw">dx</span>,offset ByteFoundMsg         <span class="co">;assume we found the byte</span>
    <span class="kw">jc</span>   PrintStatus                    <span class="co">;we did find the byte</span>
                                        <span class="co">;we didn&#39;t find the byte, figure out</span>
                                        <span class="co">;whether we found a zero byte or</span>
                                        <span class="co">;ran out of buffer</span>
    <span class="kw">mov</span> <span class="kw">dx</span>,offset NoByteFoundMsg
                                        <span class="co">;assume we didn&#39;t find a zero byte</span>
    <span class="kw">jcxz</span> PrintStatus                    <span class="co">;we didn&#39;t find a zero byte</span>
    <span class="kw">mov</span>  <span class="kw">dx</span>,offset ZeroByteFoundMsg     <span class="co">;we found a zero byte</span>
<span class="fu">PrintStatus:</span>
    <span class="kw">mov</span>  <span class="kw">ah</span>,<span class="dv">9</span>             <span class="co">;DOS print string function</span>
    <span class="kw">int</span><span class="bn">  21h              </span><span class="co">;report status</span>
    <span class="kw">mov</span>  <span class="kw">ah</span><span class="bn">,4ch           </span><span class="co">;return to DOS</span>
    <span class="kw">int</span><span class="bn">  21h</span>
Startendp

<span class="co">; Function to search a buffer of a specified length until either a</span>
<span class="co">; specified byte or a zero byte is encountered.</span>
<span class="co">; Input:</span>
<span class="co">;    AH = character to search for</span>
<span class="co">;    CX = maximum length to be searched (must be &gt; 0)</span>
<span class="co">;    DS:SI = pointer to buffer to be searched</span>
<span class="co">; Output:</span>
<span class="co">;    CX = 0 if and only if we ran out of bytes without finding</span>
<span class="co">;         either the desired byte or a zero byte</span>
<span class="co">;    DS:SI = pointer to searched-for byte if found, otherwise byte</span>
<span class="co">;         after zero byte if found, otherwise byte after last</span>
<span class="co">;         byte checked if neither searched-for byte nor zero</span>
<span class="co">;         byte is found</span>
<span class="co">;    Carry Flag = set if searched-for byte found, reset otherwise</span>

SearchMaxLengthprocnear
      <span class="kw">cld</span>
<span class="fu">SearchMaxLengthLoop:</span>
      <span class="kw">lodsb</span>                        <span class="co">;get the next byte</span>
      <span class="kw">cmp</span>   <span class="kw">al</span>,<span class="kw">ah</span>                  <span class="co">;is this the byte we want?</span>
      <span class="kw">jz</span>    ByteFound              <span class="co">;yes, we&#39;re done with success</span>
      <span class="kw">and</span>   <span class="kw">al</span>,<span class="kw">al</span>                  <span class="co">;is this the terminating 0 byte?</span>
      <span class="kw">jz</span>    ByteNotFound           <span class="co">;yes, we&#39;re done with failure</span>
      <span class="kw">loop</span>  SearchMaxLengthLoop    <span class="co">;it&#39;s neither, so check the next</span>
                                   <span class="co">;byte, if any</span>
<span class="fu">ByteNotFound:</span>
      <span class="kw">clc</span>                          <span class="co">;return &quot;not found&quot; status</span>
      <span class="kw">ret</span>
<span class="fu">ByteFound:</span>
      <span class="kw">dec</span>   <span class="kw">si</span>                     <span class="co">;point back to the location at which</span>
                                   <span class="co">;we found the searched-for byte</span>
      <span class="kw">stc</span>                          <span class="co">;return &quot;found&quot; status</span>
      <span class="kw">ret</span>
SearchMaxLengthendp
      end   Start</code></pre>
</section>
<section id="unrolling-loops" class="level3">
<h3><a href="#unrolling-loops">Unrolling Loops</a></h3>
<p>Listing 7.2 takes a different tack, unrolling the loop so that four bytes are checked for each <code>LOOP</code> performed. The same instructions are used inside the loop in each listing, but Listing 7.2 is arranged so that three-quarters of the <code>LOOP</code>s are eliminated. Listings 7.1 and 7.2 perform exactly the same task, and they use the same instructions in the loop—the searching algorithm hasn’t changed in any way—but we have sequenced the instructions differently in Listing 7.2, and that makes all the difference.</p>
<p><strong>LISTING 7.2 L7-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate searching through a buffer of a specified</span>
<span class="co">; length until a specified zero byte is encountered.</span>
<span class="co">; A loop unrolled four times and terminated with LOOP is used.</span>

       .model      small
       .stack<span class="bn">      100h</span>
       .data
<span class="co">; Sample string to search through.</span>
SampleStringlabelbyte
        <span class="dt">db</span>     ‘This is a sample string of a long enough length <span class="st">&#39;</span>
        <span class="dt">db</span>     ‘so that raw searching speed can outweigh any <span class="st">&#39;</span>
        <span class="dt">db</span>     ‘extra set-up time that may be required.<span class="st">&#39;,0</span>
SAMPLE_STRING_LENGTH  <span class="dt">equ</span>  <span class="dv">$</span>-SampleString

<span class="co">; User prompt.</span>
Prompt  <span class="dt">db</span>        ‘Enter character to search for:<span class="dv">$</span><span class="st">&#39;</span>

<span class="co">; Result status messages.</span>
ByteFoundMsg          <span class="dt">db</span><span class="bn">      0dh,</span>0ah
                      <span class="dt">db</span>      ‘Specified <span class="dt">byte</span> found.<span class="st">&#39;,0dh,0ah,‘$&#39;</span>
ZeroByteFoundMsg <span class="dt">db</span><span class="bn">   0dh,</span>0ah
                      <span class="dt">db</span>      ‘Zero <span class="dt">byte</span> encountered.<span class="st">&#39;, 0dh, 0ah, ‘$&#39;</span>
NoByteFoundMsg        <span class="dt">db</span><span class="bn">      0dh,</span>0ah
                      <span class="dt">db</span>      ‘Buffer exhausted with no match.<span class="st">&#39;, 0dh, 0ah, ‘$&#39;</span>

<span class="co">; Table of initial, possibly partial loop entry points for</span>
<span class="co">; SearchMaxLength.</span>
SearchMaxLengthEntryTable    labelword
     <span class="dt">dw</span>     SearchMaxLengthEntry4
     <span class="dt">dw</span>     SearchMaxLengthEntry1
     <span class="dt">dw</span>     SearchMaxLengthEntry2
     <span class="dt">dw</span>     SearchMaxLengthEntry3

     .code
Start proc  near
      <span class="kw">mov</span>   <span class="kw">ax</span>,@data     <span class="co">;point to standard data segment</span>
      <span class="kw">mov</span>   <span class="kw">ds</span>,<span class="kw">ax</span>
      <span class="kw">mov</span>   <span class="kw">dx</span>,offset Prompt
      <span class="kw">mov</span>   <span class="kw">ah</span>,<span class="dv">9</span>             <span class="co">;DOS print string function</span>
      <span class="kw">int</span><span class="bn">   21h              </span><span class="co">;prompt the user</span>
      <span class="kw">mov</span>   <span class="kw">ah</span>,<span class="dv">1</span>             <span class="co">;DOS get key function</span>
      <span class="kw">int</span><span class="bn">   21h              </span><span class="co">;get the key to search for</span>
      <span class="kw">mov</span>   <span class="kw">ah</span>,<span class="kw">al</span>            <span class="co">;put character to search for in AH</span>
      <span class="kw">mov</span>   <span class="kw">cx</span>,SAMPLE_STRING_LENGTH       <span class="co">;# of bytes to search</span>
      <span class="kw">mov</span>   <span class="kw">si</span>,offset SampleString        <span class="co">;point to buffer to search</span>
      <span class="kw">call</span>  SearchMaxLength               <span class="co">;search the buffer</span>
      <span class="kw">mov</span>   <span class="kw">dx</span>,offset ByteFoundMsg        <span class="co">;assume we found the byte</span>
      <span class="kw">jc</span>    PrintStatus      <span class="co">;we did find the byte</span>
                             <span class="co">;we didn&#39;t find the byte, figure out</span>
                             <span class="co">;whether we found a zero byte or</span>
                             <span class="co">;ran out of buffer</span>
      <span class="kw">mov</span>   <span class="kw">dx</span>,offset NoByteFoundMsg
                             <span class="co">;assume we didn&#39;t find a zero byte</span>
      <span class="kw">jcxz</span>  PrintStatus      <span class="co">;we didn&#39;t find a zero byte</span>
      <span class="kw">mov</span>   <span class="kw">dx</span>,offset ZeroByteFoundMsg  <span class="co">;we found a zero byte</span>
<span class="fu">PrintStatus:</span>
      <span class="kw">mov</span>   <span class="kw">ah</span>,<span class="dv">9</span>             <span class="co">;DOS print string function</span>
      <span class="kw">int</span><span class="bn">   21h              </span><span class="co">;report status</span>

      <span class="kw">mov</span>   <span class="kw">ah</span><span class="bn">,4ch           </span><span class="co">;return to DOS</span>
      <span class="kw">int</span><span class="bn">   21h</span>
Startendp

<span class="co">; Function to search a buffer of a specified length until either a</span>
<span class="co">; specified byte or a zero byte is encountered.</span>
<span class="co">; Input:</span>
<span class="co">;    AH = character to search for</span>
<span class="co">;    CX = maximum length to be searched (must be &gt; 0)</span>
<span class="co">;    DS:SI = pointer to buffer to be searched</span>
<span class="co">; Output:</span>
<span class="co">;    CX = 0 if and only if we ran out of bytes without finding</span>
<span class="co">;          either the desired byte or a zero byte</span>
<span class="co">;    DS:SI = pointer to searched-for byte if found, otherwise byte</span>
<span class="co">;          after zero byte if found, otherwise byte after last</span>
<span class="co">;          byte checked if neither searched-for byte nor zero</span>
<span class="co">;          byte is found</span>
<span class="co">;    Carry Flag = set if searched-for byte found, reset otherwise</span>

SearchMaxLength proc near
     <span class="kw">cld</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>,<span class="kw">cx</span>
     <span class="kw">add</span>   <span class="kw">cx</span>,<span class="dv">3</span>               <span class="co">;calculate the maximum # of passes</span>
     <span class="kw">shr</span>   <span class="kw">cx</span>,<span class="dv">1</span>               <span class="co">;through the loop, which is</span>
     <span class="kw">shr</span>   <span class="kw">cx</span>,<span class="dv">1</span>               <span class="co">;unrolled 4 times</span>
     <span class="kw">and</span>   <span class="kw">bx</span>,<span class="dv">3</span>               <span class="co">;calculate the index into the entry</span>
                              <span class="co">;point table for the first,</span>
                              <span class="co">;possibly partial loop</span>
     <span class="kw">shl</span>   <span class="kw">bx</span>,<span class="dv">1</span>               <span class="co">;prepare for a word-sized look-up</span>
     <span class="kw">jmp</span>   SearchMaxLengthEntryTable[<span class="kw">bx</span>]
                                  <span class="co">;branch into the unrolled loop to do</span>
                                  <span class="co">;the first, possibly partial loop</span>
<span class="fu">SearchMaxLengthLoop:</span>
<span class="fu">SearchMaxLengthEntry4:</span>
     <span class="kw">lodsb</span>                    <span class="co">;get the next byte</span>
     <span class="kw">cmp</span>   <span class="kw">al</span>,<span class="kw">ah</span>              <span class="co">;is this the byte we want?</span>
     <span class="kw">jz</span>    ByteFound          <span class="co">;yes, we&#39;re done with success</span>
     <span class="kw">and</span>   <span class="kw">al</span>,<span class="kw">al</span>              <span class="co">;is this the terminating 0 byte?</span>
     <span class="kw">jz</span>    ByteNotFound       <span class="co">;yes, we&#39;re done with failure</span>
<span class="fu">SearchMaxLengthEntry3:</span>
     <span class="kw">lodsb</span>                    <span class="co">;get the next byte</span>
     <span class="kw">cmp</span>   <span class="kw">al</span>,<span class="kw">ah</span>              <span class="co">;is this the byte we want?</span>
     <span class="kw">jz</span>    ByteFound          <span class="co">;yes, we&#39;re done with success</span>
     <span class="kw">and</span>   <span class="kw">al</span>,<span class="kw">al</span>              <span class="co">;is this the terminating 0 byte?</span>
     <span class="kw">jz</span>    ByteNotFound       <span class="co">;yes, we&#39;re done with failure</span>
<span class="fu">SearchMaxLengthEntry2:</span>
     <span class="kw">lodsb</span>                    <span class="co">;get the next byte</span>
     <span class="kw">cmp</span>   <span class="kw">al</span>,<span class="kw">ah</span>              <span class="co">;is this the byte we want?</span>
     <span class="kw">jz</span>    ByteFound          <span class="co">;yes, we&#39;re done with success</span>
     <span class="kw">and</span>   <span class="kw">al</span>,<span class="kw">al</span>              <span class="co">;is this the terminating 0 byte?</span>
     <span class="kw">jz</span>    ByteNotFound       <span class="co">;yes, we&#39;re done with failure</span>
<span class="fu">SearchMaxLengthEntry1:</span>
     <span class="kw">lodsb</span>                          <span class="co">;get the next byte</span>
     <span class="kw">cmp</span>    <span class="kw">al</span>,<span class="kw">ah</span>                   <span class="co">;is this the byte we want?</span>
     <span class="kw">jz</span>     ByteFound               <span class="co">;yes, we&#39;re done with success</span>
     <span class="kw">and</span>    <span class="kw">al</span>,<span class="kw">al</span>                   <span class="co">;is this the terminating 0 byte?</span>
     <span class="kw">jz</span>     ByteNotFound            <span class="co">;yes, we&#39;re done with failure</span>
     <span class="kw">loop</span>   SearchMaxLengthLoop     <span class="co">;it&#39;s neither, so check the next</span>
                                    <span class="co">; four bytes, if any</span>
<span class="fu">ByteNotFound:</span>
     <span class="kw">clc</span>                      <span class="co">;return &quot;not found&quot; status</span>
<span class="kw">ret</span>
<span class="fu">ByteFound:</span>
     <span class="kw">dec</span>    <span class="kw">si</span>                <span class="co">;point back to the location at which</span>
                              <span class="co">; we found the searched-for byte</span>
     <span class="kw">stc</span>                      <span class="co">;return &quot;found&quot; status</span>
     <span class="kw">ret</span>
SearchMaxLengthendp
     end    Start</code></pre>
<p>How much difference? Listing 7.2 runs in 121 µs—40 percent faster than Listing 7.1, even though Listing 7.2 still uses <code>LOOP</code> rather than <code>DEC CX/JNZ</code>. (The loop in Listing 7.2 could be unrolled further, too; it’s just a question of how much more memory you want to trade for ever-decreasing performance benefits.) That’s typical of local optimization; it won’t often yield the order-of-magnitude improvements that algorithmic improvements can produce, but it can get you a critical 50 percent or 100 percent improvement when you’ve exhausted all other avenues.</p>
<blockquote>
<p><img src="images/i.jpg" /> The point is simply this: You can gain far more by stepping back a bit and thinking of the fastest overall way for the CPU to perform a task than you can by saving a cycle here or there using different instructions. Try to think at the level of sequences of instructions rather than individual instructions, and learn to treat x86 instructions as building blocks with unique characteristics rather than as instructions dedicated to specific tasks.</p>
</blockquote>
<section id="rotating-and-shifting-with-tables" class="level4">
<h4><a href="#rotating-and-shifting-with-tables">Rotating and Shifting with Tables</a></h4>
<p>As another example of local optimization, consider the matter of rotating or shifting a mask into position. First, let’s look at the simple task of setting bit N of AX to 1.</p>
<p>The obvious way to do this is to place N in CL, rotate the bit into position, and OR it with AX, as follows:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">MOV</span>  <span class="kw">BX</span>,<span class="dv">1</span>
<span class="kw">SHL</span>  <span class="kw">BX</span>,<span class="kw">CL</span>
<span class="kw">OR</span>   <span class="kw">AX</span>,<span class="kw">BX</span></code></pre>
<p>This solution is obvious because it takes good advantage of the special ability of the x86 family to shift or rotate by the variable number of bits specified by CL. However, it takes an average of about 45 cycles on an 8088. It’s actually far faster to precalculate the results, pass the bit number in BX, and look the shifted bit up, as shown in Listing 7.3.</p>
<p><strong>LISTING 7.3 L7-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">     <span class="kw">SHL</span>  <span class="kw">BX</span>,<span class="dv">1</span>                <span class="co">;prepare for word sized look up</span>
     <span class="kw">OR</span>   <span class="kw">AX</span>,ShiftTable[<span class="kw">BX</span>]   <span class="co">;look up the bit and OR it in</span>
          :
ShiftTable     LABEL     <span class="dt">WORD</span>
BIT_PATTERN=0001H
     REPT <span class="dv">16</span>
     <span class="dt">DW</span>   BIT_PATTERN
BIT_PATTERN=BIT_PATTERN <span class="kw">SHL</span> <span class="dv">1</span>
     ENDM</code></pre>
<p>Even though it accesses memory, this approach takes only 20 cycles—more than twice as fast as the variable shift. Once again, we were able to improve performance considerably—not by knowing the fastest instructions, but by selecting the fastest <em>sequence</em> of instructions.</p>
<p>In the particular example above, we once again run into the difficulty of optimizing across the x86 family. The table lookup is faster on the 8088 and 286, but it’s slightly slower on the 386 and no faster on the 486. However, 386/486-specific code could use enhanced addressing to accomplish the whole job in just one instruction, along the lines of the code snippet in Listing 7.4.</p>
<p><strong>LISTING 7.4 L7-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">     <span class="kw">OR</span>   <span class="kw">EAX</span>,ShiftTable[<span class="kw">EBX</span>*<span class="dv">4</span>]    <span class="co">;look up the bit and OR it in</span>
          :
ShiftTable     LABEL     <span class="dt">DWORD</span>
BIT_PATTERN=0001H
     REPT <span class="dv">32</span>
     <span class="dt">DD</span>   BIT_PATTERN
BIT_PATTERN=BIT_PATTERN <span class="kw">SHL</span> <span class="dv">1</span>
     ENDM</code></pre>
<blockquote>
<p><img src="images/i.jpg" /> Besides illustrating the advantages of local optimization, this example also shows that it generally pays to precalculate results; this is often done at or before assembly time, but precalculated tables can also be built at run time. This is merely one aspect of a fundamental optimization rule: Move as much work as possible out of your critical code by whatever means necessary.</p>
</blockquote>
</section>
<section id="not-flips-bitsnot-flags" class="level4">
<h4><a href="#not-flips-bitsnot-flags">NOT Flips Bits—Not Flags</a></h4>
<p>The <code>NOT</code> instruction flips all the bits in the operand, from 0 to 1 or from 1 to 0. That’s as simple as could be, but <code>NOT</code> nonetheless has a minor but interesting talent: It doesn’t affect the flags. That can be irritating; I once spent a good hour tracking down a bug caused by my unconscious assumption that <code>NOT</code> does set the flags. After all, every other arithmetic and logical instruction sets the flags; why not <code>NOT</code>? Probably because <code>NOT</code> isn’t considered to be an arithmetic or logical instruction at all; rather, it’s a data manipulation instruction, like <code>MOV</code> and the various rotates. (These are <code>RCR</code>, <code>RCL</code>, <code>ROR</code>, and <code>ROL</code>, which affect only the Carry and Overflow flags.) NOT is often used for tasks, such as flipping masks, where there’s no reason to test the state of the result, and in that context it can be handy to keep the flags unmodified for later testing.</p>
<blockquote>
<p><img src="images/i.jpg" /> Besides, if you want to <code>NOT</code> an operand and set the flags in the process, you can just <code>XOR</code> it with -1. Put another way, the only functional difference between <code>NOT AX</code> and <code>XOR AX,0FFFFH</code> is that <code>XOR</code> modifies the flags and <code>NOT</code> doesn’t.</p>
</blockquote>
<p>The x86 instruction set offers many ways to accomplish almost any task. Understanding the subtle distinctions between the instructions—whether and which flags are set, for example—can be critical when you’re trying to optimize a code sequence and you’re running out of registers, or when you’re trying to minimize branching.</p>
</section>
<section id="incrementing-with-and-without-carry" class="level4">
<h4><a href="#incrementing-with-and-without-carry">Incrementing with and without Carry</a></h4>
<p>Another case in which there are two slightly different ways to perform a task involves adding 1 to an operand. You can do this with <code>INC</code>, as in <code>INC AX</code>, or you can do it with <code>ADD</code>, as in <code>ADD AX,1</code>. What’s the difference? The obvious difference is that <code>INC</code> is usually a byte or two shorter (the exception being <code>ADD AL,1</code>, which at two bytes is the same length as <code>INC AL</code>), and is faster on some processors. Less obvious, but no less important, is that <code>ADD</code> sets the Carry flag while <code>INC</code> leaves the Carry flag untouched.</p>
<p>Why is that important? Because it allows <code>INC</code> to function as a data pointer manipulation instruction for multi-word arithmetic. You can use <code>INC</code> to advance the pointers in code like that shown in Listing 7.5 without having to do any work to preserve the Carry status from one addition to the next.</p>
<p><strong>LISTING 7.5 L7-5.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">        <span class="kw">CLC</span>                  <span class="co">;clear the Carry for the initial addition</span>
<span class="fu">LOOP_TOP:</span>
        <span class="kw">MOV</span>    <span class="kw">AX</span>,[<span class="kw">SI</span>]<span class="co">;get next source operand word</span>
        <span class="kw">ADC</span>    [<span class="kw">DI</span>],<span class="kw">AX</span><span class="co">;add with Carry to dest operand word</span>
        <span class="kw">INC</span>    <span class="kw">SI</span>            <span class="co">;point to next source operand word</span>
        <span class="kw">INC</span>    <span class="kw">SI</span>
        <span class="kw">INC</span>    <span class="kw">DI</span>            <span class="co">;point to next dest operand word</span>
        <span class="kw">INC</span>    <span class="kw">DI</span>
        <span class="kw">LOOP</span>   LOOP_TOP</code></pre>
<p>If <code>ADD</code> were used, the Carry flag would have to be saved between additions, with code along the lines shown in Listing 7.6.</p>
<p><strong>LISTING 7.6 L7-6.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">     <span class="kw">CLC</span>            <span class="co">;clear the carry for the initial addition</span>
<span class="fu">LOOP_TOP:</span>
     <span class="kw">MOV</span>  <span class="kw">AX</span>,[<span class="kw">SI</span>]   <span class="co">;get next source operand word</span>
     <span class="kw">ADC</span>  [<span class="kw">DI</span>],<span class="kw">AX</span>   <span class="co">;add with carry to dest operand word</span>
     <span class="kw">LAHF</span>           <span class="co">;set aside the carry flag</span>
     <span class="kw">ADD</span>  <span class="kw">SI</span>,<span class="dv">2</span>      <span class="co">;point to next source operand word</span>
     <span class="kw">ADD</span>  <span class="kw">DI</span>,<span class="dv">2</span>      <span class="co">;point to next dest operand word</span>
     <span class="kw">SAHF</span>           <span class="co">;restore the carry flag</span>
     <span class="kw">LOOP</span> LOOP_TOP</code></pre>
<p>It’s not that the Listing 7.6 approach is necessarily better or worse; that depends on the processor and the situation. The Listing 7.6 approach is <em>different,</em> and if you understand the differences, you’ll be able to choose the best approach for whatever code you happen to write. (<code>DEC</code> has the same property of preserving the Carry flag, by the way.)</p>
<p>There are a couple of interesting aspects to the last example. First, note that <code>LOOP</code> doesn’t affect any flags at all; this allows the Carry flag to remain unchanged from one addition to the next. Not altering the arithmetic flags is a common characteristic of program control instructions (as opposed to arithmetic and logical instructions like <code>SUB</code> and <code>AND</code>, which do alter the flags).</p>
<blockquote>
<p><img src="images/i.jpg" /> The rule is not that the arithmetic flags change whenever the CPU performs a calculation; rather, the flags change whenever you execute an arithmetic, logical, or flag control (such as <code>CLC</code> to clear the Carry flag) instruction.</p>
</blockquote>
<p>Not only do <code>LOOP</code> and <code>JCXZ</code> not alter the flags, but <code>REP MOVS</code>, which counts down CX to 0, doesn’t affect the flags either.</p>
<p>The other interesting point about the last example is the use of <code>LAHF</code> and <code>SAHF</code>, which transfer the low byte of the FLAGS register to and from AH, respectively. These instructions were created to help provide compatibility with the 8080’s (that’s <em>8080</em>, not <em>8088</em>) <code>PUSH</code> <code>PSW</code> and <code>POP PSW</code> instructions, but turn out to be compact (one byte) instructions for saving and restoring the arithmetic flags. A word of caution, however: <code>SAHF</code> restores the Carry, Zero, Sign, Auxiliary Carry, and Parity flags—but <em>not</em> the Overflow flag, which resides in the high byte of the FLAGS register. Also, be aware that <code>LAHF</code> and <code>SAHF</code> provide a fast way to preserve the flags on an 8088 but are relatively slow instructions on the 486 and Pentium.</p>
<p>There are times when it’s a clear liability that <code>INC</code> doesn’t set the Carry flag. For instance</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">INC</span>   <span class="kw">AX</span>
<span class="kw">ADC</span>   <span class="kw">DX</span>,<span class="dv">0</span></code></pre>
<p>does <em>not</em> increment the 32-bit value in DX:AX. To do that, you’d need the following:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">ADD</span>   <span class="kw">AX</span>,<span class="dv">1</span>
<span class="kw">ADC</span>   <span class="kw">DX</span>,<span class="dv">0</span></code></pre>
<p>As always, pay attention!</p>
</section>
</section>
</section>
<section id="chapter-8-speeding-up-c-with-assembly-language" class="level2">
<h2><a href="#chapter-8-speeding-up-c-with-assembly-language">Chapter 8 – Speeding Up C with Assembly Language</a></h2>
<section id="jumping-languages-when-you-know-itll-help" class="level3">
<h3><a href="#jumping-languages-when-you-know-itll-help">Jumping Languages When You Know It’ll Help</a></h3>
<p>When I was a senior in high school, a pop song called “Seasons in the Sun,” sung by one Terry Jacks, soared up the pop charts and spent, as best I can recall, two straight weeks atop <em>Kasey Kasem’s American Top 40.</em> “Seasons in the Sun” wasn’t a particularly good song, primarily because the lyrics were silly. I’ve never understood why the song was a hit, but, as so often happens with undistinguished but popular music by forgotten one- or two-shot groups (“Don’t Pull Your Love Out on Me Baby,” “Billy Don’t Be a Hero,” <em>et al.</em>), I heard it everywhere for a month or so, then gave it not another thought for 15 years.</p>
<p>Recently, though, I came across a review of a Rhino Records collection of obscure 1970s pop hits. Knowing that Jeff Duntemann is an aficionado of such esoterica (who do <em>you</em> know who owns an album by The Peppermint Trolley Company?), I sent the review to him. He was amused by it and, as we kicked the names of old songs around, “Seasons in the Sun” came up. I expressed my wonderment that a song that really wasn’t very good was such a big hit.</p>
<p>“Well,” said Jeff, “I think it suffered in the translation from the French.”</p>
<p>Ah-ha! Mystery solved. Apparently everyone but me knew that it was translated from French, and that novelty undoubtedly made the song a big hit. The translation was also surely responsible for the sappy lyrics; dollars to donuts that the original French lyrics were stronger.</p>
<p>Which brings us without missing a beat to this chapter’s theme, speeding up C with assembly language. When you seek to speed up a C program by converting selected parts of it (generally no more than a few functions) to assembly language, make sure you end up with high-performance assembly language code, not fine-tuned C code. Compilers like Microsoft C/C++ and Watcom C are by now pretty good at fine-tuning C code, and you’re not likely to do much better by taking the compiler’s assembly language output and tweaking it.</p>
<blockquote>
<p><img src="images/i.jpg" /> To make the process of translating C code to assembly language worth the trouble, you must ignore what the compiler does and design your assembly language code from a pure assembly language perspective. With a merely adequate translation, you risk laboring mightily for little or no reward.</p>
</blockquote>
<p>Apropos of which, when was the last time you heard of Terry Jacks?</p>
<section id="billy-dont-be-a-compiler" class="level4">
<h4><a href="#billy-dont-be-a-compiler">Billy, Don’t Be a Compiler</a></h4>
<p>The key to optimizing C programs with assembly language is, as always, writing good assembly language code, but with an added twist. Rule 1 when converting C code to assembly is this: <em>Don’t think like a compiler.</em> That’s more easily said than done, especially when the C code you’re converting is readily available as a model and the assembly code that the compiler generates is available as well. Nevertheless, the principle of not thinking like a compiler is essential, and is, in one form or another, the basis for all that I’ll discuss below.</p>
<p>Before I discuss Rule 1 further, let me mention rule number 0: <em>Only optimize where it matters.</em> The bulk of execution time in any program is spent in a very small portion of the code, and most code beyond that small portion doesn’t have any perceptible impact on performance. Unless you’re supremely concerned with code size (an area in which assembly-only programs can excel), I’d suggest that you write most of your code in C and reserve assembly for the truly critical sections of your code; that’s the formula that I find gives the most bang for the buck.</p>
<p>This is not to say that complete programs shouldn’t be <em>designed</em> with optimized assembly language in mind. As you’ll see shortly, orienting your data structures towards assembly language can be a salubrious endeavor indeed, even if most of your code is in C. When it comes to actually optimizing code and/or converting it to assembly, though, do it only where it matters. Get a profiler—and use it!</p>
<p>Also make it a point to concentrate on refining your program design and algorithmic approach at the conceptual and/or C levels before doing any assembly language optimization.</p>
<blockquote>
<p><img src="images/i.jpg" /> Assembly language optimization is the final and far from the only step in the optimization chain, and as such should be performed last; converting to assembly too soon can lock in your code before the design is optimal. At the very least, conversion to assembly tends to make future changes and debugging more difficult, slowing you down and limiting your options.</p>
</blockquote>
</section>
</section>
<section id="dont-call-your-functions-on-me-baby" class="level3">
<h3><a href="#dont-call-your-functions-on-me-baby">Don’t Call Your Functions on Me, Baby</a></h3>
<p>In order to think differently from a compiler, you must understand both what compilers and C programmers tend to do and how that differs from what assembly language does well. In this pursuit, it can be useful to examine the code your compiler generates, either by viewing the code in a debugger or by having the compiler generate an assembly language output file. (The latter is done with /Fa or /Fc in Microsoft C/C++ and -S in Borland C++.)</p>
<p>C programmers tend to modularize their code with lots of function calls. That’s good for readable, reliable, reusable code, and it allows the compiler to optimize better because it can deal with fewer variables and statements in each optimization arena—but it’s not so good when viewed from the assembly language level. Calls and returns are slow, especially in the large code model, and the pushes required to put parameters on the stack are expensive as well.</p>
<p>What this means is that when you want to speed up a portion of a C program, you should identify the entire critical portion and move <em>all</em> of that critical portion into an assembly language function. You don’t want to move a part of the inner loop into assembly language and then call it from C every time through the loop; the function call and return overhead would be unacceptable. Carve out the critical code <em>en masse</em> and move it into assembly, and try to avoid calls and returns even in your assembly code. True, in assembly you can pass parameters in registers, but the calls and returns themselves are still slow; if the extra cycles they take don’t affect performance, then the code they’re in probably isn’t critical, and perhaps you’ve chosen to convert too much code to assembly, eh?</p>
</section>
<section id="stack-frames-slow-so-much" class="level3">
<h3><a href="#stack-frames-slow-so-much">Stack Frames Slow So Much</a></h3>
<p>C compilers work within the stack frame model, whereby variables reside in a block of stack memory and are accessed via offsets from BP. Compilers may store a couple of variables in registers and may briefly keep other variables in registers when they’re used repeatedly, but the stack frame is the underlying architecture. It’s a nice architecture; it’s flexible, convenient, easy to program, and makes for fairly compact code. However, stack frames have a few drawbacks. They must be constructed and destroyed, which takes both time and code. They are so easy to use that they tend to bias the assembly language programmer in favor of accessing memory variables more often than might be necessary. Finally, you cannot use BP as a general-purpose register if you intend to access a stack frame, and having that seventh register available is sometimes useful indeed.</p>
<p>That doesn’t mean you shouldn’t use stack frames, which are useful and often necessary. Just don’t fall victim to their undeniable charms.</p>
</section>
<section id="torn-between-two-segments" class="level3">
<h3><a href="#torn-between-two-segments">Torn Between Two Segments</a></h3>
<p>C compilers are not terrific at handling segments. Some compilers can efficiently handle a single far pointer used in a loop by leaving ES set for the duration of the loop. But two far pointers used in the same loop confuse every compiler I’ve seen, causing the full segment:offset address to be reloaded each time either pointer is used.</p>
<blockquote>
<p><img src="images/i.jpg" /> This particularly affects performance in 286 protected mode (under OS/2 1.X or the Rational DOS Extender, for example) because segment loads in protected mode take a minimum of 17 cycles, versus a mere 2 cycles in real mode.</p>
</blockquote>
<p>In assembly language you have full control over segments. Use it, and, if necessary, reorganize your code to minimize segment loading.</p>
<section id="why-speeding-up-is-hard-to-do" class="level4">
<h4><a href="#why-speeding-up-is-hard-to-do">Why Speeding Up Is Hard to Do</a></h4>
<p>You might think that the most obvious advantage assembly language has over C is that it allows the use of all forms of instructions and all registers in all ways, whereas C compilers tend to use a subset of registers and instructions in a limited number of ways. Yes and no. It’s true that C compilers typically don’t generate instructions such as <code>XLAT</code>, rotates, or the string instructions. On the other hand, <code>XLAT</code> and rotates are useful in a limited set of circumstances, and string instructions <em>are</em> used in the C library functions. In fact, C library code is likely to be carefully optimized by experts, and may be much better than equivalent code you’d produce yourself.</p>
<p>Am I saying that C compilers produce better code than you do? No, I’m saying that they <em>can</em>, unless you use assembly language properly. Writing code in assembly language rather than C guarantees nothing.</p>
<blockquote>
<p><img src="images/i.jpg" /> You can write good assembly, bad assembly, or assembly that is virtually indistinguishable from compiled code; you are more likely than not to write the latter if you think that optimization consists of tweaking compiled C code.</p>
</blockquote>
<p>Sure, you can probably use the registers more efficiently and take advantage of an instruction or two that the compiler missed, but the code isn’t going to get a whole lot faster that way.</p>
<p>True optimization requires rethinking your code to take advantage of assembly language. A C loop that searches through an integer array for matches might compile</p>
<figure>
<img src="images/08-01.jpg" alt="Figure 8.1  Tweaked compiler output for a loop." /><figcaption><strong>Figure 8.1</strong>  <em>Tweaked compiler output for a loop.</em></figcaption>
</figure>
<p>to something like Figure 8.1A. You might look at that and tweak it to the code shown in Figure 8.1B.</p>
<p>Congratulations! You’ve successfully eliminated all stack frame access, you’ve used <code>LOOP</code> (although <code>DEC SI/JNZ</code> is actually faster on 386 and later machines, as I explained in the last chapter), and you’ve used a string instruction. Unfortunately, the new code isn’t going to run very much faster. Maybe 25 percent faster, maybe a little more. Big deal. You’ve eliminated the trappings of the compiler—the stack frame and the restricted register usage—but you’re still <em>thinking</em> like the compiler. Try this:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">repnz <span class="kw">scasw</span>
<span class="kw">jz</span>    Match</code></pre>
<p>It’s a simple example—but, I hope, a convincing one. Stretch your brain when you optimize.</p>
</section>
</section>
<section id="taking-it-to-the-limit" class="level3">
<h3><a href="#taking-it-to-the-limit">Taking It to the Limit</a></h3>
<p>The ultimate in assembly language optimization comes when you change the rules; that is, when you reorganize the entire program to allow the use of better assembly language code in the small section of code that most affects overall performance. For example, consider that the data searched in the last example is stored in an array of structures, with each structure in the array containing other information as well. In this situation, <code>REP SCASW</code> couldn’t be used because the data searched through wouldn’t be contiguous.</p>
<p>However, if the need for performance in searching the array is urgent enough, there’s no reason why you can’t reorganize the data. This might mean removing the array elements from the structures and storing them in their own array so that <code>REP SCASW</code> <em>could</em> be used.</p>
<blockquote>
<p><img src="images/i.jpg" /> Organizing a program’s data so that the performance of the critical sections can be optimized is a key part of design, and one that’s easily shortchanged unless, during the design stage, you thoroughly understand and work to bring together your data needs, the critical sections of your program, and potential assembly language optimizations.</p>
</blockquote>
<p>More on this shortly.</p>
<p>To recap, here are some things to look for when striving to convert C code into optimized assembly language:</p>
<ul>
<li>Move the entire performance-critical section into a single assembly language function.</li>
<li>Don’t use calls or stack frame accesses inside the critical code, if possible, and avoid unnecessary memory accesses of any kind.</li>
<li>Change segments as infrequently as possible.</li>
<li>Optimize in terms of what assembly does well, <em>not</em> in terms of fine-tuning compiled C code.</li>
<li>Change the rules to the benefit of assembly, if necessary; for example, reorganize data structto allow efficient assembly language processing.</li>
</ul>
<p>That said, let me show some of these precepts in action.</p>
<section id="a-c-to-assembly-case-study" class="level4">
<h4><a href="#a-c-to-assembly-case-study">A C-to-Assembly Case Study</a></h4>
<p>Listing 8.1 is the sample C application I’m going to use to examine optimization in action. Listing 8.1 isn’t really complete—it doesn’t handle the “no-matches” case well, and it assumes that the sum of all matches will fit into an <code>int</code>-but it will do just fine as an optimization example.</p>
<p><strong>LISTING 8.1 L8-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Program to search an array spanning a linked list of variable-</span>
<span class="co">   sized blocks, for all entries with a specified ID number,</span>
<span class="co">   and return the average of the values of all such entries. Each of</span>
<span class="co">   the variable-sized blocks may contain any number of data entries,</span>
<span class="co">   stored as an array of structures within the block. */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#ifdef __TURBOC__</span>
<span class="ot">#include &lt;alloc.h&gt;</span>
<span class="ot">#else</span>
<span class="ot">#include &lt;malloc.h&gt;</span>
<span class="ot">#endif</span>

<span class="dt">void</span> main(<span class="dt">void</span>);
<span class="dt">void</span> exit(<span class="dt">int</span>);
<span class="dt">unsigned</span> <span class="dt">int</span> FindIDAverage(<span class="dt">unsigned</span> <span class="dt">int</span>, <span class="kw">struct</span> BlockHeader *);
<span class="co">/* Structure that starts each variable-sized block */</span>
<span class="kw">struct</span> BlockHeader {
   <span class="kw">struct</span> BlockHeader *NextBlock; <span class="co">/* Pointer to next block, or NULL</span>
<span class="co">                                     if this is the last block in the</span>
<span class="co">                                     linked list */</span>
   <span class="dt">unsigned</span> <span class="dt">int</span> BlockCount;       <span class="co">/* The number of DataElement entries</span>
<span class="co">                                     in this variable-sized block */</span>
};

<span class="co">/* Structure that contains one element of the array we&#39;ll search */</span>
<span class="kw">struct</span> DataElement {
   <span class="dt">unsigned</span> <span class="dt">int</span> ID;     <span class="co">/* ID # for array entry */</span>
   <span class="dt">unsigned</span> <span class="dt">int</span> Value;  <span class="co">/* Value of array entry */</span>
};

<span class="dt">void</span> main(<span class="dt">void</span>) {
   <span class="dt">int</span> i,j;
   <span class="dt">unsigned</span> <span class="dt">int</span> IDToFind;
   <span class="kw">struct</span> BlockHeader *BaseArrayBlockPointer,*WorkingBlockPointer;
   <span class="kw">struct</span> DataElement *WorkingDataPointer;
   <span class="kw">struct</span> BlockHeader **LastBlockPointer;

   printf(<span class="st">&quot;ID # for which to find average: &quot;</span>);
   scanf(<span class="st">&quot;%d&quot;</span>,&amp;IDToFind);
   <span class="co">/* Build an array across 5 blocks, for testing */</span>
   <span class="co">/* Anchor the linked list to BaseArrayBlockPointer */</span>
   LastBlockPointer = &amp;BaseArrayBlockPointer;
   <span class="co">/* Create 5 blocks of varying sizes */</span>
   <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt; <span class="dv">6</span>; i++) {
      <span class="co">/* Try to get memory for the next block */</span>
      <span class="kw">if</span> ((WorkingBlockPointer =
          (<span class="kw">struct</span> BlockHeader *) malloc(<span class="kw">sizeof</span>(<span class="kw">struct</span> BlockHeader) +
           <span class="kw">sizeof</span>(<span class="kw">struct</span> DataElement) * i * <span class="dv">10</span>)) == NULL) {
         exit(<span class="dv">1</span>);
      }
      <span class="co">/* Set the # of data elements in this block */</span>
      WorkingBlockPointer-&gt;BlockCount = i * <span class="dv">10</span>;
      <span class="co">/* Link the new block into the chain */</span>
      *LastBlockPointer = WorkingBlockPointer;
      <span class="co">/* Point to the first data field */</span>
      WorkingDataPointer =
            (<span class="kw">struct</span> DataElement *) ((<span class="dt">char</span> *)WorkingBlockPointer +
            <span class="kw">sizeof</span>(<span class="kw">struct</span> BlockHeader));
      <span class="co">/* Fill the data fields with ID numbers and values */</span>
      <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; (i * <span class="dv">10</span>); j++, WorkingDataPointer++) {
         WorkingDataPointer-&gt;ID = j;
         WorkingDataPointer-&gt;Value = i * <span class="dv">1000</span> + j;
      }
      <span class="co">/* Remember where to set link from this block to the next */</span>
      LastBlockPointer = &amp;WorkingBlockPointer-&gt;NextBlock;
   }
   <span class="co">/* Set the last block&#39;s &quot;next block&quot; pointer to NULL to indicate</span>
<span class="co">      that there are no more blocks */</span>
   WorkingBlockPointer-&gt;NextBlock = NULL;
   printf(<span class="st">&quot;Average of all elements with ID %d: %u</span><span class="ch">\n</span><span class="st">&quot;</span>,
         IDToFind, FindIDAverage(IDToFind, BaseArrayBlockPointer));
   exit(<span class="dv">0</span>);
}

<span class="co">/* Searches through the array of DataElement entries spanning the</span>
<span class="co">   linked list of variable-sized blocks, starting with the block</span>
<span class="co">   pointed to by BlockPointer, for all entries with IDs matching</span>
<span class="co">   SearchedForID, and returns the average value of those entries. If</span>
<span class="co">   no matches are found, zero is returned */</span>

<span class="dt">unsigned</span> <span class="dt">int</span> FindIDAverage(<span class="dt">unsigned</span> <span class="dt">int</span> SearchedForID,
      <span class="kw">struct</span> BlockHeader *BlockPointer)
{
   <span class="kw">struct</span> DataElement *DataPointer;
   <span class="dt">unsigned</span> <span class="dt">int</span> IDMatchSum;
   <span class="dt">unsigned</span> <span class="dt">int</span> IDMatchCount;
   <span class="dt">unsigned</span> <span class="dt">int</span> WorkingBlockCount;

   IDMatchCount = IDMatchSum = <span class="dv">0</span>;
   <span class="co">/* Search through all the linked blocks until the last block</span>
<span class="co">      (marked with a NULL pointer to the next block) has been</span>
<span class="co">      searched */</span>
   <span class="kw">do</span> {
      <span class="co">/* Point to the first DataElement entry within this block */</span>
      DataPointer =
            (<span class="kw">struct</span> DataElement *) ((<span class="dt">char</span> *)BlockPointer +
            <span class="kw">sizeof</span>(<span class="kw">struct</span> BlockHeader));
      <span class="co">/* Search all the DataElement entries within this block</span>
<span class="co">         and accumulate data from all that match the desired ID */</span>
      <span class="kw">for</span> (WorkingBlockCount=<span class="dv">0</span>;
            WorkingBlockCount&lt;BlockPointer-&gt;BlockCount;
            WorkingBlockCount++, DataPointer++) {
         <span class="co">/* If the ID matches, add in the value and increment the</span>
<span class="co">            match counter */</span>
         <span class="kw">if</span> (DataPointer-&gt;ID == SearchedForID) {
            IDMatchCount++;
            IDMatchSum += DataPointer-&gt;Value;
         }
      }
   <span class="co">/* Point to the next block, and continue as long as that pointer</span>
<span class="co">       isn&#39;t NULL */</span>
   }  <span class="kw">while</span> ((BlockPointer = BlockPointer-&gt;NextBlock) != NULL);
   <span class="co">/* Calculate the average of all matches */</span>
   <span class="kw">if</span> (IDMatchCount == <span class="dv">0</span>)
      <span class="kw">return</span>(<span class="dv">0</span>);            <span class="co">/* Avoid division by 0 */</span>
   <span class="kw">else</span>
      <span class="kw">return</span>(IDMatchSum / IDMatchCount);
}</code></pre>
<p>The main body of Listing 8.1 constructs a linked list of memory blocks of various sizes and stores an array of structures across those blocks, as shown in Figure 8.2. The function <code>FindIDAverage</code> in Listing 8.1 searches through that array for all matches to a specified ID number and returns the average value of all such matches. <code>FindIDAverage</code> contains two nested loops, the outer one repeating once for each linked block and the inner one repeating once for each array element in each block. The inner loop—the critical one—is compact, containing only four statements, and should lend itself rather well to compiler optimization.</p>
<figure>
<img src="images/08-02.jpg" alt="Figure 8.2  Linked array storage format (version 1)." /><figcaption><strong>Figure 8.2</strong>  <em>Linked array storage format (version 1).</em></figcaption>
</figure>
<p>As it happens, Microsoft C/C++ does optimize the inner loop of <code>FindIDAverage</code> nicely. Listing 8.2 shows the code Microsoft C/C++ generates for the inner loop, consisting of a mere seven assembly language instructions inside the loop. The compiler is smart enough to convert the loop index variable, which counts up but is used for nothing but counting loops, into a count-down variable so that the <code>LOOP</code> instruction can be used.</p>
<p><strong>LISTING 8.2 L8-2.COD</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Code generated by Microsoft C for inner loop of FindIDAverage.</span>
<span class="co">;|*** for (WorkingBlockCount=0;</span>
<span class="co">;|***       WorkingBlockCount&lt;BlockPointer-&gt;BlockCount;</span>
<span class="co">;|***       WorkingBlockCount++, DataPointer++) {</span>
          <span class="kw">mov</span>     <span class="dt">WORD</span> <span class="dt">PTR</span> [<span class="kw">bp</span><span class="dv">-6</span>],<span class="dv">0</span>         <span class="co">;WorkingBlockCount</span>
          <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="dt">WORD</span> <span class="dt">PTR</span> [<span class="kw">bp</span><span class="dv">+6</span>]        <span class="co">;BlockPointer</span>
          <span class="kw">cmp</span>     <span class="dt">WORD</span> <span class="dt">PTR</span> [<span class="kw">bx</span><span class="dv">+2</span>],<span class="dv">0</span>
          <span class="kw">je</span>      <span class="dv">$</span>FB264
          <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dt">WORD</span> <span class="dt">PTR</span> [<span class="kw">bx</span><span class="dv">+2</span>]
          <span class="kw">add</span>     <span class="dt">WORD</span> <span class="dt">PTR</span> [<span class="kw">bp</span><span class="dv">-6</span>],<span class="kw">cx</span>        <span class="co">;WorkingBlockCount</span>
          <span class="kw">mov</span>     <span class="kw">di</span>,<span class="dt">WORD</span> <span class="dt">PTR</span> [<span class="kw">bp</span><span class="dv">-2</span>]        <span class="co">;IDMatchSum</span>
          <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dt">WORD</span> <span class="dt">PTR</span> [<span class="kw">bp</span><span class="dv">-4</span>]        <span class="co">;IDMatchCount</span>
<span class="fu">$L20004:</span>
<span class="co">;|*** if (DataPointer-&gt;ID == SearchedForID) {</span>
          <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dt">WORD</span> <span class="dt">PTR</span> [<span class="kw">si</span>]
          <span class="kw">cmp</span>     <span class="dt">WORD</span> <span class="dt">PTR</span> [<span class="kw">bp</span><span class="dv">+4</span>],<span class="kw">ax</span>        <span class="co">;SearchedForID</span>
          <span class="kw">jne</span>     <span class="dv">$</span>I265
<span class="co">;|***             IDMatchCount++;</span>
          <span class="kw">inc</span>     <span class="kw">dx</span>
<span class="co">;|***            IDMatchSum += DataPointer-&gt;Value;</span>
          <span class="kw">add</span>     <span class="kw">di</span>,<span class="dt">WORD</span> <span class="dt">PTR</span> [<span class="kw">si</span><span class="dv">+2</span>]
<span class="co">;|***          }</span>
<span class="co">;|***       }</span>
<span class="fu">$I265:</span>
          <span class="kw">add</span>     <span class="kw">si</span>,<span class="dv">4</span>
          <span class="kw">loop</span>    <span class="dv">$</span>L20004
          <span class="kw">mov</span>     <span class="dt">WORD</span> <span class="dt">PTR</span> [<span class="kw">bp</span><span class="dv">-2</span>],<span class="kw">di</span>        <span class="co">;IDMatchSum</span>
          <span class="kw">mov</span>     <span class="dt">WORD</span> <span class="dt">PTR</span> [<span class="kw">bp</span><span class="dv">-4</span>],<span class="kw">dx</span>        <span class="co">;IDMatchCount</span>
<span class="fu">$FB264:</span></code></pre>
<p>It’s hard to squeeze much more performance from this code by tweaking it, as exemplified by Listing 8.3, a fine-tuned assembly version of <code>FindIDAverage</code> that was produced by looking at the assembly output of MS C/C++ and tightening it. Listing 8.3 eliminates all stack frame access in the inner loop, but that’s about all the tightening there is to do. The result, as shown in Table 8.1, is that Listing 8.3 runs a modest 11 percent faster than Listing 8.1 on a 386. The results could vary considerably, depending on the nature of the data set searched through (average block size and frequency of matches). But, then, understanding the typical and worst case conditions is part of optimization, isn’t it?</p>
<p><strong>LISTING 8.3 L8-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Typically optimized assembly language version of FindIDAverage.</span>
SearchedForID   <span class="dt">equ</span>     <span class="dv">4</span>      <span class="co">;Passed parameter offsets in the</span>
BlockPointer    <span class="dt">equ</span>     <span class="dv">6</span>      <span class="co">; stack frame (skip over pushed BP</span>
<span class="co">; and the return address)</span>
NextBlock       <span class="dt">equ</span>     <span class="dv">0</span>      <span class="co">;Field offsets in struct BlockHeader</span>
BlockCount      <span class="dt">equ</span>     <span class="dv">2</span>
BLOCK_HEADER_SIZE <span class="dt">equ</span>   <span class="dv">4</span>      <span class="co">;Number of bytes in struct BlockHeader</span>
ID              <span class="dt">equ</span>     <span class="dv">0</span>      <span class="co">;struct DataElement field offsets</span>
Value           <span class="dt">equ</span>     <span class="dv">2</span>
DATA_ELEMENT_SIZE <span class="dt">equ</span>   <span class="dv">4</span>      <span class="co">;Number of bytes in struct DataElement</span>
        .model  small
        .code
        public  _FindIDAverage</code></pre>
<table>
<caption>Table 8.1 Execution Times of FindIDAverage.</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">On 20 MHz 386</th>
<th style="text-align: left;">On 10 MHz 286</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Listing 8.1</strong> (MSC with maximum optimization)</td>
<td style="text-align: left;">294 microseconds</td>
<td style="text-align: left;">768 microseconds</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Listing 8.3</strong> (Assembly)</td>
<td style="text-align: left;">265</td>
<td style="text-align: left;">644</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Listing 8.4</strong> (Optimized assembly)</td>
<td style="text-align: left;">212</td>
<td style="text-align: left;">486</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Listing 8.6</strong> (Optimized assembly with reorganized data)</td>
<td style="text-align: left;">100</td>
<td style="text-align: left;">207</td>
</tr>
</tbody>
</table>
<pre class="sourceCode nasm"><code class="sourceCode nasm">_FindIDAverage  proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>              <span class="co">;Save caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>           <span class="co">;Point to our stack frame</span>
        <span class="kw">push</span>    <span class="kw">di</span>              <span class="co">;Preserve C register variables</span>
        <span class="kw">push</span>    <span class="kw">si</span>
        <span class="kw">sub</span>     <span class="kw">dx</span>,<span class="kw">dx</span>           <span class="co">;IDMatchSum = 0</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">dx</span>           <span class="co">;IDMatchCount = 0</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+BlockPointer]    <span class="co">;Pointer to first block</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SearchedForID]   <span class="co">;ID we&#39;re looking for</span>
<span class="co">; Search through all the linked blocks until the last block</span>
<span class="co">; (marked with a NULL pointer to the next block) has been searched.</span>
<span class="fu">BlockLoop:</span>
<span class="co">; Point to the first DataElement entry within this block.</span>
        <span class="kw">lea</span>     <span class="kw">di</span>,[<span class="kw">si</span>+BLOCK_HEADER_SIZE]
<span class="co">; Search through all the DataElement entries within this block</span>
<span class="co">; and accumulate data from all that match the desired ID.</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">si</span>+BlockCount]
        <span class="kw">jcxz</span>    DoNextBlock     <span class="co">;No data in this block</span>
<span class="fu">IntraBlockLoop:</span>
        <span class="kw">cmp</span>     [<span class="kw">di</span>+ID],<span class="kw">ax</span>      <span class="co">;Do we have an ID match?</span>
        <span class="kw">jnz</span>     NoMatch         <span class="co">;No match</span>
        <span class="kw">inc</span>     <span class="kw">bx</span>              <span class="co">;We have a match; IDMatchCount++;</span>
        <span class="kw">add</span>     <span class="kw">dx</span>,[<span class="kw">di</span>+Value]   <span class="co">;IDMatchSum += DataPointer-&gt;Value;</span>
<span class="fu">NoMatch:</span>
        <span class="kw">add</span>     <span class="kw">di</span>,DATA_ELEMENT_SIZE <span class="co">;point to the next element</span>
        <span class="kw">loop</span>    IntraBlockLoop
<span class="co">; Point to the next block and continue if that pointer isn&#39;t NULL.</span>
<span class="fu">DoNextBlock:</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">si</span>+NextBlock] <span class="co">;Get pointer to the next block</span>
        <span class="kw">and</span>     <span class="kw">si</span>,<span class="kw">si</span>           <span class="co">;Is it a NULL pointer?</span>
        <span class="kw">jnz</span>     BlockLoop       <span class="co">;No, continue</span>
<span class="co">; Calculate the average of all matches.</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>           <span class="co">;Assume we found no matches</span>
        <span class="kw">and</span>     <span class="kw">bx</span>,<span class="kw">bx</span>
        <span class="kw">jz</span>      Done            <span class="co">;We didn&#39;t find any matches, return 0</span>
        <span class="kw">xchg</span>    <span class="kw">ax</span>,<span class="kw">dx</span>           <span class="co">;Prepare for division</span>
        <span class="kw">div</span>     <span class="kw">bx</span>              <span class="co">;Return IDMatchSum / IDMatchCount</span>
<span class="fu">Done:</span>   <span class="kw">pop</span>     <span class="kw">si</span>              <span class="co">;Restore C register variables</span>
        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>              <span class="co">;Restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_FindIDAverage  ENDP
        end</code></pre>
<p>Listing 8.4 tosses some sophisticated optimization techniques into the mix. The loop is unrolled eight times, eliminating a good deal of branching, and <code>SCASW</code> is used instead of <code>CMP [DI],AX</code>. (Note, however, that <code>SCASW</code> is in fact slower than <code>CMP [DI],AX</code> on the 386 and 486, and is sometimes faster on the 286 and 8088 only because it’s shorter and therefore may prefetch faster.) This advanced tweaking produces a 39 percent improvement over the original C code—substantial, but not a tremendous return for the optimization effort invested.</p>
<p><strong>LISTING 8.4 L8-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Heavily optimized assembly language version of FindIDAverage.</span>
<span class="co">; Features an unrolled loop and more efficient pointer use.</span>
SearchedForID   <span class="dt">equ</span>     <span class="dv">4</span>       <span class="co">;Passed parameter offsets in the</span>
BlockPointer    <span class="dt">equ</span>     <span class="dv">6</span>       <span class="co">; stack frame (skip over pushed BP</span>
                                <span class="co">; and the return address)</span>
NextBlock       <span class="dt">equ</span>     <span class="dv">0</span>       <span class="co">;Field offsets in struct BlockHeader</span>
BlockCount      <span class="dt">equ</span>     <span class="dv">2</span>
BLOCK_HEADER_SIZE <span class="dt">equ</span>   <span class="dv">4</span>       <span class="co">;Number of bytes in struct BlockHeader</span>
ID              <span class="dt">equ</span>     <span class="dv">0</span>       <span class="co">;struct DataElement field offsets</span>
Value           <span class="dt">equ</span>     <span class="dv">2</span>
DATA_ELEMENT_SIZE <span class="dt">equ</span>   <span class="dv">4</span>       <span class="co">;Number of bytes in struct DataElement</span>
        .model  small
        .code
        public  _FindIDAverage
_FindIDAverage  proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>              <span class="co">;Save caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>           <span class="co">;Point to our stack frame</span>
        <span class="kw">push</span>    <span class="kw">di</span>              <span class="co">;Preserve C register variables</span>
        <span class="kw">push</span>    <span class="kw">si</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">ds</span>           <span class="co">;Prepare for SCASW</span>
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">di</span>
        <span class="kw">cld</span>
        <span class="kw">sub</span>     <span class="kw">dx</span>,<span class="kw">dx</span>           <span class="co">;IDMatchSum = 0</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">dx</span>           <span class="co">;IDMatchCount = 0</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+BlockPointer]    <span class="co">;Pointer to first block</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SearchedForID]   <span class="co">;ID we&#39;re looking for</span>
<span class="co">; Search through all of the linked blocks until the last block</span>
<span class="co">; (marked with a NULL pointer to the next block) has been searched.</span>
<span class="fu">BlockLoop:</span>
<span class="co">; Point to the first DataElement entry within this block.</span>
        <span class="kw">lea</span>     <span class="kw">di</span>,[<span class="kw">si</span>+BLOCK_HEADER_SIZE]
<span class="co">; Search through all the DataElement entries within this block</span>
<span class="co">; and accumulate data from all that match the desired ID.</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">si</span>+BlockCount] <span class="co">;Number of elements in this block</span>
        <span class="kw">jcxz</span>    DoNextBlock     <span class="co">;Skip this block if it&#39;s empty</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">cx</span>           <span class="co">;***stack frame no longer available***</span>
        <span class="kw">add</span>     <span class="kw">cx</span>,<span class="dv">7</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>            <span class="co">;Number of repetitions of the unrolled</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>            <span class="co">; loop = (BlockCount + 7) / 8</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>
        <span class="kw">and</span>     <span class="kw">bp</span>,<span class="dv">7</span>            <span class="co">;Generate the entry point for the</span>
        <span class="kw">shl</span>     <span class="kw">bp</span>,<span class="dv">1</span>            <span class="co">; first, possibly partial pass through</span>
        <span class="kw">jmp</span>     <span class="kw">cs</span>:[LoopEntryTable+<span class="kw">bp</span>] <span class="co">; the unrolled loop and</span>
                                <span class="co">; vector to that entry point</span>
        <span class="kw">align</span>   <span class="dv">2</span>
LoopEntryTable  label   <span class="dt">word</span>
        <span class="dt">dw</span>      LoopEntry8,LoopEntry1,LoopEntry2,LoopEntry3
        <span class="dt">dw</span>      LoopEntry4,LoopEntry5,LoopEntry6,LoopEntry7
M_IBL   macro   P1
        local   NoMatch
LoopEntry&amp;P1&amp;:
        <span class="kw">scasw</span>                   <span class="co">;Do we have an ID match?</span>
        <span class="kw">jnz</span>     NoMatch         <span class="co">;No match</span>
                                <span class="co">;We have a match</span>
        <span class="kw">inc</span>     <span class="kw">bx</span>              <span class="co">;IDMatchCount++;</span>
        <span class="kw">add</span>     <span class="kw">dx</span>,[<span class="kw">di</span>]         <span class="co">;IDMatchSum += DataPointer-&gt;Value;</span>
<span class="fu">NoMatch:</span>
        <span class="kw">add</span>     <span class="kw">di</span>,DATA_ELEMENT_SIZE<span class="dv">-2</span> <span class="co">;point to the next element</span>
                                <span class="co">; (SCASW advanced 2 bytes already)</span>
        endm
        <span class="kw">align</span>   <span class="dv">2</span>
<span class="fu">IntraBlockLoop:</span>
        M_IBL   <span class="dv">8</span>
        M_IBL   <span class="dv">7</span>
        M_IBL   <span class="dv">6</span>
        M_IBL   <span class="dv">5</span>
        M_IBL   <span class="dv">4</span>
        M_IBL   <span class="dv">3</span>
        M_IBL   <span class="dv">2</span>
        M_IBL   <span class="dv">1</span>
        <span class="kw">loop</span>    IntraBlockLoop
<span class="co">; Point to the next block and continue if that pointer isn&#39;t NULL.</span>
<span class="fu">DoNextBlock:</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">si</span>+NextBlock] <span class="co">;Get pointer to the next block</span>
        <span class="kw">and</span>     <span class="kw">si</span>,<span class="kw">si</span>           <span class="co">;Is it a NULL pointer?</span>
        <span class="kw">jnz</span>     BlockLoop       <span class="co">;No, continue</span>
<span class="co">; Calculate the average of all matches.</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>           <span class="co">;Assume we found no matches</span>
        <span class="kw">and</span>     <span class="kw">bx</span>,<span class="kw">bx</span>
        <span class="kw">jz</span>      Done            <span class="co">;We didn&#39;t find any matches, return 0</span>
        <span class="kw">xchg</span>    <span class="kw">ax</span>,<span class="kw">dx</span>           <span class="co">;Prepare for division</span>
        <span class="kw">div</span>     <span class="kw">bx</span>              <span class="co">;Return IDMatchSum / IDMatchCount</span>
<span class="fu">Done:</span>   <span class="kw">pop</span>     <span class="kw">si</span>              <span class="co">;Restore C register variables</span>
        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>              <span class="co">;Restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_FindIDAverage  ENDP
        end</code></pre>
<p>Listings 8.5 and 8.6 together go the final step and change the rules in favor of assembly language. Listing 8.5 creates the same list of linked blocks as Listing 8.1. However, instead of storing an array of structures within each block, it stores <em>two</em> arrays in each block, one consisting of ID numbers and the other consisting of the corresponding values, as shown in Figure 8.3. No information is lost; the data is merely rearranged.</p>
<p><strong>LISTING 8.5 L8-5.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Program to search an array spanning a linked list of variable-</span>
<span class="co">   sized blocks, for all entries with a specified ID number,</span>
<span class="co">   and return the average of the values of all such entries. Each of</span>
<span class="co">   the variable-sized blocks may contain any number of data entries,</span>
<span class="co">   stored in the form of two separate arrays, one for ID numbers and</span>
<span class="co">   one for values. */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#ifdef __TURBOC__</span>
<span class="ot">#include &lt;alloc.h&gt;</span>
<span class="ot">#else</span>
<span class="ot">#include &lt;malloc.h&gt;</span>
<span class="ot">#endif</span>

<span class="dt">void</span> main(<span class="dt">void</span>);
<span class="dt">void</span> exit(<span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">unsigned</span> <span class="dt">int</span> FindIDAverage2(<span class="dt">unsigned</span> <span class="dt">int</span>,
                                   <span class="kw">struct</span> BlockHeader *);</code></pre>
<figure>
<img src="images/08-03.jpg" alt="Figure 8.3  Linked array storage format (version 2)." /><figcaption><strong>Figure 8.3</strong>  <em>Linked array storage format (version 2).</em></figcaption>
</figure>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Structure that starts each variable-sized block */</span>
<span class="kw">struct</span> BlockHeader {
   <span class="kw">struct</span> BlockHeader *NextBlock; <span class="co">/* Pointer to next block, or NULL</span>
<span class="co">                                     if this is the last block in the</span>
<span class="co">                                     linked list */</span>
   <span class="dt">unsigned</span> <span class="dt">int</span> BlockCount;       <span class="co">/* The number of DataElement entries</span>
<span class="co">                                     in this variable-sized block */</span>
};

<span class="dt">void</span> main(<span class="dt">void</span>) {
   <span class="dt">int</span> i,j;
   <span class="dt">unsigned</span> <span class="dt">int</span> IDToFind;
   <span class="kw">struct</span> BlockHeader *BaseArrayBlockPointer,*WorkingBlockPointer;
   <span class="dt">int</span> *WorkingDataPointer;
   <span class="kw">struct</span> BlockHeader **LastBlockPointer;

   printf(<span class="st">&quot;ID # for which to find average: &quot;</span>);
   scanf(<span class="st">&quot;%d&quot;</span>,&amp;IDToFind);

   <span class="co">/* Build an array across 5 blocks, for testing */</span>
   <span class="co">/* Anchor the linked list to BaseArrayBlockPointer */</span>
   LastBlockPointer = &amp;BaseArrayBlockPointer;
   <span class="co">/* Create 5 blocks of varying sizes */</span>
   <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt; <span class="dv">6</span>; i++) {
      <span class="co">/* Try to get memory for the next block */</span>
      <span class="kw">if</span> ((WorkingBlockPointer =
          (<span class="kw">struct</span> BlockHeader *) malloc(<span class="kw">sizeof</span>(<span class="kw">struct</span> BlockHeader) +
           <span class="kw">sizeof</span>(<span class="dt">int</span>) * <span class="dv">2</span> * i * <span class="dv">10</span>)) == NULL) {
         exit(<span class="dv">1</span>);
      }
      <span class="co">/* Set the number of data elements in this block */</span>
      WorkingBlockPointer-&gt;BlockCount = i * <span class="dv">10</span>;
      <span class="co">/* Link the new block into the chain */</span>
      *LastBlockPointer = WorkingBlockPointer;
      <span class="co">/* Point to the first data field */</span>
      WorkingDataPointer = (<span class="dt">int</span> *) ((<span class="dt">char</span> *)WorkingBlockPointer +
            <span class="kw">sizeof</span>(<span class="kw">struct</span> BlockHeader));
      <span class="co">/* Fill the data fields with ID numbers and values */</span>
      <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; (i * <span class="dv">10</span>); j++, WorkingDataPointer++) {
         *WorkingDataPointer = j;
         *(WorkingDataPointer + i * <span class="dv">10</span>) = i * <span class="dv">1000</span> + j;
      }
      <span class="co">/* Remember where to set link from this block to the next */</span>
      LastBlockPointer = &amp;WorkingBlockPointer-&gt;NextBlock;
   }
   <span class="co">/* Set the last block&#39;s &quot;next block&quot; pointer to NULL to indicate</span>
<span class="co">      that there are no more blocks */</span>
   WorkingBlockPointer-&gt;NextBlock = NULL;
   printf(<span class="st">&quot;Average of all elements with ID %d: %u</span><span class="ch">\n</span><span class="st">&quot;</span>,
         IDToFind, FindIDAverage2(IDToFind, BaseArrayBlockPointer));
   exit(<span class="dv">0</span>);
}</code></pre>
<p><strong>LISTING 8.6 L8-6.ASM</strong></p>
<pre class="asm"><code>; Alternative optimized assembly language version of FindIDAverage
; requires data organized as two arrays within each block rather
; than as an array of two-value element structures. This allows the
; use of REP SCASW for ID searching.

SearchedForIDequ4               ;Passed parameter offsets in the
BlockPointerequ6                ; stack frame (skip over pushed BP
                                ; and the return address)
NextBlockequ0                   ;Field offsets in struct BlockHeader
BlockCountequ2
BLOCK_HEADER_SIZEequ4           ;Number of bytes in struct BlockHeader

        .model  small
        .code
        public  _FindIDAverage2
_FindIDAverage2 proc    near
        push    bp              ;Save caller&#39;s stack frame
        mov     bp,sp           ;Point to our stack frame
        push    di              ;Preserve C register variables
        push    si
        mov     di,ds           ;Prepare for SCASW
        mov     es,di
        cld
        mov     si,[bp+BlockPointer]    ;Pointer to first block
        mov     ax,[bp+SearchedForID]   ;ID we&#39;re looking for
        sub     dx,dx                       ;IDMatchSum = 0
        mov     bp,dx                       ;IDMatchCount = 0
                                            ;***stack frame no longer available***
; Search through all the linked blocks until the last block
; (marked with a NULL pointer to the next block) has been searched.
BlockLoop:
; Search through all the DataElement entries within this block
; and accumulate data from all that match the desired ID.
        mov     cx,[si+BlockCount]
        jcxz    DoNextBlock;Skip this block if there&#39;s no data
                                   ; to search through
        mov     bx,cx              ;We&#39;ll use BX to point to the
        shl     bx,1               ; corresponding value entry in the
; case of an ID match (BX is the
; length in bytes of the ID array)
; Point to the first DataElement entry within this block.
        lea     di,[si+BLOCK_HEADER_SIZE]
IntraBlockLoop:
        repnz   scasw              ;Search for the ID
        jnz     DoNextBlock        ;No match, the block is done
        inc     bp                 ;We have a match; IDMatchCount++;
        add     dx,[di+bx-2];IDMatchSum += DataPointer-&gt;Value;
; (SCASW has advanced DI 2 bytes)
        and     cx,cx              ;Is there more data to search through?
        jnz     IntraBlockLoop     ;yes
; Point to the next block and continue if that pointer isn&#39;t NULL.
DoNextBlock:
        mov     si,[si+NextBlock] ;Get pointer to the next block
        and     si,si           ;Is it a NULL pointer?
        jnz     BlockLoop       ;No, continue
; Calculate the average of all matches.
        sub     ax,ax           ;Assume we found no matches
        and     bp,bp
        jz      Done            ;We didn&#39;t find any matches, return 0
        xchg    ax,dx           ;Prepare for division
        div     bp              ;Return IDMatchSum / IDMatchCount
Done:   pop     si              ;Restore C register variables
        pop     di
        pop     bp              ;Restore caller&#39;s stack frame
        ret
_FindIDAverage2 ENDP
        end</code></pre>
<p>The whole point of this rearrangement is to allow us to use <code>REP SCASW</code> to search through each block, and that’s exactly what <code>FindIDAverage2</code> in Listing 8.6 does. The result: Listing 8.6 calculates the average about <em>three times</em> as fast as the original C implementation and more than twice as fast as Listing 8.4, heavily optimized as the latter code is.</p>
<p>I trust you get the picture. The sort of instruction-by-instruction optimization that so many of us love to do as a kind of puzzle is fun, but compilers can do it nearly as well as you can, and in the future will surely do it better. What a compiler <em>can’t</em> do is tie together the needs of the program specification on the high end and the processor on the low end, resulting in critical code that runs just about as fast as the hardware permits. The only software that can do that is located north of your sternum and slightly aft of your nose. Dust it off and put it to work—and your code will never again be confused with anything by Hamilton, Joe, Frank, eynolds or Bo Donaldson and the Heywoods.</p>
</section>
</section>
</section>
<section id="chapter-9-hints-my-readers-gave-me" class="level2">
<h2><a href="#chapter-9-hints-my-readers-gave-me">Chapter 9 – Hints My Readers Gave Me</a></h2>
<section id="optimization-odds-and-ends-from-the-field" class="level3">
<h3><a href="#optimization-odds-and-ends-from-the-field">Optimization Odds and Ends from the Field</a></h3>
<p>Back in high school, I took a pre-calculus class from Mr. Bourgeis, whose most notable characteristics were incessant pacing and truly enormous feet. My friend Barry, who sat in the back row, right behind me, claimed that it was because of his large feet that Mr. Bourgeis was so restless. Those feet were <em>so</em> heavy, Barry hypothesized, that if Mr. Bourgeis remained in any one place for too long, the floor would give way under the strain, plunging the unfortunate teacher deep into the mantle of the Earth and possibly all the way through to China. Many amusing cartoons were drawn to this effect.</p>
<p>Unfortunately, Barry was too busy drawing cartoons, or, alternatively, sleeping, to actually learn any math. In the long run, that didn’t turn out to be a handicap for Barry, who went on to become vice-president of sales for a ham-packing company, where presumably he was rarely called upon to derive the quadratic equation. Barry’s lack of scholarship caused some problems back then, though. On one memorable occasion, Barry was half-asleep, with his eyes open but unfocused and his chin balanced on his hand in the classic “if I fall asleep my head will fall off my hand and I’ll wake up” posture, when Mr. Bourgeis popped a killer problem:</p>
<p>“Barry, solve this for X, please.” On the blackboard lay the equation:</p>
<pre><code>X - 1 = 0</code></pre>
<p>“Minus 1,” Barry said promptly.</p>
<p>Mr. Bourgeis shook his head mournfully. “Try again.” Barry thought hard. He knew the fundamental rule that the answer to most mathematical questions is either 0, 1, infinity, -1, or minus infinity (do not apply this rule to balancing your checkbook, however); unfortunately, that gave him only a 25 percent chance of guessing right.</p>
<p>“One,” I whispered surreptitiously.</p>
<p>“Zero,” Barry announced. Mr. Bourgeis shook his head even more sadly.</p>
<p>“One,” I whispered louder. Barry looked still more thoughtful—a bad sign—so I whispered “one” again, even louder. Barry looked so thoughtful that his eyes nearly rolled up into his head, and I realized that he was just doing his best to convince Mr. Bourgeis that Barry had solved this one by himself.</p>
<p>As Barry neared the climax of his stirring performance and opened his mouth to speak, Mr. Bourgeis looked at him with great concern. “Barry, can you hear me all right?”</p>
<p>“Yes, sir,” Barry replied. “Why?”</p>
<p>“Well, I could hear the answer all the way up here. Surely you could hear it just one row away?”</p>
<p>The class went wild. They might as well have sent us home early for all we accomplished the rest of the day.</p>
<p>I like to think I know more about performance programming than Barry knew about math. Nonetheless, I always welcome good ideas and comments, and many readers have sent me a slew of those over the years. So in this chapter, I think I’ll return the favor by devoting a chapter to reader feedback.</p>
<section id="another-look-at-lea" class="level4">
<h4><a href="#another-look-at-lea">Another Look at LEA</a></h4>
<p>Several people have pointed out that while <code>LEA</code> is great for performing certain additions (see Chapter 6), it isn’t a perfect replacement for <code>ADD</code>. What’s the difference? <code>LEA</code>, an addressing instruction by trade, doesn’t affect the flags, while the arithmetic <code>ADD</code> instruction most certainly does. This is no problem when performing additions that involve only quantities that fit in one machine word (32 bits in 386 protected mode, 16 bits otherwise), but it renders <code>LEA</code> useless for multiword operations, which use the Carry flag to tie together partial results. For example, these instructions</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">ADD</span>  <span class="kw">EAX</span>,<span class="kw">EBX</span>
<span class="kw">ADC</span>  <span class="kw">EDX</span>,<span class="kw">ECX</span></code></pre>
<p>could <em>not</em> be replaced</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">LEA</span>  <span class="kw">EAX</span>,[<span class="kw">EAX</span>+<span class="kw">EBX</span>]
<span class="kw">ADC</span>  <span class="kw">EDX</span>,<span class="kw">ECX</span></code></pre>
<p>because <code>LEA</code> doesn’t affect the Carry flag.</p>
<p>The no-carry characteristic of <code>LEA</code> becomes a distinct advantage when performing pointer arithmetic, however. For instance, the following code uses <code>LEA</code> to advance the pointers while adding one 128-bit memory variable to another such variable:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">   <span class="kw">MOV</span>   <span class="kw">ECX</span>,<span class="dv">4</span>   <span class="co">;# of 32-bit words to add</span>
   <span class="kw">CLC</span>
<span class="co">;no carry into the initial ADC</span>
<span class="fu">ADDLOOP:</span>

   <span class="kw">MOV</span>   <span class="kw">EAX</span>,[<span class="kw">ESI</span>]    <span class="co">;get the next element of one array</span>
   <span class="kw">ADC</span>   [<span class="kw">EDI</span>],<span class="kw">EAX</span>    <span class="co">;add it to the other array, with carry</span>
   <span class="kw">LEA</span>   <span class="kw">ESI</span>,[<span class="kw">ESI</span><span class="dv">+4</span>]  <span class="co">;advance one array&#39;s pointer</span>
   <span class="kw">LEA</span>   <span class="kw">EDI</span>,[<span class="kw">EDI</span><span class="dv">+4</span>]  <span class="co">;advance the other array&#39;s pointer</span>
         <span class="kw">LOOP</span> ADDLOOP</code></pre>
<p>(Yes, I could use <code>LODSD</code> instead of <code>MOV/LEA</code>; I’m just illustrating a point here. Besides, <code>LODS</code> is only 1 cycle faster than <code>MOV/LEA</code> on the 386, and is actually more than twice as slow on the 486.) If we used <code>ADD</code> rather than <code>LEA</code> to advance the pointers, the carry from one <code>ADC</code> to the next would have to be preserved with either <code>PUSHF/POPF</code> or <code>LAHF/SAHF</code>. (Alternatively, we could use multiple <code>INC</code>s, since <code>INC</code> doesn’t affect the Carry flag.)</p>
<p>In short, <code>LEA</code> is indeed different from <code>ADD</code>. Sometimes it’s better. Sometimes not; that’s the nature of the various instruction substitutions and optimizations that will occur to you over time. There’s no such thing as “best” instructions on the x86; it all depends on what you’re trying to do.</p>
<p>But there sure are a lot of interesting options, aren’t there?</p>
</section>
<section id="the-kennedy-portfolio" class="level4">
<h4><a href="#the-kennedy-portfolio">The Kennedy Portfolio</a></h4>
<p>Reader John Kennedy regularly passes along intriguing assembly programming tricks, many of which I’ve never seen mentioned anywhere else. John likes to optimize for size, whereas I lean more toward speed, but many of his optimizations are good for both purposes. Here are a few of my favorites:</p>
<p>John’s code for setting AX to its absolute value is:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">CWD</span>
<span class="kw">XOR</span>   <span class="kw">AX</span>,<span class="kw">DX</span>
<span class="kw">SUB</span>   <span class="kw">AX</span>,<span class="kw">DX</span></code></pre>
<p>This does nothing when bit 15 of AX is 0 (that is, if AX is positive). When AX is negative, the code “nots” it and adds 1, which is exactly how you perform a two’s complement negate. For the case where AX is not negative, this trick usually beats the stuffing out of the standard absolute value code:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">   <span class="kw">AND</span>   <span class="kw">AX</span>,<span class="kw">AX</span>        <span class="co">;negative?</span>
   <span class="kw">JNS</span>   IsPositive   <span class="co">;no</span>
   <span class="kw">NEG</span>   <span class="kw">AX</span>           <span class="co">;yes,negate it</span>
<span class="fu">IsPositive:</span></code></pre>
<p>However, John’s code is slower on a 486; as you’re no doubt coming to realize (and as I’ll explain in Chapters 12 and 13), the 486 is an optimization world unto itself.</p>
<p>Here’s how John copies a block of bytes from DS:SI to ES:DI, moving as much data as possible a word at a time:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">SHR</span>   <span class="kw">CX</span>,<span class="dv">1</span>      <span class="co">;word count</span>
REP   <span class="kw">MOVSW</span>     <span class="co">;copy as many words as possible</span>
<span class="kw">ADC</span>   <span class="kw">CX</span>,<span class="kw">CX</span>     <span class="co">;CX=1 if copy length was odd,</span>
                <span class="co">;0 else</span>
REP   <span class="kw">MOVSB</span>     <span class="co">;copy any odd byte</span></code></pre>
<p>(<code>ADC CX,CX</code> can be replaced with <code>RCL CX,1</code>; which is faster depends on the processor type.) It might be hard to believe that the above is faster than this:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">   <span class="kw">SHR</span>   <span class="kw">CX</span>,<span class="dv">1</span>      <span class="co">;word count</span>
   REP   <span class="kw">MOVSW</span>     <span class="co">;copy as many words as</span>
                   <span class="co">;possible</span>
   <span class="kw">JNC</span>   CopyDone  <span class="co">;done if even copy length</span>
   <span class="kw">MOVSB</span>           <span class="co">;copy the odd byte</span>
<span class="fu">CopyDone:</span></code></pre>
<p>However, it generally is. Sure, if the length is odd, John’s approach incurs a penalty approximately equal to the <code>REP</code> startup time for <code>MOVSB</code>. However, if the length is even, John’s approach doesn’t branch, saving cycles and not emptying the prefetch queue. If copy lengths are evenly distributed between even and odd, John’s approach is faster in most x86 systems. (Not on the 486, though.)</p>
<p>John also points out that on the 386, multiple <code>LEA</code>s can be combined to perform multiplications that can’t be handled by a single <code>LEA</code>, much as multiple shifts and adds can be used for multiplication, only faster. <code>LEA</code> can be used to multiply in a single instruction on the 386, but only by the values 2, 3, 4, 5, 8, and 9; several <code>LEA</code>s strung together can handle a much wider range of values. For example, video programmers are undoubtedly familiar with the following code to multiply AX times 80 (the width in bytes of the bitmap in most PC display modes):</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">SHL</span>   <span class="kw">AX</span>,<span class="dv">1</span>        <span class="co">;*2</span>
SH   LAX,<span class="dv">1</span>        <span class="co">;*4</span>
SH   LAX,<span class="dv">1</span>        <span class="co">;*8</span>
SH   LAX,<span class="dv">1</span>        <span class="co">;*16</span>
MO   VBX,<span class="kw">AX</span>
SH   LAX,<span class="dv">1</span>        <span class="co">;*32</span>
SH   LAX,<span class="dv">1</span>        <span class="co">;*64</span>
<span class="kw">ADD</span>  <span class="kw">AX</span>,<span class="kw">BX</span>        <span class="co">;*80</span></code></pre>
<p>Using <code>LEA</code> on the 386, the above could be reduced to</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">LEA</span>   <span class="kw">EAX</span>,[<span class="kw">EAX</span>*<span class="dv">2</span>]     <span class="co">;*2</span>
<span class="kw">LEA</span>   <span class="kw">EAX</span>,[<span class="kw">EAX</span>*<span class="dv">8</span>]     <span class="co">;*16</span>
<span class="kw">LEA</span>   <span class="kw">EAX</span>,[<span class="kw">EAX</span>+<span class="kw">EAX</span>*<span class="dv">4</span>] <span class="co">;*80</span></code></pre>
<p>which still isn’t as fast as using a lookup table like</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">MOV</span>   <span class="kw">EAX</span>,MultiplesOf80Table[<span class="kw">EAX</span>*<span class="dv">4</span>]</code></pre>
<p>but is close and takes a great deal less space.</p>
<p>Of course, on the 386, the shift and add version could also be reduced to this considerably more efficient code:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">SH    LAX,<span class="dv">4</span>      <span class="co">;*16</span>
<span class="kw">MOV</span>   <span class="kw">BX</span>,<span class="kw">AX</span>
<span class="kw">SHL</span>   <span class="kw">AX</span>,<span class="dv">2</span>       <span class="co">;*64</span>
<span class="kw">ADD</span>   <span class="kw">AX</span>,<span class="kw">BX</span>      <span class="co">;*80</span></code></pre>
</section>
<section id="speeding-up-multiplication" class="level4">
<h4><a href="#speeding-up-multiplication">Speeding Up Multiplication</a></h4>
<p>That brings us to multiplication, one of the slowest of x86 operations and one that allows for considerable optimization. One way to speed up multiplication is to use shift and add, <code>LEA</code>, or a lookup table to hard-code a multiplication operation for a fixed multiplier, as shown above. Another is to take advantage of the early-out feature of the 386 (and the 486, but in the interests of brevity I’ll just say “386” from now on) by arranging your operands so that the multiplier (always the rightmost operand following <code>MUL</code> or <code>IMUL</code>) is no larger than the other operand.</p>
<blockquote>
<p><img src="images/i.jpg" /> Why? Because the 386 processes one multiplier bit per cycle and immediately ends a multiplication when all significant bits of the multiplier have been processed, so fewer cycles are required to multiply a large multiplicand times a small multiplier than a small multiplicand times a large multiplier, by a factor of about 1 cycle for each significant multiplier bit eliminated.</p>
</blockquote>
<p>(There’s a minimum execution time on this trick; below 3 significant multiplier bits, no additional cycles are saved.) For example, multiplication of 32,767 times 1 is 12 cycles faster than multiplication of 1 times 32,727.</p>
<p>Choosing the right operand as the multiplier can work wonders. According to published specs, the 386 takes 38 cycles to multiply by a multiplier with 32 significant bits but only 9 cycles to multiply by a multiplier of 2, a performance improvement of more than four times! (My tests regularly indicate that multiplication takes 3 to 4 cycles longer than the specs indicate, but the cycle-per-bit advantage of smaller multipliers holds true nonetheless.)</p>
<p>This highlights another interesting point: <code>MUL</code> and <code>IMUL</code> on the 386 are so fast that alternative multiplication approaches, while generally still faster, are worthwhile only in truly time-critical code.</p>
<blockquote>
<p><img src="images/i.jpg" /> On 386SXs and uncached 386s, where code size can significantly affect performance due to instruction prefetching, the compact <code>MUL</code> and <code>IMUL</code> instructions can approach and in some cases even outperform the “optimized” alternatives.</p>
</blockquote>
<p>All in all, <code>MUL</code> and <code>IMUL</code> are reasonable performers on the 386, no longer to be avoided in most cases—and you can help that along by arranging your code to make the smaller operand the multiplier whenever you know which operand is smaller.</p>
<p>That doesn’t mean that your code should test and swap operands to make sure the smaller one is the multiplier; that rarely pays off. I’m speaking more of the case where you’re scaling an array up by a value that’s always in the range of, say, 2 to 10; because the scale value will always be small and the array elements may have any value, the scale value is the logical choice for the multiplier.</p>
</section>
<section id="optimizing-optimized-searching" class="level4">
<h4><a href="#optimizing-optimized-searching">Optimizing Optimized Searching</a></h4>
<p>Rob Williams writes with a wonderful optimization to the <code>REPNZ SCASB</code>-based optimized searching routine I discussed in Chapter 5. As a quick refresher, I described searching a buffer for a text string as follows: Scan for the first byte of the text string with <code>REPNZ SCASB</code>, then use <code>REPZ CMPS</code> to check for a full match whenever <code>REPNZ SCASB</code> finds a match for the first character, as shown in Figure 9.1. The principle is that most buffer characters won’t match the first character of any given string, so <code>REPNZ SCASB</code>, by far the fastest way to search on the PC, can be used to eliminate most potential matches; each remaining potential match can then be checked in its entirety with <code>REPZ CMPS</code>.</p>
<figure>
<img src="images/09-01.jpg" alt="Figure 9.1  Simple searching method for locating a text string." /><figcaption><strong>Figure 9.1</strong>  <em>Simple searching method for locating a text string.</em></figcaption>
</figure>
<p>Rob’s revelation, which he credits without explanation to Edgar Allen Poe (search nevermore?), was that by far the slowest part of the whole deal is handling <code>REPNZ SCASB</code> matches, which require checking the remainder of the string with <code>REPZ CMPS</code> and restarting <code>REPNZ SCASB</code> if no match is found.</p>
<blockquote>
<p><img src="images/i.jpg" /> Rob points out that the number of <code>REPNZ SCASB</code> matches can easily be reduced simply by scanning for the character in the searched-for string that appears least often in the buffer being searched.</p>
</blockquote>
<p>Imagine, if you will, that you’re searching for the string “EQUAL.” By my approach, you’d use <code>REPNZ SCASB</code> to scan for each occurrence of “E,” which crops up quite often in normal text. Rob points out that it would make more sense to scan for “Q,” then back up one character and check the whole string when a “Q” is found, as shown in Figure 9.2. “Q” is likely to occur much less often, resulting in many fewer whole-string checks and much faster processing.</p>
<p>Listing 9.1 implements the scan-on-first-character approach. Listing 9.2 scans for whatever character the caller specifies. Listing 9.3 is a test program used to compare the two approaches. How much difference does Rob’s revelation make? Plenty. Even when the entire C function call to <code>FindString</code> is timed—<code>strlen</code> calls, parameter pushing, calling, setup, and all—the version of <code>FindString</code> in Listing 9.2, which is directed by Listing 9.3 to scan for the infrequently-occurring “Q,” is about 40 percent faster on a 20 MHz cached 386 for the test search of Listing 9.3 than is the version of <code>FindString</code> in Listing 9.1, which always scans for the first character, in this case “E.” However, when only the search loops (the code that actually does the searching) in the two versions of <code>FindString</code> are compared, Listing 9.2 is more than <em>twice</em> as fast as Listing 9.1—a remarkable improvement over code that already uses <code>REPNZ SCASB</code> and <code>REPZ CMPS</code>.</p>
<p>What I like so much about Rob’s approach is that it demonstrates that optimization involves much more than instruction selection and cycle counting. Listings 9.1 and 9.2 use pretty much the same instructions, and even use the same approach of scanning with <code>REPNZ SCASB</code> and using <code>REPZ CMPS</code> to check scanning matches.</p>
<blockquote>
<p><img src="images/i.jpg" /> The difference between Listings 9.1 and 9.2 (which gives you more than a doubling of performance) is due entirely to understanding the nature of the data being handled, and biasing the code to reflect that knowledge.</p>
</blockquote>
<figure>
<img src="images/09-02.jpg" alt="Figure 9.2  Faster searching method for locating a text string." /><figcaption><strong>Figure 9.2</strong>  <em>Faster searching method for locating a text string.</em></figcaption>
</figure>
<p><strong>LISTING 9.1 L9-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Searches a text buffer for a text string. Uses REPNZ SCASB to sca&quot;n</span>
<span class="co">; the buffer for locations that match the first character of the</span>
<span class="co">; searched-for string, then uses REPZ CMPS to check fully only those</span>
<span class="co">; locations that REPNZ SCASB has identified as potential matches.</span>
<span class="co">;</span>
<span class="co">; Adapted from Zen of Assembly Language, by Michael Abrash</span>
<span class="co">;</span>
<span class="co">; C small model-callable as:</span>
<span class="co">;    unsigned char * FindString(unsigned char * Buffer,</span>
<span class="co">;     unsigned int BufferLength, unsigned char * SearchString,</span>
<span class="co">;     unsigned int SearchStringLength);</span>
<span class="co">;</span>
<span class="co">; Returns a pointer to the first match for SearchString in Buffer,or</span>
<span class="co">; a NULL pointer if no match is found. Buffer should not start at</span>
<span class="co">; offset 0 in the data segment to avoid confusing a match at 0 with</span>
<span class="co">; no match found.</span>
Parmsstruc
                        <span class="dt">dw</span>    <span class="dv">2</span> dup(?) <span class="co">;pushed BP/return address</span>
Buffer                  <span class="dt">dw</span>      ?      <span class="co">;pointer to buffer to search</span>
BufferLength            <span class="dt">dw</span>      ?      <span class="co">;length of buffer to search</span>
SearchString            <span class="dt">dw</span>      ?      <span class="co">;pointer to string for which to search</span>
SearchStringLength      <span class="dt">dw</span>      ?      <span class="co">;length of string for which to search</span>
Parmsends
      .model      small
      .code
      public _FindString
_FindStringprocnear
      <span class="kw">push</span>     <span class="kw">bp</span>      <span class="co">;preserve caller&#39;s stack frame</span>
      <span class="kw">mov</span>      <span class="kw">bp</span>,<span class="kw">sp</span>   <span class="co">;point to our stack frame</span>
      <span class="kw">push</span>     <span class="kw">si</span>      <span class="co">;preserve caller&#39;s register variables</span>
      <span class="kw">push</span>     <span class="kw">di</span>
      <span class="kw">cld</span>              <span class="co">;make string instructions increment pointers</span>
      <span class="kw">mov</span>      <span class="kw">si</span>,[<span class="kw">bp</span>+SearchString]       <span class="co">;pointer to string to search for</span>
      <span class="kw">mov</span>      <span class="kw">bx</span>,[<span class="kw">bp</span>+SearchStringLength] <span class="co">;length of string</span>
      <span class="kw">and</span> <span class="kw">bx</span>,<span class="kw">bx</span>
      <span class="kw">jz</span>       FindStringNotFound         <span class="co">;no match if string is 0 length</span>
      <span class="kw">movd</span>      x,[<span class="kw">bp</span>+BufferLength]       <span class="co">;length of buffer</span>
      <span class="kw">sub</span>      <span class="kw">dx</span>,<span class="kw">bx</span>                      <span class="co">;difference between buffer and string lengths</span>
      <span class="kw">jc</span>      FindStringNotFound          <span class="co">;no match if search string is</span>
                                          <span class="co">; longer than buffer</span>
      <span class="kw">inc</span>      <span class="kw">dx</span>      <span class="co">;difference between buffer and search string</span>
                       <span class="co">; lengths, plus 1 (# of possible string start</span>
                       <span class="co">; locations to check in the buffer)</span>
      <span class="kw">mov</span>      <span class="kw">di</span>,<span class="kw">ds</span>
      <span class="kw">mov</span>      <span class="kw">es</span>,<span class="kw">di</span>
      <span class="kw">mov</span>      <span class="kw">di</span>,[<span class="kw">bp</span>+Buffer]       <span class="co">;point ES:DI to buffer to search thru</span>
      <span class="kw">lodsb</span>                         <span class="co">;put the first byte of the search string in AL</span>
      <span class="kw">mov</span>      <span class="kw">bp</span>,<span class="kw">si</span>                <span class="co">;set aside pointer to the second search byte</span>
      <span class="kw">dec</span>      <span class="kw">bx</span>                   <span class="co">;don&#39;t need to compare the first byte of the</span>
                                    <span class="co">; string with CMPS; we&#39;ll do it with SCAS</span>
<span class="fu">FindStringLoop:</span>
      <span class="kw">mov</span>    <span class="kw">cx</span>,<span class="kw">dx</span> <span class="co">;put remaining buffer search length in CX</span>
      repnz  <span class="kw">scasb</span> <span class="co">;scan for the first byte of the string</span>
      <span class="kw">jnz</span>    FindStringNotFound <span class="co">;not found, so there&#39;s no match</span>
                                <span class="co">;found, so we have a potential match-check the</span>
                                <span class="co">; rest of this candidate location</span>
      <span class="kw">push</span>   <span class="kw">di</span>                 <span class="co">;remember the address of the next byte to scan</span>
      <span class="kw">mov</span>    <span class="kw">dx</span>,<span class="kw">cx</span>              <span class="co">;set aside the remaining length to search in</span>
                                <span class="co">; the buffer</span>
      <span class="kw">mov</span>    <span class="kw">si</span>,<span class="kw">bp</span>              <span class="co">;point to the rest of the search string</span>
      <span class="kw">mov</span>    <span class="kw">cx</span>,<span class="kw">bx</span>              <span class="co">;string length (minus first byte)</span>
      <span class="kw">shr</span>    <span class="kw">cx</span>,<span class="dv">1</span>               <span class="co">;convert to word for faster search</span>
      <span class="kw">jnc</span>    FindStringWord     <span class="co">;do word search if no odd byte</span>
      <span class="kw">cmpsb</span>                     <span class="co">;compare the odd byte</span>
      <span class="kw">jnz</span>    FindStringNoMatch  <span class="co">;odd byte doesn&#39;t match, so we</span>
                                <span class="co">; haven&#39;t found the search string here</span>
<span class="fu">FindStringWord:</span>
      <span class="kw">jcxz</span>   FindStringFound    <span class="co">;test whether we&#39;ve already checked</span>
                                <span class="co">; the whole string; if so, this is a match</span>
                                <span class="co">; bytes long; if so, we&#39;ve found a match</span>
      repz   <span class="kw">cmpsw</span>              <span class="co">;check the rest of the string a word at a time</span>
      <span class="kw">jz</span>     FindStringFound    <span class="co">;it&#39;s a match</span>
<span class="fu">FindStringNoMatch:</span>
      <span class="kw">pop</span>    <span class="kw">di</span>                 <span class="co">;get back pointer to the next byte to scan</span>
      <span class="kw">and</span>    <span class="kw">dx</span>,<span class="kw">dx</span>              <span class="co">;is there anything left to check?</span>
      <span class="kw">jnz</span>    FindStringLoop     <span class="co">;yes-check next byte</span>
<span class="fu">FindStringNotFound:</span>
      <span class="kw">sub</span>    <span class="kw">ax</span>,<span class="kw">ax</span>              <span class="co">;return a NULL pointer indicating that the</span>
      <span class="kw">jmp</span>    FindStringDone     <span class="co">; string was not found</span>
<span class="fu">FindStringFound:</span>
      <span class="kw">pop</span>    <span class="kw">ax</span>                 <span class="co">;point to the buffer location at which the</span>
      <span class="kw">dec</span>    <span class="kw">ax</span>                 <span class="co">; string was found (earlier we pushed the</span>
                                <span class="co">; address of the byte after the start of the</span>
                                <span class="co">; potential match)</span>
<span class="fu">FindStringDone:</span>
      <span class="kw">pop</span>    <span class="kw">di</span>                 <span class="co">;restore caller&#39;s register variables</span>
      <span class="kw">pop</span>    <span class="kw">si</span>
      <span class="kw">pop</span>    <span class="kw">bp</span>                 <span class="co">;restore caller&#39;s stack frame</span>
<span class="kw">ret</span>
_FindStringendp
      end</code></pre>
<p><strong>LISTING 9.2 L9-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Searches a text buffer for a text string. Uses REPNZ SCASB to scan</span>
<span class="co">; the buffer for locations that match a specified character of the</span>
<span class="co">; searched-for string, then uses REPZ CMPS to check fully only those</span>
<span class="co">; locations that REPNZ SCASB has identified as potential matches.</span>
<span class="co">;</span>
<span class="co">; C small model-callable as:</span>
<span class="co">;    unsigned char * FindString(unsigned char * Buffer,</span>
<span class="co">;     unsigned int BufferLength, unsigned char * SearchString,</span>
<span class="co">;     unsigned int SearchStringLength,</span>
<span class="co">;     unsigned int ScanCharOffset);</span>
<span class="co">;</span>
<span class="co">; Returns a pointer to the first match for SearchString in Buffer,or</span>
<span class="co">; a NULL pointer if no match is found. Buffer should not start at</span>
<span class="co">; offset 0 in the data segment to avoid confusing a match at 0 with</span>
<span class="co">; no match found.</span>
Parms  <span class="kw">struc</span>
                        <span class="dt">dw</span>      <span class="dv">2</span> dup(?)      <span class="co">;pushed BP/return address</span>
Buffer                  <span class="dt">dw</span>      ?             <span class="co">;pointer to buffer to search</span>
BufferLength            <span class="dt">dw</span>      ?             <span class="co">;length of buffer to search</span>
SearchString            <span class="dt">dw</span>      ?             <span class="co">;pointer to string for which to search</span>
SearchStringLength      <span class="dt">dw</span>      ?             <span class="co">;length of string for which to search</span>
ScanCharOffset          <span class="dt">dw</span>      ?             <span class="co">;offset in string of character for</span>
                                              <span class="co">; which to scan</span>
Parmsends
      .model      small
      .code
      public _FindString
_FindStringprocnear
      <span class="kw">push</span>     <span class="kw">bp</span>      <span class="co">;preserve caller&#39;s stack frame</span>
      <span class="kw">mov</span>      <span class="kw">bp</span>,<span class="kw">sp</span>   <span class="co">;point to our stack frame</span>
      <span class="kw">push</span>     <span class="kw">si</span>      <span class="co">;preserve caller&#39;s register variables</span>
      <span class="kw">push</span>     <span class="kw">di</span>
      <span class="kw">cld</span>              <span class="co">;make string instructions increment pointers</span>
      <span class="kw">mov</span>      <span class="kw">si</span>,[<span class="kw">bp</span>+SearchString]       <span class="co">;pointer to string to search for</span>
      <span class="kw">mov</span>      <span class="kw">cx</span>,[<span class="kw">bp</span>+SearchStringLength] <span class="co">;length of string</span>
      <span class="kw">jcxz</span>     FindStringNotFound         <span class="co">;no match if string is 0 length</span>
      <span class="kw">mov</span>      <span class="kw">dx</span>,[<span class="kw">bp</span>+BufferLength]       <span class="co">;length of buffer</span>
      <span class="kw">sub</span>      <span class="kw">dx</span>,<span class="kw">cx</span>                      <span class="co">;difference between buffer and search</span>
                                          <span class="co">; lengths</span>
      <span class="kw">jc</span>        FindStringNotFound <span class="co">;no match if search string is</span>
                    <span class="co">; longer than buffer</span>
      <span class="kw">inc</span>       <span class="kw">dx</span>  <span class="co">; difference between buffer and search string</span>
                    <span class="co">; lengths, plus 1 (# of possible string start</span>
                    <span class="co">; locations to check in the buffer)</span>
      <span class="kw">mov</span>       <span class="kw">di</span>,<span class="kw">ds</span>
      <span class="kw">mov</span>       <span class="kw">es</span>,<span class="kw">di</span>
      <span class="kw">mov</span>       <span class="kw">di</span>,[<span class="kw">bp</span>+Buffer]         <span class="co">;point ES:DI to buffer to search thru</span>
      <span class="kw">mov</span>       <span class="kw">bx</span>,[<span class="kw">bp</span>+ScanCharOffset] <span class="co">;offset in string of character</span>
                                       <span class="co">; on which to scan</span>
      <span class="kw">add</span>       <span class="kw">di</span>,<span class="kw">bx</span>         <span class="co">;point ES:DI to first buffer byte to scan</span>
      <span class="kw">mov</span>       <span class="kw">al</span>,[<span class="kw">si</span>+<span class="kw">bx</span>]    <span class="co">;put the scan character in AL</span>
      <span class="kw">inc</span>       <span class="kw">bx</span>            <span class="co">;set BX to the offset back to the start of the</span>
                              <span class="co">; potential full match after a scan match,</span>
                              <span class="co">; accounting for the 1-byte overrun of</span>
                              <span class="co">; REPNZ SCASB</span>
<span class="fu">FindStringLoop:</span>
      <span class="kw">mov</span>       <span class="kw">cx</span>,<span class="kw">dx</span>              <span class="co">;put remaining buffer search length in CX</span>
      repnz     <span class="kw">scasb</span>              <span class="co">;scan for the scan byte</span>
      <span class="kw">jnz</span>       FindStringNotFound <span class="co">;not found, so there&#39;s no match</span>
                                   <span class="co">;found, so we have a potential match-check the</span>
                                   <span class="co">; rest of this candidate location</span>
      <span class="kw">push</span>       <span class="kw">di</span>                <span class="co">;remember the address of the next byte to scan</span>
      <span class="kw">mov</span>        <span class="kw">dx</span>,<span class="kw">cx</span>             <span class="co">;set aside the remaining length to search in</span>
                                   <span class="co">; the buffer</span>
      <span class="kw">sub</span>        <span class="kw">di</span>,<span class="kw">bx</span>             <span class="co">;point back to the potential start of the</span>
                                   <span class="co">; match in the buffer</span>
      <span class="kw">mov</span>        <span class="kw">si</span>,[<span class="kw">bp</span>+SearchString]       <span class="co">;point to the start of the string</span>
      <span class="kw">mov</span>        <span class="kw">cx</span>,[<span class="kw">bp</span>+SearchStringLength] <span class="co">;string length</span>
      <span class="kw">shr</span>        <span class="kw">cx</span>,<span class="dv">1</span>                       <span class="co">;convert to word for faster search</span>
      <span class="kw">jnc</span>        FindStringWord             <span class="co">;do word search if no odd byte</span>
      <span class="kw">cmpsb</span>                                 <span class="co">;compare the odd byte</span>
      <span class="kw">jnz</span>        FindStringNoMatch          <span class="co">;odd byte doesn&#39;t match, so we</span>
                                            <span class="co">; haven&#39;t found the search string here</span>
<span class="fu">FindStringWord:</span>
      <span class="kw">jcxz</span>       FindStringFound        <span class="co">;if the string is only 1 byte long,</span>
                                        <span class="co">; we&#39;ve found a match</span>
      repz       <span class="kw">cmpsw</span>                  <span class="co">;check the rest of the string a word at a time</span>
      <span class="kw">jz</span>         FindStringFound        <span class="co">;it&#39;s a match</span>
<span class="fu">FindStringNoMatch:</span>
      <span class="kw">pop</span>        <span class="kw">di</span>                     <span class="co">;get back pointer to the next byte to scan</span>
      <span class="kw">and</span>        <span class="kw">dx</span>,<span class="kw">dx</span>                  <span class="co">;is there anything left to check?</span>
      <span class="kw">jnz</span>        FindStringLoop         <span class="co">;yes-check next byte</span>
<span class="fu">FindStringNotFound:</span>
      <span class="kw">sub</span>        <span class="kw">ax</span>,<span class="kw">ax</span>                  <span class="co">;return a NULL pointer indicating that the</span>
      <span class="kw">jmp</span>        FindStringDone         <span class="co">; string was not found</span>
<span class="fu">FindStringFound:</span>
      <span class="kw">pop</span>         <span class="kw">ax</span>         <span class="co">;point to the buffer location at which the</span>
      <span class="kw">sub</span>         <span class="kw">ax</span>,<span class="kw">bx</span>      <span class="co">; string was found (earlier we pushed the</span>
                             <span class="co">; address of the byte after the scan match)</span>
<span class="fu">FindStringDone:</span>
      <span class="kw">pop</span>         <span class="kw">di</span>         <span class="co">;restore caller&#39;s register variables</span>
      <span class="kw">pop</span>         <span class="kw">si</span>
      <span class="kw">pop</span>         <span class="kw">bp</span>         <span class="co">;restore caller&#39;s stack frame</span>
      <span class="kw">ret</span>
_FindStringendp
      end</code></pre>
<p><strong>LISTING 9.3 L9-3.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Program to exercise buffer-search routines in Listings 9.1 &amp; 9.2 */</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="ot">#define DISPLAY_LENGTH  40</span>
<span class="kw">extern</span> <span class="dt">unsigned</span> <span class="dt">char</span> * FindString(<span class="dt">unsigned</span> <span class="dt">char</span> *, <span class="dt">unsigned</span> <span class="dt">int</span>,
      <span class="dt">unsigned</span> <span class="dt">char</span> *, <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">unsigned</span> <span class="dt">int</span>);
<span class="dt">void</span> main(<span class="dt">void</span>);
<span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">char</span> TestBuffer[] = <span class="st">&quot;When, in the course of human \</span>
events, it becomes necessary <span class="kw">for</span> one people to dissolve the \
political bands which have connected them with another, and to \
assume among the powers of the earth the separate and equal station \
to which the laws of nature and of nature&#39;s God entitle them...<span class="st">&quot;;</span>
<span class="dt">void</span> main() {
   <span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">char</span> TestString[] = <span class="st">&quot;equal&quot;</span>;
   <span class="dt">unsigned</span> <span class="dt">char</span> TempBuffer[DISPLAY_LENGTH<span class="dv">+1</span>];
   <span class="dt">unsigned</span> <span class="dt">char</span> *MatchPtr;
   <span class="co">/* Search for TestString and report the results */</span>
   <span class="kw">if</span> ((MatchPtr = FindString(TestBuffer,
         (<span class="dt">unsigned</span> <span class="dt">int</span>) strlen(TestBuffer), TestString,
         (<span class="dt">unsigned</span> <span class="dt">int</span>) strlen(TestString), <span class="dv">1</span>)) == NULL) {
      <span class="co">/* TestString wasn&#39;t found */</span>
      printf(<span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">%s</span><span class="ch">\&quot;</span><span class="st"> not found</span><span class="ch">\n</span><span class="st">&quot;</span>, TestString);
   } <span class="kw">else</span> {
      <span class="co">/* TestString was found. Zero-terminate TempBuffer; strncpy</span>
<span class="co">         won&#39;t do it if DISPLAY_LENGTH characters are copied */</span>
      TempBuffer[DISPLAY_LENGTH] = <span class="dv">0</span>;
      printf(<span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">%s</span><span class="ch">\&quot;</span><span class="st"> found. Next %d characters at match:</span><span class="ch">\n\&quot;</span><span class="st">%s</span><span class="ch">\&quot;\n</span><span class="st">&quot;</span>,
            TestString, DISPLAY_LENGTH,
            strncpy(TempBuffer, MatchPtr, DISPLAY_LENGTH));
   }
}</code></pre>
<p>You’ll notice that in Listing 9.2 I didn’t use a table of character frequencies in English text to determine the character for which to scan, but rather let the caller make that choice. Each buffer of bytes has unique characteristics, and English-letter frequency could well be inappropriate. What if the buffer is filled with French text? Cyrillic? What if it isn’t text that’s being searched? It might be worthwhile for an application to build a dynamic frequency table for each buffer so that the best scan character could be chosen for each search. Or perhaps not, if the search isn’t time-critical or the buffer is small.</p>
<p>The point is that you can improve performance dramatically by understanding the nature of the data with which you work. (This is equally true for high-level language programming, by the way.) Listing 9.2 is very similar to and only slightly more complex than Listing 9.1; the difference lies not in elbow grease or cycle counting but in the organic integrating optimizer technology we all carry around in our heads.</p>
</section>
<section id="short-sorts" class="level4">
<h4><a href="#short-sorts">Short Sorts</a></h4>
<p>David Stafford (recently of Borland and Borland Japan) who happens to be one of the best assembly language programmers I’ve ever met, has written a C-callable routine that sorts an array of integers in ascending order. That wouldn’t be particularly noteworthy, except that David’s routine, shown in Listing 9.4, is exactly <em>25 bytes</em> long. Look at the code; you’ll keep saying to yourself, “But this doesn’t work…oh, yes, I guess it does.” As they say in the Prego spaghetti sauce ads, <em>it’s in there</em>—and what a job of packing. Anyway, David says that a 24-byte sort routine eludes him, and he’d like to know if anyone can come up with one.</p>
<p><strong>LISTING 9.4 L9-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">;--------------------------------------------------------------------------</span>
<span class="co">; Sorts an array of ints.  C callable (small model).  25 bytes.</span>
<span class="co">; void sort( int num, int a[] );</span>
<span class="co">;</span>
<span class="co">; Courtesy of David Stafford.</span>
<span class="co">;--------------------------------------------------------------------------</span>

      .model small
      .code
        public _sort

<span class="fu">top:</span>    <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bx</span>]         <span class="co">;swap two adjacent integers</span>
        <span class="kw">xchg</span>    <span class="kw">dx</span>,[<span class="kw">bx</span><span class="dv">+2</span>]
        <span class="kw">xchg</span>    <span class="kw">dx</span>,[<span class="kw">bx</span>]
        <span class="kw">cmp</span>     <span class="kw">dx</span>,[<span class="kw">bx</span>]         <span class="co">;did we put them in the right order?</span>
        <span class="kw">jl</span>      top             <span class="co">;no, swap them back</span>
        <span class="kw">inc</span>     <span class="kw">bx</span>              <span class="co">;go to next integer</span>
        <span class="kw">inc</span>     <span class="kw">bx</span>
        <span class="kw">loop</span>    top
<span class="fu">_sort:</span>  <span class="kw">pop</span>     <span class="kw">dx</span>              <span class="co">;get return address (entry point)</span>
        <span class="kw">pop</span>     <span class="kw">cx</span>              <span class="co">;get count</span>
        <span class="kw">pop</span>     <span class="kw">bx</span>              <span class="co">;get pointer</span>
        <span class="kw">push</span>    <span class="kw">bx</span>              <span class="co">;restore pointer</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>              <span class="co">;decrement count</span>
        <span class="kw">push</span>    <span class="kw">cx</span>              <span class="co">;save count</span>
        <span class="kw">push</span>    <span class="kw">dx</span>              <span class="co">;restore return address</span>
        <span class="kw">jg</span>      top             <span class="co">;if cx &gt; 0</span>

        <span class="kw">ret</span>

      end</code></pre>
</section>
<section id="full-32-bit-division" class="level4">
<h4><a href="#full-32-bit-division">Full 32-Bit Division</a></h4>
<p>One of the most annoying limitations of the x86 is that while the dividend operand to the <code>DIV</code> instruction can be 32 bits in size, both the divisor and the result must be 16 bits. That’s particularly annoying in regards to the result because sometimes you just don’t know whether the ratio of the dividend to the divisor is greater than 64K-1 or not—and if you guess wrong, you get that godawful Divide By Zero interrupt. So, what is one to do when the result might not fit in 16 bits, or when the dividend is larger than 32 bits? Fall back to a software division approach? That will work—but oh so slowly.</p>
<p>There’s another technique that’s much faster than a pure software approach, albeit not so flexible. This technique allows arbitrarily large dividends and results, but the divisor is still limited to16 bits. That’s not perfect, but it does solve a number of problems, in particular eliminating the possibility of a Divide By Zero interrupt from a too-large result.</p>
<p>This technique involves nothing more complicated than breaking up the division into word-sized chunks, starting with the most significant word of the dividend. The most significant word is divided by the divisor (with no chance of overflow because there are only 16 bits in each); then the remainder is prepended to the next 16 bits of dividend, and the process is repeated, as shown in Figure 9.3. This process is equivalent to dividing by hand, except that here we stop to carry the remainder manually only after each word of the dividend; the hardware divide takes care of the rest. Listing 9.5 shows a function to divide an arbitrarily large dividend by a 16-bit divisor, and Listing 9.6 shows a sample division of a large dividend. Note that the same principle can be applied to handling arbitrarily large dividends in 386 native mode code, but in that case the operation can proceed a dword, rather than a word, at a time.</p>
<figure>
<img src="images/09-03.jpg" alt="Figure 9.3  Fast multiword division on the 386." /><figcaption><strong>Figure 9.3</strong>  <em>Fast multiword division on the 386.</em></figcaption>
</figure>
<p>As for handling signed division with arbitrarily large dividends, that can be done easily enough by remembering the signs of the dividend and divisor, dividing the absolute value of the dividend by the absolute value of the divisor, and applying the stored signs to set the proper signs for the quotient and remainder. There may be more clever ways to produce the same result, by using <code>IDIV</code>, for example; if you know of one, drop me a line c/o Coriolis Group Books.</p>
<p><strong>LISTING 9.5 L9-5.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Divides an arbitrarily long unsigned dividend by a 16-bit unsigned</span>
<span class="co">; divisor. C near-callable as:</span>
<span class="co">;     unsigned int Div(unsigned int * Dividend,</span>
<span class="co">;     int DividendLength, unsigned int Divisor,</span>
<span class="co">;     unsigned int * Quotient);</span>
<span class="co">;</span>
<span class="co">; Returns the remainder of the division.</span>
<span class="co">;</span>
<span class="co">; Tested with TASM 2.</span>

parms <span class="kw">struc</span>
          <span class="dt">dw</span>     <span class="dv">2</span> dup (?)     <span class="co">;pushed BP &amp; return address</span>
Dividend  <span class="dt">dw</span>     ?             <span class="co">;pointer to value to divide, stored in Intel</span>
                               <span class="co">; order, with lsb at lowest address, msb at</span>
                               <span class="co">; highest. Must be composed of an integral</span>
                               <span class="co">; number of words</span>
DividendLength   <span class="dt">dw</span>  ?         <span class="co">;# of bytes in Dividend. Must be a multiple</span>
                               <span class="co">; of 2</span>
Divisor          <span class="dt">dw</span> ?          <span class="co">;value by which to divide. Must not be zero,</span>
                               <span class="co">; or a Divide By Zero interrupt will occur</span>
Quotient         <span class="dt">dw</span> ?          <span class="co">;pointer to buffer in which to store the</span>
                               <span class="co">; result of the division, in Intel order.</span>
                               <span class="co">; The quotient returned is of the same</span>
                               <span class="co">; length as the dividend</span>
parmsends

               .model     small
               .code
               public     _Div
_Divprocnear
               <span class="kw">push</span>    <span class="kw">bp</span>      <span class="co">;preserve caller&#39;s stack frame</span>
               <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>   <span class="co">;point to our stack frame</span>
               <span class="kw">push</span>    <span class="kw">si</span>      <span class="co">;preserve caller&#39;s register variables</span>
               <span class="kw">push</span>    <span class="kw">di</span>

               <span class="kw">std</span>             <span class="co">;we&#39;re working from msb to lsb</span>
               <span class="kw">mov</span>  <span class="kw">ax</span>,<span class="kw">ds</span>
               <span class="kw">mov</span>  <span class="kw">es</span>,<span class="kw">ax</span>      <span class="co">;for STOS</span>
               <span class="kw">mov</span>  <span class="kw">cx</span>,[<span class="kw">bp</span>+DividendLength]
               <span class="kw">sub</span>  <span class="kw">cx</span>,<span class="dv">2</span>
               <span class="kw">mov</span>  <span class="kw">si</span>,[<span class="kw">bp</span>+Dividend]
               <span class="kw">add</span>  <span class="kw">si</span>,<span class="kw">cx</span>      <span class="co">;point to the last word of the dividend</span>
                               <span class="co">; (the most significant word)</span>
               <span class="kw">mov</span>  <span class="kw">di</span>,[<span class="kw">bp</span>+Quotient]
               <span class="kw">add</span>  <span class="kw">di</span>,<span class="kw">cx</span>      <span class="co">;point to the last word of the quotient</span>
                               <span class="co">; buffer (the most significant word)</span>
               <span class="kw">mov</span>  <span class="kw">bx</span>,[<span class="kw">bp</span>+Divisor]
               <span class="kw">shr</span>  <span class="kw">cx</span>,<span class="dv">1</span>
               <span class="kw">inc</span>  <span class="kw">cx</span>         <span class="co">;# of words to process</span>
               <span class="kw">sub</span>  <span class="kw">dx</span>,<span class="kw">dx</span>      <span class="co">;convert initial divisor word to a 32-bit</span>
                               <span class="co">;value for DIV</span>
<span class="fu">DivLoop:</span>
               lod  sw         <span class="co">;get next most significant word of divisor</span>
               <span class="kw">div</span>  <span class="kw">bx</span>
               sto  sw         <span class="co">;save this word of the quotient</span>
                               <span class="co">;DX contains the remainder at this point,</span>
                               <span class="co">; ready to prepend to the next divisor word</span>
               <span class="kw">loop</span>  DivLoop
               <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="kw">dx</span>     <span class="co">;return the remainder</span>
               <span class="kw">cld</span>             <span class="co">;restore default Direction flag setting</span>
               <span class="kw">pop</span>   <span class="kw">di</span>        <span class="co">;restore caller&#39;s register variables</span>
               <span class="kw">pop</span>   <span class="kw">si</span>
               <span class="kw">pop</span>   <span class="kw">bp</span>        <span class="co">;restore caller&#39;s stack frame</span>
               <span class="kw">ret</span>
_Divendp
               end</code></pre>
<p><strong>LISTING 9.6 L9-6.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Sample use of Div function to perform division when the result</span>
<span class="co">   doesn&#39;t fit in 16 bits */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="kw">extern</span> <span class="dt">unsigned</span> <span class="dt">int</span> Div(<span class="dt">unsigned</span> <span class="dt">int</span> * Dividend,
          <span class="dt">int</span> DividendLength, <span class="dt">unsigned</span> <span class="dt">int</span> Divisor,
          <span class="dt">unsigned</span> <span class="dt">int</span> * Quotient);

main() {
   <span class="dt">unsigned</span> <span class="dt">long</span> m, i = <span class="bn">0x20000001</span>;
   <span class="dt">unsigned</span> <span class="dt">int</span> k, j = <span class="bn">0x10</span>;

   k = Div((<span class="dt">unsigned</span> <span class="dt">int</span> *)&amp;i, <span class="kw">sizeof</span>(i), j, (<span class="dt">unsigned</span> <span class="dt">int</span> *)&amp;m);
   printf(<span class="st">&quot;%lu / %u = %lu r %u</span><span class="ch">\n</span><span class="st">&quot;</span>, i, j, m, k);
}</code></pre>
</section>
<section id="sweet-spot-revisited" class="level4">
<h4><a href="#sweet-spot-revisited">Sweet Spot Revisited</a></h4>
<p>Way back in Volume 1, Number 1 of <em>PC TECHNIQUES</em>, (April/May 1990) I wrote the very first of that magazine’s HAX (#1), which extolled the virtues of placing your most commonly-used automatic (stack-based) variables within the stack’s “sweet spot,” the area between +127 to -128 bytes away from BP, the stack frame pointer. The reason was that the 8088 can store addressing displacements that fall within that range in a single byte; larger displacements require a full word of storage, increasing code size by a byte per instruction, and thereby slowing down performance due to increased instruction fetching time.</p>
<p>This takes on new prominence in 386 native mode, where straying from the sweet spot costs not one, but two or three bytes. Where the 8088 had two possible displacement sizes, either byte or word, on the 386 there are three possible sizes: byte, word, or dword. In native mode (32-bit protected mode), however, a prefix byte is needed in order to use a word-sized displacement, so a variable located outside the sweet spot requires either two extra bytes (an extra displacement byte plus a prefix byte) or three extra bytes (a dword displacement rather than a byte displacement). Either way, instructions grow alarmingly.</p>
<p>Performance may or may not suffer from missing the sweet spot, depending on the processor, the memory architecture, and the code mix. On a 486, prefix bytes often cost a cycle; on a 386SX, increased code size often slows performance because instructions must be fetched through the half-pint 16-bit bus; on a 386, the effect depends on the instruction mix and whether there’s a cache.</p>
<blockquote>
<p><img src="images/i.jpg" /> On balance, though, it’s as important to keep your most-used variables in the stack’s sweet spot in 386 native mode as it was on the 8088.</p>
</blockquote>
<p>In assembly, it’s easy to control the organization of your stack frame. In C, however, you’ll have to figure out the allocation scheme your compiler uses to allocate automatic variables, and declare automatics appropriately to produce the desired effect. It can be done: I did it in Turbo C some years back, and trimmed the size of a program (admittedly, a large one) by several K—not bad, when you consider that the “sweet spot” optimization is essentially free, with no code reorganization, change in logic, or heavy thinking involved.</p>
</section>
<section id="hard-core-cycle-counting" class="level4">
<h4><a href="#hard-core-cycle-counting">Hard-Core Cycle Counting</a></h4>
<p>Next, we come to an item that cycle counters will love, especially since it involves apparently incorrect documentation on Intel’s part. According to Intel’s documents, all <code>RCR</code> and <code>RCL</code> instructions, which perform rotations through the Carry flag, as shown in Figure 9.4, take 9 cycles on the 386 when working with a register operand. My measurements indicate that the 9-cycle execution time almost holds true for <em>multibit</em> rotate-through-carries, which I’ve timed at 8 cycles apiece; for example, <code>RCR AX,CL</code> takes 8 cycles on <em>my</em> 386, as does <code>RCL DX,2</code>. Contrast that with <code>ROR</code> and <code>ROL</code>, which can rotate the contents of a register any number of bits in just 3 cycles.</p>
<p>However, rotating by one bit through the Carry flag does <em>not</em> take 9 cycles, contrary to Intel’s <em>80386 Programmer’s Reference Manual</em>, or even 8 cycles. In fact, <code>RCR</code> <em>reg</em>,1 and <code>RCL</code> <em>reg</em>,1 take 3 cycles, just like <code>ROR</code>, <code>ROL</code>, <code>SHR</code>, and <code>SHL</code>. At least, that’s how fast they run on my 386, and I very much doubt that you’ll find different execution times on other 386s. (Please let me know if you do, though!)</p>
<figure>
<img src="images/09-04.jpg" alt="Figure 9.4  Performing rotate instructions using the Carry flag." /><figcaption><strong>Figure 9.4</strong>  <em>Performing rotate instructions using the Carry flag.</em></figcaption>
</figure>
<p>Interestingly, according to Intel’s <em>i486 Microprocessor Programmer’s Reference Manual</em>, the 486 can <code>RCR</code> or <code>RCL</code> a register by one bit in 3 cycles, but takes between 8 and 30 cycles to perform a multibit register <code>RCR</code> or <code>RCL</code>!</p>
<p>No great lesson here, just a caution to be leery of multibit <code>RCR</code> and <code>RCL</code> when performance matters—and to take cycle-time documentation with a grain of salt.</p>
</section>
<section id="hardwired-far-jumps" class="level4">
<h4><a href="#hardwired-far-jumps">Hardwired Far Jumps</a></h4>
<p>Did you ever wonder how to code a far jump to an absolute address in assembly language? Probably not, but if you ever do, you’re going to be glad for this next item, because the obvious solution doesn’t work. You might think all it would take to jump to, say, 1000:5 would be <code>JMP FAR PTR 1000:5</code>, but you’d be wrong. That won’t even assemble. You might then think to construct in memory a far pointer containing 1000:5, as in the following:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="dt">Ptr</span>  <span class="dt">dd</span>   ?
     :
     <span class="kw">mov</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="dt">Ptr</span>],<span class="dv">5</span>
     <span class="kw">mov</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="dt">Ptr</span><span class="dv">+2</span>]<span class="bn">,1000h</span>
     <span class="kw">jmp</span>  [<span class="dt">Ptr</span>]</code></pre>
<p>That will work, but at a price in performance. On an 8088, <code>JMP DWORD PTR [*mem*]</code> (an indirect far jump) takes at least 37 cycles; <code>JMP DWORD PTR *label*</code> (a direct far jump) takes only 15 cycles (plus, almost certainly, some cycles for instruction fetching). On a 386, an indirect far jump is documented to take at least 43 cycles in real mode (31 in protected mode); a direct far jump is documented to take at least 12 cycles, about three times faster. In truth, the difference between those two is nowhere near that big; the fastest I’ve measured for a direct far jump is 21 cycles, and I’ve measured indirect far jumps as fast as 30 cycles, so direct is still faster, but not by so much. (Oh, those cycle-time documentation blues!) Also, a direct far jump is documented to take at least 27 cycles in protected mode; why the big difference in protected mode, I have no idea.</p>
<p>At any rate, to return to our original problem of jumping to 1000:5: Although an indirect far jump will work, a direct far jump is still preferable.</p>
<p>Listing 9.7 shows a short program that performs a direct far call to 1000:5. (Don’t run it, unless you want to crash your system!) It does this by creating a dummy segment at 1000H, so that the label <code>FarLabel</code> can be created with the desired far attribute at the proper location. (Segments created with “AT” don’t cause the generation of any actual bytes or the allocation of any memory; they’re just templates.) It’s a little kludgey, but at least it does work. There may be a better solution; if you have one, pass it along.</p>
<p><strong>LISTING 9.7 L9-7.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to perform a direct far jump to address 1000:5.</span>
<span class="co">; *** Do not run this program! It&#39;s just an example of how ***</span>
<span class="co">; *** to build a direct far jump to an absolute address    ***</span>
<span class="co">;</span>
<span class="co">; Tested with TASM 2 and MASM 5.</span>

FarSeg     <span class="kw">segment</span>  <span class="kw">at</span><span class="bn"> 01000h</span>
      <span class="kw">org</span>  <span class="dv">5</span>
FarLabel label  far
FarSeg      ends

      .model     small
      .code
<span class="fu">start:</span>
      <span class="kw">jmp</span>     FarLabel
      end     start</code></pre>
<p>By the way, if you’re wondering how I figured this out, I merely applied my good friend Dan Illowsky’s long-standing rule for dealing with MASM:</p>
<p>If the obvious doesn’t work (and it usually doesn’t), just try everything you can think of, no matter how ridiculous, until you find something that does—a rule with plenty of history on its side.</p>
</section>
<section id="setting-32-bit-registers-time-versus-space" class="level4">
<h4><a href="#setting-32-bit-registers-time-versus-space">Setting 32-Bit Registers: Time versus Space</a></h4>
<p>To finish up this chapter, consider these two items. First, in 32-bit protected mode,</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">sub</span>  <span class="kw">eax</span>,<span class="kw">eax</span>
<span class="kw">inc</span>  <span class="kw">eax</span></code></pre>
<p>takes 4 cycles to execute, but is only 3 bytes long, while</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">eax</span>,<span class="dv">1</span></code></pre>
<p>takes only 2 cycles to execute, but is 5 bytes long (because native mode constants are dwords and the <code>MOV</code> instruction doesn’t sign-extend). Both code fragments are ways to set <code>EAX</code> to 1 (although the first affects the flags and the second doesn’t); this is a classic trade-off of speed for space. Second,</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">or</span>    <span class="kw">ebx</span>,-<span class="dv">1</span></code></pre>
<p>takes 2 cycles to execute and is 3 bytes long, while</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">move  <span class="kw">bx</span>,-<span class="dv">1</span></code></pre>
<p>takes 2 cycles to execute and is 5 bytes long. Both instructions set <code>EBX</code> to -1; this is a classic trade-off of—gee, it’s not a trade-off at all, is it? <code>OR</code> is a better way to set a 32-bit register to all 1-bits, just as <code>SUB</code> or <code>XOR</code> is a better way to set a register to all 0-bits. Who woulda thunk it? Just goes to show how the 32-bit displacements and constants of 386 native mode change the familiar landscape of 80x86 optimization.</p>
<p>Be warned, though, that I’ve found <code>OR</code>, <code>AND</code>, <code>ADD</code>, and the like to be a cycle slower than <code>MOV</code> when working with immediate operands on the 386 under some circumstances, for reasons that thus far escape me. This just reinforces the first rule of optimization: Measure your code in action, and place not your trust in documented cycle times.</p>
</section>
</section>
</section>
<section id="chapter-10-patient-coding-faster-code" class="level2">
<h2><a href="#chapter-10-patient-coding-faster-code">Chapter 10 – Patient Coding, Faster Code</a></h2>
<section id="how-working-quickly-can-bring-execution-to-a-crawl" class="level3">
<h3><a href="#how-working-quickly-can-bring-execution-to-a-crawl">How Working Quickly Can Bring Execution to a Crawl</a></h3>
<p>My grandfather does <em>The New York Times</em> crossword puzzle every Sunday. In ink. With nary a blemish.</p>
<p>The relevance of which will become apparent in a trice.</p>
<p>What my grandfather is, is a pattern matcher <em>par excellence</em>. You’re a pattern matcher, too. So am I. We can’t help it; it comes with the territory. Try focusing on text and not reading it. Can’t do it. Can you hear the voice of someone you know and not recognize it? I can’t. And how in the Nine Billion Names of God is it that we’re capable of instantly recognizing one face out of the thousands we’ve seen in our lifetimes—even years later, from a different angle and in different light? Although we take them for granted, our pattern-matching capabilities are surely a miracle on the order of loaves and fishes.</p>
<p>By “pattern matching,” I mean more than just recognition, though. I mean that we are generally able to take complex and often seemingly woefully inadequate data, instantaneously match it in an incredibly flexible way to our past experience, extrapolate, and reach amazing conclusions, something that computers can scarcely do at all. Crossword puzzles are an excellent example; given a couple of letters and a cryptic clue, we’re somehow able to come up with one out of several hundred thousand words that we know. Try writing a program to do that! What’s more, we don’t process data in the serial brute-force way that computers do. Solutions tend to be virtually instantaneous or not at all; none of those “N log N” or “N^2”^ execution times for us.</p>
<p>It goes without saying that pattern matching is good; more than that, it’s a large part of what we are, and, generally, the faster we are at it, the better. Not always, though. Sometimes insufficient information really is insufficient, and, in our haste to get the heady rush of coming up with a solution, incorrect or less-than-optimal conclusions are reached, as anyone who has ever done the <em>Times</em> Sunday crossword will attest. Still, my grandfather does that puzzle every Sunday <em>in ink</em>. What’s his secret? Patience and discipline. He never fills a word in until he’s confirmed it in his head via intersecting words, no matter how strong the urge may be to put something down where he can see it and feel like he’s getting somewhere.</p>
<p>There’s a surprisingly close parallel to programming here. Programming is certainly a sort of pattern matching in the sense I’ve described above, and, as with crossword puzzles, following your programming instincts too quickly can be a liability. For many programmers, myself included, there’s a strong urge to find a workable approach to a particular problem and start coding it <em>right now</em>, what some people call “hacking” a program. Going with the first thing your programming pattern matcher comes up with can be a lot of fun; there’s instant gratification and a feeling of unbounded creativity. Personally, I’ve always hungered to get results from my work as soon as possible; I gravitated toward graphics for its instant and very visible gratification. Over time, however, I’ve learned patience.</p>
<blockquote>
<p><img src="images/i.jpg" /> I’ve come to spend an increasingly large portion of my time choosing algorithms, designing, and simply giving my mind quiet time in which to work on problems and come up with non-obvious approaches before coding; and I’ve found that the extra time up front more than pays for itself in both decreased coding time and superior programs.</p>
</blockquote>
<p>In this chapter, I’m going to walk you through a simple but illustrative case history that nicely points up the wisdom of delaying gratification when faced with programming problems, so that your mind has time to chew on the problems from other angles. The alternative solutions you find by doing this may seem obvious, once you’ve come up with them. They may not even differ greatly from your initial solutions. Often, however, they will be much better—and you’ll never even have the chance to decide whether they’re better or not if you take the first thing that comes into your head and run with it.</p>
<section id="the-case-for-delayed-gratification" class="level4">
<h4><a href="#the-case-for-delayed-gratification">The Case for Delayed Gratification</a></h4>
<p>Once upon a time, I set out to read <em>Algorithms</em>, by Robert Sedgewick (Addison-Wesley), which turned out to be a wonderful, stimulating, and most useful book, one that I recommend highly. My story, however, involves only what happened in the first 12 pages, for it was in those pages that Sedgewick discussed Euclid’s algorithm.</p>
<p>Euclid’s algorithm (discovered by Euclid, of Euclidean geometry fame, a very long time ago, way back when computers still used core memory) is a straightforward algorithm that solves one of the simplest problems imaginable: finding the greatest common integer divisor (GCD) of two positive integers. Sedgewick points out that this is useful for reducing a fraction to its lowest terms. I’m sure it’s useful for other things, as well, although none spring to mind. (A long time ago, I wrote an article about optimizing a bit of code that wasn’t even vaguely time-critical, and got swamped with letters telling me so. I knew it wasn’t time-critical; it was just a good example. So for now, close your eyes and <em>imagine</em> that finding the GCD is not only necessary but must also be done as quickly as possible, because it’s perfect for the point I want to make here and now. Okay?)</p>
<p>The problem at hand, then, is simply this: Find the largest integer value that evenly divides two arbitrary positive integers. That’s all there is to it. So warm up your pattern matchers…and go!</p>
</section>
</section>
<section id="the-brute-force-syndrome" class="level3">
<h3><a href="#the-brute-force-syndrome">The Brute-Force Syndrome</a></h3>
<p>I have a funny feeling that you’d already figured out how to find the GCD before I even said “go.” That’s what I did when reading <em>Algorithms;</em> before I read another word, I had to figure it out for myself. Programmers are like that; give them a problem and their eyes immediately glaze over as they try to solve it before you’ve even shut your mouth. That sort of instant response can certainly be impressive, but it can backfire, too, as it did in my case.</p>
<p>You see, I fell victim to a common programming pitfall, the “brute-force” syndrome. The basis of this syndrome is that there are many problems that have obvious, brute-force solutions—with one small drawback. The drawback is that if you were to try to apply a brute-force solution by hand—that is, work a single problem out with pencil and paper or a calculator—it would generally require that you have the patience and discipline to work on the problem for approximately seven hundred years, not counting eating and sleeping, in order to get an answer. Finding all the prime numbers less than 1,000,000 is a good example; just divide each number up to 1,000,000 by every lesser number, and see what’s left standing. For most of the history of humankind, people were forced to think of cleverer solutions, such as the Sieve of Eratosthenes (we’d have been in big trouble if the ancient Greeks had had computers), mainly because after about five minutes of brute force-type work, people’s attention gets diverted to other important matters, such as how far a paper airplane will fly from a second-story window.</p>
<p>Not so nowadays, though. Computers love boring work; they’re very patient and disciplined, and, besides, one human year = seven dog years = two zillion computer years. So when we’re faced with a problem that has an obvious but exceedingly lengthy solution, we’re apt to say, “Ah, let the computer do that, it’s fast,” and go back to making paper airplanes. Unfortunately, brute-force solutions tend to be slow even when performed by modern-day microcomputers, which are capable of several MIPS except when I’m late for an appointment and want to finish a compile and run just one more test before I leave, in which case the crystal in my computer is apparently designed to automatically revert to 1 Hz.)</p>
<p>The solution that I instantly came up with to finding the GCD is about as brute- force as you can get: Divide both the larger integer (iL) and the smaller integer (iS) by every integer equal to or less than the smaller integer, until a number is found that divides both evenly, as shown in Figure 10.1. This works, but it’s a lousy solution, requiring as many as iS*2 divisions; <em>very</em> expensive, especially for large values of iS. For example, finding the GCD of 30,001 and 30,002 would require 60,002 divisions, which alone, disregarding tests and branches, would take about 2 seconds on an 8088, and more than 50 milliseconds even on a 25 MHz 486—a <em>very</em> long time in computer years, and not insignificant in human years either.</p>
<p>Listing 10.1 is an implementation of the brute-force approach to GCD calculation. Table 10.1 shows how long it takes this approach to find the GCD for several integer pairs. As expected, performance is extremely poor when iS is large.</p>
<figure>
<img src="images/10-01.jpg" alt="Figure 10.1  Using a brute-force algorithm to find a GCD." /><figcaption><strong>Figure 10.1</strong>  <em>Using a brute-force algorithm to find a GCD.</em></figcaption>
</figure>
<p><strong>Integer pairs for which to find GCD</strong></p>
<table>
<caption>Table 10.1 Performance of GCD algorithm implementations.</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">90 &amp; 27</th>
<th style="text-align: left;">42 &amp; 998</th>
<th style="text-align: left;">453 &amp; 121</th>
<th style="text-align: left;">27432 &amp; 165</th>
<th style="text-align: left;">27432 &amp; 17550</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Listing 10.1</strong> (Brute force)</td>
<td style="text-align: left;">60µs (100%)</td>
<td style="text-align: left;">110µs (100%)</td>
<td style="text-align: left;">311ms (100%)</td>
<td style="text-align: left;">426µs (100%)</td>
<td style="text-align: left;">43580µs (100%)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Listing 10.2</strong> (Subtraction)</td>
<td style="text-align: left;">25 (42%)</td>
<td style="text-align: left;">72 (65%)</td>
<td style="text-align: left;">67 (22%)</td>
<td style="text-align: left;">280 (66%)</td>
<td style="text-align: left;">72 (0.16%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Listing 10.3</strong> (Division: code recursive Euclid’s algorithm)</td>
<td style="text-align: left;">20 (33%)</td>
<td style="text-align: left;">33 (30%)</td>
<td style="text-align: left;">48 (15%)</td>
<td style="text-align: left;">32 (8%)</td>
<td style="text-align: left;">53 (0.12%)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Listing 10.4</strong> (C version of data recursive Euclid’s algorithm; normal optimization)</td>
<td style="text-align: left;">12 (20%)</td>
<td style="text-align: left;">17 (15%)</td>
<td style="text-align: left;">25 (8%)</td>
<td style="text-align: left;">16 (4%)</td>
<td style="text-align: left;">26 (0.06%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Listing 10.4</strong> (/Ox = maximumoptimization)</td>
<td style="text-align: left;">12 (20%)</td>
<td style="text-align: left;">16 (15%)</td>
<td style="text-align: left;">20 (6%)</td>
<td style="text-align: left;">15 (4%)</td>
<td style="text-align: left;">23 (0.05%)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Listing 10.5</strong> (Assembly version of data recursive Euclid’s algorithm)</td>
<td style="text-align: left;">10 (17%)</td>
<td style="text-align: left;">10 (9%)</td>
<td style="text-align: left;">15 (5%)</td>
<td style="text-align: left;">10 (2%)</td>
<td style="text-align: left;">17 (0.04%)</td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> Performance of Listings 10.1 through 10.5 in finding the greatest common divisors of various pairs of integers. Times are in microseconds. Percentages represent execution time as a percentage of the execution time of Listing 10.1 for the same integer pair. Listings 10.1-10.4 were compiled with Microsoft C /C++ except as noted, the default optimization was used. All times measured with the Zen timer (from Chapter 3) on a 20 MHz cached 386.</p>
<p><strong>LISTING 10.1 L10-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Finds and returns the greatest common divisor of two positive</span>
<span class="co">   integers. Works by trying every integral divisor between the</span>
<span class="co">   smaller of the two integers and 1, until a divisor that divides</span>
<span class="co">   both integers evenly is found. All C code tested with Microsoft</span>
<span class="co">   and Borland compilers.*/</span>

<span class="dt">unsigned</span> <span class="dt">int</span> gcd(<span class="dt">unsigned</span> <span class="dt">int</span> int1, <span class="dt">unsigned</span> <span class="dt">int</span> int2) {
   <span class="dt">unsigned</span> <span class="dt">int</span> temp, trial_divisor;
   <span class="co">/* Swap if necessary to make sure that int1 &gt;= int2 */</span>
   <span class="kw">if</span> (int1 &lt; int2) {
      temp = int1;
      int1 = int2;
      int2 = temp;
   }
   <span class="co">/* Now just try every divisor from int2 on down, until a common</span>
<span class="co">      divisor is found. This can never be an infinite loop because</span>
<span class="co">      1 divides everything evenly */</span>
   <span class="kw">for</span> (trial_divisor = int2; ((int1 % trial_divisor) != <span class="dv">0</span>) ||
         ((int2 % trial_divisor) != <span class="dv">0</span>); trial_divisor—)
      ;
   <span class="kw">return</span>(trial_divisor);
}</code></pre>
<section id="wasted-breakthroughs" class="level4">
<h4><a href="#wasted-breakthroughs">Wasted Breakthroughs</a></h4>
<p>Sedgewick’s first solution to the GCD problem was pretty much the one I came up with. He then pointed out that the GCD of iL and iS is the same as the GCD of iL-iS and iS. This was obvious (once Sedgewick pointed it out); by the very nature of division, any number that divides iL evenly nL times and iS evenly nS times must divide iL-iS evenly nL-nS times. Given that insight, I immediately designed a new, faster approach, shown in Listing 10.2.</p>
<p><strong>LISTING 10.2 L10-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Finds and returns the greatest common divisor of two positive</span>
<span class="co">   integers. Works by subtracting the smaller integer from the</span>
<span class="co">   larger integer until either the values match (in which case</span>
<span class="co">   that&#39;s the gcd), or the larger integer becomes the smaller of</span>
<span class="co">   the two, in which case the two integers swap roles and the</span>
<span class="co">   subtraction process continues. */</span>

<span class="dt">unsigned</span> <span class="dt">int</span> gcd(<span class="dt">unsigned</span> <span class="dt">int</span> int1, <span class="dt">unsigned</span> <span class="dt">int</span> int2) {
   <span class="dt">unsigned</span> <span class="dt">int</span> temp;
   <span class="co">/* If the two integers are the same, that&#39;s the gcd and we&#39;re</span>
<span class="co">      done */</span>
   <span class="kw">if</span> (int1 == int2) {
      <span class="kw">return</span>(int1);
   }
   <span class="co">/* Swap if necessary to make sure that int1 &gt;= int2 */</span>
   <span class="kw">if</span> (int1 &lt; int2) {
      temp = int1;
      int1 = int2;
      int2 = temp;
   }

   <span class="co">/* Subtract int2 from int1 until int1 is no longer the larger of</span>
<span class="co">      the two */</span>
   <span class="kw">do</span> {
      int1 -= int2;
   } <span class="kw">while</span> (int1 &gt; int2);
   <span class="co">/* Now recursively call this function to continue the process */</span>
   <span class="kw">return</span>(gcd(int1, int2));
}</code></pre>
<p>Listing 10.2 repeatedly subtracts iS from iL until iL becomes less than or equal to iS. If iL becomes equal to iS, then that’s the GCD; alternatively, if iL becomes <em>less</em> than iS, iL and iS switch values, and the process is repeated, as shown in Figure 10.2. The number of iterations this approach requires relative to Listing 10.1 depends heavily on the values of iL and iS, so it’s not always faster, but, as Table 10.1 indicates, Listing 10.2 is generally much better code.</p>
<figure>
<img src="images/10-02.jpg" alt="Figure 10.2  Using repeated subtraction algorithm to find a GCD." /><figcaption><strong>Figure 10.2</strong>  <em>Using repeated subtraction algorithm to find a GCD.</em></figcaption>
</figure>
<p>Listing 10.2 is a far graver misstep than Listing 10.1, for all that it’s faster. Listing 10.1 is obviously a hacked-up, brute-force approach; no one could mistake it for anything else. It could be speeded up in any of a number of ways with a little thought. (Simply skipping testing all the divisors between iS and iS/2, not inclusive, would cut the worst-case time in half, for example; that’s not a particularly <em>good</em> optimization, but it illustrates how easily Listing 10.1 can be improved.) Listing 10.1 is a hack job, crying out for inspiration.</p>
<p>Listing 10.2, on the other hand, has gotten the inspiration—and largely wasted it through haste. Had Sedgewick not told me otherwise, I might well have assumed that Listing 10.2 was optimized, a mistake I would never have made with Listing 10.1. I experienced a conceptual breakthrough when I understood Sedgewick’s point: A smaller number can be subtracted from a larger number without affecting their GCD, thereby inexpensively reducing the scale of the problem. And, in my hurry to make this breakthrough reality, I missed its full scope. As Sedgewick says on the very next page, the number that one gets by subtracting iS from iL until iL is less than iS is precisely the same as the remainder that one gets by dividing iL by iS—again, this is inherent in the nature of division—and <em>that</em> is the basis for Euclid’s algorithm, shown in Figure 10.3. Listing 10.3 is an implementation of Euclid’s algorithm.</p>
<p><strong>LISTING 10.3 L10-3.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Finds and returns the greatest common divisor of two integers.</span>
<span class="co">   Uses Euclid&#39;s algorithm: divides the larger integer by the</span>
<span class="co">   smaller; if the remainder is 0, the smaller integer is the GCD,</span>
<span class="co">   otherwise the smaller integer becomes the larger integer, the</span>
<span class="co">   remainder becomes the smaller integer, and the process is</span>
<span class="co">   repeated. */</span>

<span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">int</span> gcd_recurs(<span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">unsigned</span> <span class="dt">int</span>);

<span class="dt">unsigned</span> <span class="dt">int</span> gcd(<span class="dt">unsigned</span> <span class="dt">int</span> int1, <span class="dt">unsigned</span> <span class="dt">int</span> int2) {
   <span class="dt">unsigned</span> <span class="dt">int</span> temp;
   <span class="co">/* If the two integers are the same, that&#39;s the GCD and we&#39;re</span>
<span class="co">      done */</span>
   <span class="kw">if</span> (int1 == int2) {
      <span class="kw">return</span>(int1);
   }
   <span class="co">/* Swap if necessary to make sure that int1 &gt;= int2 */</span>
   <span class="kw">if</span> (int1 &lt; int2) {
      temp = int1;
      int1 = int2;
      int2 = temp;
   }

   <span class="co">/* Now call the recursive form of the function, which assumes</span>
<span class="co">      that the first parameter is the larger of the two */</span>
   <span class="kw">return</span>(gcd_recurs(int1, int2));
}

<span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">int</span> gcd_recurs(<span class="dt">unsigned</span> <span class="dt">int</span> larger_int,
      <span class="dt">unsigned</span> <span class="dt">int</span> smaller_int)
{
   <span class="dt">int</span> temp;

   <span class="co">/* If the remainder of larger_int divided by smaller_int is 0,</span>
<span class="co">      then smaller_int is the gcd */</span>
   <span class="kw">if</span> ((temp = larger_int % smaller_int) == <span class="dv">0</span>) {
      <span class="kw">return</span>(smaller_int);
   }
   <span class="co">/* Make smaller_int the larger integer and the remainder the</span>
<span class="co">      smaller integer, and call this function recursively to</span>
<span class="co">      continue the process */</span>
   <span class="kw">return</span>(gcd_recurs(smaller_int, temp));
}</code></pre>
<p>As you can see from Table 10.1, Euclid’s algorithm is superior, especially for large numbers (and imagine if we were working with large <em>longs!</em>).</p>
<blockquote>
<p><img src="images/i.jpg" /> Had I been implementing GCD determination without Sedgewick’s help, I would surely not have settled for Listing 10.1—but I might well have ended up with Listing 10.2 in my enthusiasm over the “brilliant” discovery of subtracting the lesser Using Euclid’s algorithm to find a GCD number from the greater. In a commercial product, my lack of patience and discipline could have been costly indeed.</p>
</blockquote>
<figure>
<img src="images/10-03.jpg" alt="Figure 10.3  Using Euclid’s algorithm to find a GCD." /><figcaption><strong>Figure 10.3</strong>  <em>Using Euclid’s algorithm to find a GCD.</em></figcaption>
</figure>
<p>Give your mind time and space to wander around the edges of important programming problems before you settle on any one approach. I titled this book’s first chapter “The Best Optimizer Is between Your Ears,” and that’s still true; what’s even more true is that the optimizer between your ears does its best work not at the implementation stage, but at the very beginning, when you try to imagine how what you want to do and what a computer is capable of doing can best be brought together.</p>
</section>
</section>
<section id="recursion" class="level3">
<h3><a href="#recursion">Recursion</a></h3>
<p>Euclid’s algorithm lends itself to recursion beautifully, so much so that an implementation like Listing 10.3 comes almost without thought. Again, though, take a moment to stop and consider what’s really going on, at the assembly language level, in Listing 10.3. There’s recursion and then there’s recursion; code recursion and data recursion, to be exact. Listing 10.3 is code recursion—recursion through calls—the sort most often used because it is conceptually simplest. However, code recursion tends to be slow because it pushes parameters and calls a subroutine for every iteration. Listing 10.4, which uses data recursion, is much faster and no more complicated than Listing 10.3. Actually, you could just say that Listing 10.4 uses a loop and ignore any mention of recursion; conceptually, though, Listing 10.4 performs the same recursive operations that Listing 10.3 does.</p>
<p><strong>LISTING 10.4 L10-4.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Finds and returns the greatest common divisor of two integers.</span>
<span class="co">   Uses Euclid&#39;s algorithm: divides the larger integer by the</span>
<span class="co">   smaller; if the remainder is 0, the smaller integer is the GCD,</span>
<span class="co">   otherwise the smaller integer becomes the larger integer, the</span>
<span class="co">   remainder becomes the smaller integer, and the process is</span>
<span class="co">   repeated. Avoids code recursion. */</span>

<span class="dt">unsigned</span> <span class="dt">int</span> gcd(<span class="dt">unsigned</span> <span class="dt">int</span> int1, <span class="dt">unsigned</span> <span class="dt">int</span> int2) {
   <span class="dt">unsigned</span> <span class="dt">int</span> temp;

   <span class="co">/* Swap if necessary to make sure that int1 &gt;= int2 */</span>
   <span class="kw">if</span> (int1 &lt; int2) {
      temp = int1;
      int1 = int2;
      int2 = temp;
   }
   <span class="co">/* Now loop, dividing int1 by int2 and checking the remainder,</span>
<span class="co">      until the remainder is 0. At each step, if the remainder isn&#39;t</span>
<span class="co">      0, assign int2 to int1, and the remainder to int2, then</span>
<span class="co">      repeat */</span>
   <span class="kw">for</span> (;;) {
      <span class="co">/* If the remainder of int1 divided by int2 is 0, then int2 is</span>
<span class="co">         the gcd */</span>
      <span class="kw">if</span> ((temp = int1 % int2) == <span class="dv">0</span>) {
         <span class="kw">return</span>(int2);
      }
      <span class="co">/* Make int2 the larger integer and the remainder the</span>
<span class="co">         smaller integer, and repeat the process */</span>
      int1 = int2;
      int2 = temp;
   }
}</code></pre>
<section id="patient-optimization" class="level4">
<h4><a href="#patient-optimization">Patient Optimization</a></h4>
<p>At long last, we’re ready to optimize GCD determination in the classic sense. Table 10.1 shows the performance of Listing 10.4 with and without Microsoft C/C++’s maximum optimization, and also shows the performance of Listing 10.5, an assembly language version of Listing 10.4. Sure, the optimized versions are faster than the unoptimized version of Listing 10.4—but the gains are small compared to those realized from the higher-level optimizations in Listings 10.2 through 10.4.</p>
<p><strong>LISTING 10.5 L10-5.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Finds and returns the greatest common divisor of two integers.</span>
<span class="co">; Uses Euclid&#39;s algorithm: divides the larger integer by the</span>
<span class="co">; smaller; if the remainder is 0, the smaller integer is the GCD,</span>
<span class="co">; otherwise the smaller integer becomes the larger integer, the</span>
<span class="co">; remainder becomes the smaller integer, and the process is</span>
<span class="co">; repeated. Avoids code recursion.</span>
<span class="co">;</span>
<span class="co">;</span>
<span class="co">;</span>
<span class="co">; C near-callable as:</span>
<span class="co">; unsigned int gcd(unsigned int int1, unsigned int int2);</span>

<span class="co">; Parameter structure:</span>
parms <span class="kw">struc</span>
      <span class="dt">dw</span>    ?              <span class="co">;pushed BP</span>
      <span class="dt">dw</span>    ?              <span class="co">;pushed return address</span>
<span class="kw">int1</span>  <span class="dt">dw</span>    ?              <span class="co">;integers for which to find</span>
int2  <span class="dt">dw</span>    ?              <span class="co">; the GCD</span>
parms ends

      .model         small
      .code
      public         _gcd
      <span class="kw">align</span> <span class="dv">2</span>
_gcd  proc  near
      <span class="kw">push</span>  <span class="kw">bp</span>             <span class="co">;preserve caller&#39;s stack frame</span>
      <span class="kw">mov</span>   <span class="kw">bp</span>,<span class="kw">sp</span>          <span class="co">;set up our stack frame</span>
      <span class="kw">push</span>  <span class="kw">si</span>             <span class="co">;preserve caller&#39;s register variables</span>
      <span class="kw">push</span>  <span class="kw">di</span>

<span class="co">;Swap if necessary to make sure that int1 &gt;= int2</span>
      <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="kw">int1</span>[<span class="kw">bp</span>]
      <span class="kw">mov</span>   <span class="kw">bx</span>,int2[<span class="kw">bp</span>]
      <span class="kw">cmp</span>   <span class="kw">ax</span>,<span class="kw">bx</span>          <span class="co">;is int1 &gt;= int2?</span>
      <span class="kw">jnb</span>   IntsSet        <span class="co">;yes, so we&#39;re all set</span>
      <span class="kw">xchg</span>  <span class="kw">ax</span>,<span class="kw">bx</span>          <span class="co">;no, so swap int1 and int2</span>
<span class="fu">IntsSet:</span>

<span class="co">; Now loop, dividing int1 by int2 and checking the remainder, until</span>
<span class="co">; the remainder is 0. At each step, if the remainder isn&#39;t 0, assign</span>
<span class="co">; int2 to int1, and the remainder to int2, then repeat.</span>
<span class="fu">GCDLoop:</span>
                           <span class="co">;if the remainder of int1 divided by</span>
                           <span class="co">; int2 is 0, then int2 is the gcd</span>
      <span class="kw">sub</span>   <span class="kw">dx</span>,<span class="kw">dx</span>          <span class="co">;prepare int1 in DX:AX for division</span>
      <span class="kw">div</span>   <span class="kw">bx</span>             <span class="co">;int1/int2; remainder is in DX</span>
      <span class="kw">and</span>   <span class="kw">dx</span>,<span class="kw">dx</span>          <span class="co">;is the remainder zero?</span>
      <span class="kw">jz</span>    Done           <span class="co">;yes, so int2 (BX) is the gcd</span>
                           <span class="co">;no, so move int2 to int1 and the</span>
                           <span class="co">; remainder to int2, and repeat the</span>
                           <span class="co">; process</span>
      <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="kw">bx</span>          <span class="co">;int1 = int2;</span>
      <span class="kw">mov</span>   <span class="kw">bx</span>,<span class="kw">dx</span>          <span class="co">;int2 = remainder from DIV</span>

<span class="co">;—start of loop unrolling; the above is repeated three times—</span>
      <span class="kw">sub</span>   <span class="kw">dx</span>,<span class="kw">dx</span>          <span class="co">;prepare int1 in DX:AX for division</span>
      <span class="kw">div</span>   <span class="kw">bx</span>             <span class="co">;int1/int2; remainder is in DX</span>
      <span class="kw">and</span>   <span class="kw">dx</span>,<span class="kw">dx</span>          <span class="co">;is the remainder zero?</span>
      <span class="kw">jz</span>    Done           <span class="co">;yes, so int2 (BX) is the gcd</span>
      <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="kw">bx</span>          <span class="co">;int1 = int2;</span>
      <span class="kw">mov</span>   <span class="kw">bx</span>,<span class="kw">dx</span>          <span class="co">;int2 = remainder from DIV</span>
<span class="co">;—</span>
      <span class="kw">sub</span>   <span class="kw">dx</span>,<span class="kw">dx</span>          <span class="co">;prepare int1 in DX:AX for division</span>
      <span class="kw">div</span>   <span class="kw">bx</span>             <span class="co">;int1/int2; remainder is in DX</span>
      <span class="kw">and</span>   <span class="kw">dx</span>,<span class="kw">dx</span>          <span class="co">;is the remainder zero?</span>
      <span class="kw">jz</span>    Done           <span class="co">;yes, so int2 (BX) is the gcd</span>
      <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="kw">bx</span>          <span class="co">;int1 = int2;</span>
      <span class="kw">mov</span>   <span class="kw">bx</span>,<span class="kw">dx</span>          <span class="co">;int2 = remainder from DIV</span>
<span class="co">;—</span>
      <span class="kw">sub</span>   <span class="kw">dx</span>,<span class="kw">dx</span>          <span class="co">;prepare int1 in DX:AX for division</span>
      <span class="kw">div</span>   <span class="kw">bx</span>             <span class="co">;int1/int2; remainder is in DX</span>
      <span class="kw">and</span>   <span class="kw">dx</span>,<span class="kw">dx</span>          <span class="co">;is the remainder zero?</span>
      <span class="kw">jz</span>    Done           <span class="co">;yes, so int2 (BX) is the gcd</span>
      <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="kw">bx</span>          <span class="co">;int1 = int2;</span>
      <span class="kw">mov</span>   <span class="kw">bx</span>,<span class="kw">dx</span>          <span class="co">;int2 = remainder from DIV</span>
<span class="co">;—end of loop unrolling—</span>
      <span class="kw">jmp</span>   GCDLoop

      align2
<span class="fu">Done:</span>
      <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="kw">bx</span>          <span class="co">;return the GCD</span>
      <span class="kw">pop</span>   <span class="kw">di</span>             <span class="co">;restore caller&#39;s register variables</span>
      <span class="kw">pop</span>   <span class="kw">si</span>
      <span class="kw">pop</span>   <span class="kw">bp</span>             <span class="co">;restore caller&#39;s stack frame</span>
      <span class="kw">ret</span>
_gcd  endp
      end</code></pre>
<p>Assembly language optimization is pattern matching on a local scale. Frankly, it’s also the sort of boring, brute-force work that people are lousy at; compilers could out-optimize you at this level with one pass tied behind their back <em>if</em> they knew as much about the code you’re writing as you do, which they don’t.</p>
<blockquote>
<p><img src="images/i.jpg" /> Design optimization—conceptual breakthroughs in understanding the relationships between the needs of an application, the nature of the data the application works with, and what the computer can do—is global pattern matching.</p>
</blockquote>
<p>Computers are <em>much</em> worse at that sort of pattern matching than humans; computers have no way to integrate vast amounts of disparate information, much of it only vaguely defined or subject to change. People, oddly enough, are <em>better</em> at global optimization than at local optimization. For one thing, it’s more interesting. For another, it’s complex and imprecise enough to allow intuition and inspiration, two vastly underrated programming tools, to come to the fore. And, as I pointed out earlier, people tend to perform instantaneous solutions to even the most complex problems, while computers bog down in geometrically or exponentially increasing execution times. Oh, it may take days or weeks for a person to absorb enough information to be able to reach a solution, and the solution may only be near-optimal—but the solution itself (or, at least, each of the pieces of the solution) arrives in a flash.</p>
<p>Those flashes are your programming pattern matcher doing its job. <em>Your</em> job is to give your pattern matcher the opportunity to get to know each problem and run through it two or three times, from different angles, to see what unexpected solutions it can come up with.</p>
<p>Pull back the reins a little. Don’t measure progress by lines of code written today; measure it instead by overall progress and by quality. Relax and listen to that quiet inner voice that provides the real breakthroughs. Stop, look, listen—and think. Not only will you find that it’s a more productive and creative way to program—but you’ll also find that it’s more fun.</p>
<p>And think what you could do with all those extra computer years!</p>
</section>
</section>
</section>
<section id="chapter-11-pushing-the-286-and-386" class="level2">
<h2><a href="#chapter-11-pushing-the-286-and-386">Chapter 11 – Pushing the 286 and 386</a></h2>
<section id="new-registers-new-instructions-new-timings-new-complications" class="level3">
<h3><a href="#new-registers-new-instructions-new-timings-new-complications">New Registers, New Instructions, New Timings, New Complications</a></h3>
<p>This chapter, adapted from my earlier book <em>Zen of Assembly Language</em> (1989; now out of print), provides an overview of the 286 and 386, often contrasting those processors with the 8088. At the time I originally wrote this, the 8088 was the king of processors, and the 286 and 386 were the new kids on the block. Today, of course, all three processors are past their primes, but many millions of each are still in use, and the 386 in particular is still well worth considering when optimizing software.</p>
<p>This chapter provides an interesting look at the evolution of the x86 architecture, to a greater degree than you might expect, for the x86 family came into full maturity with the 386; the 486 and the Pentium are really nothing more than faster 386s, with very little in the way of new functionality. In contrast, the 286 added a number of instructions, respectable performance, and protected mode to the 8088’s capabilities, and the 386 added more instructions and a whole new set of addressing modes, and brought the x86 family into the 32-bit world that represents the future (and, increasingly, the present) of personal computing. This chapter also provides insight into the effects on optimization of the variations in processors and memory architectures that are common in the PC world. So, although the 286 and 386 no longer represent the mainstream of computing, this chapter is a useful mix of history lesson, x86 overview, and details on two workhorse processors that are still in wide use.</p>
<section id="family-matters" class="level4">
<h4><a href="#family-matters">Family Matters</a></h4>
<p>While the x86 family is a large one, only a few members of the family—which includes the 8088, 8086, 80188, 80186, 286, 386SX, 386DX, numerous permutations of the 486, and now the Pentium—really matter.</p>
<p>The 8088 is now all but extinct in the PC arena. The 8086 was used fairly widely for a while, but has now all but disappeared. The 80186 and 80188 never really caught on for use in PC and don’t require further discussion.</p>
<p>That leaves us with the high-end chips: the 286, the 386SX, the 386, the 486, and the Pentium. At this writing, the 386SX is fast going the way of the 8088; people are realizing that its relatively small cost advantage over the 386 isn’t enough to offset its relatively large performance disadvantage. After all, the 386SX suffers from the same debilitating problem that looms over the 8088—a too-small bus. Internally, the 386SX is a 32-bit processor, but externally, it’s a 16-bit processor, a non-optimal architecture, especially for 32-bit code.</p>
<p>I’m not going to discuss the 386SX in detail. If you do find yourself programming for the 386SX, follow the same general rules you should follow for the 8088: use short instructions, use the registers as heavily as possible, and don’t branch. In other words, avoid memory, since the 386SX is by definition better at processing data internally than it is at accessing memory.</p>
<p>The 486 is a world unto itself for the purposes of optimization, and the Pentium is a <em>universe</em> unto itself. We’ll treat them separately in later chapters.</p>
<p>This leaves us with just two processors: the 286 and the 386. Each was <em>the</em> PC standard in its day. The 286 is no longer used in new systems, but there are millions of 286-based systems still in daily use. The 386 is still being used in new systems, although it’s on the downhill leg of its lifespan, and it is in even wider use than the 286. The future clearly belongs to the 486 and Pentium, but the 286 and 386 are still very much a part of the present-day landscape.</p>
</section>
<section id="crossing-the-gulf-to-the-286-and-the-386" class="level4">
<h4><a href="#crossing-the-gulf-to-the-286-and-the-386">Crossing the Gulf to the 286 and the 386</a></h4>
<p>Apart from vastly improved performance, the biggest difference between the 8088 and the 286 and 386 (as well as the later Intel CPUs) is that the 286 introduced protected mode, and the 386 greatly expanded the capabilities of protected mode. We’re only going to talk about real-mode operation of the 286 and 386 in this book, however. Protected mode offers a whole new memory management scheme, one that isn’t supported by the 8088. Only code specifically written for protected mode can run in that mode; it’s an alien and hostile environment for MS-DOS programs.</p>
<p>In particular, segments are different creatures in protected mode. They’re <em>selectors</em>—indexes into a table of segment descriptors—rather than plain old registers, and can’t be set to arbitrary values. That means that segments can’t be used for temporary storage or as part of a fast indivisible 32-bit load from memory, as in</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">les</span>  <span class="kw">ax</span>,<span class="dt">dword</span> <span class="dt">ptr</span> [LongVar]
<span class="kw">mov</span>  <span class="kw">dx</span>,<span class="kw">es</span></code></pre>
<p>which loads <code>LongVar</code> into DX:AX faster than this:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [LongVar]
<span class="kw">mov</span>  <span class="kw">dx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [LongVar<span class="dv">+2</span>]</code></pre>
<p>Protected mode uses those altered segment registers to offer access to a great deal more memory than real mode: The 286 supports 16 megabytes of memory, while the 386 supports 4 gigabytes (4K megabytes) of physical memory and 64 <em>terabytes</em> (64K gigabytes!) of virtual memory.</p>
<p>In protected mode, your programs generally run under an operating system (OS/2, Unix, Windows NT or the like) that exerts much more control over the computer than does MS-DOS. Protected mode operating systems can generally run multiple programs simultaneously, and the performance of any one program may depend far less on code quality than on how efficiently the program uses operating system services and how often and under what circumstances the operating system preempts the program. Protected mode programs are often mostly collections of operating system calls, and the performance of whatever code <em>isn’t</em> operating-system oriented may depend primarily on how large a time slice the operating system gives that code to run in.</p>
<p>In short, taken as a whole, protected mode programming is a different kettle of fish altogether from what I’ve been describing in this book. There’s certainly a knack to optimizing specifically for protected mode under a given operating system…but it’s not what we’ve been learning, and now is not the time to pursue it further. In general, though, the optimization strategies discussed in this book still hold true in protected mode; it’s just issues specific to protected mode or a particular operating system that we won’t discuss.</p>
</section>
<section id="in-the-lair-of-the-cycle-eaters-part-ii" class="level4">
<h4><a href="#in-the-lair-of-the-cycle-eaters-part-ii">In the Lair of the Cycle-Eaters, Part II</a></h4>
<p>Under the programming interface, the 286 and 386 differ considerably from the 8088. Nonetheless, with one exception and one addition, the cycle-eaters remain much the same on computers built around the 286 and 386. Next, we’ll review each of the familiar cycle-eaters I covered in Chapter 4 as they apply to the 286 and 386, and we’ll look at the new member of the gang, the data alignment cycle-eater.</p>
<p>The one cycle-eater that vanishes on the 286 and 386 is the 8-bit bus cycle-eater. The 286 is a 16-bit processor both internally and externally, and the 386 is a 32-bit processor both internally and externally, so the Execution Unit/Bus Interface Unit size mismatch that plagues the 8088 is eliminated. Consequently, there’s no longer any need to use byte-sized memory variables in preference to word-sized variables, at least so long as word-sized variables start at even addresses, as we’ll see shortly. On the other hand, access to byte-sized variables still isn’t any <em>slower</em> than access to word-sized variables, so you can use whichever size suits a given task best.</p>
<p>You might think that the elimination of the 8-bit bus cycle-eater would mean that the prefetch queue cycle-eater would also vanish, since on the 8088 the prefetch queue cycle-eater is a side effect of the 8-bit bus. That would seem all the more likely given that both the 286 and the 386 have larger prefetch queues than the 8088 (6 bytes for the 286, 16 bytes for the 386) and can perform memory accesses, including instruction fetches, in far fewer cycles than the 8088.</p>
<p>However, the prefetch queue cycle-eater <em>doesn’t</em> vanish on either the 286 or the 386, for several reasons. For one thing, branching instructions still empty the prefetch queue, so instruction fetching still slows things down after most branches; when the prefetch queue is empty, it doesn’t much matter how big it is. (Even apart from emptying the prefetch queue, branches aren’t particularly fast on the 286 or the 386, at a minimum of seven-plus cycles apiece. Avoid branching whenever possible.)</p>
<p>After a branch it <em>does</em> matter how fast the queue can refill, and there we come to the second reason the prefetch queue cycle-eater lives on: The 286 and 386 are so fast that sometimes the Execution Unit can execute instructions faster than they can be fetched, even though instruction fetching is <em>much</em> faster on the 286 and 386 than on the 8088.</p>
<p>(All other things being equal, too-slow instruction fetching is more of a problem on the 286 than on the 386, since the 386 fetches 4 instruction bytes at a time versus the 2 instruction bytes fetched per memory access by the 286. However, the 386 also typically runs at least twice as fast as the 286, meaning that the 386 can easily execute instructions faster than they can be fetched unless very high-speed memory is used.)</p>
<p>The most significant reason that the prefetch queue cycle-eater not only survives but prospers on the 286 and 386, however, lies in the various memory architectures used in computers built around the 286 and 386. Due to the memory architectures, the 8-bit bus cycle-eater is replaced by a new form of the wait state cycle-eater: wait states on accesses to normal system memory.</p>
</section>
<section id="system-wait-states" class="level4">
<h4><a href="#system-wait-states">System Wait States</a></h4>
<p>The 286 and 386 were designed to lose relatively little performance to the prefetch queue cycle-eater…<em>when used with zero-wait-state memory:</em> memory that can complete memory accesses so rapidly that no wait states are needed. However, true zero-wait-state memory is almost never used with those processors. Why? Because memory that can keep up with a 286 is fairly expensive, and memory that can keep up with a 386 is <em>very</em> expensive. Instead, computer designers use alternative memory architectures that offer more performance for the dollar—but less performance overall—than zero-wait-state memory. (It <em>is</em> possible to build zero-wait-state systems for the 286 and 386; it’s just so expensive that it’s rarely done.)</p>
<p>The IBM AT and true compatibles use one-wait-state memory (some AT clones use zero-wait-state memory, but such clones are less common than one-wait-state AT clones). The 386 systems use a wide variety of memory systems—including high-speed caches, interleaved memory, and static-column RAM—that insert anywhere from 0 to about 5 wait states (and many more if 8 or 16-bit memory expansion cards are used); the exact number of wait states inserted at any given time depends on the interaction between the code being executed and the memory system it’s running on.</p>
<blockquote>
<p><img src="images/i.jpg" /> The performance of most 386 memory systems can vary greatly from one memory access to another, depending on factors such as what data happens to be in the cache and which interleaved bank and/or RAM column was accessed last.</p>
</blockquote>
<p>The many memory systems in use make it impossible for us to optimize for 286/386 computers with the precision that’s possible on the 8088. Instead, we must write code that runs reasonably well under the varying conditions found in the 286/386 arena.</p>
<p>The wait states that occur on most accesses to system memory in 286 and 386 computers mean that nearly every access to system memory—memory in the DOS’s normal 640K memory area—is slowed down. (Accesses in computers with high-speed caches may be wait-state-free if the desired data is already in the cache, but will certainly encounter wait states if the data isn’t cached; this phenomenon produces highly variable instruction execution times.) While this is our first encounter with system memory wait states, we have run into a wait-state cycle-eater before: the display adapter cycle-eater, which we discussed along with the other 8088 cycle-eaters way back in Chapter 4. System memory generally has fewer wait states per access than display memory. However, system memory is also accessed far more often than display memory, so system memory wait states hurt plenty—and the place they hurt most is instruction fetching.</p>
<p>Consider this: The 286 can store an immediate value to memory, as in <code>MOV [WordVar],0</code>, in just 3 cycles. However, that instruction is 6 bytes long. The 286 is capable of fetching 1 word every 2 cycles; however, the one-wait-state architecture of the AT stretches that to 3 cycles. Consequently, nine cycles are needed to fetch the six instruction bytes. On top of that, 3 cycles are needed to write to memory, bringing the total memory access time to 12 cycles. On balance, memory access time—especially instruction prefetching—greatly exceeds execution time, to the extent that this particular instruction can take up to four times as long to run as it does to execute in the Execution Unit.</p>
<p>And that, my friend, is unmistakably the prefetch queue cycle-eater. I might add that the prefetch queue cycle-eater is in rare good form in the above example: A 4-to-1 ratio of instruction fetch time to execution time is in a class with the best (or worst!) that’s found on the 8088.</p>
<p>Let’s check out the prefetch queue cycle-eater in action. Listing 11.1 times <code>MOV [WordVar],0</code>. The Zen timer reports that on a one-wait-state 10 MHz 286-based AT clone (the computer used for all tests in this chapter), Listing 11.1 runs in 1.27 µs per instruction. That’s 12.7 cycles per instruction, just as we calculated. (That extra seven-tenths of a cycle comes from DRAM refresh, which we’ll get to shortly.)</p>
<p><strong>LISTING 11.1 L11-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">;</span>
<span class="co">; *** Listing 11.1 ***</span>
<span class="co">;</span>
<span class="co">; Measures the performance of an immediate move to</span>
<span class="co">; memory, in order to demonstrate that the prefetch</span>
<span class="co">; queue cycle-eater is alive and well on the AT.</span>
<span class="co">;</span>
        <span class="kw">jmp</span>     Skip
<span class="co">;</span>
        even            <span class="co">;always make sure word-sized memory</span>
                        <span class="co">; variables are word-aligned!</span>
WordVar <span class="dt">dw</span>      <span class="dv">0</span>
<span class="co">;</span>
<span class="fu">Skip:</span>
        <span class="kw">call</span>    ZTimerOn
        rept    <span class="dv">1000</span>
        <span class="kw">mov</span>     [WordVar],<span class="dv">0</span>
        endm
        <span class="kw">call</span>    ZTimerOff</code></pre>
<p>What does this mean? It means that, practically speaking, the 286 as used in the AT doesn’t have a 16-bit bus. From a performance perspective, the 286 in an AT has two-thirds of a 16-bit bus (a 10.7-bit bus?), since every bus access on an AT takes 50 percent longer than it should. A 286 running at 10 MHz <em>should</em> be able to access memory at a maximum rate of 1 word every 200 ns; in a 10 MHz AT, however, that rate is reduced to 1 word every 300 ns by the one-wait-state memory.</p>
<p>In short, a close relative of our old friend the 8-bit bus cycle-eater—the system memory wait state cycle-eater—haunts us still on all but zero-wait-state 286 and 386 computers, and that means that the prefetch queue cycle-eater is alive and well. (The system memory wait state cycle-eater isn’t really a new cycle-eater, but rather a variant of the general wait state cycle-eater, of which the display adapter cycle-eater is yet another variant.) While the 286 in the AT can fetch instructions much faster than can the 8088 in the PC, it can execute those instructions faster still.</p>
<p>The picture is less clear in the 386 world since there are so many different memory architectures, but similar problems can occur in any computer built around a 286 or 386. The prefetch queue cycle-eater is even a factor—albeit a lesser one—on zero-wait-state machines, both because branching empties the queue and because some instructions can outrun even zero—5 cycles longer than the official execution time.)</p>
<p>To summarize:</p>
<ul>
<li>Memory-accessing instructions don’t run at their official speeds on non-zero-wait-state 286/386 computers.</li>
<li>The prefetch queue cycle-eater reduces performance on 286/386 computers, particularly when non-zero-wait-state memory is used.</li>
<li>Branches often execute at less than their rated speeds on the 286 and 386 since the prefetch queue is emptied.</li>
<li>The extent to which the prefetch queue and wait states affect performance varies from one 286/386 computer to another, making precise optimization impossible.</li>
</ul>
<p>What’s to be learned from all this? Several things:</p>
<ul>
<li>Keep your instructions short.</li>
<li>Keep it in the registers; avoid memory, since memory generally can’t keep up with the processor.</li>
<li>Don’t jump.</li>
</ul>
<p>Of course, those are exactly the rules that apply to 8088 optimization as well. Isn’t it convenient that the same general rules apply across the board?</p>
</section>
<section id="data-alignment" class="level4">
<h4><a href="#data-alignment">Data Alignment</a></h4>
<p>Thanks to its 16-bit bus, the 286 can access word-sized memory variables just as fast as byte-sized variables. There’s a catch, however: That’s only true for word-sized variables that start at even addresses. When the 286 is asked to perform a word-sized access starting at an odd address, it actually performs two separate accesses, each of which fetches 1 byte, just as the 8088 does for all word-sized accesses.</p>
<p>Figure 11.1 illustrates this phenomenon. The conversion of word-sized accesses to odd addresses into double byte-sized accesses is transparent to memory-accessing instructions; all any instruction knows is that the requested word has been accessed, no matter whether 1 word-sized access or 2 byte-sized accesses were required to accomplish it.</p>
<p>The penalty for performing a word-sized access starting at an odd address is easy to calculate: Two accesses take twice as long as one access.</p>
<blockquote>
<p><img src="images/i.jpg" /> In other words, the effective capacity of the 286’s external data bus is <em>halved</em> when a word-sized access to an odd address is performed.</p>
</blockquote>
<p>That, in a nutshell, is the data alignment cycle-eater, the one new cycle-eater of the 286 and 386. (The data alignment cycle-eater is a close relative of the 8088’s 8-bit bus cycle-eater, but since it behaves differently—occurring only at odd addresses—and is avoided with a different workaround, we’ll consider it to be a new cycle-eater.)</p>
<figure>
<img src="images/11-01.jpg" alt="Figure 11.1  The data alignment cycle-eater." /><figcaption><strong>Figure 11.1</strong>  <em>The data alignment cycle-eater.</em></figcaption>
</figure>
<p>The way to deal with the data alignment cycle-eater is straightforward: <em>Don’t perform word-sized accesses to odd addresses on the 286 if you can help it</em>. The easiest way to avoid the data alignment cycle-eater is to place the directive <code>EVEN</code> before each of your word-sized variables. <code>EVEN</code> forces the offset of the next byte assembled to be even by inserting a <code>NOP</code> if the current offset is odd; consequently, you can ensure that any word-sized variable can be accessed efficiently by the 286 simply by preceding it with <code>EVEN</code>.</p>
<p>Listing 11.2, which accesses memory a word at a time with each word starting at an odd address, runs on a 10 MHz AT clone in 1.27 ms per repetition of <code>MOVSW</code>, or 0.64 ms per word-sized memory access. That’s 6-plus cycles per word-sized access, which breaks down to two separate memory accesses—3 cycles to access the high byte of each word and 3 cycles to access the low byte of each word, the inevitable result of non-word-aligned word-sized memory accesses—plus a bit extra for DRAM refresh.</p>
<p><strong>LISTING 11.2 L11-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">;</span>
<span class="co">; *** Listing 11.2 ***</span>
<span class="co">;</span>
<span class="co">; Measures the performance of accesses to word-sized</span>
<span class="co">; variables that start at odd addresses (are not</span>
<span class="co">; word-aligned).</span>
<span class="co">;</span>
<span class="fu">Skip:</span>
        <span class="kw">push</span>    <span class="kw">ds</span>
        <span class="kw">pop</span>     <span class="kw">es</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,<span class="dv">1</span>    <span class="co">;source and destination are the same</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">si</span>   <span class="co">; and both are not word-aligned</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">1000</span> <span class="co">;move 1000 words</span>
        <span class="kw">cld</span>
        <span class="kw">call</span>    ZTimerOn
        rep     <span class="kw">movsw</span>
        <span class="kw">call</span>    ZTimerOff</code></pre>
<p>On the other hand, Listing 11.3, which is exactly the same as Listing 11.2 save that the memory accesses are word-aligned (start at even addresses), runs in 0.64 ms per repetition of <code>MOVSW</code>, or 0.32 µs per word-sized memory access. That’s 3 cycles per word-sized access—exactly twice as fast as the non-word-aligned accesses of Listing 11.2, just as we predicted.</p>
<p><strong>LISTING 11.3 L11-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">;</span>
<span class="co">; *** Listing 11.3 ***</span>
<span class="co">;</span>
<span class="co">; Measures the performance of accesses to word-sized</span>
<span class="co">; variables that start at even addresses (are word-aligned).</span>
<span class="co">;</span>
<span class="fu">Skip:</span>
        <span class="kw">push</span>    <span class="kw">ds</span>
        <span class="kw">pop</span>     <span class="kw">es</span>
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">si</span>   <span class="co">;source and destination are the same</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">si</span>   <span class="co">; and both are word-aligned</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">1000</span> <span class="co">;move 1000 words</span>
        <span class="kw">cld</span>
        <span class="kw">call</span>    ZTimerOn
        rep     <span class="kw">movsw</span>
        <span class="kw">call</span>    ZTimerOff</code></pre>
<p>The data alignment cycle-eater has intriguing implications for speeding up 286/386 code. The expenditure of a little care and a few bytes to make sure that word-sized variables and memory blocks are word-aligned can literally double the performance of certain code running on the 286. Even if it doesn’t double performance, word alignment usually helps and never hurts.</p>
</section>
<section id="code-alignment" class="level4">
<h4><a href="#code-alignment">Code Alignment</a></h4>
<p>Lack of word alignment can also interfere with instruction fetching on the 286, although not to the extent that it interferes with access to word-sized memory variables. The 286 prefetches instructions a word at a time; even if a given instruction doesn’t begin at an even address, the 286 simply fetches the first byte of that instruction at the same time that it fetches the last byte of the previous instruction, as shown in Figure 11.2, then separates the bytes internally. That means that in most cases, instructions run just as fast whether they’re word-aligned or not.</p>
<p>There is, however, a non-word-alignment penalty on <em>branches</em> to odd addresses. On a branch to an odd address, the 286 is only able to fetch 1 useful byte with the first instruction fetch following the branch, as shown in Figure 11.3. In other words, lack of word alignment of the target instruction for any branch effectively cuts the instruction-fetching power of the 286 in half for the first instruction fetch after that branch. While that may not sound like much, you’d be surprised at what it can do to tight loops; in fact, a brief story is in order.</p>
<p>When I was developing the Zen timer, I used my trusty 10 MHz 286-based AT clone to verify the basic functionality of the timer by measuring the performance of simple instruction sequences. I was cruising along with no problems until I timed the following code:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">    <span class="kw">mov</span>    <span class="kw">cx</span>,<span class="dv">1000</span>
    <span class="kw">call</span>   ZTimerOn
<span class="fu">LoopTop:</span>
    <span class="kw">loop</span>   LoopTop
    <span class="kw">call</span>   ZTimerOff</code></pre>
<figure>
<img src="images/11-02.jpg" alt="Figure 11.2  Word-aligned prefetching on the 286." /><figcaption><strong>Figure 11.2</strong>  <em>Word-aligned prefetching on the 286.</em></figcaption>
</figure>
<figure>
<img src="images/11-03.jpg" alt="Figure 11.3  How instruction bytes are fetched after a branch." /><figcaption><strong>Figure 11.3</strong>  <em>How instruction bytes are fetched after a branch.</em></figcaption>
</figure>
<p>Now, this code <em>should</em> run in, say, about 12 cycles per loop at most. Instead, it took over 14 cycles per loop, an execution time that I could not explain in any way. After rolling it around in my head for a while, I took a look at the code under a debugger…and the answer leaped out at me. <em>The loop began at an odd address!</em> That meant that two instruction fetches were required each time through the loop; one to get the opcode byte of the <code>LOOP</code> instruction, which resided at the end of one word-aligned word, and another to get the displacement byte, which resided at the start of the next word-aligned word.</p>
<p>One simple change brought the execution time down to a reasonable 12.5 cycles per loop:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">  <span class="kw">mov</span>   <span class="kw">cx</span>,<span class="dv">1000</span>
  <span class="kw">call</span>  ZTimerOn
  even
<span class="fu">LoopTop:</span>
  <span class="kw">loop</span>  LoopTop
  <span class="kw">call</span>  ZTimerOff</code></pre>
<p>While word-aligning branch destinations can improve branching performance, it’s a nuisance and can increase code size a good deal, so it’s not worth doing in most code. Besides, <code>EVEN</code> inserts a <code>NOP</code> instruction if necessary, and the time required to execute a <code>NOP</code> can sometimes cancel the performance advantage of having a word-aligned branch destination.</p>
<blockquote>
<p><img src="images/i.jpg" /> Consequently, it’s best to word-align only those branch destinations that can be reached solely by branching.</p>
</blockquote>
<p>I recommend that you only go out of your way to word-align the start offsets of your subroutines, as in:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">          even
FindChar  proc near
          :</code></pre>
<p>In my experience, this simple practice is the one form of code alignment that consistently provides a reasonable return for bytes and effort expended, although sometimes it also pays to word-align tight time-critical loops.</p>
</section>
<section id="alignment-and-the-386" class="level4">
<h4><a href="#alignment-and-the-386">Alignment and the 386</a></h4>
<p>So far we’ve only discussed alignment as it pertains to the 286. What, you may well ask, of the 386?</p>
<p>The 386 adds the issue of <em>doubleword</em> alignment (that is, alignment to addresses that are multiples of four.) The rule for the 386 is: Word-sized memory accesses should be word-aligned (it’s impossible for word-aligned word-sized accesses to cross doubleword boundaries), and doubleword-sized memory accesses should be doubleword-aligned. However, in real (as opposed to 32-bit protected) mode, doubleword-sized memory accesses are rare, so the simple word-alignment rule we’ve developed for the 286 serves for the 386 in real mode as well.</p>
<p>As for code alignment…the subroutine-start word-alignment rule of the 286 serves reasonably well there too since it avoids the worst case, where just 1 byte is fetched on entry to a subroutine. While optimum performance would dictate doubleword alignment of subroutines, that takes 3 bytes, a high price to pay for an optimization that improves performance <em>only</em> on the post 286 processors.</p>
</section>
<section id="alignment-and-the-stack" class="level4">
<h4><a href="#alignment-and-the-stack">Alignment and the Stack</a></h4>
<p>One side-effect of the data alignment cycle-eater of the 286 and 386 is that you should <em>never</em> allow the stack pointer to become odd. (You can make the stack pointer odd by adding an odd value to it or subtracting an odd value from it, or by loading it with an odd value.) An odd stack pointer on the 286 or 386 (or a non-doubleword-aligned stack in 32-bit protected mode on the 386, 486, or Pentium) will significantly reduce the performance of <code>PUSH</code>, <code>POP</code>, <code>CALL</code>, and <code>RET</code>, as well as <code>INT</code> and <code>IRET</code>, which are executed to invoke DOS and BIOS functions, handle keystrokes and incoming serial characters, and manage the mouse. I know of a Forth programmer who vastly improved the performance of a complex application on the AT simply by forcing the Forth interpreter to maintain an even stack pointer at all times.</p>
<p>An interesting corollary to this rule is that you shouldn’t <code>INC SP</code> twice to add 2, even though that takes fewer bytes than <code>ADD SP,2</code>. The stack pointer is odd between the first and second <code>INC</code>, so any interrupt occurring between the two instructions will be serviced more slowly than it normally would. The same goes for decrementing twice; use <code>SUB SP,2</code> instead.</p>
<blockquote>
<p><img src="images/i.jpg" /> Keep the stack pointer aligned at all times.</p>
</blockquote>
</section>
<section id="the-dram-refresh-cycle-eater-still-an-act-of-god" class="level4">
<h4><a href="#the-dram-refresh-cycle-eater-still-an-act-of-god">The DRAM Refresh Cycle-Eater: Still an Act of God</a></h4>
<p>The DRAM refresh cycle-eater is the cycle-eater that’s least changed from its 8088 form on the 286 and 386. In the AT, DRAM refresh uses a little over five percent of all available memory accesses, slightly less than it uses in the PC, but in the same ballpark. While the DRAM refresh penalty varies somewhat on various AT clones and 386 computers (in fact, a few computers are built around static RAM, which requires no refresh at all; likewise, caches are made of static RAM so cached systems generally suffer less from DRAM refresh), the 5 percent figure is a good rule of thumb.</p>
<p>Basically, the effect of the DRAM refresh cycle-eater is pretty much the same throughout the PC-compatible world: fairly small, so it doesn’t greatly affect performance; unavoidable, so there’s no point in worrying about it anyway; and a nuisance since it results in fractional cycle counts when using the Zen timer. Just as with the PC, a given code sequence on the AT can execute at varying speeds at different times as a result of the interaction between the code and DRAM refresh.</p>
<p>There’s nothing much new with DRAM refresh on 286/386 computers, then. Be aware of it, but don’t overly concern yourself—DRAM refresh is still an act of God, and there’s not a blessed thing you can do about it. Happily, the internal caches of the 486 and Pentium make DRAM refresh largely a performance non-issue on those processors.</p>
</section>
<section id="the-display-adapter-cycle-eater-1" class="level4">
<h4><a href="#the-display-adapter-cycle-eater-1">The Display Adapter Cycle-Eater</a></h4>
<p>Finally we come to the last of the cycle-eaters, the display adapter cycle-eater. There are two ways of looking at this cycle-eater on 286/386 computers: (1) It’s much worse than it was on the PC, or (2) it’s just about the same as it was on the PC.</p>
<p>Either way, the display adapter cycle-eater is extremely bad news on 286/386 computers and on 486s and Pentiums as well. In fact, this cycle-eater on those systems is largely responsible for the popularity of VESA local bus (VLB).</p>
<p>The two ways of looking at the display adapter cycle-eater on 286/386 computers are actually the same. As you’ll recall from my earlier discussion of the matter in Chapter 4, display adapters offer only a limited number of accesses to display memory during any given period of time. The 8088 is capable of making use of most but not all of those slots with <code>REP MOVSW</code>, so the number of memory accesses allowed by a display adapter such as a standard VGA is reasonably well-matched to an 8088’s memory access speed. Granted, access to a VGA slows the 8088 down considerably—but, as we’re about to find out, “considerably” is a relative term. What a VGA does to PC performance is nothing compared to what it does to faster computers.</p>
<p>Under ideal conditions, a 286 can access memory much, much faster than an 8088. A 10 MHz 286 is capable of accessing a word of system memory every 0.20 ms with <code>REP MOVSW</code>, dwarfing the 1 byte every 1.31 µs that the 8088 in a PC can manage. However, access to display memory is anything but ideal for a 286. For one thing, most display adapters are 8-bit devices, although newer adapters are 16-bit in nature. One consequence of that is that only 1 byte can be read or written per access to display memory; word-sized accesses to 8-bit devices are automatically split into 2 separate byte-sized accesses by the AT’s bus. Another consequence is that accesses are simply slower; the AT’s bus inserts additional wait states on accesses to 8-bit devices since it must assume that such devices were designed for PCs and may not run reliably at AT speeds.</p>
<p>However, the 8-bit size of most display adapters is but one of the two factors that reduce the speed with which the 286 can access display memory. Far more cycles are eaten by the inherent memory-access limitations of display adapters—that is, the limited number of display memory accesses that display adapters make available to the 286. Look at it this way: If <code>REP MOVSW</code> on a PC can use more than half of all available accesses to display memory, then how much faster can code running on a 286 or 386 possibly run when accessing display memory?</p>
<p>That’s right—less than twice as fast.</p>
<p>In other words, instructions that access display memory won’t run a whole lot faster on ATs and faster computers than they do on PCs. That explains one of the two viewpoints expressed at the beginning of this section: The display adapter cycle-eater is just about the same on high-end computers as it is on the PC, in the sense that it allows instructions that access display memory to run at just about the same speed on all computers.</p>
<p>Of course, the picture is quite a bit different when you compare the performance of instructions that access display memory to the <em>maximum</em> performance of those instructions. Instructions that access display memory receive many more wait states when running on a 286 than they do on an 8088. Why? While the 286 is capable of accessing memory much more often than the 8088, we’ve seen that the frequency of access to display memory is determined not by processor speed but by the display adapter itself. As a result, both processors are actually allowed just about the same maximum number of accesses to display memory in any given time. By definition, then, the 286 must spend many more cycles waiting than does the 8088.</p>
<p>And that explains the second viewpoint expressed above regarding the display adapter cycle-eater vis-a-vis the 286 and 386. The display adapter cycle-eater, as measured in cycles lost to wait states, is indeed much worse on AT-class computers than it is on the PC, and it’s worse still on more powerful computers.</p>
<blockquote>
<p><img src="images/i.jpg" /> How bad is the display adapter cycle-eater on an AT? It’s this bad: Based on my (not inconsiderable) experience in timing display adapter access, I’ve found that the display adapter cycle-eater can slow an AT—or even a 386 computer—to near-PC speeds when display memory is accessed.</p>
</blockquote>
<p>I know that’s hard to believe, but the display adapter cycle-eater gives out just so many display memory accesses in a given time, and no more, no matter how fast the processor is. In fact, the faster the processor, the more the display adapter cycle-eater hurts the performance of instructions that access display memory. The display adapter cycle-eater is not only still present in 286/386 computers, it’s worse than ever.</p>
<p>What can we do about this new, more virulent form of the display adapter cycle-eater? The workaround is the same as it was on the PC: Access display memory as little as you possibly can.</p>
</section>
<section id="new-instructions-and-features-the-286" class="level4">
<h4><a href="#new-instructions-and-features-the-286">New Instructions and Features: The 286</a></h4>
<p>The 286 and 386 offer a number of new instructions. The 286 has a relatively small number of instructions that the 8088 lacks, while the 386 has those instructions and quite a few more, along with new addressing modes and data sizes. We’ll discuss the 286 and the 386 separately in this regard.</p>
<p>The 286 has a number of instructions designed for protected-mode operations. As I’ve said, we’re not going to discuss protected mode in this book; in any case, protected-mode instructions are generally used only by operating systems. (I should mention that the 286’s protected mode brings with it the ability to address 16 MB of memory, a considerable improvement over the 8088’s 1 MB. In real mode, however, programs are still limited to 1 MB of addressable memory on the 286. In either mode, each segment is still limited to 64K.)</p>
<p>There are also a handful of 286-specific real-mode instructions, and they can be quite useful. <code>BOUND</code> checks array bounds. <code>ENTER</code> and <code>LEAVE</code> support compact and speedy stack frame construction and removal, ideal for interfacing to high-level languages such as C and Pascal (although these instructions are actually relatively slow on the 386 and its successors, and should be used with caution when performance matters). <code>INS</code> and <code>OUTS</code> are new string instructions that support efficient data transfer between memory and I/O ports. Finally, <code>PUSHA</code> and <code>POPA</code> push and pop all eight general-purpose registers.</p>
<p>A couple of old instructions gain new features on the 286. For one, the 286 version of <code>PUSH</code> is capable of pushing a constant on the stack. For another, the 286 allows all shifts and rotates to be performed for not just 1 bit or the number of bits specified by CL, but for <em>any</em> constant number of bits.</p>
</section>
<section id="new-instructions-and-features-the-386" class="level4">
<h4><a href="#new-instructions-and-features-the-386">New Instructions and Features: The 386</a></h4>
<p>The 386 is somewhat more complex than the 286 regarding new features. Once again, we won’t discuss protected mode, which on the 386 comes with the ability to address up to 4 gigabytes per segment and 64 terabytes in all. In real mode (and in virtual-86 mode, which allows the 386 to multitask MS-DOS applications, and which is identical to real mode so far as MS-DOS programs are concerned), programs running on the 386 are still limited to 1 MB of addressable memory and 64K per segment.</p>
<p>The 386 has many new instructions, as well as new registers, addressing modes and data sizes that have trickled down from protected mode. Let’s take a quick look at these new real-mode features.</p>
<p>Even in real mode, it’s possible to access many of the 386’s new and extended registers. Most of these registers are simply 32-bit extensions of the 16-bit registers of the 8088. For example, EAX is a 32-bit register containing AX as its lower 16 bits, EBX is a 32-bit register containing BX as its lower 16 bits, and so on. There are also two new segment registers: FS and GS.</p>
<p>The 386 also comes with a slew of new real-mode instructions beyond those supported by the 8088 and 286. These instructions can scan data on a bit-by-bit basis, set the Carry flag to the value of a specified bit, sign-extend or zero-extend data as it’s moved, set a register or memory variable to 1 or 0 on the basis of any of the conditions that can be tested with conditional jumps, and more. (Again, beware: Many of these complex 386-specific instructions are slower than equivalent sequences of simple instructions on the 486 and especially on the Pentium.) What’s more, both old and new instructions support 32-bit operations on the 386. For example, it’s relatively simple to copy data in chunks of 4 bytes on a 386, even in real mode, by using the <code>MOVSD</code> (“move string double”) instruction, or to negate a 32-bit value with <code>NEG eax</code>.</p>
<p>Finally, it’s possible in real mode to use the 386’s new addressing modes, in which <em>any</em> 32-bit general-purpose register or pair of registers can be used to address memory. What’s more, multiplication of memory-addressing registers by 2, 4, or 8 for look-ups in word, doubleword, or quadword tables can be built right into the memory addressing mode. (The 32-bit addressing modes are discussed further in later chapters.) In protected mode, these new addressing modes allow you to address a full 4 gigabytes per segment, but in real mode you’re still limited to 64K, even with 32-bit registers and the new addressing modes, unless you play some unorthodox tricks with the segment registers.</p>
<blockquote>
<p><img src="images/i.jpg" /> Note well: Those tricks don’t necessarily work with system software such as Windows, so I’d recommend against using them. If you want 4-gigabyte segments, use a 32-bit environment such as Win32.</p>
</blockquote>
</section>
<section id="optimization-rules-the-more-things-change" class="level4">
<h4><a href="#optimization-rules-the-more-things-change">Optimization Rules: The More Things Change…</a></h4>
<p>Let’s see what we’ve learned about 286/386 optimization. Mostly what we’ve learned is that our familiar PC cycle-eaters still apply, although in somewhat different forms, and that the major optimization rules for the PC hold true on ATs and 386-based computers. You won’t go wrong on any of these computers if you keep your instructions short, use the registers heavily and avoid memory, don’t branch, and avoid accessing display memory like the plague.</p>
<p>Although we haven’t touched on them, repeated string instructions are still desirable on the 286 and 386 since they provide a great deal of functionality per instruction byte and eliminate both the prefetch queue cycle-eater and branching. However, string instructions are not quite so spectacularly superior on the 286 and 386 as they are on the 8088 since non-string memory-accessing instructions have been speeded up considerably on the newer processors.</p>
<p>There’s one cycle-eater with new implications on the 286 and 386, and that’s the data alignment cycle-eater. From the data alignment cycle-eater we get a new rule: Word-align your word-sized variables, and start your subroutines at even addresses.</p>
</section>
<section id="detailed-optimization" class="level4">
<h4><a href="#detailed-optimization">Detailed Optimization</a></h4>
<p>While the major 8088 optimization rules hold true on computers built around the 286 and 386, many of the instruction-specific optimizations no longer hold, for the execution times of most instructions are quite different on the 286 and 386 than on the 8088. We have already seen one such example of the sometimes vast difference between 8088 and 286/386 instruction execution times: <code>MOV [WordVar],0</code>, which has an Execution Unit execution time of 20 cycles on the 8088, has an EU execution time of just 3 cycles on the 286 and 2 cycles on the 386.</p>
<p>In fact, the performance of virtually all memory-accessing instructions has been improved enormously on the 286 and 386. The key to this improvement is the near elimination of effective address (EA) calculation time. Where an 8088 takes from 5 to 12 cycles to calculate an EA, a 286 or 386 usually takes no time whatsoever to perform the calculation. If a base+index+displacement addressing mode, such as <code>MOV AX,[WordArray+bx+si]</code>, is used on a 286 or 386, 1 cycle is taken to perform the EA calculation, but that’s both the worst case and the only case in which there’s any EA overhead at all.</p>
<p>The elimination of EA calculation time means that the EU execution time of memory-addressing instructions is much closer to the EU execution time of register-only instructions. For instance, on the 8088 <code>ADD [WordVar],100H</code> is a 31-cycle instruction, while <code>ADD DX,100H</code> is a 4-cycle instruction—a ratio of nearly 8 to 1. By contrast, on the 286 <code>ADD [WordVar],100H</code> is a 7-cycle instruction, while <code>ADD DX,100H</code> is a 3-cycle instruction—a ratio of just 2.3 to 1.</p>
<p>It would seem, then, that it’s less necessary to use the registers on the 286 than it was on the 8088, but that’s simply not the case, for reasons we’ve already seen. The key is this: The 286 can execute memory-addressing instructions so fast that there’s no spare instruction prefetching time during those instructions, so the prefetch queue runs dry, especially on the AT, with its one-wait-state memory. On the AT, the 6-byte instruction <code>ADD [WordVar],100H</code> is effectively at least a 15-cycle instruction, because 3 cycles are needed to fetch each of the three instruction words and 6 more cycles are needed to read <code>WordVar</code> and write the result back to memory.</p>
<p>Granted, the register-only instruction <code>ADD DX,100H</code> also slows down—to 6 cycles—because of instruction prefetching, leaving a ratio of 2.5 to 1. Now, however, let’s look at the performance of the same code on an 8088. The register-only code would run in 16 cycles (4 instruction bytes at 4 cycles per byte), while the memory-accessing code would run in 40 cycles (6 instruction bytes at 4 cycles per byte, plus 2 word-sized memory accesses at 8 cycles per word). That’s a ratio of 2.5 to 1, <em>exactly the same as on the 286</em>.</p>
<p>This is all theoretical. We put our trust not in theory but in actual performance, so let’s run this code through the Zen timer. On a PC, Listing 11.4, which performs register-only addition, runs in 3.62 ms, while Listing 11.5, which performs addition to a memory variable, runs in 10.05 ms. On a 10 MHz AT clone, Listing 11.4 runs in 0.64 ms, while Listing 11.5 runs in 1.80 ms. Obviously, the AT is much faster…but the ratio of Listing 11.5 to Listing 11.4 is virtually identical on both computers, at 2.78 for the PC and 2.81 for the AT. If anything, the register-only form of <code>ADD</code> has a slightly <em>larger</em> advantage on the AT than it does on the PC in this case.</p>
<p>Theory confirmed.</p>
<p><strong>LISTING 11.4 L11-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">;</span>
<span class="co">; *** Listing 11.4 ***</span>
<span class="co">;</span>
<span class="co">; Measures the performance of adding an immediate value</span>
<span class="co">; to a register, for comparison with Listing 11.5, which</span>
<span class="co">; adds an immediate value to a memory variable.</span>
<span class="co">;</span>
        <span class="kw">call</span>    ZTimerOn
        rept    <span class="dv">1000</span>
        <span class="kw">add</span>     <span class="kw">dx</span><span class="bn">,100h</span>
        endm
        <span class="kw">call</span>    ZTimerOff</code></pre>
<p><strong>LISTING 11.5 L11-5.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">;</span>
<span class="co">; *** Listing 11.5 ***</span>
<span class="co">;</span>
<span class="co">; Measures the performance of adding an immediate value</span>
<span class="co">; to a memory variable, for comparison with Listing 11.4,</span>
<span class="co">; which adds an immediate value to a register.</span>
<span class="co">;</span>
        <span class="kw">jmp</span>     Skip
<span class="co">;</span>
        even            <span class="co">;always make sure word-sized memory</span>
                        <span class="co">; variables are word-aligned!</span>
WordVar <span class="dt">dw</span>      <span class="dv">0</span>
<span class="co">;</span>
<span class="fu">Skip:</span>
        <span class="kw">call</span>    ZTimerOn
        rept    <span class="dv">1000</span>
        <span class="kw">add</span>     [WordVar]100h
        endm
        <span class="kw">call</span>    ZTimerOff</code></pre>
<p>What’s going on? Simply this: Instruction fetching is controlling overall execution time on <em>both</em> processors. Both the 8088 in a PC and the 286 in an AT can execute the bytes of the instructions in Listings 11.4 and 11.5 faster than they can be fetched. Since the instructions are exactly the same lengths on both processors, it stands to reason that the ratio of the overall execution times of the instructions should be the same on both processors as well. Instruction length controls execution time, and the instruction lengths are the same—therefore the ratios of the execution times are the same. The 286 can both fetch and execute instruction bytes faster than the 8088 can, so code executes much faster on the 286; nonetheless, because the 286 can also execute those instruction bytes much faster than it can fetch them, overall performance is still largely determined by the size of the instructions.</p>
<p>Is this always the case? No. When the prefetch queue is full, memory-accessing instructions on the 286 and 386 are much faster (relative to register-only instructions) than they are on the 8088. Given the system wait states prevalent on 286 and 386 computers, however, the prefetch queue is likely to be empty quite a bit, especially when code consisting of instructions with short EU execution times is executed. Of course, that’s just the sort of code we’re likely to write when we’re optimizing, so the performance of high-speed code is more likely to be controlled by instruction size than by EU execution time on most 286 and 386 computers, just as it is on the PC.</p>
<p>All of which is just a way of saying that faster memory access and EA calculation notwithstanding, it’s just as desirable to keep instructions short and memory accesses to a minimum on the 286 and 386 as it is on the 8088. And the way to do that is to use the registers as heavily as possible, use string instructions, use short forms of instructions, and the like.</p>
<p>The more things change, the more they remain the same….</p>
</section>
<section id="popf-and-the-286" class="level4">
<h4><a href="#popf-and-the-286">POPF and the 286</a></h4>
<p>We’ve one final 286-related item to discuss: the hardware malfunction of <code>POPF</code> under certain circumstances on the 286.</p>
<p>The problem is this: Sometimes <code>POPF</code> permits interrupts to occur when interrupts are initially off and the setting popped into the Interrupt flag from the stack keeps interrupts off. In other words, an interrupt can happen even though the Interrupt flag is never set to 1. Now, I don’t want to blow this particular bug out of proportion. It only causes problems in code that cannot tolerate interrupts under any circumstances, and that’s a rare sort of code, especially in user programs. However, some code really does need to have interrupts absolutely disabled, with no chance of an interrupt sneaking through. For example, a critical portion of a disk BIOS might need to retrieve data from the disk controller the instant it becomes available; even a few hundred microseconds of delay could result in a sector’s worth of data misread. In this case, one misplaced interrupt during a <code>POPF</code> could result in a trashed hard disk if that interrupt occurs while the disk BIOS is reading a sector of the File Allocation Table.</p>
<p>There is a workaround for the <code>POPF</code> bug. While the workaround is easy to use, it’s considerably slower than <code>POPF</code>, and costs a few bytes as well, so you won’t want to use it in code that can tolerate interrupts. On the other hand, in code that truly cannot be interrupted, you should view those extra cycles and bytes as cheap insurance against mysterious and erratic program crashes.</p>
<p>One obvious reason to discuss the <code>POPF</code> workaround is that it’s useful. Another reason is that the workaround is an excellent example of Zen-level assembly coding, in that there’s a well-defined goal to be achieved but no obvious way to do so. The goal is to reproduce the functionality of the <code>POPF</code> instruction without using <code>POPF</code>, and the place to start is by asking exactly what <code>POPF</code> does.</p>
<p>All <code>POPF</code> does is pop the word on top of the stack into the FLAGS register, as shown in Figure 11.4. How can we do that without <code>POPF</code>? Of course, the 286’s designers intended us to use <code>POPF</code> for this purpose, and didn’t intentionally provide any alternative approach, so we’ll have to devise an alternative approach of our own. To do that, we’ll have to search for instructions that contain some of the same functionality as <code>POPF</code>, in the hope that one of those instructions can be used in some way to replace <code>POPF</code>.</p>
<p>Well, there’s only one instruction other than <code>POPF</code> that loads the FLAGS register directly from the stack, and that’s <code>IRET</code>, which loads the FLAGS register from the stack as it branches, as shown in Figure 11.5. iret has no known bugs of the sort that plague <code>POPF</code>, so it’s certainly a candidate to replace popf in non-interruptible applications. Unfortunately, <code>IRET</code> loads the FLAGS register with the <em>third</em> word down on the stack, not the word on top of the stack, as is the case with <code>POPF</code>; the far return address that <code>IRET</code> pops into CS:IP lies between the top of the stack and the word popped into the FLAGS register.</p>
<p>Obviously, the segment:offset that <code>IRET</code> expects to find on the stack above the pushed flags isn’t present when the stack is set up for <code>POPF</code>, so we’ll have to adjust the stack a bit before we can substitute <code>IRET</code> for <code>POPF</code>. What we’ll have to do is push the segment:offset of the instruction after our workaround code onto the stack right above the pushed flags. <code>IRET</code> will then branch to that address and pop the flags, ending up at the instruction after the workaround code with the flags popped. That’s just the result that would have occurred had we executed <code>POPF</code>—WITH the bonus that no interrupts can accidentally occur when the Interrupt flag is 0 both before and after the pop.</p>
<figure>
<img src="images/11-04.jpg" alt="Figure 11.4  The operation of POPF." /><figcaption><strong>Figure 11.4</strong>  <em>The operation of POPF.</em></figcaption>
</figure>
<p>How can we push the segment:offset of the next instruction? Well, finding the offset of the next instruction by performing a near call to that instruction is a tried-and-true trick. We can do something similar here, but in this case we need a far call, since <code>IRET</code> requires both a segment and an offset. We’ll also branch backward so that the address pushed on the stack will point to the instruction we want to continue with. The code works out like this:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">      jmpshort popfskip
<span class="fu">popfiret:</span>
      <span class="kw">iret</span><span class="co">;      branches to the instruction after the</span>
                 <span class="co">; call, popping the word below the address</span>
                 <span class="co">; pushed by CALL into the FLAGS register</span>
<span class="fu">popfskip:</span>
      <span class="kw">call</span>  far <span class="dt">ptr</span> popfiret
                 <span class="co">;pushes the segment:offset of the next</span>
                 <span class="co">; instruction on the stack just above</span>
                 <span class="co">; the flags word, setting things up so</span>
                 <span class="co">; that IRET will branch to the next</span>
                 <span class="co">; instruction and pop the flags</span>
<span class="co">; When execution reaches the instruction following this comment,</span>
<span class="co">; the word that was on top of the stack when JMP SHORT POPFSKIP</span>
<span class="co">; was reached has been popped into the FLAGS register, just as</span>
<span class="co">; if a POPF instruction had been executed.</span></code></pre>
<figure>
<img src="images/11-05.jpg" alt="Figure 11.5  The operation of IRET." /><figcaption><strong>Figure 11.5</strong>  <em>The operation of IRET.</em></figcaption>
</figure>
<p>The operation of this code is illustrated in Figure 11.6.</p>
<p>The <code>POPF</code> workaround can best be implemented as a macro; we can also emulate a far call by pushing CS and performing a near call, thereby shrinking the workaround code by 1 byte:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">EMULATE_POPF             macro
     local popfskip, popfiret
     <span class="kw">jmp</span>   <span class="dt">short</span> popfskip
<span class="fu">popfiret:</span>
     <span class="kw">iret</span>
<span class="fu">popfskip:</span>
     <span class="kw">push</span>  <span class="kw">cs</span>
     <span class="kw">call</span>  popfiret
     endm</code></pre>
<p>By the way, the flags can be popped much more quickly if you’re willing to alter a register in the process. For example, the following macro emulates <code>POPF</code> with just one branch, but wipes out AX:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">EMULATE_POPF_TRASH_AX   macro
   <span class="kw">push</span>  <span class="kw">cs</span>
   <span class="kw">mov</span>   <span class="kw">ax</span>,offset <span class="dv">$</span>+<span class="dv">5</span>
   <span class="kw">push</span>  <span class="kw">ax</span>
   <span class="kw">iret</span>
   endm</code></pre>
<p>It’s not a perfect substitute for <code>POPF</code>, since <code>POPF</code> doesn’t alter any registers, but it’s faster and shorter than <code>EMULATE_POPF</code> when you can spare the register. If you’re using 286-specific instructions, you can use which is shorter still, alters no registers, and branches just once. (Of course, this version of <code>EMULATE_POPF</code> won’t work on an 8088.)</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">      .<span class="dv">286</span>
                 :
EMULATE_POPFmacro
      pushcs
      pushoffset <span class="dv">$</span>+<span class="dv">4</span>
      <span class="kw">iret</span>
      endm</code></pre>
<figure>
<img src="images/11-06.jpg" alt="Figure 11.6  Workaround code for the POPF bug." /><figcaption><strong>Figure 11.6</strong>  <em>Workaround code for the POPF bug.</em></figcaption>
</figure>
<p>The standard version of <code>EMULATE_POPF</code> is 6 bytes longer than <code>POPF</code> and much slower, as you’d expect given that it involves three branches. Anyone in his/her right mind would prefer <code>POPF</code> to a larger, slower, three-branch macro—given a choice. In noncode, however, there’s no choice here; the safer—if slower—approach is the best. (Having people associate your programs with crashed computers is <em>not</em> a desirable situation, no matter how unfair the circumstances under which it occurs.)</p>
<p>And now you know the nature of and the workaround for the <code>POPF</code> bug. Whether you ever need the workaround or not, it’s a neatly packaged example of the tremendous flexibility of the x86 instruction set.</p>
</section>
</section>
</section>
<section id="chapter-12-pushing-the-486" class="level2">
<h2><a href="#chapter-12-pushing-the-486">Chapter 12 – Pushing the 486</a></h2>
<section id="its-not-just-a-bigger-386" class="level3">
<h3><a href="#its-not-just-a-bigger-386">It’s Not Just a Bigger 386</a></h3>
<p>So this traveling salesman is walking down a road, and he sees a group of men digging a ditch with their bare hands. “Whoa, there!” he says. “What you guys need is a Model 8088 ditch digger!” And he whips out a trowel and sells it to them.</p>
<p>A few days later, he stops back around. They’re happy with the trowel, but he sells them the latest ditch-digging technology, the Model 80286 spade. That keeps them content until he stops by again with a Model 80386 shovel (a full 32 inches wide, with a narrow point to emulate the trowel), and <em>that</em> holds them until he comes back around with what they really need: a Model 80486 bulldozer.</p>
<p>Having reached the top of the line, the salesman doesn’t pay them a call for a while. When he does, not only are they none too friendly, but they’re digging with the 80386 shovel; the bulldozer is sitting off to one side. “Why on earth are you using that shovel?” the salesman asks. “Why aren’t you digging with the bulldozer?”</p>
<p>“Well, Lord knows we tried,” says the foreman, “but it was all we could do just to lift the damn thing!”</p>
<p>Substitute “processor” for the various digging implements, and you get an idea of just how different the optimization rules for the 486 are from what you’re used to. Okay, it’s not quite <em>that</em> bad—but upon encountering a processor where string instructions are often to be avoided and memory-to-register <code>MOV</code>s are frequently as fast as register-to-register <code>MOV</code>s, Dorothy was heard to exclaim (before she sank out of sight in a swirl of hopelessly mixed metaphors), “I don’t think we’re in Kansas anymore, Toto.”</p>
<section id="enter-the-486" class="level4">
<h4><a href="#enter-the-486">Enter the 486</a></h4>
<p>No chip that is a direct, fully compatible descendant of the 8088, 286, and 386 could ever be called a RISC chip, but the 486 certainly contains RISC elements, and it’s those elements that are most responsible for making 486 optimization unique. Simple, common instructions are executed in a single cycle by a RISC-like core processor, but other instructions are executed pretty much as they were on the 386, where every instruction takes at least 2 cycles. For example, <code>MOV AL, [TestChar]</code> takes only 1 cycle on the 486, assuming both instruction and data are in the cache—3 cycles faster than the 386—but <code>STOSB</code> takes 5 cycles, 1 cycle <em>slower</em> than on the 386. The floating-point execution unit inside the 486 is also much faster than the 387 math coprocessor, largely because, being in the same silicon as the CPU (the 486 has a math coprocessor built in), it is more tightly coupled. The results are sometimes startling: <code>FMUL</code> (floating point multiply) is usually faster on the 486 than <code>IMUL</code> (integer multiply)!</p>
<p>An encyclopedic approach to 486 optimization would take a book all by itself, so in this chapter I’m only going to hit the highlights of 486 optimization, touching on several optimization rules, some documented, some not. You might also want to check out the following sources of 486 information: <em>i486 Microprocessor Programmer’s Reference Manual,</em> from Intel; “8086 Optimization: Aim Down the Middle and Pray,” in the March, 1991 <em>Dr. Dobb’s Journal</em>; and “Peak Performance: On to the 486,” in the November, 1990 <em>Programmer’s Journal.</em></p>
</section>
</section>
<section id="rules-to-optimize-by" class="level3">
<h3><a href="#rules-to-optimize-by">Rules to Optimize By</a></h3>
<p>In Appendix G of the <em>i486 Microprocessor Programmer</em>’<em>s</em> <em>Reference Manual</em>, Intel lists a number of optimization techniques for the 486. While neither exhaustive (we’ll look at two undocumented optimizations shortly) nor entirely accurate (we’ll correct two of the rules here), Intel’s list is certainly a good starting point. In particular, the list conveys the extent to which 486 optimization differs from optimization for earlier x86 processors. Generally, I’ll be discussing optimization for real mode (it being the most widely used mode at the moment), although many of the rules should apply to protected mode as well.</p>
<blockquote>
<p><img src="images/i.jpg" /> 486 optimization is generally more precise and less frustrating than optimization for other x86 processors because every 486 has an identical internal cache. Whenever both the instructions being executed and the data the instructions access are in the cache, those instructions will run in a consistent and calculatable number of cycles on all 486s, with little chance of interference from the prefetch queue and without regard to the speed of external memory.</p>
</blockquote>
<p>In other words, for cached code (which time-critical code almost always is), performance is predictable and can be calculated with good precision, and those calculations will apply on any 486. However, “predictable” doesn’t mean “trivial”; the cycle times printed for the various instructions are not the whole story. You must be aware of all the rules, documented and undocumented, that go into calculating actual execution times—and uncovering some of those rules is exactly what this chapter is about.</p>
<section id="the-hazards-of-indexed-addressing" class="level4">
<h4><a href="#the-hazards-of-indexed-addressing">The Hazards of Indexed Addressing</a></h4>
<p>Rule #1: Avoid indexed addressing (that is, try not to use either two registers or scaled addressing to point to memory).</p>
<p>Intel cautions against using indexing to address memory because there’s a one-cycle penalty for indexed addressing. True enough—but “indexed addressing” might not mean what you expect.</p>
<p>Traditionally, SI and DI are considered the index registers of the x86 CPUs. That is not the sense in which “indexed addressing” is meant here, however. In real mode, indexed addressing means that two registers, rather than one or none, are used to point to memory. (In this context, the use of one register to address memory is “base addressing,” no matter what register is used.) <code>MOV AX, [BX+DI]</code> and <code>MOV CL, [BP+SI+10]</code> perform indexed addressing; <code>MOV AX,[BX]</code> and <code>MOV DL, [SI+1]</code> do not.</p>
<blockquote>
<p><img src="images/i.jpg" /> Therefore, in real mode, the rule is to avoid using two registers to point to memory whenever possible. Often, this simply means adding the two registers together outside a loop before memory is actually addressed.</p>
</blockquote>
<p>As an example, you might adhere to this rule by replacing the code</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="fu">LoopTop:</span>
    <span class="kw">add</span>  <span class="kw">ax</span>,[<span class="kw">bx</span>+<span class="kw">si</span>]
    <span class="kw">add</span>  <span class="kw">si</span>,<span class="dv">2</span>
    <span class="kw">dec</span>  <span class="kw">cx</span>
    <span class="kw">jnz</span>  LoopTop</code></pre>
<p>with this</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">    <span class="kw">add</span>  <span class="kw">si</span>,<span class="kw">bx</span>
<span class="fu">LoopTop:</span>
    <span class="kw">add</span>  <span class="kw">ax</span>,[<span class="kw">si</span>]
    <span class="kw">add</span>  <span class="kw">si</span>,<span class="dv">2</span>
    <span class="kw">dec</span>  <span class="kw">cx</span>
    <span class="kw">jnz</span>  LoopTop
    <span class="kw">sub</span>  <span class="kw">si</span>,<span class="kw">bx</span></code></pre>
<p>which calculates the same sum and leaves the registers in the same state as the first example, but avoids indexed addressing.</p>
<p>In protected mode, the definition of indexed addressing is a tad more complex. The use of two registers to address memory, as in <code>MOV EAX, [EDX+EDI]</code>, still qualifies for the one-cycle penalty. In addition, the use of 386/486 scaled addressing, as in <code>MOV [ECX*2],EAX</code>, also constitutes indexed addressing, even if only one register is used to point to memory.</p>
<p>All this fuss over one cycle! You might well wonder how much difference one cycle could make. After all, on the 8088, effective address calculations take a <em>minimum</em> of 5 cycles. On the 486, however, 1 cycle is a big deal because many instructions, including most register-only instructions (<code>MOV</code>, <code>ADD</code>, <code>CMP</code>, and so on) execute in just 1 cycle. In particular, <code>MOV</code>s to and from memory execute in 1 cycle—if they’re not hampered by something like indexed addressing, in which case they slow to half speed (or worse, as we will see shortly).</p>
<p>For example, consider the summing example shown earlier. The version that uses base+index ([BX+SI]) addressing executes in eight cycles per loop. As expected, the version that uses base ([SI]) addressing runs one cycle faster, at seven cycles per loop. However, the loop code executes so fast on the 486 that the single cycle saved by using base addressing makes the <em>whole loop</em> more than 14 percent faster.</p>
<p>In a key loop on the 486, 1 cycle can indeed matter.</p>
</section>
<section id="calculate-memory-pointers-ahead-of-time" class="level4">
<h4><a href="#calculate-memory-pointers-ahead-of-time">Calculate Memory Pointers Ahead of Time</a></h4>
<p>Rule #2: Don’t use a register as a memory pointer during the next two cycles after loading it.</p>
<p>Intel states that if the destination of one instruction is used as the base addressing component of the next instruction, then a one-cycle penalty is imposed. This rule, unlike anything ever before seen in the x86 family, reflects the heavily pipelined nature of the 486. Apparently, the 486 starts each effective address calculation before the start of the instruction that will need it, as shown in Figure 12.1; this effectively makes the address calculation time vanish, because it happens while the preceding instruction executes.</p>
<p>Of course, the 486 <em>can’t</em> perform an effective address calculation for a target instruction ahead of time if one of the address components isn’t known until the instruction starts, and that’s exactly the case when the preceding instruction modifies one of the target instruction’s addressing registers. For example, in the code</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">MOV</span>  <span class="kw">BX</span>,OFFSET MemVar
<span class="kw">MOV</span>  <span class="kw">AX</span>,[<span class="kw">BX</span>]</code></pre>
<p>there’s no way that the 486 can calculate the address referenced by <code>MOV AX,[BX]</code> until <code>MOV BX,OFFSET MemVar</code> finishes, so pipelining that calculation ahead of time is not possible. A good workaround is rearranging your code so that at least one instruction lies between the loading of the memory pointer and its use. For example, postdecrementing, as in the following</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="fu">LoopTop:</span>
    <span class="kw">add</span>    <span class="kw">ax</span>,[<span class="kw">si</span>]
    <span class="kw">add</span>    <span class="kw">si</span>,<span class="dv">2</span>
    <span class="kw">dec</span>    <span class="kw">cx</span>
    <span class="kw">jnz</span>    LoopTop</code></pre>
<p>is faster than preincrementing, as in:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="fu">LoopTop:</span>
    <span class="kw">add</span>    <span class="kw">si</span>,<span class="dv">2</span>
    <span class="kw">add</span>    <span class="kw">ax</span>,[<span class="kw">SI</span>]
    <span class="kw">dec</span>    <span class="kw">cx</span>
    <span class="kw">jnz</span>    LoopTop</code></pre>
<p>Now that we understand what Intel means by this rule, let me make a very important comment: My observations indicate that for real-mode code, the documentation understates the extent of the penalty for interrupting the address calculation pipeline by loading a memory pointer just before it’s used.</p>
<blockquote>
<p><img src="images/i.jpg" /> The truth of the matter appears to be that if a register is the destination of one instruction and is then used by the next instruction to address memory in real mode, not one but two cycles are lost!</p>
</blockquote>
<p>In 32-bit protected mode, however, the penalty is, in fact, the 1 cycle that Intel .</p>
<p>Considering that <code>MOV</code> normally takes only one cycle total, that’s quite a loss. For example, the postdecrement loop shown above is 2 full cycles faster than the preincrement loop, resulting in a 29 percent improvement in the performance of the entire loop. But wait, there’s more. If a register is loaded 2 cycles (which generally means 2 instructions, but, because some 486 instructions take more than 1 cycle,</p>
<figure>
<img src="images/12-01.jpg" alt="Figure 12.1  One-cycle-ahead address pipelining." /><figcaption><strong>Figure 12.1</strong>  <em>One-cycle-ahead address pipelining.</em></figcaption>
</figure>
<p>the 2 are not always equivalent) before it’s used to point to memory, 1 cycle is lost. Therefore, whereas this code</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>    <span class="kw">bx</span>,offset MemVar
<span class="kw">mov</span>    <span class="kw">ax</span>,[<span class="kw">bx</span>]
<span class="kw">inc</span>    <span class="kw">dx</span>
<span class="kw">dec</span>    <span class="kw">cx</span>
<span class="kw">jnz</span>    LoopTop</code></pre>
<p>loses two cycles from interrupting the address calculation pipeline, this code</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>    <span class="kw">bx</span>,offset MemVar
<span class="kw">inc</span>    <span class="kw">dx</span>
<span class="kw">mov</span>    <span class="kw">ax</span>,[<span class="kw">bx</span>]
<span class="kw">dec</span>    <span class="kw">cx</span>
<span class="kw">jnz</span>    LoopTop</code></pre>
<p>loses only one cycle, and this code</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>    <span class="kw">bx</span>,offset MemVar
<span class="kw">inc</span>    <span class="kw">dx</span>
<span class="kw">dec</span>    <span class="kw">cx</span>
<span class="kw">mov</span>    <span class="kw">ax</span>,[<span class="kw">bx</span>]
<span class="kw">jnz</span>    LoopTop</code></pre>
<p>loses no cycles at all. Apparently, the 486’s addressing calculation pipeline actually starts 2 cycles ahead, as shown in Figure 12.2. (In truth, my best guess at the moment is that the addressing pipeline really does start only 1 cycle ahead; the additional cycle crops up when the addressing pipeline has to wait for a register to be written into the register file before it can read it out for use in addressing calculations. However, I’m guessing here, and the 2-cycle-ahead model in Figure 12.2 will do just fine for optimization purposes.)</p>
<p>Clearly, there’s considerable optimization potential in careful rearrangement of 486 code.</p>
<figure>
<img src="images/12-02.jpg" alt="Figure 12.2  Two-cycle-ahead address pipelining." /><figcaption><strong>Figure 12.2</strong>  <em>Two-cycle-ahead address pipelining.</em></figcaption>
</figure>
</section>
</section>
<section id="caveat-programmor" class="level3">
<h3><a href="#caveat-programmor">Caveat Programmor</a></h3>
<p>A caution: I’m quite certain that the 2-cycle-ahead addressing pipeline interruption penalty I’ve described exists in the two 486s I’ve tested. However, there’s no guarantee that Intel won’t change this aspect of the 486 in the future, especially given that the documentation indicates otherwise. Perhaps the 2-cycle penalty is the result of a bug in the initial steps of the 486, and will revert to the documented 1-cycle penalty someday; likewise for the undocumented optimizations I’ll describe below. Nonetheless, none of the optimizations I suggest would hurt performance even if the undocumented performance characteristics of the 486 were to vanish, and they certainly will help performance on at least some 486s right now, so I feel they’re well worth using.</p>
<p>There is, of course, no guarantee that I’m entirely correct about the optimizations discussed in this chapter. Without knowing the internals of the 486, all I can do is time code and make inferences from the results; I invite you to deduce your own rules and cross-check them against mine. Also, most likely there are other optimizations that I’m unaware of. If you have further information on these or any other undocumented optimizations, please write and let me know. And, of course, if anyone from Intel is reading this and wants to give us the gospel truth, please do!</p>
<section id="stack-addressing-and-address-pipelining" class="level4">
<h4><a href="#stack-addressing-and-address-pipelining">Stack Addressing and Address Pipelining</a></h4>
<p>Rule #2A: Rule #2 sometimes, but not always, applies to the stack pointer when it is implicitly used to point to memory.</p>
<p>Intel states that the stack pointer is an implied destination register for <code>CALL</code>, <code>ENTER</code>, <code>LEAVE</code>, <code>RET</code>, <code>PUSH</code>, and <code>POP</code> (which alter (E)SP), and that it is the implied base addressing register for <code>PUSH</code>, <code>POP</code>, and <code>RET</code> (which use (E)SP to address memory). Intel then implies that the aforementioned addressing pipeline penalty is incurred whenever the stack pointer is used as a destination by one of the first set of instructions and is then immediately used to address memory by one of the second set. This raises the specter of unpleasant programming contortions such as intermixing <code>PUSH</code>es and <code>POP</code>s with other instructions to avoid interrupting the addressing pipeline. Fortunately, matters are actually not so grim as Intel’s documentation would indicate; my tests indicate that the addressing pipeline penalty pops up only spottily when the stack pointer is involved.</p>
<p>For example, you’d certainly expect a sequence such as</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">:
<span class="kw">pop</span>    <span class="kw">ax</span>
<span class="kw">ret</span>
<span class="kw">pop</span>    <span class="kw">ax</span>
et
:</code></pre>
<p>to exhibit the addressing pipeline interruption phenomenon (SP is both destination and addressing register for both instructions, according to Intel), but this code runs in six cycles per <code>POP/RET</code> pair, matching the official execution times exactly. Likewise, a sequence like</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">pop</span>    <span class="kw">dx</span>
<span class="kw">pop</span>    <span class="kw">cx</span>
<span class="kw">pop</span>    <span class="kw">bx</span>
<span class="kw">pop</span>    <span class="kw">ax</span></code></pre>
<p>runs in one cycle per instruction, just as it should.</p>
<p>On the other hand, performing arithmetic directly on SP as an <em>explicit</em> destination—for example, to deallocate local variables—and then using <code>PUSH</code>, <code>POP</code>, or <code>RET</code>, definitely can interrupt the addressing pipeline. For example</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">add</span>    <span class="kw">sp</span><span class="bn">,10h</span>
<span class="kw">ret</span></code></pre>
<p>loses two cycles because SP is the explicit destination of one instruction and then the implied addressing register for the next, and the sequence</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">add</span>    <span class="kw">sp</span><span class="bn">,10h</span>
<span class="kw">pop</span>    <span class="kw">ax</span></code></pre>
<p>loses two cycles for the same reason.</p>
<p>I certainly haven’t tried all possible combinations, but the results so far indicate that the stack pointer incurs the addressing pipeline penalty only if (E)SP is the <em>explicit</em> destination of one instruction and is then used by one of the two following instructions to address memory. So, for instance, SP isn’t the explicit operand of <code>POP AX</code>-AX is—and no cycles are lost if <code>POP AX</code> is followed by <code>POP</code> or <code>RET</code>. Happily, then, we need not worry about the sequence in which we use <code>PUSH</code> and <code>POP</code>. However, adding to, moving to, or subtracting from the stack pointer should ideally be done at least two cycles before <code>PUSH</code>, <code>POP</code>, <code>RET</code>, or any other instruction that uses the stack pointer to address memory.</p>
</section>
<section id="problems-with-byte-registers" class="level4">
<h4><a href="#problems-with-byte-registers">Problems with Byte Registers</a></h4>
<p>There are two ways to lose cycles by using byte registers, and neither of them is documented by Intel, so far as I know. Let’s start with the lesser and simpler of the two.</p>
<p>Rule #3: Do not load a byte portion of a register during one instruction, then use that register in its entirety as a source register during the next instruction.</p>
<p>So, for example, it would be a bad idea to do this</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>    <span class="kw">ah</span>,o
            :
<span class="kw">mov</span>    <span class="kw">cx</span>,[MemVar1]
<span class="kw">mov</span>    <span class="kw">al</span>,[MemVar2]
<span class="kw">add</span>    <span class="kw">cx</span>,<span class="kw">ax</span></code></pre>
<p>because AL is loaded by one instruction, then AX is used as the source register for the next instruction. A cycle can be saved simply by rearranging the instructions so that the byte register load isn’t immediately followed by the word register usage, like so:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>    <span class="kw">ah</span>,o
            :
<span class="kw">mov</span>    <span class="kw">al</span>,[MemVar2]
<span class="kw">mov</span>    <span class="kw">cx</span>,[MemVar1]
<span class="kw">add</span>    <span class="kw">cx</span>,<span class="kw">ax</span></code></pre>
<p>Strange as it may seem, this rule is neither arbitrary nor nonsensical. Basically, when a byte destination register is part of a word source register for the next instruction, the 486 is unable to directly use the result from the first instruction as the source for the second instruction, because only part of the register required by the second instruction is contained in the first instruction’s result. The full, updated register value must be read from the register file, and that value can’t be read out until the result from the first instruction has been written <em>into</em> the register file, a process that takes an extra cycle. I’m not going to explain this in great detail because it’s not important that you understand why this rule exists (only that it <em>does</em> in fact exist), but it is an interesting window on the way the 486 works.</p>
<p>In case you’re curious, there’s no such penalty for the typical <code>XLAT</code> sequence like</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>    <span class="kw">bx</span>,offset MemTable
       :
<span class="kw">mov</span>    <span class="kw">al</span>,[<span class="kw">si</span>]
<span class="kw">xlat</span></code></pre>
<p>even though AL must be converted to a word by <code>XLAT</code> before it can be added to BX and used to address memory. In fact, none of the penalties mentioned in this chapter apply to <code>XLAT</code>, apparently because <code>XLAT</code> is so slow—4 cycles—that it gives the 486 time to perform addressing calculations during the course of the instruction.</p>
<blockquote>
<p><img src="images/i.jpg" /> While it’s nice that <code>XLAT</code> doesn’t suffer from the various 486 addressing penalties, the reason for that is basically that <code>XLAT</code> is slow, so there’s still no compelling reason to use <code>XLAT</code> on the 486.</p>
</blockquote>
<p>In general, penalties for interrupting the 486’s pipeline apply primarily to the fast core instructions of the 486, most notably register-only instructions and <code>MOV</code>, although arithmetic and logical operations that access memory are also often affected. I don’t know all the performance dependencies, and I don’t plan to; figuring all of them out would be a big, boring job of little value. Basically, on the 486 you should concentrate on using those fast core instructions when performance matters, and all the rules I’ll discuss do indeed apply to those instructions.</p>
<p>You don’t need to understand every corner of the 486 universe unless you’re a diehard ASMhead who does this stuff for fun. Just learn enough to be able to speed up the key portions of your programs, and spend the rest of your time on a fast design and overall implementation.</p>
</section>
<section id="more-fun-with-byte-registers" class="level4">
<h4><a href="#more-fun-with-byte-registers">More Fun with Byte Registers</a></h4>
<p>Rule #4: Don’t load <em>any</em> byte register exactly 2 cycles before using <em>any</em> register to address memory.</p>
<p>This, the last of this chapter’s rules, is the strangest of the lot. If any byte register is loaded, and then two cycles later any register is used to point to memory, one cycle is lost. So, for example, this code</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>    <span class="kw">al</span>,<span class="kw">bl</span>
<span class="kw">mov</span>    <span class="kw">cx</span>,<span class="kw">dx</span>
<span class="kw">mov</span>    <span class="kw">si</span>,[<span class="kw">di</span>]</code></pre>
<p>takes four rather than the expected three cycles to execute. Note that it is <em>not</em> required that the byte register be part of the register used to address memory; any byte register will do the trick.</p>
<p>Worse still, loading byte registers both one and two cycles before a register is used to address memory costs two cycles, as in</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>    <span class="kw">bl</span>,<span class="kw">al</span>
<span class="kw">mov</span>    <span class="kw">cl</span>,<span class="dv">3</span>
<span class="kw">mov</span>    <span class="kw">bx</span>,[<span class="kw">si</span>]</code></pre>
<p>which takes five rather than three cycles to run. However, there is <em>no</em> penalty if a byte register is loaded one cycle but not two cycles before a register is used to address memory. Therefore,</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>    <span class="kw">cx</span>,<span class="dv">3</span>
<span class="kw">mov</span>    <span class="kw">dl</span>,<span class="kw">al</span>
<span class="kw">mov</span>    <span class="kw">si</span>,[<span class="kw">bx</span>]</code></pre>
<p>runs in the expected three cycles.</p>
<p>In truth, I do not know why this happens. Clearly, it has something to do with interrupting the start of the addressing pipeline, and I have my theories about how this works, but at this point they’re pure speculation. Whatever the reason for this rule, ignorance of it—and of its interaction with the other rules—could lead to considerable performance loss in seemingly air-tight code. For instance, a casual observer would expect the following code to run in 3 cycles:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>    <span class="kw">bx</span>,offset MemVar
<span class="kw">mov</span>    <span class="kw">cl</span>,<span class="kw">al</span>
<span class="kw">mov</span>    <span class="kw">ax</span>,[<span class="kw">bx</span>]</code></pre>
<p>A more sophisticated programmer would expect to lose one cycle, because BX is loaded two cycles before being used to address memory. In fact, though, this code takes 5 cycles—2 cycles, or 67 percent, longer than normal. Why? Well, under normal conditions, loading a byte register—CL in this case—one cycle before using a register to address memory produces no penalty; loading 2 cycles ahead is the only case that normally incurs a penalty. However, think of Rule #4 as meaning that loading a byte register disrupts the memory addressing pipeline as it starts up. Viewed that way, we can see that <code>MOV BX,OFFSET MemVar</code> interrupts the addressing pipeline, forcing it to start again, and then, presumably, <code>MOV CL,AL</code> interrupts the pipeline again because the pipeline is now on its first cycle: the one that loading a byte register can affect.</p>
<blockquote>
<p><img src="images/i.jpg" /> I know—it seems awfully complicated. It isn’t, really. Generally, try not to use byte destinations exactly two cycles before using a register to address memory, and try not to load a register either one or two cycles before using it to address memory, and you’ll be fine.</p>
</blockquote>
</section>
<section id="timing-your-own-486-code" class="level4">
<h4><a href="#timing-your-own-486-code">Timing Your Own 486 Code</a></h4>
<p>In case you want to do some 486 performance analysis of your own, let me show you how I arrived at one of the above conclusions; at the same time, I can warn you of the timing hazards of the cache. Listings 12.1 and 12.2 show the code I ran through the Zen timer in order to establish the effects of loading a byte register before using a register to address memory. Listing 12.1 ran in 120 µs on a 33 MHz 486, or 4 cycles per repetition (120 µs/1000 repetitions = 120 ns per repetition; 120 ns per repetition/30 ns per cycle = 4 cycles per repetition); Listing 12.2 ran in 90 µs, or 3 cycles, establishing that loading a byte register costs a cycle only when it’s performed exactly 2 cycles before addressing memory.</p>
<p><strong>LISTING 12.1 LST12-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Measures the effect of loading a byte register 2 cycles before</span>
<span class="co">; using a register to address memory.</span>
    <span class="kw">mov</span>    <span class="kw">bp</span>,<span class="dv">2</span>    <span class="co">;run the test code twice to make sure</span>
                   <span class="co">; it&#39;s cached</span>
    <span class="kw">sub</span>    <span class="kw">bx</span>,<span class="kw">bx</span>
<span class="fu">CacheFillLoop:</span>
    <span class="kw">call</span>    ZTimerOn <span class="co">;start timing</span>
    rept    <span class="dv">1000</span>
    <span class="kw">mov</span>     <span class="kw">dl</span>,<span class="kw">cl</span>
    <span class="kw">nop</span>
    <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bx</span>]
    endm
    <span class="kw">call</span>    ZTimerOff <span class="co">;stop timing</span>
    <span class="kw">dec</span>     <span class="kw">bp</span>
    <span class="kw">jz</span>      Done
    <span class="kw">jmp</span>     CacheFillLoop
<span class="fu">Done:</span></code></pre>
<p><strong>LISTING 12.2 LST12-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Measures the effect of loading a byte register 1 cycle before</span>
<span class="co">; using a register to address memory.</span>
    <span class="kw">mov</span>    <span class="kw">bp</span>,<span class="dv">2</span>   <span class="co">;run the test code twice to make sure</span>
                  <span class="co">; it&#39;s cached</span>
    <span class="kw">sub</span>    <span class="kw">bx</span>,<span class="kw">bx</span>
<span class="fu">CacheFillLoop:</span>
    <span class="kw">call</span>   ZTimerOn <span class="co">;start timing</span>
    rept   <span class="dv">1000</span>
    <span class="kw">nop</span>
    <span class="kw">mov</span>    <span class="kw">dl</span>,<span class="kw">cl</span>
    <span class="kw">mov</span>    <span class="kw">ax</span>,[<span class="kw">bx</span>]
    endm
    <span class="kw">call</span>   ZTimerOff <span class="co">;stop timing</span>
    <span class="kw">dec</span>    <span class="kw">bp</span>
    <span class="kw">jz</span>     Done
    <span class="kw">jmp</span>    CacheFillLoop
<span class="fu">Done:</span></code></pre>
<p>Note that Listings 12.1 and 12.2 each repeat the timing of the code under test a second time, to make sure that the instructions are in the cache on the second pass, the one for which results are displayed. Also note that the code is less than 8K in size, so that it can all fit in the 486’s 8K internal cache. If I double the <code>REPT</code> value in Listing 12.2 to 2,000, making the test code larger than 8K, the execution time more than doubles to 224 µs, or 3.7 cycles per repetition; the extra seven-tenths of a cycle comes from fetching non-cached instruction bytes.</p>
<blockquote>
<p><img src="images/i.jpg" /> Whenever you see non-integral timing results of this sort, it’s a good bet that the test code or data isn’t cached.</p>
</blockquote>
</section>
</section>
<section id="the-story-continues" class="level3">
<h3><a href="#the-story-continues">The Story Continues</a></h3>
<p>There’s certainly plenty more 486 lore to explore, including the 486’s unique prefetch queue, more optimization rules, branching optimizations, performance implications of the cache, the cost of cache misses for reads, and the implications of cache write-through for writes. Nonetheless, we’ve covered quite a bit of ground in this chapter, and I trust you’ve gotten a feel for the considerable extent to which 486 optimization differs from what you’re used to. Odd as 486 optimization is, though, it’s well worth mastering, for the 486 is, at its best, so staggeringly fast that carefully crafted 486 code can do more than twice as much per cycle as the best 386 code—which makes it perhaps 50 times as fast as optimized code for the original PC.</p>
<p>Sometimes it <em>is</em> hard to believe we’re still in Kansas!</p>
</section>
</section>
<section id="chapter-13-aiming-the-486" class="level2">
<h2><a href="#chapter-13-aiming-the-486">Chapter 13 – Aiming the 486</a></h2>
<section id="pipelines-and-other-hazards-of-the-high-end" class="level3">
<h3><a href="#pipelines-and-other-hazards-of-the-high-end">Pipelines and Other Hazards of the High End</a></h3>
<p>It’s a sad but true fact that 84 percent of American schoolchildren are ignorant of 92 percent of American history. Not my daughter, though. We recently visited historical Revolutionary-War-vintage Fort Ticonderoga, and she’s now 97 percent aware of a key element of our national heritage: that the basic uniform for soldiers in those days was what appears to be underwear, plus a hat so that no one could complain that they were undermining family values. Ha! Just kidding! Actually, what she learned was that in those days, it was pure coincidence if a cannonball actually hit anything it was aimed at, which isn’t surprising considering the lack of rifling, precision parts, and ballistics. The guides at the fort shot off three cannons; the closest they came to the target was about 50 feet, and that was only because the wind helped. I think the idea in early wars was just to put so much lead in the air that some of it was bound to hit <em>something;</em> preferably, but not necessarily, the enemy.</p>
<p>Nowadays, of course, we have automatic weapons that allow a teenager to singlehandedly defeat the entire U.S. Army, not to mention so-called “smart” bombs, which are smart in the sense that they can seek out and empty a taxpayer’s wallet without being detected by radar. There’s an obvious lesson here about progress, which I leave you to deduce for yourselves.</p>
<p>Here’s the same lesson, in another form. Ten years ago, we had a slow processor, the 8088, for which it was devilishly hard to optimize, and for which there was no good optimization documentation available. Now we have a processor, the 486, that’s 50 to 100 times faster than the 8088—and for which there is no good optimization documentation available. Sure, Intel provides a few tidbits on optimization in the back of the <em>i486 Microprocessor Programmer’s Reference Manual,</em> but, as I discussed in Chapter 12, that information is both incomplete and not entirely correct. Besides, most assembly language programmers don’t bother to read Intel’s manuals (which are extremely informative and well done, but only slightly more fun to read than the phone book), and go right on programming the 486 using outdated 8088 optimization techniques, blissfully unaware of a new and heavily mutated generation of cycle-eaters that interact with their code in ways undreamt of even on the 386.</p>
<p>For example, consider how Terje Mathisen doubled the speed of his word-counting program on a 486 simply by shuffling a couple of instructions.</p>
<section id="pipeline-optimization" class="level4">
<h4><a href="#pipeline-optimization">486 Pipeline Optimization</a></h4>
<p>I’ve mentioned Terje Mathisen in my writings before. Terje is an assembly language programmer extraordinaire, and author of the incredibly fast public-domain word-counting program WC (which comes complete with source code; well worth a look, if you want to see what <em>really</em> fast code looks like). Terje’s a regular participant in the ibm.pc/fast.code topic on Bix. In a thread titled “486 Pipeline Optimization, or TANSTATFC (There Ain’t No Such Thing As The Fastest Code),” he detailed the following optimization to WC, perhaps the best example of 486 pipeline optimization I’ve yet seen.</p>
<p>Terje’s inner loop originally looked something like the code in Listing 13.1. (I’ve taken a few liberties for illustrative purposes.) Of course, Terje unrolls this loop a few times (128 times, to be exact). By the way, in Listing 13.1 you’ll notice that Terje counts not only words but also lines, at a rate of three instructions for every two characters!</p>
<p><strong>LISTING 13.1 L13-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">di</span>,[<span class="kw">bp</span>+OFFS]    <span class="co">;get the next pair of characters</span>
<span class="kw">mov</span> <span class="kw">bl</span>,[<span class="kw">di</span>]         <span class="co">;get the state value for the pair</span>
<span class="kw">add</span> <span class="kw">dx</span>,[<span class="kw">bx</span>+8000h]   <span class="co">;increment word and line count</span>
                    <span class="co">; appropriately for the pair</span></code></pre>
<p>Listing 13.1 looks as tight as it could be, with just two one-cycle instructions, one two-cycle instruction, and no branches. It <em>is</em> tight, but those three instructions actually take a minimum of 8 cycles to execute, as shown in Figure 13.1. The problem is that DI is loaded just before being used to address memory, and that costs 2 cycles because it interrupts the 486’s internal instruction pipeline. Likewise, BX is loaded just before being used to address memory, costing another two cycles. Thus, this loop takes twice as long as cycle counts would seem to indicate, simply because two registers are loaded immediately before being used, disrupting the 486’s pipeline.</p>
<p>Listing 13.2 shows Terje’s immediate response to these pipelining problems; he simply swapped the instructions that load DI and BL. This one change cut execution time per character pair from eight cycles to five cycles! The load of BL is now separated by one instruction from the use of BX to address memory, so the pipeline penalty is reduced from two cycles to one cycle. The load of DI is also separated by one instruction from the use of DI to address memory (remember, the loop is unrolled, so the last instruction is followed by the first instruction), but because the intervening instruction takes two cycles, there’s no penalty at all.</p>
<figure>
<img src="images/13-01.jpg" alt="Figure 13.1  Cycle-eaters in the original WC." /><figcaption><strong>Figure 13.1</strong>  <em>Cycle-eaters in the original WC.</em></figcaption>
</figure>
<blockquote>
<p><img src="images/i.jpg" /> Remember, pipeline penalties diminish with increasing number of cycles, not instructions, between the pipeline disrupter and the potentially affected instruction.</p>
</blockquote>
<p><strong>LISTING 13.2 L13-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">bl</span>,[<span class="kw">di</span>]         <span class="co">;get the state value for the pair</span>
<span class="kw">mov</span> <span class="kw">di</span>,[<span class="kw">bp</span>+OFFS]    <span class="co">;get the next pair of characters</span>
<span class="kw">add</span> <span class="kw">dx</span>,[<span class="kw">bx</span>+8000h]   <span class="co">;increment word and line count</span>
                    <span class="co">; appropriately for the pair</span></code></pre>
<p>At this point, Terje had nearly doubled the performance of this code simply by moving one instruction. (Note that swapping the instructions also made it necessary to preload DI at the start of the loop; Listing 13.2 is not exactly equivalent to Listing 13.1.) I’ll let Terje describe his next optimization in his own words:</p>
<p>“When I looked closely as this, I realized that the two cycles for the final <code>ADD</code> is just the sum of 1 cycle to load the data from memory, and 1 cycle to add it to DX, so the code could just as well have been written as shown in Listing 13.3. The final breakthrough came when I realized that by initializing AX to zero outside the loop, I could rearrange it as shown in Listing 13.4 and do the final <code>ADD DX,AX</code> after the loop. This way there are two single-cycle instructions between the first and the fourth line, avoiding all pipeline stalls, for a total throughput of two cycles/char.”</p>
<p><strong>LISTING 13.3 L13-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">bl</span>,[<span class="kw">di</span>]         <span class="co">;get the state value for the pair</span>
<span class="kw">mov</span> <span class="kw">di</span>,[<span class="kw">bp</span>+OFFS]    <span class="co">;get the next pair of characters</span>
<span class="kw">mov</span> <span class="kw">ax</span>,[<span class="kw">bx</span>+8000h]   <span class="co">;increment word and line count</span>
<span class="kw">add</span> <span class="kw">dx</span>,<span class="kw">ax</span>           <span class="co">; appropriately for the pair</span></code></pre>
<p><strong>LISTING 13.4 L13-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">bl</span>,[<span class="kw">di</span>]         <span class="co">;get the state value for the pair</span>
<span class="kw">mov</span> <span class="kw">di</span>,[<span class="kw">bp</span>+OFFS]    <span class="co">;get the next pair of characters</span>
<span class="kw">add</span> <span class="kw">dx</span>,<span class="kw">ax</span>           <span class="co">;increment word and line count</span>
                    <span class="co">; appropriately for the pair</span>
<span class="kw">mov</span> <span class="kw">ax</span>,[<span class="kw">bx</span>+8000h]   <span class="co">;get increments for next time</span></code></pre>
<p>I’d like to point out two fairly remarkable things. First, the single cycle that Terje saved in Listing 13.4 sped up his entire word-counting engine by 25 percent or more; Listing 13.4 is fully twice as fast as Listing 13.1—all the result of nothing more than shifting an instruction and splitting another into two operations. Second, Terje’s word-counting engine can process more than 16 million characters <em>per second</em> on a 486/33.</p>
<p>Clever 486 optimization can pay off big. QED.</p>
</section>
</section>
<section id="bswap-more-useful-than-you-might-think" class="level3">
<h3><a href="#bswap-more-useful-than-you-might-think">BSWAP: More Useful Than You Might Think</a></h3>
<p>There are only 3 non-system instructions unique to the 486. None is earthshaking, but they have their uses. Consider <code>BSWAP</code>. <code>BSWAP</code> does just what its name implies, swapping the bytes (not bits) of a 32-bit register from one end of the register to the other, as shown in Figure 13.2. (<code>BSWAP</code> can only work with 32-bit registers; memory locations and 16-bit registers are not valid operands.) The obvious use of <code>BSWAP</code> is to convert data from Intel format (least significant byte first in memory, also called <em>little endian</em>) to Motorola format (most significant byte first in memory, or <em>big endian</em>), like so:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">lodsd</span>
<span class="kw">bswap</span>
<span class="kw">stosd</span></code></pre>
<p><code>BSWAP</code> can also be useful for reversing the order of pixel bits from a bitmap so that they can be rotated 32 bits at a time with an instruction such as <code>ROR EAX,1</code>. Intel’s byte ordering for multiword values (least-significant byte first) loads pixels in the wrong order, so far as word rotation is concerned, but <code>BSWAP</code> can take care of that.</p>
<figure>
<img src="images/13-02.jpg" alt="Figure 13.2  BSWAP in operation." /><figcaption><strong>Figure 13.2</strong>  <em>BSWAP in operation.</em></figcaption>
</figure>
<p>As it turns out, though, <code>BSWAP</code> is also useful in an unexpected way, having to do with making efficient use of the upper half of 32-bit registers. As any assembly language programmer knows, the x86 register set is too small; or, to phrase that another way, it sure would be nice if the register set were bigger. As any 386/486 assembly language programmer knows, there are many cases in which 16 bits is plenty. For example, a 16-bit scan-line counter generally does the trick nicely in a video driver, because there are <em>very</em> few video devices with more than 65,535 addressable scan lines. Combining these two observations yields the obvious conclusion that it would be great if there were some way to use the upper and lower 16 bits of selected 386 registers as separate 16-bit registers, effectively increasing the available register space.</p>
<p>Unfortunately, the x86 instruction set doesn’t provide any way to work directly with only the upper half of a 32-bit register. The next best solution is to rotate the register to give you access in the lower 16 bits to the half you need at any particular time, with code along the lines of that in Listing 13.5. Having to rotate the 16-bit fields into position certainly isn’t as good as having direct access to the upper half, but surely it’s better than having to get the values out of memory, isn’t it?</p>
<p><strong>LISTING 13.5 L13-5.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>   <span class="kw">cx</span>,[initialskip]
<span class="kw">shl</span>   <span class="kw">ecx</span>,<span class="dv">16</span>       <span class="co">;put skip value in upper half of ECX</span>
<span class="kw">mov</span>   <span class="kw">cx</span>,<span class="dv">100</span>       <span class="co">;put loop count in CX</span>
<span class="fu">looptop:</span>
       :
      <span class="kw">ror</span>   <span class="kw">ecx</span>,<span class="dv">16</span>      <span class="co">;make skip value word accessible in CX</span>
      <span class="kw">add</span>   <span class="kw">bx</span>,<span class="kw">cx</span>       <span class="co">;skip BX ahead</span>
      <span class="kw">inc</span>   <span class="kw">cx</span>          <span class="co">;set next skip value</span>
      <span class="kw">ror</span>   <span class="kw">ecx</span>,<span class="dv">16</span>      <span class="co">;put loop count in CX</span>
      <span class="kw">dec</span>   <span class="kw">cx</span>          <span class="co">;count down loop</span>
      <span class="kw">jnz</span>   looptop</code></pre>
<p>Not necessarily. Shifts and rotates are among the worst performing instructions of the 486, taking 2 to 3 cycles to execute. Thus, it takes 2 cycles to rotate the skip value into CX in Listing 13.5, and 2 more cycles to rotate it back to the upper half of ECX. I’d say four cycles is a pretty steep price to pay, especially considering that a <code>MOV</code> to or from memory takes only one cycle. Basically, using <code>ROR</code> to access a 16-bit value in the upper half of a 16-bit register is a pretty marginal technique, unless for some reason you can’t access memory at all (for example, if you’re using BP as a working register, temporarily making the stack frame inaccessible).</p>
<p>On the 386, <code>ROR</code> was the only way to split a 32-bit register into two 16-bit registers. On the 486, however, <code>BSWAP</code> can not only do the job, but can do it better, because <code>BSWAP</code> executes in just one cycle. <code>BSWAP</code> has the added benefit of not affecting any flags, unlike <code>ROR</code>. With <code>BSWAP</code>-based code like that in Listing 13.6, the upper 16 bits of a register can be accessed with only 2 cycles of overhead and without altering any flags, making the technique of packing two 16-bit registers into one 32-bit register much more useful.</p>
<p><strong>LISTING 13.6 L13-6.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">      <span class="kw">mov</span>    <span class="kw">cx</span>,[initialskip]
      <span class="kw">bswap</span>  <span class="kw">ecx</span>        <span class="co">;put skip value in upper half of ECX</span>
      <span class="kw">mov</span>    <span class="kw">cx</span>,<span class="dv">100</span>     <span class="co">;put loop count in CX</span>
<span class="fu">looptop:</span>
       :
      <span class="kw">bswap</span>  <span class="kw">ecx</span>        <span class="co">;make skip value word accessible in CX</span>
      <span class="kw">add</span>    <span class="kw">bx</span>,<span class="kw">cx</span>      <span class="co">;skip BX ahead</span>
      <span class="kw">inc</span>    <span class="kw">cx</span>         <span class="co">;set next skip value</span>
      <span class="kw">bswap</span>  <span class="kw">ecx</span>        <span class="co">;put loop count in CX</span>
      <span class="kw">dec</span>    <span class="kw">cx</span>         <span class="co">;count down loop</span>
      <span class="kw">jnz</span>    looptop</code></pre>
</section>
<section id="pushing-and-popping-memory" class="level3">
<h3><a href="#pushing-and-popping-memory">Pushing and Popping Memory</a></h3>
<p>Pushing or popping a memory location, as in <code>PUSH WORD PTR [BX]</code> or <code>POP [MemVar]</code>, is a compact, easy way to get a value onto or off of the stack, especially when pushing parameters for calling a C-compatible function. However, on a 486, these are unattractive instructions from a performance perspective. Pushing a memory location takes four cycles; by contrast, loading a memory location into a register takes only one cycle, and pushing a register takes just 1 more cycle, for a total of two cycles. Therefore,</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>   <span class="kw">ax</span>,[<span class="kw">bx</span>]
<span class="kw">push</span>  <span class="kw">ax</span></code></pre>
<p>is twice as fast as</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">push</span>   <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bx</span>]</code></pre>
<p>and the only cost is that the previous contents of AX are destroyed.</p>
<p>Likewise, popping a memory location takes six cycles, but popping a register and writing it to memory takes only two cycles combined. The <em>i486 Microprocessor Programmer’s Reference Manual</em> lists a 4-cycle execution time for popping a register, but pay that no mind; popping a register takes only 1 cycle.</p>
<p>Why is it that such a convenient operation as pushing or popping memory is so slow? The rule on the 486 is that simple operations, which can be executed in a single cycle by the 486’s RISC core, are fast; whereas complex operations, which must be carried out in microcode just as they were on the 386, are almost all relatively slow. Slow, complex operations include all the string instructions except <code>REP MOVS</code>, as well as <code>XLAT</code>, <code>LOOP</code>, and, of course, <code>PUSH *mem*</code> and <code>POP *mem*</code>.</p>
<blockquote>
<p><img src="images/i.jpg" /> Whenever possible, try to use the 486’s 1-cycle instructions, including <code>MOV</code>, <code>ADD</code>, <code>SUB</code>, <code>CMP</code>, <code>ADC</code>, <code>SBB</code>, <code>XOR</code>, <code>AND</code>, <code>OR</code>, <code>TEST</code>, <code>LEA</code>, and <code>PUSH reg</code> and <code>POP reg</code>. These instructions have an added benefit in that it’s often possible to rearrange them for maximum pipeline efficiency, as is the case with Terje’s optimization described earlier in this chapter.</p>
</blockquote>
</section>
<section id="optimal-1-bit-shifts-and-rotates" class="level3">
<h3><a href="#optimal-1-bit-shifts-and-rotates">Optimal 1-Bit Shifts and Rotates</a></h3>
<p>On a 486, the n-bit forms of the shift and rotate instructions—as in <code>ROR AX,2</code> and <code>SHL BX,9</code>—are 2-cycle instructions, but the 1-bit forms—as in <code>ROR AX,1</code> and <code>SHL BX,1</code>-are <em>3-cycle</em> instructions. Go figure.</p>
<p>Assemblers default to the 1-bit instruction for 1-bit shifts and rotates. That’s not unreasonable since the 1-bit form is a byte shorter and is just as fast as the n-bit forms on a 386 and faster on a 286, and the n-bit form doesn’t even exist on an 8088. In a really critical loop, however, it might be worth hand-assembling the n-bit form of a single-bit shift or rotate in order to save that cycle. The easiest way to do this is to assemble a 2-bit form of the desired instruction, as in <code>SHL AX,2</code>, then look at the hex codes that the assembler generates and use <code>DB</code> to insert them in your program code, with the value two replaced with the value one. For example, you could determine that <code>SHL AX,2</code> assembles to the bytes 0C1H 0E0H 002H, either by looking at the disassembly in a debugger or by having the assembler generate a listing file. You could then insert the n-bit version of <code>SHL AX,1</code> in your code as follows:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>   <span class="kw">ax</span>,<span class="dv">1</span>
<span class="dt">db</span><span class="bn">    0c1h, </span>0e0h<span class="bn">, 001h</span>
<span class="kw">mov</span>   <span class="kw">dx</span>,<span class="kw">ax</span></code></pre>
<p>At the end of this sequence, DX will contain 2, and the fast n-bit version of <code>SHL AX,1</code> will have executed. If you use this approach, I’d recommend using a macro, rather than sticking DBs in the middle of your code.</p>
<p>Again, this technique is advantageous <em>only</em> on a 486. It also doesn’t apply to <code>RCL</code> and <code>RCR</code>, where you definitely want to use the 1-bit versions whenever you can, because the n-bit versions are horrendously slow. But if you’re optimizing for the 486, these tidbits can save a few critical cycles—and Lord knows that if you’re optimizing for the 486—that is, if you need even more performance than you get from unoptimized code on a 486—you almost certainly need all the speed you can get.</p>
</section>
<section id="bit-addressing-modes" class="level3">
<h3><a href="#bit-addressing-modes">32-Bit Addressing Modes</a></h3>
<p>The 386 and 486 both support 32-bit addressing modes, in which any register may serve as the base memory addressing register, and almost any register may serve as the potentially scaled index register. For example,</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">al</span>,BaseTable[<span class="kw">ecx</span>+<span class="kw">edx</span>*<span class="dv">4</span>]</code></pre>
<p>uses a perfectly valid 32-bit address, with the byte accessed being the one at the offset in DS pointed to by the sum of EDX times 4 plus the offset of <code>BaseTable</code> plus ECX. This is a very powerful memory addressing scheme, far superior to 8088-style 16-bit addressing, but it’s not without its quirks and costs, so let’s take a quick look at 32-bit addressing. (By the way, 32-bit addressing is not limited to protected mode; 32-bit instructions may be used in real mode, although each instruction that uses 32-bit addressing must have an address-size prefix byte, and the presence of a prefix byte costs a cycle on a 486.)</p>
<p>Any register may serve as the base register component of an address. Any register except ESP may also serve as the index register, which can be scaled by 1, 2, 4, or 8. (Scaling is very handy for performing lookups in arrays and tables.) The same register may serve as both base and index register, except for ESP, which can only be the base. Incidentally, it makes sense that ESP can’t be scaled; ESP presumably always points to a valid stack, and I can’t think of any reason you’d want to use the stack pointer times 2, 4, or 8 in an address. ESP is, by its nature, a base rather than index pointer.</p>
<p>That’s all there is to the functionality of 32-bit addressing; it’s very simple, much simpler than 16-bit addressing, with its sharply limited memory addressing register combinations. The costs of 32-bit addressing are a bit more subtle. The only performance cost (apart from the aforementioned 1-cycle penalty for using 32-bit addressing in real mode) is a 1-cycle penalty imposed for using an index register. In this context, you use an index register when you use a register that’s scaled, or when you use the sum of two registers to point to memory. <code>MOV BL,[EBX*2]</code> uses an index register and takes an extra cycle, as does <code>MOV CL,[EAX+EDX]; MOV CL,[EAX+100H]</code> is not indexed, however.</p>
<p>The other cost of 32-bit addressing is in instruction size. Old-style 16-bit addressing usually (except in a few special cases) uses one extra byte, which Intel calls the Mod-R/M byte, which is placed immediately after each instruction’s opcode to describe the memory addressing mode, plus 1 or 2 optional bytes of addressing displacement—that is, a constant value to add into the address. In many cases, 32-bit addressing continues to use the Mod-R/M byte, albeit with a different interpretation; in these cases, 32-bit addressing is no larger than 16-bit addressing, except when a 32-bit displacement is involved. For example, <code>MOV AL, [EBX]</code> is a 2-byte instruction; <code>MOV AL, [EBX+10H]</code> is a 3-byte instruction; and <code>MOV AL, [EBX+10000H]</code> is a 6-byte instruction.</p>
<blockquote>
<p><img src="images/i.jpg" /> Note that 1 and 4-byte displacements, but not 2-byte displacements, are supported for 32-bit addressing. Code size can be greatly improved by keeping stack frame variables within 128 bytes of EBP, and variables in pointed-to structures within 127 bytes of the start of the structure, so that displacements can be 1 rather than 4 bytes.</p>
</blockquote>
<p>However, because 32-bit addressing supports many more addressing combinations than 16-bit addressing, the Mod-R/M byte can’t describe all the combinations. Therefore, whenever an index register (as described above) is involved, a second byte, the SIB byte, follows the Mod-R/M byte to provide additional address information. Consequently, whenever you use a scaled memory addressing register or use the sum of two registers to point to memory, you automatically add 1 cycle and 1 byte to that instruction. This is not to say that you shouldn’t use index registers when they’re needed, but if you find yourself using them inside key loops, you should see if it’s possible to move the index calculation outside the loop as, for example, in a loop like this:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="fu">LoopTop:</span>
      <span class="kw">add</span>   <span class="kw">ax</span>,DataTable[<span class="kw">ebx</span>*<span class="dv">2</span>]
      <span class="kw">inc</span>   <span class="kw">ebx</span>
      <span class="kw">dec</span>   <span class="kw">cx</span>
      <span class="kw">jnz</span>   LoopTop</code></pre>
<p>You could change this to the following for greater performance:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">      <span class="kw">add</span>   <span class="kw">ebx</span>,<span class="kw">ebx</span>      <span class="co">;ebx*2</span>
<span class="fu">LoopTop:</span>
      <span class="kw">add</span>   <span class="kw">ax</span>,DataTable[<span class="kw">ebx</span>]
      <span class="kw">add</span>   ebxX,<span class="dv">2</span>
      <span class="kw">dec</span>   <span class="kw">cx</span>
      <span class="kw">jnz</span>   LoopTop
      <span class="kw">shr</span>   <span class="kw">ebx</span>,<span class="dv">1</span> <span class="co">;ebx*2/2</span></code></pre>
<p>I’ll end this chapter with two more quirks of 32-bit addressing. First, as with 16-bit addressing, addressing that uses EBP as a base register both accesses the SS segment by default and always has a displacement of at least 1 byte. This reflects the common use of EBP to address a stack frame, but is worth keeping in mind if you should happen to use EBP to address non-stack memory.</p>
<p>Lastly, as I mentioned, ESP cannot be scaled. In fact, ESP cannot be an index register; it must be a base register. Ironically, however, ESP is the one register that cannot be used to address memory without the presence of an SIB byte, even if it’s used without an index register. This is an outcome of the way in which the SIB byte extends the capabilities of the Mod-R/M byte, and there’s nothing to be done about it, but it’s at least worth noting that ESP-based, non-indexed addressing makes for instructions that are a byte larger than other non-indexed addressing (but not any slower; there’s no 1-cycle penalty for using ESP as a base register) on the 486.</p>
</section>
</section>
<section id="chapter-14-boyer-moore-string-searching" class="level2">
<h2><a href="#chapter-14-boyer-moore-string-searching">Chapter 14 – Boyer-Moore String Searching</a></h2>
<section id="optimizing-a-pretty-optimum-search-algorithm" class="level3">
<h3><a href="#optimizing-a-pretty-optimum-search-algorithm">Optimizing a Pretty Optimum Search Algorithm</a></h3>
<p>When you seem to be stumped, stop for a minute and <em>think.</em> All the information you need may be right in front of your nose if you just look at things a little differently. Here’s a case in point:</p>
<p>When I was in college, I used to stay around campus for the summer. Oh, I’d take a course or two, but mostly it was an excuse to hang out and have fun. In that spirit, my girlfriend, Adrian (<em>not</em> my future wife, partly for reasons that will soon become apparent), bussed in to spend a week, sharing a less-than-elegant $150 per month apartment with me and, by necessity, my roommate.</p>
<p>Our apartment was pretty much standard issue for two male college students; maybe even a cut above. The dishes were usually washed, there was generally food in the refrigerator, and nothing larger than a small dog had taken up permanent residence in the bathroom. However, there was one sticking point (literally): the kitchen floor. This floor—standard tile, with a nice pattern of black lines on an off-white background (or so we thought)—had never been cleaned. By which I mean that I know for a certainty that <em>we</em> had never cleaned it, but I suspect that it had in fact not been cleaned since the Late Jurassic, or possibly earlier. Our feet tended to stick to it; had the apartment suddenly turned upside-down, I think we’d all have been hanging from the ceiling.</p>
<p>One day, my roommate and I returned from a pick-up basketball game. Adrian, having been left to her own devices for a couple of hours, had apparently kept herself busy. “Notice anything?” she asked, with an edge to her voice that suggested we had damned well better.</p>
<p>“Uh, you cooked dinner?” I guessed. “Washed the dishes? Had your hair done?” My roommate was equally without a clue.</p>
<p>She stamped her foot (really; the only time I’ve ever seen it happen), and said, “No, you jerks! The kitchen floor! Look at the floor! I cleaned it!”</p>
<p>The floor really did look amazing. It was actually all white; the black lines had been grooves filled with dirt. We assured her that it looked terrific, it just wasn’t that obvious until you knew to look for it; anyone would tell you that it wasn’t the kind of thing that jumped out at you, but it really was great, no kidding. We had almost smoothed things over, when a friend walked in, looked around with a start, and said, “Hey! Did you guys put in a new floor?”</p>
<p>As I said, sometimes everything you need to know is right in front of your nose. Which brings us to Boyer-Moore string searching.</p>
</section>
<section id="string-searching-refresher" class="level3">
<h3><a href="#string-searching-refresher">String Searching Refresher</a></h3>
<p>I’ve discussed string searching earlier in this book, in Chapters 5 and 9. You may want to refer back to these chapters for some background on string searching in general. I’m also going to use some of the code from that chapter as part of this chapter’s test suite. For further information, you may want to refer to the discussion of string searching in the excellent <em>Algorithms in C,</em> by Robert Sedgewick (Addison-Wesley), which served as the primary reference for this chapter. (If you look at Sedgewick, be aware that in the Boyer-Moore listing on page 288, there is a mistake: “j &gt; 0” in the <code>for</code> loop should be “j &gt;= 0,” unless I’m missing something.)</p>
<p>String searching is the simple matter of finding the first occurrence of a particular sequence of bytes (the pattern) within another sequence of bytes (the buffer). The obvious, brute-force approach is to try every possible match location, starting at the beginning of the buffer and advancing one position after each mismatch, until either a match is found or the buffer is exhausted. There’s even a nifty string instruction, <code>REPZ CMPS</code>, that’s perfect for comparing the pattern to the contents of the buffer at each location. What could be simpler?</p>
<p>We have some important information that we’re not yet using, though. Typically, the buffer will contain a wide variety of bytes. Let’s assume that the buffer contains text, in which case there will be dozens of different characters; and although the distribution of characters won’t usually be even, neither will any one character constitute half the buffer, or anything close. A reasonable conclusion is that the first character of the pattern will rarely match the first character of the buffer location currently being checked. This allows us to use the speedy <code>REPNZ SCASB</code> to whiz through the buffer, eliminating most potential match locations with single repetitions of <code>SCASB</code>. Only when that first character does (infrequently) match must we drop back to the slower <code>REPZ CMPS</code> approach.</p>
<p>It’s important to understand that we’re assuming that the buffer is typical text. That’s what I meant at the outset, when I said that the information you need may be under your nose.</p>
<blockquote>
<p><img src="images/i.jpg" /> Formally, you don’t know a blessed thing about the search buffer, but experience, common sense, and your knowledge of the application give you a great deal of useful, if somewhat imprecise, information.</p>
</blockquote>
<p>If the buffer contains the letter ‘A’ repeated 1,000 times, followed by the letter ‘B,’ then the <code>REPNZ SCASB/REPZ CMPS</code> approach will be much slower than the brute-force <code>REPZ CMPS</code> approach when searching for the pattern “AB,” because <code>REPNZ SCASB</code> would match at every buffer location. You could construct a horrendous worst-case scenario for almost any good optimization; the key is understanding the usual conditions under which your code will work.</p>
<p>As discussed in Chapter 9, we also know that certain characters have lower probabilities of matching than others. In a normal buffer, ‘T’ will match far more often than ‘X.’ Therefore, if we use <code>REPNZ SCASB</code> to scan for the least common letter in the search string, rather than the first letter, we’ll greatly decrease the number of times we have to drop back to <code>REPZ CMPS</code>, and the search time will become very close to the time it takes <code>REPNZ SCASB</code> to go from the start of the buffer to the match location. If the distance to the first match is N bytes, the least-common <code>REPNZ SCASB</code> approach will take about as long as N repetitions of <code>REPNZ SCASB</code>.</p>
<p>At this point, we’re pretty much searching at the speed of <code>REPNZ SCASB</code>. On the x86, there simply is no faster way to test each character in turn. In order to get any faster, we’d have to check fewer characters—but we can’t do that and still be sure of finding all matches. Can we?</p>
<p>Actually, yes, we can.</p>
</section>
<section id="the-boyer-moore-algorithm" class="level3">
<h3><a href="#the-boyer-moore-algorithm">The Boyer-Moore Algorithm</a></h3>
<p>All our <em>a priori</em> knowledge of string searching is stated above, but there’s another sort of knowledge—knowledge that’s generated dynamically. As we search through the buffer, we acquire information each time we check for a match. One sort of information that we acquire is based on partial matches; we can often skip ahead after partial matches because (take a deep breath!) by partially matching, we have already implicitly done a comparison of the partially matched buffer characters with all possible pattern start locations that overlap those partially-matched bytes.</p>
<p>If that makes your head hurt, it should—and don’t worry. This line of thinking, which is the basis of the Knuth-Morris-Pratt algorithm and half the basis of the Boyer-Moore algorithm, is what gives Boyer-Moore its reputation for inscrutability. That reputation is well deserved for this aspect (which I will not discuss further in this book), but there’s another part of Boyer-Moore that’s easily understood, easily implemented, and highly effective.</p>
<p>Consider this: We’re searching for the pattern “ABC,” beginning the search at the start (offset 0) of a buffer containing “ABZABC.” We match on ‘A,’ we match on ‘B,’ and we mismatch on ‘C’; the buffer contains a ‘Z’ in this position. What have we learned? Why, we’ve learned not only that the pattern doesn’t match the buffer starting at offset 0, but also that it can’t possibly match starting at offset 1 or offset 2, either! After all, there’s a ‘Z’ in the buffer at offset 2; since the pattern doesn’t contain a single ‘Z,’ there’s no way that the pattern can match starting at <em>any</em> location from which it would span the ‘Z’ at offset 2. We can just skip straight from offset 0 to offset 3 and continue, saving ourselves two comparisons.</p>
<p>Unfortunately, this approach only pays off big when a near-complete partial match is found; if the comparison fails on the first pattern character, as often happens, we can only skip ahead 1 byte, as usual. Look at it differently, though: What if we compare the pattern starting with the last (rightmost) byte, rather than the first (leftmost) byte? In other words, what if we compare from high memory toward low, in the direction in which string instructions go after the <code>STD</code> instruction? After all, we’re comparing one set of bytes (the pattern) to another set of bytes (a portion of the buffer); it doesn’t matter in the least in what order we compare them, so long as all the bytes in one set are compared to the corresponding bytes in the other set.</p>
<blockquote>
<p><img src="images/i.jpg" /> Why on earth would we want to start with the rightmost character? Because a mismatch on the rightmost character tells us a great deal more than a mismatch on the leftmost character.</p>
</blockquote>
<p>We learn nothing new from a mismatch on the leftmost character, except that the pattern can’t match starting at that location. A mismatch on the rightmost character, however, tells us about the possibilities of the pattern matching starting at every buffer location from which the pattern spans the mismatch location. If the mismatched character in the buffer doesn’t appear in the pattern, then we’ve just eliminated not one potential match, but as many potential matches as there are characters in the pattern; that’s how many locations there are in the buffer that <em>might</em> have matched, but have just been shown not to, because they overlap the mismatched character that doesn’t belong in the pattern. In this case, we can skip ahead by the full pattern length in the buffer! This is how we can outperform even <code>REPNZ SCASB; REPNZ SCASB</code> has to check every byte in the buffer, but Boyer-Moore doesn’t.</p>
<p>Figure 14.1 illustrates the operation of a Boyer-Moore search when the rightcharacter of the search pattern (which is the first character that’s compared at each location because we’re comparing backwards) mismatches with a buffer character that appears nowhere in the pattern. Figure 14.2 illustrates the operation of a partial match when the mismatch occurs with a character that’s not a pattern member. In this case, we can only skip ahead past the mismatch location, resulting in an advance of fewer bytes than the pattern length, and potentially as little as the same single byte distance by which the standard search approach advances.</p>
<figure>
<img src="images/14-01.jpg" alt="Figure 14.1  Mismatch on first character checked." /><figcaption><strong>Figure 14.1</strong>  <em>Mismatch on first character checked.</em></figcaption>
</figure>
<p>What if the mismatch occurs with a buffer character that <em>does</em> occur in the pattern? Then we can’t skip past the mismatch location, but we can skip to whatever location aligns the rightmost occurrence of that character in the pattern with the mismatch location, as shown in Figure 14.3.</p>
<p>Basically, we exercise our right as members of a free society to compare strings in whichever direction we choose, and we choose to do so right to left, rather than the more intuitive left to right. Whenever we find a mismatch, we see what we can learn from the buffer character that failed to match the pattern. Imagine that we move the pattern to the right across the mismatch location until we find a start location that the mismatch does not eliminate as a possible match for the pattern. If the mismatch character doesn’t appear in the pattern, the pattern can move clear past the mismatch location. Otherwise, the pattern moves until a matching pattern byte lies atop the mismatch. That’s all there is to it!</p>
<figure>
<img src="images/14-02.jpg" alt="Figure 14.2  Mismatch on third character checked." /><figcaption><strong>Figure 14.2</strong>  <em>Mismatch on third character checked.</em></figcaption>
</figure>
</section>
<section id="boyer-moore-the-good-and-the-bad" class="level3">
<h3><a href="#boyer-moore-the-good-and-the-bad">Boyer-Moore: The Good and the Bad</a></h3>
<p>The worst case for this version of Boyer-Moore is that the pattern mismatches on the leftmost character—the last character compared—every time. Again, not very likely, but it is true that this version of Boyer-Moore performs better as there are fewer and shorter partial matches; ideally, the rightmost character would never match until the full match location was reached. Longer patterns, which make for longer skips, help Boyer-Moore, as does a long distance to the match location, which helps diffuse the overhead of building the table of distances to skip ahead on all the possible mismatch values.</p>
<figure>
<img src="images/14-03.jpg" alt="Figure 14.3  Mismatch on character that appears in pattern." /><figcaption><strong>Figure 14.3</strong>  <em>Mismatch on character that appears in pattern.</em></figcaption>
</figure>
<p>The best case for Boyer-Moore is good indeed: About N/M comparisons are required, where N is the buffer length and M is the pattern length. This reflects the ability of Boyer-Moore to skip ahead by a full pattern length on a complete mismatch.</p>
<p>How fast <em>is</em> Boyer-Moore? Listing 14.1 is a C implementation of Boyer-Moore searching; Listing 14.2 is a test-bed program that searches up to the first 32K of a file for a pattern. Table 14.1 (all times measured with Turbo Profiler on a 20 MHz cached 386, searching a modified version of the text of this chapter) shows that this implementation is generally much slower than <code>REPNZ SCASB</code>, although it does come close when searching for long patterns. Listing 14.1 is designed primarily to make later assembly implemenmore comprehensible, rather than faster; Sedge’s implementation uses arrays rather than pointers, is a great deal more compact and very clever, and may be somewhat faster. Regardless, the far superior performance of <code>REPNZ SCASB</code> clearly indicates that assembly language is in order at this point.</p>
<table>
<caption>Table 14.1 Comparison of searching techniques.</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">“g;”</th>
<th style="text-align: left;">“Yogi”</th>
<th style="text-align: left;">“igoY”</th>
<th style="text-align: left;">“Adrian”</th>
<th style="text-align: left;">“Conclusion”</th>
<th style="text-align: left;">“You don’t know what you know”</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Searching approach</td>
<td style="text-align: left;">(16K)</td>
<td style="text-align: left;">(16K)</td>
<td style="text-align: left;">(16K)</td>
<td style="text-align: left;">(&lt;1K)</td>
<td style="text-align: left;">(16K)</td>
<td style="text-align: left;">(16K)</td>
</tr>
<tr class="even">
<td style="text-align: left;">REPNZ SCASB on first char a (Listing 9.1)</td>
<td style="text-align: left;">8.2</td>
<td style="text-align: left;">7.5</td>
<td style="text-align: left;">9.7</td>
<td style="text-align: left;">0.4</td>
<td style="text-align: left;">7.4</td>
<td style="text-align: left;">8.1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REPNZ SCASB on least common char (Listing 9.2)</td>
<td style="text-align: left;">7.6</td>
<td style="text-align: left;">7.5</td>
<td style="text-align: left;">7.5</td>
<td style="text-align: left;">0.5</td>
<td style="text-align: left;">7.5</td>
<td style="text-align: left;">7.5</td>
</tr>
<tr class="even">
<td style="text-align: left;">Boyer-Moore in C (Listing 14.1)</td>
<td style="text-align: left;">71.0</td>
<td style="text-align: left;">38.4</td>
<td style="text-align: left;">37.7</td>
<td style="text-align: left;">1.8</td>
<td style="text-align: left;">18.2</td>
<td style="text-align: left;">9.2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Standard Boyer-Moore in ASM (code not shown)</td>
<td style="text-align: left;">38.5</td>
<td style="text-align: left;">21.0</td>
<td style="text-align: left;">20.5</td>
<td style="text-align: left;">0.8</td>
<td style="text-align: left;">9.4</td>
<td style="text-align: left;">4.8</td>
</tr>
<tr class="even">
<td style="text-align: left;">Quick handling of first mismatch Boyer-Moore in ASM (Listing 14.3)</td>
<td style="text-align: left;">14.1</td>
<td style="text-align: left;">8.9</td>
<td style="text-align: left;">7.7</td>
<td style="text-align: left;">0.4</td>
<td style="text-align: left;">4.0</td>
<td style="text-align: left;">2.0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&lt;=255 pattern length + sentinelBoyer-Moore in ASM (Listing 14.4)</td>
<td style="text-align: left;">8.1</td>
<td style="text-align: left;">5.2</td>
<td style="text-align: left;">4.6</td>
<td style="text-align: left;">0.3</td>
<td style="text-align: left;">2.6</td>
<td style="text-align: left;">1.2</td>
</tr>
</tbody>
</table>
<p>Search pattern (approximate distance searched before match is shown in parentheses).<br /> Times are in milliseconds; shorter is better.</p>
<p>The entry “Standard Boyer-Moore in ASM” in Table 14.1 refers to straight-forward hand optimization of Listing 14.1, code that is not included in this chapter for the perfectly good reason that it is slower in most cases than <code>REPNZ SCASB</code>. I say this casually now, but not so yesterday, when I had all but concluded that Boyer-Moore was simply inferior on the x86, due to two architectural quirks: the string instructions and slow branch. I had even coined a neat phrase for it: Architecture is destiny. Has a nice ring, doesn’t it?</p>
<p><strong>LISTING 14.1 L14-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Searches a buffer for a specified pattern. In case of a mismatch,</span>
<span class="co">   uses the value of the mismatched byte to skip across as many</span>
<span class="co">   potential match locations as possible (partial Boyer-Moore).</span>
<span class="co">   Returns start offset of first match searching forward, or NULL if</span>
<span class="co">   no match is found.</span>
<span class="co">   Tested with Borland C++ in C mode and the small model. */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">unsigned</span> <span class="dt">char</span> * FindString(<span class="dt">unsigned</span> <span class="dt">char</span> * BufferPtr,
   <span class="dt">unsigned</span> <span class="dt">int</span> BufferLength, <span class="dt">unsigned</span> <span class="dt">char</span> * PatternPtr,
   <span class="dt">unsigned</span> <span class="dt">int</span> PatternLength)
{
   <span class="dt">unsigned</span> <span class="dt">char</span> * WorkingPatternPtr, * WorkingBufferPtr;
   <span class="dt">unsigned</span> <span class="dt">int</span> CompCount, SkipTable[<span class="dv">256</span>], Skip, DistanceMatched;
   <span class="dt">int</span> i;

   <span class="co">/* Reject if the buffer is too small */</span>
   <span class="kw">if</span> (BufferLength &lt; PatternLength) <span class="kw">return</span>(NULL);

   <span class="co">/* Return an instant match if the pattern is 0-length */</span>
   <span class="kw">if</span> (PatternLength == <span class="dv">0</span>) <span class="kw">return</span>(BufferPtr);

   <span class="co">/* Create the table of distances by which to skip ahead on</span>
<span class="co">      mismatches for every possible byte value */</span>
   <span class="co">/* Initialize all skips to the pattern length; this is the skip</span>
<span class="co">      distance for bytes that don&#39;t appear in the pattern */</span>
   <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">256</span>; i++) SkipTable[i] = PatternLength;
   <span class="co">/*Set the skip values for the bytes that do appear in the pattern</span>
<span class="co">     to the distance from the byte location to the end of the</span>
<span class="co">     pattern. When there are multiple instances of the same byte,</span>
<span class="co">     the rightmost instance&#39;s skip value is used. Note that the</span>
<span class="co">     rightmost byte of the pattern isn&#39;t entered in the skip table;</span>
<span class="co">     if we get that value for a mismatch, we know for sure that the</span>
<span class="co">     right end of the pattern has already passed the mismatch</span>
<span class="co">     location, so this is not a relevant byte for skipping purposes */</span>
   <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; (PatternLength - <span class="dv">1</span>); i++)
      SkipTable[PatternPtr[i]] = PatternLength - i - <span class="dv">1</span>;

   <span class="co">/* Point to rightmost byte of the pattern */</span>
   PatternPtr += PatternLength - <span class="dv">1</span>;
   <span class="co">/* Point to last (rightmost) byte of the first potential pattern</span>
<span class="co">      match location in the buffer */</span>
   BufferPtr += PatternLength - <span class="dv">1</span>;
   <span class="co">/* Count of number of potential pattern match locations in</span>
<span class="co">      buffer */</span>
   BufferLength -= PatternLength - <span class="dv">1</span>;

   <span class="co">/* Search the buffer */</span>
   <span class="kw">while</span> (<span class="dv">1</span>) {
      <span class="co">/* See if we have a match at this buffer location */</span>
      WorkingPatternPtr = PatternPtr;
      WorkingBufferPtr = BufferPtr;
      CompCount = PatternLength;
      <span class="co">/* Compare the pattern and the buffer location, searching from</span>
<span class="co">         high memory toward low (right to left) */</span>
      <span class="kw">while</span> (*WorkingPatternPtr— == *WorkingBufferPtr—) {
         <span class="co">/* If we&#39;ve matched the entire pattern, it&#39;s a match */</span>
         <span class="kw">if</span> (-CompCount == <span class="dv">0</span>)
           <span class="co">/* Return a pointer to the start of the match location */</span>
            <span class="kw">return</span>(BufferPtr - PatternLength + <span class="dv">1</span>);
      }
      <span class="co">/* It&#39;s a mismatch; let&#39;s see what we can learn from it */</span>
      WorkingBufferPtr++;  <span class="co">/* point back to the mismatch location */</span>
      <span class="co">/* # of bytes that did match */</span>
      DistanceMatched = BufferPtr - WorkingBufferPtr;
      <span class="co">/*If, based on the mismatch character, we can&#39;t even skip ahead</span>
<span class="co">            as far as where we started this particular comparison, then</span>
<span class="co">            just advance by 1 to the next potential match; otherwise,</span>
<span class="co">            skip ahead from the mismatch location by the skip distance</span>
<span class="co">            for the mismatch character */</span>
      <span class="kw">if</span> (SkipTable[*WorkingBufferPtr] &lt;= DistanceMatched)
      Skip = <span class="dv">1</span>;   <span class="co">/* skip doesn&#39;t do any good, advance by 1 */</span>
      <span class="kw">else</span>
         <span class="co">/* Use skip value, accounting for distance covered by the</span>
<span class="co">            partial match */</span>
         Skip = SkipTable[*WorkingBufferPtr] - DistanceMatched;
      <span class="co">/* If skipping ahead would exhaust the buffer, we&#39;re done</span>
<span class="co">         without a match */</span>
      <span class="kw">if</span> (Skip &gt;= BufferLength) <span class="kw">return</span>(NULL);
      <span class="co">/* Skip ahead and perform the next comparison */</span>
      BufferLength -= Skip;
      BufferPtr += Skip;
   }
}</code></pre>
<p><strong>LISTING 14.2 L14-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Program to exercise buffer-search routines in Listings 14.1 &amp; 14.3.</span>
<span class="co">   (Must be modified to put copy of pattern as sentinel at end of the</span>
<span class="co">   search buffer in order to be used with Listing 14.4.) */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;fcntl.h&gt;</span>

<span class="ot">#define DISPLAY_LENGTH  40</span>
<span class="ot">#define BUFFER_SIZE     0x8000</span>

<span class="kw">extern</span> <span class="dt">unsigned</span> <span class="dt">char</span> * FindString(<span class="dt">unsigned</span> <span class="dt">char</span> *, <span class="dt">unsigned</span> <span class="dt">int</span>,
   <span class="dt">unsigned</span> <span class="dt">char</span> *, <span class="dt">unsigned</span> <span class="dt">int</span>);
<span class="dt">void</span> main(<span class="dt">void</span>);

<span class="dt">void</span> main() {
   <span class="dt">unsigned</span> <span class="dt">char</span> TempBuffer[DISPLAY_LENGTH<span class="dv">+1</span>];
   <span class="dt">unsigned</span> <span class="dt">char</span> Filename[<span class="dv">150</span>], Pattern[<span class="dv">150</span>], *MatchPtr, *TestBuffer;
   <span class="dt">int</span> Handle;
   <span class="dt">unsigned</span> <span class="dt">int</span> WorkingLength;

   printf(<span class="st">&quot;File to search:&quot;</span>);
   gets(Filename);
   printf(<span class="st">&quot;Pattern for which to search:&quot;</span>);
   gets(Pattern);

   <span class="kw">if</span> ( (Handle = open(Filename, O_RDONLY | O_BINARY)) == -<span class="dv">1</span> ) {
      printf(<span class="st">&quot;Can&#39;t open file: %s</span><span class="ch">\n</span><span class="st">&quot;</span>, Filename); exit(<span class="dv">1</span>);
   }
   <span class="co">/* Get memory in which to buffer the data */</span>
   <span class="kw">if</span> ( (TestBuffer=(<span class="dt">unsigned</span> <span class="dt">char</span> *)malloc(BUFFER_SIZE<span class="dv">+1</span>)) == NULL) {
      printf(<span class="st">&quot;Can&#39;t get enough memory</span><span class="ch">\n</span><span class="st">&quot;</span>); exit(<span class="dv">1</span>);
   }
   <span class="co">/* Process a BUFFER_SIZE chunk */</span>
   <span class="kw">if</span> ( (<span class="dt">int</span>)(WorkingLength =
         read(Handle, TestBuffer, BUFFER_SIZE)) == -<span class="dv">1</span> ) {
      printf(<span class="st">&quot;Error reading file %s</span><span class="ch">\n</span><span class="st">&quot;</span>, Filename); exit(<span class="dv">1</span>);
   }
   TestBuffer[WorkingLength] = <span class="dv">0</span>; <span class="co">/* 0-terminate buffer for printf */</span>
   <span class="co">/* Search for the pattern and report the results */</span>
   <span class="kw">if</span> ((MatchPtr = FindString(TestBuffer, WorkingLength, Pattern,
         (<span class="dt">unsigned</span> <span class="dt">int</span>) strlen(Pattern))) == NULL) {
      <span class="co">/* Pattern wasn&#39;t found */</span>
      printf(<span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">%s</span><span class="ch">\&quot;</span><span class="st"> not found</span><span class="ch">\n</span><span class="st">&quot;</span>, Pattern);
   } <span class="kw">else</span> {
      <span class="co">/* Pattern was found. Zero-terminate TempBuffer; strncpy</span>
<span class="co">         won&#39;t do it if DISPLAY_LENGTH characters are copied */</span>
      TempBuffer[DISPLAY_LENGTH] = <span class="dv">0</span>;
      printf(<span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">%s</span><span class="ch">\&quot;</span><span class="st"> found. Next %d characters at match:</span><span class="ch">\n\&quot;</span><span class="st">%s</span><span class="ch">\&quot;\n</span><span class="st">&quot;</span>,
            Pattern, DISPLAY_LENGTH,
            strncpy(TempBuffer, MatchPtr, DISPLAY_LENGTH));
   }
   exit(<span class="dv">0</span>);
}</code></pre>
<p>Well, architecture carries a lot of weight, but it sure as heck isn’t destiny. I had simply fallen into the trap of figuring that the algorithm was so clever that I didn’t have to do any thinking myself. The path leading to <code>REPNZ SCASB</code> from the original brute-force approach of <code>REPZ CMPSB</code> at every location had been based on my observation that the first character comparison at each buffer location usually fails. Why not apply the same concept to Boyer-Moore? Listing 14.3 is just like the standard implementation—except that it’s optimized to handle a first-comparison mismatch as quickly as possible in the loop at <code>QuickSearchLoop</code>, much as <code>REPNZ SCASB</code> optimizes first-comparison mismatches for the brute-force approach. The results in Table 14.1 speak for themselves; Listing 14.3 is more than twice as fast as what I assure you was already a nice, tight assembly implementation (and unrolling <code>QuickSearchLoop</code> could boost performance by up to 10 percent more). Listing 14.3 is also <em>four times</em> faster than <code>REPNZ SCASB</code> in one case.</p>
<p><strong>LISTING 14.3 L14-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Searches a buffer for a specified pattern. In case of a mismatch,</span>
<span class="co">; uses the value of the mismatched byte to skip across as many</span>
<span class="co">; potential match locations as possible (partial Boyer-Moore).</span>
<span class="co">; Returns start offset of first match searching forward, or NULL if</span>
<span class="co">; no match is found.</span>
<span class="co">; Tested with TASM.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;       unsigned char * FindString(unsigned char * BufferPtr,</span>
<span class="co">;          unsigned int BufferLength, unsigned char * PatternPtr,</span>
<span class="co">;          unsigned int PatternLength);</span>

parms   <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup(?)   <span class="co">;pushed BP &amp; return address</span>
BufferPtr <span class="dt">dw</span>    ?          <span class="co">;pointer to buffer to be searched</span>
BufferLength <span class="dt">dw</span> ?          <span class="co">;# of bytes in buffer to be searched</span>
PatternPtr <span class="dt">dw</span>   ?          <span class="co">;pointer to pattern for which to search</span>
PatternLength <span class="dt">dw</span> ?         <span class="co">;length of pattern for which to search</span>
parms   ends

        .model small
        .code
        public _FindString
_FindString     proc    near
        <span class="kw">cld</span>
        <span class="kw">push</span>    <span class="kw">bp</span>         <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>      <span class="co">;point to our stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>         <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">sub</span>     <span class="kw">sp</span>,<span class="dv">256</span>*<span class="dv">2</span>   <span class="co">;allocate space for SkipTable</span>
<span class="co">; Create the table of distances by which to skip ahead on mismatches</span>
<span class="co">; for every possible byte value. First, initialize all skips to the</span>
<span class="co">; pattern length; this is the skip distance for bytes that don&#39;t</span>
<span class="co">; appear in the pattern.</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+PatternLength]
        <span class="kw">and</span>     <span class="kw">ax</span>,<span class="kw">ax</span>      <span class="co">;return an instant match if the pattern is</span>
        <span class="kw">jz</span>      InstantMatch <span class="co">;0-length</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">ds</span>
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">di</span>      <span class="co">;ES=DS=SS</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">sp</span>      <span class="co">;point to SkipBuffer</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">256</span>
        rep     <span class="kw">stosw</span>
        <span class="kw">dec</span>     <span class="kw">ax</span>                      <span class="co">;from now on, we only need</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+PatternLength],<span class="kw">ax</span>   <span class="co">; PatternLength - 1</span>
<span class="co">; Point to last (rightmost) byte of first potential pattern match</span>
<span class="co">; location in buffer.</span>
        <span class="kw">add</span>     [<span class="kw">bp</span>+BufferPtr],<span class="kw">ax</span>
<span class="co">; Reject if buffer is too small, and set the count of the number of</span>
<span class="co">; potential pattern match locations in the buffer.</span>
        <span class="kw">sub</span>     [<span class="kw">bp</span>+BufferLength],<span class="kw">ax</span>
        <span class="kw">jbe</span>     NoMatch
<span class="co">; Set the skip values for the bytes that do appear in the pattern to</span>
<span class="co">; the distance from the byte location to the end of the pattern.</span>
<span class="co">; When there are multiple instances of the same byte, the rightmost</span>
<span class="co">; instance&#39;s skip value is used. Note that the rightmost byte of the</span>
<span class="co">; pattern isn&#39;t entered in the skip table; if we get that value for</span>
<span class="co">; a mismatch, we know for sure that the right end of the pattern has</span>
<span class="co">; already passed the mismatch location, so this is not a relevant byte</span>
<span class="co">; for skipping purposes.</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+PatternPtr] <span class="co">;point to start of pattern</span>
        <span class="kw">and</span>     <span class="kw">ax</span>,<span class="kw">ax</span>              <span class="co">;are there any skips to set?</span>
        <span class="kw">jz</span>      SetSkipDone        <span class="co">;no</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">sp</span>              <span class="co">;point to SkipBuffer</span>
<span class="fu">SetSkipLoop:</span>
        <span class="kw">sub</span>     <span class="kw">bx</span>,<span class="kw">bx</span>      <span class="co">;prepare for word addressing off byte value</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,[<span class="kw">si</span>]    <span class="co">;get the next pattern byte</span>
        <span class="kw">inc</span>     <span class="kw">si</span>         <span class="co">;advance the pattern pointer</span>
        <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>       <span class="co">;prepare for word lookup</span>
        <span class="kw">mov</span>     [<span class="kw">di</span>+<span class="kw">bx</span>],<span class="kw">ax</span> <span class="co">;set the skip value when this byte value is</span>
                           <span class="co">; the mismatch value in the buffer</span>
        <span class="kw">dec</span>     <span class="kw">ax</span>
        <span class="kw">jnz</span>     SetSkipLoop
<span class="fu">SetSkipDone:</span>
        <span class="kw">mov</span>     <span class="kw">dl</span>,[<span class="kw">si</span>]            <span class="co">;DL=rightmost pattern byte from now on</span>
        <span class="kw">dec</span>     <span class="kw">si</span>                 <span class="co">;point to next-to-rightmost byte of pattern</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+PatternPtr],<span class="kw">si</span> <span class="co">; from now on</span>
<span class="co">; Search the buffer.</span>
        <span class="kw">std</span>                        <span class="co">;for backward REPZ CMPSB</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+BufferPtr]  <span class="co">;point to first search location</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+BufferLength]   <span class="co">;# of match locations to check</span>
<span class="fu">SearchLoop:</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,<span class="kw">sp</span>                  <span class="co">;point SI to SkipTable</span>
<span class="co">; Skip through until there&#39;s a match for the rightmost pattern byte.</span>
<span class="fu">QuickSearchLoop:</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,[<span class="kw">di</span>]         <span class="co">;rightmost buffer byte at this location</span>
        <span class="kw">cmp</span>     <span class="kw">dl</span>,<span class="kw">bl</span>           <span class="co">;does it match the rightmost pattern byte?</span>
        <span class="kw">jz</span>      FullCompare     <span class="co">;yes, so keep going</span>
        <span class="kw">sub</span>     <span class="kw">bh</span>,<span class="kw">bh</span>           <span class="co">;convert to a word</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,<span class="kw">bx</span>           <span class="co">;prepare for look-up in SkipTable</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">si</span>+<span class="kw">bx</span>]      <span class="co">;get skip value from skip table for this</span>
                                <span class="co">; mismatch value</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>           <span class="co">;BufferPtr += Skip;</span>
        <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">ax</span>           <span class="co">;BufferLength -= Skip;</span>
        <span class="kw">ja</span>      QuickSearchLoop <span class="co">;continue if any buffer left</span>
        <span class="kw">jmp</span>     <span class="dt">short</span> NoMatch
<span class="co">; Return a pointer to the start of the buffer (for 0-length pattern).</span>
        <span class="kw">align</span>   <span class="dv">2</span>
<span class="fu">InstantMatch:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+BufferPtr]
        <span class="kw">jmp</span>     <span class="dt">short</span> Done
<span class="co">; Compare the pattern and the buffer location, searching from high</span>
<span class="co">; memory toward low (right to left).</span>
        <span class="kw">align</span>   <span class="dv">2</span>
<span class="fu">FullCompare:</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+BufferPtr],<span class="kw">di</span>       <span class="co">;save the current state of</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+BufferLength],<span class="kw">cx</span>    <span class="co">; the search</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+PatternLength]   <span class="co">;# of bytes yet to compare</span>
        <span class="kw">jcxz</span>    Match                   <span class="co">;done if only one character</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+PatternPtr]      <span class="co">;point to next-to-rightmost bytes</span>
        <span class="kw">dec</span>     <span class="kw">di</span>                      <span class="co">; of buffer location and pattern</span>
        repz    <span class="kw">cmpsb</span>                   <span class="co">;compare the rest of the pattern</span>
        <span class="kw">jz</span>      Match                   <span class="co">;that&#39;s it; we&#39;ve found a match</span>
<span class="co">; It&#39;s a mismatch; let&#39;s see what we can learn from it.</span>
        <span class="kw">inc</span>     <span class="kw">di</span>      <span class="co">;compensate for 1-byte overrun of REPZ CMPSB;</span>
                        <span class="co">; point to mismatch location in buffer</span>
<span class="co">; # of bytes that did match.</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+BufferPtr]
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">di</span>
<span class="co">; If, based on the mismatch character, we can&#39;t even skip ahead as far</span>
<span class="co">; as where we started this particular comparison, then just advance by</span>
<span class="co">; 1 to the next potential match; otherwise, skip ahead from this</span>
<span class="co">; comparison location by the skip distance for the mismatch character,</span>
<span class="co">; less the distance covered by the partial match.</span>
        <span class="kw">sub</span>     <span class="kw">bx</span>,<span class="kw">bx</span>     <span class="co">;prepare for word addressing off byte value</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,[<span class="kw">di</span>]   <span class="co">;get the value of the mismatch byte in buffer</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,<span class="kw">bx</span>     <span class="co">;prepare for word look-up</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,<span class="kw">sp</span>     <span class="co">;SP points to SkipTable</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bx</span>]   <span class="co">;get the skip value for this mismatch</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dv">1</span>      <span class="co">;assume we&#39;ll just advance to the next</span>
                          <span class="co">; potential match location</span>
        <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">si</span>     <span class="co">;is the skip far enough to be worth taking?</span>
        <span class="kw">jna</span>     MoveAhead <span class="co">;no, go with the default advance of 1</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">cx</span>     <span class="co">;yes; this is the distance to skip ahead from</span>
                          <span class="co">; the last potential match location checked</span>
<span class="fu">MoveAhead:</span>
<span class="co">; Skip ahead and perform the next comparison, if there&#39;s any buffer</span>
<span class="co">; left to check.</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+BufferPtr]
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>                   <span class="co">;BufferPtr += Skip;</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+BufferLength]
        <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">ax</span>                   <span class="co">;BufferLength -= Skip;</span>
        <span class="kw">ja</span>      SearchLoop              <span class="co">;continue if any buffer left</span>
<span class="co">; Return a NULL pointer for no match.</span>
        <span class="kw">align</span>   <span class="dv">2</span>
<span class="fu">NoMatch:</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>
        <span class="kw">jmp</span>     <span class="dt">short</span> Done
<span class="co">; Return start of match in buffer (BufferPtr - (PatternLength - 1)).</span>
        <span class="kw">align</span>   <span class="dv">2</span>
<span class="fu">Match:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+BufferPtr]
        <span class="kw">sub</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+PatternLength]
<span class="fu">Done:</span>
        <span class="kw">cld</span>              <span class="co">;restore default direction flag</span>
        <span class="kw">add</span>     <span class="kw">sp</span>,<span class="dv">256</span>*<span class="dv">2</span> <span class="co">;deallocate space for SkipTable</span>
        <span class="kw">pop</span>     <span class="kw">di</span>       <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>       <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_FindString     endp
        end</code></pre>
<p>Table 14.1 represents a limited and decidedly unscientific comparison of searching techniques. Nonetheless, the overall trend is clear: For all but the shortest patterns, well-implemented Boyer-Moore is generally as good as or better than—sometimes <em>much</em> better than—brute-force searching. (For short patterns, you might want to use <code>REPNZ SCASB</code>, thereby getting the best of both worlds.)</p>
<p>Know your data and use your smarts. Don’t stop thinking just because you’re implementing a big-name algorithm; you know more than it does.</p>
</section>
<section id="further-optimization-of-boyer-moore" class="level3">
<h3><a href="#further-optimization-of-boyer-moore">Further Optimization of Boyer-Moore</a></h3>
<p>We can do substantially better yet than Listing 14.3 if we’re willing to accept tighter limits on the data. Limiting the length of the searched-for pattern to a maximum of 255 bytes allows us to use the <code>XLAT</code> instruction and generally tighten the critical loop. (Be aware, however, that <code>XLAT</code> is a relatively expensive instruction on the 486 and Pentium.) Putting a copy of the searched-for string at the end of the search buffer as a sentinel, so that the search never fails, frees us from counting down the buffer length, and makes it easy to unroll the critical loop. Listing 14.4, which implements these optimizations, is about 60 percent faster than Listing 14.3.</p>
<p><strong>LISTING 14.4 L14-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Searches a buffer for a specified pattern. In case of a mismatch,</span>
<span class="co">; uses the value of the mismatched byte to skip across as many</span>
<span class="co">; potential match locations as possible (partial Boyer-Moore).</span>
<span class="co">; Returns start offset of first match searching forward, or NULL if</span>
<span class="co">; no match is found.</span>
<span class="co">; Requires that the pattern be no longer than 255 bytes, and that</span>
<span class="co">; there be a match for the pattern somewhere in the buffer (ie., a</span>
<span class="co">; copy of the pattern should be placed as a sentinel at the end of</span>
<span class="co">; the buffer if the pattern isn&#39;t already known to be in the buffer).</span>
<span class="co">; Tested with TASM.</span>
<span class="co">; C near-callable as:</span>
<span class="co">; unsigned char * FindString(unsigned char * BufferPtr,</span>
<span class="co">; unsigned int BufferLength, unsigned char * PatternPtr,</span>
<span class="co">; unsigned int PatternLength);</span>

parms   <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup(?)    <span class="co">;pushed BP &amp; return address</span>
BufferPtr <span class="dt">dw</span>    ?           <span class="co">;pointer to buffer to be searched</span>
BufferLength <span class="dt">dw</span> ?           <span class="co">;# of bytes in buffer to be searched</span>
                            <span class="co">; (not used, actually)</span>
PatternPtr <span class="dt">dw</span>   ?           <span class="co">;pointer to pattern for which to search</span>
                            <span class="co">; (pattern *MUST* exist in the buffer)</span>
PatternLength <span class="dt">dw</span> ?          <span class="co">;length of pattern for which to search (must</span>
                            <span class="co">; be &lt;= 255)</span>
parms   ends

        .model small
        .code
        public _FindString
_FindString     proc    near
        <span class="kw">cld</span>
        <span class="kw">push</span>    <span class="kw">bp</span>          <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>       <span class="co">;point to our stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>          <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">sub</span>     <span class="kw">sp</span>,<span class="dv">256</span>      <span class="co">;allocate space for SkipTable</span>
<span class="co">; Create the table of distances by which to skip ahead on mismatches</span>
<span class="co">; for every possible byte value. First, initialize all skips to the</span>
<span class="co">; pattern length; this is the skip distance for bytes that don&#39;t</span>
<span class="co">; appear in the pattern.</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">ds</span>
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">di</span>        <span class="co">;ES=DS=SS</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">sp</span>        <span class="co">;point to SkipBuffer</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+PatternLength]
        <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">al</span>        <span class="co">;return an instant match if the pattern is</span>
        <span class="kw">jz</span>      InstantMatch <span class="co">; 0-length</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">al</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">256</span>/<span class="dv">2</span>
        rep     <span class="kw">stosw</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+PatternLength]
        <span class="kw">dec</span>     <span class="kw">ax</span>                       <span class="co">;from now on, we only need</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+PatternLength],<span class="kw">ax</span>    <span class="co">; PatternLength - 1</span>
<span class="co">; Point to rightmost byte of first potential pattern match location</span>
<span class="co">; in buffer.</span>
        <span class="kw">add</span>     [<span class="kw">bp</span>+BufferPtr],<span class="kw">ax</span>
<span class="co">; Set the skip values for the bytes that do appear in the pattern to</span>
<span class="co">; the distance from the byte location to the end of the pattern.</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+PatternPtr] <span class="co">;point to start of pattern</span>
        <span class="kw">and</span>     <span class="kw">ax</span>,<span class="kw">ax</span>       <span class="co">;are there any skips to set?</span>
        <span class="kw">jz</span>      SetSkipDone <span class="co">;no</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">sp</span>       <span class="co">;point to SkipBuffer</span>
        <span class="kw">sub</span>     <span class="kw">bx</span>,<span class="kw">bx</span>       <span class="co">;prepare for word addressing off byte value</span>
<span class="fu">SetSkipLoop:</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,[<span class="kw">si</span>]     <span class="co">;get the next pattern byte</span>
        <span class="kw">inc</span>     <span class="kw">si</span>          <span class="co">;advance the pattern pointer</span>
        <span class="kw">mov</span>     [<span class="kw">di</span>+<span class="kw">bx</span>],<span class="kw">al</span>  <span class="co">;set the skip value when this byte value is</span>
                            <span class="co">;the mismatch value in the buffer</span>
        <span class="kw">dec</span>     <span class="kw">ax</span>
        <span class="kw">jnz</span>     SetSkipLoop
<span class="fu">SetSkipDone:</span>
        <span class="kw">mov</span>     <span class="kw">dl</span>,[<span class="kw">si</span>]       <span class="co">;DL=rightmost pattern byte from now on</span>
        <span class="kw">dec</span>     <span class="kw">si</span>            <span class="co">;point to next-to-rightmost byte of pattern</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+PatternPtr],<span class="kw">si</span> <span class="co">; from now on</span>
<span class="co">; Search the buffer.</span>
        <span class="kw">std</span>                       <span class="co">;for backward REPZ CMPSB</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+BufferPtr] <span class="co">;point to the first search location</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">sp</span>             <span class="co">;point to SkipTable for XLAT</span>
<span class="fu">SearchLoop:</span>
        <span class="kw">sub</span>     <span class="kw">ah</span>,<span class="kw">ah</span>   <span class="co">;used to convert AL to a word</span>
<span class="co">; Skip through until there&#39;s a match for the first pattern byte.</span>
<span class="fu">QuickSearchLoop:</span>
<span class="co">; See if we have a match at the first buffer location.</span>
        REPT    <span class="dv">8</span>           <span class="co">;unroll loop 8 times to reduce branching</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,[<span class="kw">di</span>]     <span class="co">;next buffer byte</span>
        <span class="kw">cmp</span>     <span class="kw">dl</span>,<span class="kw">al</span>       <span class="co">;does it match the pattern?</span>
        <span class="kw">jz</span>      FullCompare <span class="co">;yes, so keep going</span>
        <span class="kw">xlat</span>                <span class="co">;no, look up the skip value for this mismatch</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>       <span class="co">;BufferPtr += Skip;</span>
        ENDM
        <span class="kw">jmp</span>     QuickSearchLoop
<span class="co">; Return a pointer to the start of the buffer (for 0-length pattern).</span>
        <span class="kw">align</span>   <span class="dv">2</span>
<span class="fu">InstantMatch:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+BufferPtr]
        <span class="kw">jmp</span>     <span class="dt">short</span> Done
<span class="co">; Compare the pattern and the buffer location, searching from high</span>
<span class="co">; memory toward low (right to left).</span>
        <span class="kw">align</span>   <span class="dv">2</span>
<span class="fu">FullCompare:</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+BufferPtr],<span class="kw">di</span> <span class="co">;save the current buffer location</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+PatternLength] <span class="co">;# of bytes yet to compare</span>
        <span class="kw">jcxz</span>    Match   <span class="co">;done if there was only one character</span>
        <span class="kw">dec</span>     <span class="kw">di</span>      <span class="co">;point to next destination byte to compare (SI</span>
                        <span class="co">; points to next-to-rightmost source byte)</span>
        repz    <span class="kw">cmpsb</span>   <span class="co">;compare the rest of the pattern</span>
        <span class="kw">jz</span>      Match   <span class="co">;that&#39;s it; we&#39;ve found a match</span>
<span class="co">; It&#39;s a mismatch; let&#39;s see what we can learn from it.</span>
        <span class="kw">inc</span>     <span class="kw">di</span>      <span class="co">;compensate for 1-byte overrun of REPZ CMPSB;</span>
                        <span class="co">; point to mismatch location in buffer</span>
<span class="co">; # of bytes that did match.</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+BufferPtr]
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">di</span>
<span class="co">; If, based on the mismatch character, we can&#39;t even skip ahead as far</span>
<span class="co">; as where we started this particular comparison, then just advance by</span>
<span class="co">; 1 to the next potential match; otherwise, skip ahead from this</span>
<span class="co">; comparison location by the skip distance for the mismatch character,</span>
<span class="co">; less the distance covered by the partial match.</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,[<span class="kw">di</span>] <span class="co">;get the value of the mismatch byte in buffer</span>
        <span class="kw">xlat</span>               <span class="co">;get the skip value for this mismatch</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">1</span>       <span class="co">;assume we&#39;ll just advance to the next</span>
                           <span class="co">; potential match location</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">si</span>      <span class="co">;is the skip far enough to be worth taking?</span>
        <span class="kw">jna</span>     MoveAhead  <span class="co">;no, go with the default advance of 1</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">ax</span>      <span class="co">;yes, this is the distance to skip ahead from</span>
                           <span class="co">;the last potential match location checked</span>
<span class="fu">MoveAhead:</span>
<span class="co">; Skip ahead and perform the next comparison.</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+BufferPtr]
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">cx</span>              <span class="co">;BufferPtr += Skip;</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+PatternPtr] <span class="co">;point to the next-to-rightmost</span>
                                   <span class="co">; pattern byte</span>
        <span class="kw">jmp</span>     SearchLoop
<span class="co">; Return start of match in buffer (BufferPtr - (PatternLength - 1)).</span>
        <span class="kw">align</span>   <span class="dv">2</span>
<span class="fu">Match:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+BufferPtr]
        <span class="kw">sub</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+PatternLength]
<span class="fu">Done:</span>
        <span class="kw">cld</span>             <span class="co">;restore default direction flag</span>
        <span class="kw">add</span>     <span class="kw">sp</span>,<span class="dv">256</span>  <span class="co">;deallocate space for SkipTable</span>
        <span class="kw">pop</span>     <span class="kw">di</span>      <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>      <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_FindString     endp
        end</code></pre>
<p>Note that Table 14.1 includes the time required to build the skip table each time <code>FindString</code> is called. This time could be eliminated for all but the first search when repeatedly searching for a particular pattern, by building the skip table externally and passing a pointer to it as a parameter.</p>
</section>
<section id="know-what-you-know" class="level3">
<h3><a href="#know-what-you-know">Know What You Know</a></h3>
<p>Here we’ve turned up our nose at a repeated string instruction, we’ve gone against the grain by comparing backward, and yet we’ve speeded up our code quite a bit. All this without any restrictions or special requirements (excluding Listing 14.4)—and without any new information. Everything we needed was sitting there all along; we just needed to think to look at it.</p>
<p>As Yogi Berra might put it, “You don’t know what you know until you know it.”</p>
</section>
</section>
<section id="chapter-15-linked-lists-and-plain-unintended-challenges" class="level2">
<h2><a href="#chapter-15-linked-lists-and-plain-unintended-challenges">Chapter 15 – Linked Lists and plain Unintended Challenges</a></h2>
<section id="unfamiliar-problems-with-familiar-data-structures" class="level3">
<h3><a href="#unfamiliar-problems-with-familiar-data-structures">Unfamiliar Problems with Familiar Data Structures</a></h3>
<p>After 21 years, this story still makes me wince. Oh, the humiliations I suffer for your enlightenment….</p>
<p>It wasn’t until ninth grade that I had my first real girlfriend. Okay, maybe I was a little socially challenged as a kid, but hey, show me a good programmer who wasn’t; it goes with the territory. Her name was Jeannie Schweigert, and she was about four feet tall, pretty enough, and female—and willing to go out with me, which made her approximately as attractive as Cheryl Tiegs, in my book.</p>
<p>Jeannie and I hung out together at school, and went to basketball games and a few parties together, but somehow the two of us were never alone. Being 14, neither of us could drive, so her parents tended to end up chauffeuring us. That’s a next-to-ideal arrangement, I now realize, having a daughter of my own (ideal being exiling all males between the ages of 12 and 18 to Tasmania), but at the time, it drove me nuts. You see…ahem…I had never actually kissed Jeannie—or anyone, for that matter, unless you count maiden aunts and the like—and I was dying to. At the same time, I was terrified at the prospect. What if I turned out to be no good at it? It wasn’t as if I could go to Kisses ‘R’ Us and take lessons.</p>
<p>My long-awaited opportunity finally came after a basketball game. For a change, <em>my</em> father was driving, and when we dropped her off at her house, I walked her to the door. This was my big chance. I put my arms around her, bent over with my eyes closed, just like in the movies….</p>
<p>And whacked her on the top of the head with my chin. (As I said, she was only about four feet tall.) And I do mean whacked. Jeannie burst into hysterical laughter, tried to calm herself down, said goodnight, and went inside, still giggling. No kiss.</p>
<p>I was a pretty mature teenager, so this was only slightly more traumatic than leading the Tournament of Roses parade in my underwear. On the next try, though, I did manage to get the hang of this kissing business, and eventually even went on to have a child. (Not with Jeannie, I might add; the mind boggles at the mess I could have made of <em>that</em> with her.) As it turns out, none of that stuff is particularly difficult; in fact, it’s kind of enjoyable, wink, wink, say no more.</p>
<p>When you’re dealing with something new, a little knowledge goes a long way. When it comes to kissing, we have to fumble along the learning curve on our own, but there are all sorts of resources to help speed up the learning process when it comes to programming. The basic mechanisms of programming—searches, sorts, parsing, and the like—are well-understood and superbly well-documented. Treat yourself to a book like <em>Algorithms,</em> by Robert Sedgewick (Addison Wesley), or Knuth’s <em>The Art of Computer Programming</em> series (also from Addison Wesley; and where was Knuth with <em>The Art of Kissing</em> when I needed him?), or practically anything by Jon Bentley, and when you tackle a new area, give yourself a head start. There’s still plenty of room for inventiveness and creativity on your part, but why not apply that energy on top of the knowledge that’s already been gained, instead of reinventing the wheel? I know, reinventing the wheel is just the kind of challenge programmers love—but can you really afford to waste the time? And do you honestly think that you’re so smart that you can out-think Knuth, who’s spent a lifetime at this stuff and happens to be a genius?</p>
<p>Maybe you can—but I sure can’t. For example, consider the evolution of my understanding of linked lists.</p>
</section>
<section id="linked-lists" class="level3">
<h3><a href="#linked-lists">Linked Lists</a></h3>
<p>Linked lists are data structures composed of discrete elements, or nodes, joined together with links. In C, the links are typically pointers. Like all data structures, linked lists have their strengths and their weaknesses. Primary among the strengths are: simplicity; speedy sequential processing; ease and speed of insertion and deletion; the ability to mix nodes of various sizes and types; and the ability to handle variable amounts of data, especially when the total amount of data changes dynamically or is not always known beforehand. Weaknesses include: greater memory requirements than arrays (the pointers take up space); slow non-sequential processing, including finding arbitrary nodes; and an inability to backtrack, unless doubly-linked lists are used. Unfortunately, doubly linked lists need more memory, as well as processing time to maintain the backward links.</p>
<p>Linked lists aren’t very good for most types of sorts. Insertion and bubble sorts work fine, but more sophisticated sorts depend on efficient random access, which linked lists don’t provide. Likewise, you wouldn’t want to do a binary search on a linked list. On the other hand, linked lists are ideal for applications where nothing more than sequential access is needed to data that’s always sorted or nearly sorted.</p>
<p>Consider a polygon fill function, for example. Polygon edges are added to the active edge list in x-sorted order, and tend to stay pretty nearly x-sorted, so sophisticated sorting is never needed. Edges are read out of the list in sorted order, just the way linked lists work best. Moreover, linked lists are straightforward to implement, and with linked lists an arbitrary number of polygon edges can be handled with no fuss. All in all, linked lists work beautifully for filling polygons. For an example of the use of linked lists in polygon filling, see my column in the May 1991 issue of <em>Dr. Dobb’s Journal.</em> Be warned, though, that none of the following optimizations are to be found in that column.</p>
<p>You see, that column was my first heavy-duty use of linked lists, and they seemed so simple that I didn’t even open Sedgewick or Knuth. For hashing or Boyer-Moore searching, sure, I’d have done my homework first; but linked lists seemed too obvious to bother. I was much more concerned with the polygon-related aspects of the implementation, and, in truth, I gave the linked list implementation not a moment’s thought before I began coding. Heck, I had handled <em>much</em> tougher programming problems in the past; surely it would be faster to figure this one out on my own than to look it up.</p>
<p>Not!</p>
<p>The basic concept of a linked list—the one I came up with for that <em>DDJ</em> column—is straightforward, as shown in Figure 15.1. A head pointer points to the first node in the list, which points to the next node, which points to the next, and so on, until the last node in the list is reached (typically denoted by a <code>NULL</code> next-node pointer). Conceptually, nothing could be simpler. From an implementation perspective, however, there are serious flaws with this model.</p>
<p>The fundamental problem is that the model of Figure 15.1 unnecessarily complicates link manipulation. In order to delete a node, for example, you must change the preceding node’s <code>NextNode</code> pointer to point to the following node, as shown in Listing 15.1. (Listing 15.2 is the header file LLIST.H, which is <code>#include</code>d by all the linked list listings in this chapter.) Easy enough—unless the preceding node happens to be the head pointer, which doesn’t <em>have</em> a <code>NextNode</code> field, because it’s not a node, so Listing 15.1 won’t work. Cumbersome special code and extra information (a pointer to the head of the list) are required to handle the head-pointer case, as shown in Listing 15.3. (I’ll grant you that if you make the next-node pointer the first field in the <code>LinkNode</code> structure, at offset 0, then you could successfully point to the head pointer and pretend it was a <code>LinkNode</code> structure—but that’s an ugly and potentially dangerous trick, and we’ll see a better approach next.)</p>
<figure>
<img src="images/15-01.jpg" alt="Figure 15.1  The basic concept of a linked list." /><figcaption><strong>Figure 15.1</strong>  <em>The basic concept of a linked list.</em></figcaption>
</figure>
<p><strong>LISTING 15.1 L15-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Deletes the node in a linked list that follows the indicated node.</span>
<span class="co">   Assumes list is headed by a dummy node, so no special testing for</span>
<span class="co">   the head-of-list pointer is required.  Returns the same pointer</span>
<span class="co">   that was passed in. */</span>

<span class="ot">#include &quot;llist.h&quot;</span>
<span class="kw">struct</span> LinkNode *DeleteNodeAfter(<span class="kw">struct</span> LinkNode *NodeToDeleteAfter)
{
   NodeToDeleteAfter-&gt;NextNode =
         NodeToDeleteAfter-&gt;NextNode-&gt;NextNode;
   <span class="kw">return</span>(NodeToDeleteAfter);
}</code></pre>
<p><strong>LISTING 15.2 LLIST.H</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Linked list header file. */</span>
<span class="ot">#define MAX_TEXT_LENGTH 100   </span><span class="co">/* longest allowed Text field */</span>
<span class="ot">#define SENTINEL  32767       </span><span class="co">/* largest possible Value field */</span>

<span class="kw">struct</span> LinkNode {
   <span class="kw">struct</span> LinkNode *NextNode;
   <span class="dt">int</span> Value;
   <span class="dt">char</span> Text[MAX_TEXT_LENGTH<span class="dv">+1</span>];
   <span class="co">/* Any number of additional data fields may by present */</span>
};
<span class="kw">struct</span> LinkNode *DeleteNodeAfter(<span class="kw">struct</span> LinkNode *);
<span class="kw">struct</span> LinkNode *FindNodeBeforeValue(<span class="kw">struct</span> LinkNode *, <span class="dt">int</span>);
<span class="kw">struct</span> LinkNode *InitLinkedList(<span class="dt">void</span>);
<span class="kw">struct</span> LinkNode *InsertNodeSorted(<span class="kw">struct</span> LinkNode *,
   <span class="kw">struct</span> LinkNode *);</code></pre>
<p><strong>LISTING 15.3 L15-3.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Deletes the node in the specified linked list that follows the</span>
<span class="co">   indicated node. List is headed by a head-of-list pointer; if the</span>
<span class="co">   pointer to the node to delete after points to the head-of-list</span>
<span class="co">   pointer, special handling is performed. */</span>
<span class="ot">#include &quot;llist.h&quot;</span>
<span class="kw">struct</span> LinkNode *DeleteNodeAfter(<span class="kw">struct</span> LinkNode **HeadOfListPtr,
   <span class="kw">struct</span> LinkNode *NodeToDeleteAfter)
{
   <span class="co">/* Handle specially if the node to delete after is actually the</span>
<span class="co">      head of the list (delete the first element in the list) */</span>
   <span class="kw">if</span> (NodeToDeleteAfter == (<span class="kw">struct</span> LinkNode *)HeadOfListPtr) {
      *HeadOfListPtr = (*HeadOfListPtr)-&gt;NextNode;
   } <span class="kw">else</span> {
      NodeToDeleteAfter-&gt;NextNode =
            NodeToDeleteAfter-&gt;NextNode-&gt;NextNode;
   }
   <span class="kw">return</span>(NodeToDeleteAfter);
}</code></pre>
<p>However, it is true that if you’re going to store a variety of types of structures in your linked lists, you should start each node with the <code>LinkNode</code> field. That way, the link pointer is in the same place in <em>every</em> structure, and the same linked list code can handle all of the structure types by casting them to the base link-node structure type. This is a less than elegant approach, but it works. C++ can handle data mixing more cleanly than C, via derivation from a base link-node class.</p>
<p>Note that Listings 15.1 and 15.3 have to specify the linked-list delete operation as “delete the <em>next</em> node,” rather than “delete this node,” because in order to relink it’s necessary to access the <code>NextNode</code> field of the node preceding the node to be deleted, and it’s impossible to backtrack in a singly linked list. For this reason, singly-linked list operations tend to work with the structure preceding the one of interest—and that makes the problem of having to special-case the head pointer all the more acute.</p>
<p>Similar problems with the head pointer crop up when you’re inserting nodes, and in fact in all link manipulation code. It’s easy to end up working with either pointers to pointers or lots of special-case code, and while those approaches work, they’re inelegant and inefficient.</p>
</section>
<section id="dummies-and-sentinels" class="level3">
<h3><a href="#dummies-and-sentinels">Dummies and Sentinels</a></h3>
<p>A far better approach is to use a <em>dummy node</em> for the head of the list, as shown in Figure 15.2. I invented this one for myself the next time I encountered linked lists, while designing a seed fill function for MetaWindows, back during my tenure at Metagraphics Corp. But I could have learned it by spending five minutes with Sedgewick’s book.</p>
<figure>
<img src="images/15-02.jpg" alt="Figure 15.2  Using a dummy head and tail node with a linked list." /><figcaption><strong>Figure 15.2</strong>  <em>Using a dummy head and tail node with a linked list.</em></figcaption>
</figure>
<blockquote>
<p><img src="images/i.jpg" /> The next-node pointer of the head node, which points to the first real node, is the only part of the head node that’s actually used. This way the same code works on the head node as on the rest of the list, so there are no special cases.</p>
</blockquote>
<p>Likewise, there should be a separate node for the tail of the list, so that every node that contains real data is guaranteed to have a node on either side of it. In this scheme, an empty list contains two nodes, as shown in Figure 15.3. Although it is not necessary, the tail node may point to itself as its own next node, rather than contain a <code>NULL</code> pointer. This way, a deletion operation on an empty list will have no effect—quite unlike the same operation performed on a list terminated with a <code>NULL</code> pointer. The tail node of a list terminated like this can be detected because it will be the only node for which the next-node pointer equals the current-node pointer.</p>
<p>Figure 15.3 is a giant step in the right direction, but we can still make a few refinements. The inner loop of any code that scans through such a list has to perform a special test on each node to determine whether the tail has been reached. So, for example, code to find the first node containing a value field greater than or equal to a certain value has to perform two tests in the inner loop, as shown in Listing 15.4.</p>
<p><strong>LISTING 15.4 L15-4.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*  Finds the first node in a linked list with a value field greater</span>
<span class="co">    than or equal to a key value, and returns a pointer to the node</span>
<span class="co">    preceding that node (to facilitate insertion and deletion), or a</span>
<span class="co">    NULL pointer if no such value was found. Assumes the list is</span>
<span class="co">    terminated with a tail node pointing to itself as the next node. */</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &quot;llist.h&quot;</span>
<span class="kw">struct</span> LinkNode *FindNodeBeforeValueNotLess(
   <span class="kw">struct</span> LinkNode *HeadOfListNode, <span class="dt">int</span> SearchValue)
{
   <span class="kw">struct</span> LinkNode *NodePtr = HeadOfListNode;

   <span class="kw">while</span> ( (NodePtr-&gt;NextNode-&gt;NextNode != NodePtr-&gt;NextNode) &amp;&amp;
         (NodePtr-&gt;NextNode-&gt;Value &lt; SearchValue) )
      NodePtr = NodePtr-&gt;NextNode;

   <span class="kw">if</span> (NodePtr-&gt;NextNode-&gt;NextNode == NodePtr-&gt;NextNode)
      <span class="kw">return</span>(NULL);     <span class="co">/* we found the sentinel; failed search */</span>
   <span class="kw">else</span>
      <span class="kw">return</span>(NodePtr);  <span class="co">/* success; return pointer to node preceding</span>
<span class="co">                           node that was &gt;= */</span>
}</code></pre>
<p>Suppose, however, that we make the tail node a <em>sentinel</em> by giving it a value that is guaranteed to terminate the search, as shown in Figure 15.4. The list in Figure 15.4 has a sentinel with a value field of 32,767; since we’re working with integers, that’s the highest possible search value, and is guaranteed to satisfy any search that comes down the pike. The success or failure of the search can then be determined outside the loop, if necessary, by checking for the tail node’s special pointer—but the inside of the loop is streamlined to just one test, as shown in Listing 15.5. Not all linked lists lend themselves to sentinels, but the performance benefits are considerable for those lend themselves to sentinels, but the performance benefits are considerable for those that do.</p>
<figure>
<img src="images/15-03.jpg" alt="Figure 15.3  Representing an empty list." /><figcaption><strong>Figure 15.3</strong>  <em>Representing an empty list.</em></figcaption>
</figure>
<p><strong>LISTING 15.5 L15-5.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Finds the first node in a value-sorted linked list that</span>
<span class="co">   has a Value field greater than or equal to a key value, and</span>
<span class="co">   returns a pointer to the node preceding that node (to facilitate</span>
<span class="co">   insertion and deletion), or a NULL pointer if no such value was</span>
<span class="co">   found. Assumes the list is terminated with a sentinel tail node</span>
<span class="co">   containing the largest possible Value field setting and pointing</span>
<span class="co">   to itself as the next node. */</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &quot;llist.h&quot;</span>
<span class="kw">struct</span> LinkNode *FindNodeBeforeValueNotLess(
   <span class="kw">struct</span> LinkNode *HeadOfListNode, <span class="dt">int</span> SearchValue)
{
   <span class="kw">struct</span> LinkNode *NodePtr = HeadOfListNode;
   <span class="kw">while</span> (NodePtr-&gt;NextNode-&gt;Value &lt; SearchValue)
      NodePtr = NodePtr-&gt;NextNode;
   <span class="kw">if</span> (NodePtr-&gt;NextNode-&gt;NextNode == NodePtr-&gt;NextNode)
      <span class="kw">return</span>(NULL);     <span class="co">/* we found the sentinel; failed search */</span>
   <span class="kw">else</span>
      <span class="kw">return</span>(NodePtr);  <span class="co">/* success; return pointer to node preceding</span>
<span class="co">                           node that was &gt;= */</span>
}</code></pre>
<figure>
<img src="images/15-04.jpg" alt="Figure 15.4  List terminated by a sentinel." /><figcaption><strong>Figure 15.4</strong>  <em>List terminated by a sentinel.</em></figcaption>
</figure>
</section>
<section id="circular-lists" class="level3">
<h3><a href="#circular-lists">Circular Lists</a></h3>
<p>One minor but elegant refinement yet remains: Use a single node as both the head <em>and</em> the tail of the list. We can do this by connecting the last node back to the first through the head/tail node in a circular fashion, as shown in Figure 15.5. This head/tail node can also, of course, be a sentinel; when it’s necessary to check for the end of the list explicitly, that can be done by comparing the current node pointer to the head pointer. If they’re equal, you’re at the head/tail node.</p>
<p>Why am I so fond of this circular list architecture? For one thing, it saves a node, and most of my linked list programming has been done in severely memory-constrained environments. Mostly, though, it’s just so <em>neat;</em> with this setup, there’s not a single node or inner-loop instruction wasted. Perfect economy of programming, if you ask me.</p>
<p>I must admit that I racked my brains for quite a while to come up with the circular list, simple as it may seem. Shortly after coming up with it, I happened to look in Sedgewick’s book, only to find my nifty optimization described plain as day; and a little while after <em>that,</em> I came across a thread in the algorithms/computer.sci topic on BIX that described it in considerable detail. Folks, the information is out there. Look it up <em>before</em> turning on your optimizer afterburners!</p>
<p>Listings 15.1 and 15.6 together form a suite of C functions for maintaining a circular linked list sorted by ascending value. (Listing 15.5 requires modification before it will work with circular lists.) Listing 15.7 is an assembly language version of <code>InsertNodeSorted()</code>; note the tremendous efficiency of the scanning loop in <code>InsertNodeSorted()</code>-four instructions per node!—thanks to the dummy head/tail/sentinel node. Listing 15.8 is a simple application that illustrates the use of the linked-list functions in Listings 15.1 and 15.6.</p>
<p>Contrast Figure 15.5 with Figure 15.1, and Listings 15.1, 15.5, 15.6, and 15.7 with Listings 15.3 and 15.4. Yes, linked lists are simple, but not so simple that a little knowledge doesn’t make a substantial difference. Make it a habit to read Knuth or Sedgewick or the like before you write a single line of code.</p>
<figure>
<img src="images/15-05.jpg" alt="Figure 15.5  Representing a circular list." /><figcaption><strong>Figure 15.5</strong>  <em>Representing a circular list.</em></figcaption>
</figure>
<p><strong>LISTING 15.6 L15-6.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*  Suite of functions for maintaining a linked list sorted by</span>
<span class="co">    ascending order of the Value field. The list is circular; that</span>
<span class="co">    is,it has a dummy node as both the head and the tail of the list.</span>
<span class="co">    The dummy node is a sentinel, containing the largest possible</span>
<span class="co">    Value field setting. Tested with Borland C++ in C mode. */</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &quot;llist.h&quot;</span>
<span class="co">/* Initializes an empty linked list of LinkNode structures,</span>
<span class="co">   consisting of a single head/tail/sentinel node, and returns a</span>
<span class="co">   pointer to the list. Returns NULL for failure. */</span>
<span class="kw">struct</span> LinkNode *InitLinkedList()
{
   <span class="kw">struct</span> LinkNode *Sentinel;

   <span class="kw">if</span> ((Sentinel = malloc(<span class="kw">sizeof</span>(<span class="kw">struct</span> LinkNode))) == NULL)
      <span class="kw">return</span>(NULL);
   Sentinel-&gt;NextNode = Sentinel;
   Sentinel-&gt;Value = SENTINEL;
   strcpy(Sentinel-&gt;Text, <span class="st">&quot;*** sentinel ***&quot;</span>);
   <span class="kw">return</span>(Sentinel);
}

<span class="co">/* Finds the first node in a value-sorted linked list with a value</span>
<span class="co">   field equal to a key value, and returns a pointer to the node</span>
<span class="co">   preceding that node (to facilitate insertion and deletion), or a</span>
<span class="co">   NULL pointer if no value was found. Assumes list is terminated</span>
<span class="co">   with a sentinel node containing the largest possible value. */</span>

<span class="kw">struct</span> LinkNode *FindNodeBeforeValue(<span class="kw">struct</span> LinkNode *HeadOfListNode,
<span class="dt">int</span> SearchValue)
{
   <span class="kw">struct</span> LinkNode *NodePtr = HeadOfListNode;

   <span class="kw">while</span> (NodePtr-&gt;NextNode-&gt;Value &lt; SearchValue)
      NodePtr = NodePtr-&gt;NextNode;
   <span class="kw">if</span> (NodePtr-&gt;NextNode-&gt;Value == SearchValue) {
      <span class="co">/* Found the search value; success unless we found the</span>
<span class="co">         sentinel (can happen only if SearchValue == SENTINEL) */</span>
      <span class="kw">if</span> (NodePtr-&gt;NextNode == HeadOfListNode) {
         <span class="kw">return</span>(NULL);     <span class="co">/* failure; we found the sentinel */</span>
      } <span class="kw">else</span> {
         <span class="kw">return</span>(NodePtr);  <span class="co">/* success; return pointer to node</span>
<span class="co">                              preceding the node that was equal */</span>
      }
   } <span class="kw">else</span> {
       <span class="kw">return</span>(NULL);       <span class="co">/* No match; return failure status */</span>
   }
}

<span class="co">/* Inserts the specified node into a value-sorted linked list, such</span>
<span class="co">   that value-sorting is maintained. Returns a pointer to the node</span>
<span class="co">   after which the new node is inserted. */</span>
<span class="kw">struct</span> LinkNode *InsertNodeSorted(<span class="kw">struct</span> LinkNode *HeadOfListNode,
   <span class="kw">struct</span> LinkNode *NodeToInsert)
{
   <span class="kw">struct</span> LinkNode *NodePtr = HeadOfListNode;
   <span class="dt">int</span> SearchValue = NodeToInsert-&gt;Value;
   <span class="kw">while</span> (NodePtr-&gt;NextNode-&gt;Value &lt; SearchValue)
      NodePtr = NodePtr-&gt;NextNode;
   NodeToInsert-&gt;NextNode = NodePtr-&gt;NextNode;
   NodePtr-&gt;NextNode = NodeToInsert;
   <span class="kw">return</span>(NodePtr);
}</code></pre>
<p><strong>LISTING 15.7 L15-7.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; C near-callable assembly function for inserting a new node in a</span>
<span class="co">; linked list sorted by ascending order of the Value field. The list</span>
<span class="co">; is circular; that is, it has a dummy node as both the head and the</span>
<span class="co">; tail of the list. The dummy node is a sentinel, containing the</span>
<span class="co">; largest possible Value field setting. Tested with TASM.</span>
MAX_TEXT_LENGTH <span class="dt">equ</span> <span class="dv">100</span>         <span class="co">;longest allowed Text field</span>
SENTINEL <span class="dt">equ</span>  <span class="dv">32767</span>             <span class="co">;largest possible Value field</span>
LinkNode <span class="kw">struc</span>
NextNode <span class="dt">dw</span>     ?
Value    <span class="dt">dw</span>     ?
Text     <span class="dt">db</span>     MAX_TEXT_LENGTH<span class="dv">+1</span> dup(?)
<span class="co">;*** Any number of additional data fields may by present ***</span>
LinkNode ends

        .model  small
        .code

<span class="co">; Inserts the specified node into a ascending-value-sorted linked</span>
<span class="co">; list, such that value-sorting is maintained. Returns a pointer to</span>
<span class="co">; the node after which the new node is inserted.</span>
<span class="co">; C near-callable as:</span>
<span class="co">; struct LinkNode *InsertNodeSorted(struct LinkNode *HeadOfListNode,</span>
<span class="co">;      struct LinkNode *NodeToInsert)</span>
parms   <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup (?)       <span class="co">;pushed return address &amp; BP</span>
HeadOfListNode <span class="dt">dw</span>       ?       <span class="co">;pointer to head node of list</span>
NodeToInsert <span class="dt">dw</span>         ?       <span class="co">;pointer to node to insert</span>
parms   ends

        public  _InsertNodeSorted
_InsertNodeSorted proc  near
        <span class="kw">push</span>    <span class="kw">bp</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>                   <span class="co">;point to stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>                      <span class="co">;preserve register vars</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>].NodeToInsert    <span class="co">;point to node to insert</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">si</span>].Value           <span class="co">;search value</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>].HeadOfListNode  <span class="co">;point to linked list in</span>
                                        <span class="co">; which to insert</span>
<span class="fu">SearchLoop:</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">di</span>                   <span class="co">;advance to the next node</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bx</span>].NextNode        <span class="co">;point to following node</span>
        <span class="kw">cmp</span>     [<span class="kw">di</span>].Value,<span class="kw">ax</span>           <span class="co">;is the following node&#39;s</span>
                                        <span class="co">; value less than the value</span>
                                        <span class="co">; from the node to insert?</span>
        <span class="kw">jl</span>      SearchLoop              <span class="co">;yes, so continue searching</span>
                                        <span class="co">;no, so we have found our</span>
                                        <span class="co">; insert point</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bx</span>].NextNode        <span class="co">;link the new node between</span>
        <span class="kw">mov</span>     [<span class="kw">si</span>].NextNode,<span class="kw">ax</span>        <span class="co">; the current node and the</span>
        <span class="kw">mov</span>     [<span class="kw">bx</span>].NextNode,<span class="kw">si</span>        <span class="co">; following node</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">bx</span>                   <span class="co">;return pointer to node</span>
                                        <span class="co">; after which we inserted</span>
        <span class="kw">pop</span>     <span class="kw">di</span>                      <span class="co">;restore register vars</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>
        <span class="kw">ret</span>
_InsertNodeSorted endp
        end</code></pre>
<p><strong>LISTING 15.8 L15-8.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Sample linked list program. Tested with Borland C++. */</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;ctype.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &quot;llist.h&quot;</span>

<span class="dt">void</span> main()
{ <span class="dt">int</span> Done = <span class="dv">0</span>, Char, TempValue;
   <span class="kw">struct</span> LinkNode *TempPtr, *ListPtr, *TempPtr2;
   <span class="dt">char</span> TempBuffer[MAX_TEXT_LENGTH<span class="dv">+3</span>];

   <span class="kw">if</span> ((ListPtr = InitLinkedList()) == NULL) {
       printf(<span class="st">&quot;Out of memory</span><span class="ch">\n</span><span class="st">&quot;</span>);
       exit(<span class="dv">1</span>);
   }
   <span class="kw">while</span> (!Done) {
      printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">A=add; D=delete; F=find; L=list all; Q=quit</span><span class="ch">\n</span><span class="st">&gt;&quot;</span>);
      Char = toupper(getche());
      printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
      <span class="kw">switch</span> (Char) {
         <span class="kw">case</span> &#39;A&#39;:               <span class="co">/* add a node */</span>
            <span class="kw">if</span> ((TempPtr = malloc(<span class="kw">sizeof</span>(<span class="kw">struct</span> LinkNode))) == NULL)
            {
               printf(<span class="st">&quot;Out of memory</span><span class="ch">\n</span><span class="st">  );</span>
               exit(<span class="dv">1</span>);
             }
            printf(<span class="st">&quot;Node value: &quot;</span>);
            scanf(<span class="st">&quot;%d&quot;</span>, &amp;TempPtr-&gt;Value);
            <span class="kw">if</span> ((FindNodeBeforeValue(ListPtr,TempPtr-&gt;Value))!=NULL)
            {  printf(<span class="st">&quot;*** value already in list; try again ***</span><span class="ch">\n</span><span class="st">&quot;</span>);
               free(TempPtr);
            } <span class="kw">else</span> {printf(<span class="st">&quot;Node text: &quot;</span>);
               TempBuffer[<span class="dv">0</span>] = MAX_TEXT_LENGTH;
               cgets(TempBuffer);
               strcpy(TempPtr-&gt;Text, &amp;TempBuffer[<span class="dv">2</span>]);
               InsertNodeSorted(ListPtr, TempPtr);
               printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
            }
            <span class="kw">break</span>;
         <span class="kw">case</span> &#39;D&#39;:               <span class="co">/* delete a node */</span>
            printf(<span class="st">&quot;Value field of node to delete: &quot;</span>);
            scanf(<span class="st">&quot;%d&quot;</span>, &amp;TempValue);
            <span class="kw">if</span> ((TempPtr = FindNodeBeforeValue(ListPtr, TempValue))
                 != NULL) {
               TempPtr2 = TempPtr-&gt;NextNode; <span class="co">/* -&gt; node to delete */</span>
               DeleteNodeAfter(TempPtr);     <span class="co">/* delete it */</span>
               free(TempPtr2);               <span class="co">/* free its memory */</span>
            } <span class="kw">else</span> {
               printf(<span class="st">&quot;*** no such value field in list ***</span><span class="ch">\n</span><span class="st">&quot;</span>)
            <span class="kw">break</span>;
         <span class="kw">case</span> &#39;F&#39;:               <span class="co">/* find a node */</span>
            printf(<span class="st">&quot;Value field of node to find: &quot;</span>);
            scanf(<span class="st">&quot;%d&quot;</span>, &amp;TempValue);
            <span class="kw">if</span> ((TempPtr = FindNodeBeforeValue(ListPtr, TempValue))
                  != NULL)
               printf(<span class="st">&quot;Value: %d</span><span class="ch">\n</span><span class="st">Text: %s</span><span class="ch">\n</span><span class="st">&quot;</span>,
                 TempPtr-&gt;NextNode-&gt;Value, TempPtr-&gt;NextNode-&gt;Text);
            <span class="kw">else</span>
               printf(<span class="st">&quot;*** no such value field in list ***</span><span class="ch">\n</span><span class="st">&quot;</span>);
            <span class="kw">break</span>;
         <span class="kw">case</span> &#39;L&#39;:               <span class="co">/* list all nodes */</span>
            TempPtr = ListPtr-&gt;NextNode;  <span class="co">/* point to first node */</span>
            <span class="kw">if</span> (TempPtr == ListPtr) {     <span class="co">/* empty if at sentinel */</span>
               printf(<span class="st">&quot;*** List is empty ***</span><span class="ch">\n</span><span class="st">&quot;</span>);
            } <span class="kw">else</span> {
               <span class="kw">do</span> {printf(<span class="st">&quot;Value: %d</span><span class="ch">\n</span><span class="st">  Text: %s</span><span class="ch">\n</span><span class="st">&quot;</span>, TempPtr-&gt;Value,
                        TempPtr-&gt;Text);
                  TempPtr = TempPtr-&gt;NextNode;
               } <span class="kw">while</span> (TempPtr != ListPtr);
            }
            <span class="kw">break</span>;
         <span class="kw">case</span> &#39;Q&#39;:
            Done = <span class="dv">1</span>;
            <span class="kw">break</span>;
         <span class="kw">default</span>:
            <span class="kw">break</span>;
      }
   }
}</code></pre>
</section>
<section id="hilo-in-24-bytes" class="level3">
<h3><a href="#hilo-in-24-bytes">Hi/Lo in 24 Bytes</a></h3>
<p>In one of my <em>PC TECHNIQUES</em> “Pushing the Envelope” columns, I passed along one of David Stafford’s fiendish programming puzzles: Write a C-callable function to find the greatest or smallest unsigned <code>int</code>. Not a big deal—except that David had <em>already</em> done it in 24 bytes, so the challenge was to do it in 24 bytes or less.</p>
<p>Such routines soon began coming at me from all angles. However (and I hate to say this because some of my correspondents were <em>very</em> pleased with the thought that they had bested David), no one has yet met the challenge—because most of you folks missed a key point. When David said, “Write a function to find the greatest or smallest unsigned <code>int</code> in 24 bytes or less,” he meant, “Write the <code>hi</code> and the <code>lo</code> functions in 24 bytes or less—<em>combined</em>.”</p>
<p>Oh.</p>
<p>Yes, a 24-byte hi/lo function is possible, anatomically improbable as it might seem. Which I guess goes to show that when one of David’s puzzles seems less than impossible, odds are you’re missing something. Listing 15.9 is David’s 24-byte solution, from which a lot may be learned if one reads closely enough.</p>
<p><strong>LISTING 15.9 L15-9.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Find the greatest or smallest unsigned int.</span>
<span class="co">; C callable (small model); 24 bytes.</span>
<span class="co">; By David Stafford.</span>
<span class="co">; unsigned hi( int num, unsigned a[] );</span>
<span class="co">; unsigned lo( int num, unsigned a[] );</span>

                public _hi, _lo

<span class="fu">_hi:</span>            <span class="dt">db</span><span class="bn">      0b9h            </span><span class="co">;mov cx,immediate</span>
<span class="fu">_lo:</span>            <span class="kw">xor</span>     <span class="kw">cx</span>,<span class="kw">cx</span>
                <span class="kw">pop</span>     <span class="kw">ax</span>              <span class="co">;get return address</span>
                <span class="kw">pop</span>     <span class="kw">dx</span>              <span class="co">;get count</span>
                <span class="kw">pop</span>     <span class="kw">bx</span>              <span class="co">;get pointer</span>
                <span class="kw">push</span>    <span class="kw">bx</span>              <span class="co">;restore pointer</span>
                <span class="kw">push</span>    <span class="kw">dx</span>              <span class="co">;restore count</span>
                <span class="kw">push</span>    <span class="kw">ax</span>              <span class="co">;restore return address</span>
<span class="fu">save:</span>           <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bx</span>]
<span class="fu">top:</span>            <span class="kw">cmp</span>     <span class="kw">ax</span>,[<span class="kw">bx</span>]
                <span class="kw">jcxz</span>    around
                <span class="kw">cmc</span>
<span class="fu">around:</span>         <span class="kw">ja</span>      save
                <span class="kw">inc</span>     <span class="kw">bx</span>
                <span class="kw">inc</span>     <span class="kw">bx</span>
                <span class="kw">dec</span>     <span class="kw">dx</span>
                <span class="kw">jnz</span>     top

                <span class="kw">ret</span></code></pre>
<p>Before I end this chapter, let me say that I get a lot of feedback from my readers, and it’s much appreciated. Keep those cards, letters, and email messages coming. And if any of you know Jeannie Schweigert, have her drop me a line and let me know how she’s doing these days….</p>
</section>
</section>
<section id="chapter-16-there-aint-no-such-thing-as-the-fastest-code" class="level2">
<h2><a href="#chapter-16-there-aint-no-such-thing-as-the-fastest-code">Chapter 16 – There Ain’t No Such Thing as the Fastest Code</a></h2>
<section id="lessons-learned-in-the-pursuit-of-the-ultimate-word-counter" class="level3">
<h3><a href="#lessons-learned-in-the-pursuit-of-the-ultimate-word-counter">Lessons Learned in the Pursuit of the Ultimate Word Counter</a></h3>
<p>I remember reading an overview of C++ development tools for Windows in a past issue of <em>PC Week</em>. In the lower left corner was the familiar box listing the 10 leading concerns of corporate buyers when it comes to C++. Boiled down, the list looked like this, in order of descending importance to buyers:</p>
<ol type="1">
<li><p>Debugging</p></li>
<li><p>Documentation</p></li>
<li><p>Windows development tools</p></li>
<li><p>High-level Windows support</p></li>
<li><p>Class library</p></li>
<li><p>Development cycle efficiency</p></li>
<li><p>Object-oriented development aids</p></li>
<li><p>Programming management aids</p></li>
<li><p>Online help</p></li>
<li><p> Windows development cycle automation</p></li>
</ol>
<p>Is something missing here? You bet your maximum <em>gluteus</em> something’s missing—nowhere on that list is there so much as one word about how fast the compiled code runs! I’m not saying that performance is everything, but optimization isn’t even down there at number 10, below online help! Ye gods and little fishes! We are talking here about people who would take a bus from LA to New York instead of a plane because it had a cleaner bathroom; who would choose a painting from a Holiday Inn over a Matisse because it had a fancier frame; who would buy a Yugo instead of—well, hell, anything—because it had a nice owner’s manual and particularly attractive keys. We are talking about people who are focusing on means, and have forgotten about ends. We are talking about people with no programming souls.</p>
</section>
<section id="counting-words-in-a-hurry" class="level3">
<h3><a href="#counting-words-in-a-hurry">Counting Words in a Hurry</a></h3>
<p>What are we to make of this? At the very least, we can safely guess that very few corporate buyers ever enter optimization contests. Most of my readers do, however; in fact, far more than I thought ever would, but that gladdens me to no end. I issued my first optimization challenge in a “Pushing the Envelope” column in <em>PC TECHNIQUES</em> back in 1991, and was deluged by respondents who, one might also gather, do not live by <em>PC Week</em>.</p>
<p>That initial challenge was sparked by a column David Gerrold wrote (also in <em>PC TECHNIQUES</em> ) concerning the matter of counting the number of words in a document; David turned up some pretty interesting optimization issues along the way. David did all his coding in Pascal, pointing out that while an assembly language version would probably be faster, his Pascal utility worked properly and was fast enough for him.</p>
<p>It wasn’t, however, fast enough for me. The logical starting place for speeding up word counting would be David’s original Pascal code, but I’m much more comfortable with C, so Listing 16.1 is a loose approximation of David’s word count program, translated to C. I left out a few details, such as handling comment blocks, partly because I don’t use such blocks myself, and partly so we can focus on optimizing the core word-counting code. As Table 16.1 indicates, Listing 16.1 counts the words in a 104,448-word file in 4.6 seconds. The file was stored on a RAM disk, and Listing 16.1 was compiled with Borland C++ with all optimization enabled. A RAM disk was used partly because it returns consistent times—no seek times, rotational latency, or cache to muddy the waters—and partly to highlight word-counting speed rather than disk access speed.</p>
<table>
<caption>Table 16.1 Word count timings.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Listing</th>
<th style="text-align: left;">Time to Count Words</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">16.1 (C)</td>
<td style="text-align: left;">4.6 seconds</td>
</tr>
<tr class="even">
<td style="text-align: left;">16.2 &amp; 16.3 (C+ASM)</td>
<td style="text-align: left;">2.4 seconds</td>
</tr>
<tr class="odd">
<td style="text-align: left;">16.2 &amp; 16.4 (C+ASM w/lookup)</td>
<td style="text-align: left;">1.6 seconds</td>
</tr>
</tbody>
</table>
<p>These are the times taken to search a file containing 104,448 words, timed from a RAM disk on a 20 MHz 386.</p>
<p><strong>LISTING 16.1 L16-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"> <span class="co">/* Word-counting program. Tested with Borland C++ in C</span>
<span class="co">    compilation mode and the small model. */</span>
 
 <span class="ot">#include &lt;stdio.h&gt;</span>
 <span class="ot">#include &lt;fcntl.h&gt;</span>
 <span class="ot">#include &lt;sys\stat.h&gt;</span>
 <span class="ot">#include &lt;stdlib.h&gt;</span>
 <span class="ot">#include &lt;io.h&gt;</span>
 
 <span class="ot">#define  B UFFER_SIZE  0x8000   </span><span class="co">/* largest chunk of file worked </span>
<span class="co">                                  with at any one time */</span>
 <span class="dt">int</span> main(<span class="dt">int</span>, <span class="dt">char</span> **);
 
 <span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {
    <span class="dt">int</span> Handle;
    <span class="dt">unsigned</span> <span class="dt">int</span> BlockSize;
    <span class="dt">long</span> FileSize;
    <span class="dt">unsigned</span> <span class="dt">long</span> WordCount = <span class="dv">0</span>;
    <span class="dt">char</span> *Buffer, CharFlag = <span class="dv">0</span>, PredCharFlag, *BufferPtr, Ch;
 
    <span class="kw">if</span> (argc != <span class="dv">2</span>) {
       printf(<span class="st">&quot;usage: wc &lt;filename&gt;</span><span class="ch">\n</span><span class="st">&quot;</span>);
       exit(<span class="dv">1</span>);
    }
 
    <span class="kw">if</span> ((Buffer = malloc(BUFFER_SIZE)) == NULL) {
       printf(<span class="st">&quot;Can&#39;t allocate adequate memory</span><span class="ch">\n</span><span class="st">&quot;</span>);
       exit(<span class="dv">1</span>);
    }
 
    <span class="kw">if</span> ((Handle = open(argv[<span class="dv">1</span>], O_RDONLY | O_BINARY)) == -<span class="dv">1</span>) {
       printf(<span class="st">&quot;Can&#39;t open file %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
       exit(<span class="dv">1</span>);
    }
 
    <span class="kw">if</span> ((FileSize = filelength(Handle)) == -<span class="dv">1</span>) {
       printf(<span class="st">&quot;Error sizing file %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
       exit(<span class="dv">1</span>);
    }
 
    <span class="co">/* Process the file in chunks */</span>
    <span class="kw">while</span> (FileSize &gt; <span class="dv">0</span>) {
       <span class="co">/* Get the next chunk */</span>
       FileSize -= (BlockSize = min(FileSize, BUFFER_SIZE));
       <span class="kw">if</span> (read(Handle, Buffer, BlockSize) == -<span class="dv">1</span>) {
          printf(<span class="st">&quot;Error reading file %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
          exit(<span class="dv">1</span>);
       }
       <span class="co">/* Count words in the chunk */</span>
       BufferPtr = Buffer;
       <span class="kw">do</span> {
          PredCharFlag = CharFlag;
          Ch = *BufferPtr++ &amp; <span class="bn">0x7F</span>; <span class="co">/* strip high bit, which some</span>
<span class="co">                                       word processors set as an</span>
<span class="co">                                       internal flag */</span>
          CharFlag = ((Ch &gt;= ‘a&#39;) &amp;&amp; (Ch &lt;= ‘z&#39;)) ||
                     ((Ch &gt;= ‘A&#39;) &amp;&amp; (Ch &lt;= ‘Z&#39;)) ||
                     ((Ch &gt;= ‘0&#39;) &amp;&amp; (Ch &lt;= ‘9&#39;)) ||
                     (Ch == ‘\&#39;&#39;);
          <span class="kw">if</span> ((!CharFlag) &amp;&amp; PredCharFlag) {
             WordCo u nt++; 
          }
       } <span class="kw">while</span> (—BlockSize);
    }
 
    <span class="co">/*  Catch the last word, if any */</span> 
    <span class="kw">if</span> (CharFlag) {
       WordCount++;
    }
    printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Total words in file: %lu</span><span class="ch">\n</span><span class="st">&quot;</span>, WordCount);
    <span class="kw">return</span>(<span class="dv">0</span>);
 }</code></pre>
<p>Listing 16.2 is Listing 16.1 modified to call a function that scans each block for words, and Listing 16.3 contains an assembly function that counts words. Used together, Listings 16.2 and 16.3 are just about twice as fast as Listing 16.1, a good return for a little assembly language. Listing 16.3 is a pretty straightforward translation from C to assembly; the new code makes good use of registers, but the key code—determining whether each byte is a character or not—is still done with the same multiple-sequential-tests approach used by the code that the C compiler generates.</p>
<p><strong>LISTING 16.2 L16-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Word-counting program incorporating assembly language. Tested</span>
<span class="co">   with Borland C++ in C compilation mode &amp; the small model. */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;fcntl.h&gt;</span>
<span class="ot">#include &lt;sys\stat.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;io.h&gt;</span>

<span class="ot">#define BUFFER_SIZE  0x8000   </span><span class="co">/* largest chunk of file worked</span>
<span class="co">                                 with at any one time */</span>
<span class="dt">int</span> main(<span class="dt">int</span>, <span class="dt">char</span> **);
<span class="dt">void</span> ScanBuffer(<span class="dt">char</span> *, <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">char</span> *, <span class="dt">unsigned</span> <span class="dt">long</span> *);

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {
   <span class="dt">int</span> Handle;
   <span class="dt">unsigned</span> <span class="dt">int</span> BlockSize;
   <span class="dt">long</span> FileSize;
   <span class="dt">unsigned</span> <span class="dt">long</span> WordCount = <span class="dv">0</span>;
   <span class="dt">char</span> *Buffer, CharFlag = <span class="dv">0</span>;

   <span class="kw">if</span> (argc != <span class="dv">2</span>) {
      printf(<span class="st">&quot;usage: wc &lt;filename&gt;</span><span class="ch">\n</span><span class="st">&quot;</span>);
      exit(<span class="dv">1</span>);
   }

   <span class="kw">if</span> ((Buffer = malloc(BUFFER_SIZE)) == NULL) {
      printf(<span class="st">&quot;Can&#39;t allocate adequate memory</span><span class="ch">\n</span><span class="st">&quot;</span>);
      exit(<span class="dv">1</span>);
   }

   <span class="kw">if</span> ((Handle = open(argv[<span class="dv">1</span>], O_RDONLY | O_BINARY)) == -<span class="dv">1</span>) {
      printf(<span class="st">&quot;Can&#39;t open file %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
      exit(<span class="dv">1</span>);
   }

   <span class="kw">if</span> ((FileSize = filelength(Handle)) == -<span class="dv">1</span>) {
      printf(<span class="st">&quot;Error sizing file %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
      exit(<span class="dv">1</span>);
   }

   CharFlag = <span class="dv">0</span>;
   <span class="kw">while</span> (FileSize &gt; <span class="dv">0</span>) {
      FileSize -= (BlockSize = min(FileSize, BUFFER_SIZE));
      <span class="kw">if</span> (read(Handle, Buffer, BlockSize) == -<span class="dv">1</span>) {
         printf(<span class="st">&quot;Error reading file %s</span><span class="ch">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);
         exit(<span class="dv">1</span>);
      }
      ScanBuffer(Buffer, BlockSize, &amp;CharFlag, &amp;WordCount);
   }

   <span class="co">/* Catch the last word, if any */</span>
   <span class="kw">if</span> (CharFlag) {
      WordCount++;
   }
   printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Total words in file: %lu</span><span class="ch">\n</span><span class="st">&quot;</span>, WordCount);
   <span class="kw">return</span>(<span class="dv">0</span>);
}</code></pre>
<p><strong>LISTING 16.3 L16-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Assembly subroutine for Listing 16.2. Scans through Buffer, of</span>
<span class="co">; length BufferLength, counting words and updating WordCount as</span>
<span class="co">; appropriate. BufferLength must be &gt; 0. *CharFlag and *WordCount</span>
<span class="co">; should equal 0 on the first call. Tested with TASM.</span>
<span class="co">; C near-callable as:</span>
<span class="co">; void ScanBuffer(char *Buffer, unsigned int BufferLength,</span>
<span class="co">; char *CharFlag, unsigned long *WordCount);</span>

parms   <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup(?)        <span class="co">;pushed return address &amp; BP</span>
Buffer  <span class="dt">dw</span>      ?               <span class="co">;buffer to scan</span>
BufferLength <span class="dt">dw</span> ?               <span class="co">;length of buffer to scan</span>
CharFlag <span class="dt">dw</span>     ?               <span class="co">;pointer to flag for state of last</span>
                                <span class="co">; char processed on entry (0 on</span>
                                <span class="co">; initial call). Updated on exit</span>
WordCount <span class="dt">dw</span>    ?               <span class="co">;pointer to 32-bit count of words</span>
                                <span class="co">; found (0 on initial call)</span>
parms   ends

        .model  small
        .code
        public  _ScanBuffer
_ScanBuffer     proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>              <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>           <span class="co">;set up local stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>              <span class="co">;preserve caller&#39;s register vars</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+Buffer]  <span class="co">;point to buffer to scan</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+WordCount]
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bx</span>]         <span class="co">;get current 32-bit word count</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bx</span><span class="dv">+2</span>]
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+CharFlag]
        <span class="kw">mov</span>     <span class="kw">bl</span>,[<span class="kw">bx</span>]            <span class="co">;get current CharFlag</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+BufferLength]<span class="co">;get # of bytes to scan</span>
<span class="fu">ScanLoop:</span>
        <span class="kw">mov</span>     <span class="kw">bh</span>,<span class="kw">bl</span>           <span class="co">;PredCharFlag = CharFlag;</span>
        <span class="kw">lodsb</span>                   <span class="co">;Ch = *BufferPtr++ &amp; 0x7F;</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,7fh          </span><span class="co">;strip high bit for word processors</span>
                                <span class="co">; that set it as an internal flag</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,<span class="dv">1</span>            <span class="co">;assume this is a char; CharFlag = 1;</span>
        <span class="kw">cmp</span>     <span class="kw">al</span>,‘a<span class="st">&#39;          ;it is a char if between a and z</span>
        <span class="kw">jb</span>      CheckAZ
        <span class="kw">cmp</span>     <span class="kw">al</span>,‘z<span class="st">&#39;</span>
        <span class="kw">jna</span>     IsAChar
<span class="fu">CheckAZ:</span>
        <span class="kw">cmp</span>     <span class="kw">al</span>,‘A<span class="st">&#39;          ;it is a char if between A and Z</span>
        <span class="kw">jb</span>      Check09
        <span class="kw">cmp</span>     <span class="kw">al</span>,‘Z<span class="st">&#39;</span>
        <span class="kw">jna</span>     IsAChar
<span class="fu">Check09:</span>
        <span class="kw">cmp</span>     <span class="kw">al</span>,‘0<span class="st">&#39;          ;it is a char if between 0 and 9</span>
        <span class="kw">jb</span>      CheckApostrophe
        <span class="kw">cmp</span>     <span class="kw">al</span>,‘9<span class="st">&#39;</span>
        <span class="kw">jna</span>     IsAChar
<span class="fu">CheckApostrophe:</span>
        <span class="kw">cmp</span>      <span class="kw">al</span><span class="bn">,27h           </span><span class="co">;it is a char if an apostrophe </span>
        <span class="kw">jz</span>      IsAChar
        <span class="kw">sub</span>     <span class="kw">bl</span>,<span class="kw">bl</span>           <span class="co">;not a char; CharFlag = 0;</span>
        <span class="kw">and</span>     <span class="kw">bh</span>,<span class="kw">bh</span>
        <span class="kw">jz</span>      ScanLoopBottom  <span class="co">;if ((!CharFlag) &amp;&amp; PredCharFlag) {</span>
        <span class="kw">add</span>     <span class="kw">cx</span>,<span class="dv">1</span>            <span class="co">;    (WordCount)++;</span>
        <span class="kw">adc</span>     <span class="kw">dx</span>,<span class="dv">0</span>            <span class="co">;}</span>
<span class="fu">IsAChar:</span>
<span class="fu">ScanLoopBottom:</span>
        <span class="kw">dec</span>     <span class="kw">di</span>              <span class="co">;} while (—BufferLength);</span>
        <span class="kw">jnz</span>     ScanLoop

        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+CharFlag]
        <span class="kw">mov</span>     [<span class="kw">si</span>],<span class="kw">bl</span>         <span class="co">;set new CharFlag</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+WordCount]
        <span class="kw">mov</span>     [<span class="kw">bx</span>],<span class="kw">cx</span>         <span class="co">;set new word count</span>
        <span class="kw">mov</span>     [<span class="kw">bx</span><span class="dv">+2</span>],<span class="kw">dx</span>

        <span class="kw">pop</span>     <span class="kw">di</span>              <span class="co">;restore caller&#39;s register vars</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>              <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_ScanBuffer     endp
        end</code></pre>
<section id="which-way-to-go-from-here" class="level4">
<h4><a href="#which-way-to-go-from-here">Which Way to Go from Here?</a></h4>
<p>We could rearrange the tests in light of the nature of the data being scanned; for example, we could perform the tests more efficiently by taking advantage of the knowledge that if a byte is less than ‘0,’ it’s either an apostrophe or not a character at all. However, that sort of fine-tuning is typically good for speedups of only 10 to 20 percent, and I’ve intentionally refrained from implementing this in Listing 16.3 to avoid pointing you down the wrong path; what we need is a different tack altogether. Ponder this. What we <em>really</em> want to know is nothing more than whether a byte is a character, not what sort of character it is. For each byte value, we want a yes/no status, and nothing else—and that description practically begs for a lookup table. Listing 16.4 uses a lookup table approach to boost performance another 50 percent, to three times the performance of the original C code. On a 20 MHz 386, this represents a change from 4.6 to 1.6 seconds, which could be significant—who likes to wait? On an 8088, the improvement in word-counting a large file could easily be 10 or 20 seconds, which is <em>definitely</em> significant.</p>
<p><strong>LISTING 16.4 L16-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Assembly subroutine for Listing 16.2. Scans through Buffer, of</span>
<span class="co">; length BufferLength, counting words and updating WordCount as</span>
<span class="co">; appropriate, using a lookup table-based approach. BufferLength</span>
<span class="co">; must be &gt; 0. *CharFlag and *WordCount should equal 0 on the</span>
<span class="co">; first call. Tested with TASM.</span>
<span class="co">; C near-callable as:</span>
<span class="co">; void ScanBuffer(char *Buffer, unsigned int BufferLength,</span>
<span class="co">; char *CharFlag, unsigned long *WordCount);</span>

parms   <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup(?)        <span class="co">;pushed return address &amp; BP</span>
Buffer  <span class="dt">dw</span>      ?               <span class="co">;buffer to scan</span>
BufferLength <span class="dt">dw</span> ?               <span class="co">;length of buffer to scan</span>
CharFlag <span class="dt">dw</span>     ?               <span class="co">;pointer to flag for state of last</span>
                                <span class="co">;char processed on entry (0 on</span>
                                <span class="co">;initial call). Updated on exit</span>
WordCount <span class="dt">dw</span>    ?               <span class="co">;pointer to 32-bit count of words</span>
                                <span class="co">; found (0 on initial call)</span>
parms   ends

        .model  small
        .data
<span class="co">; Table of char/not statuses for byte values 0-255 (128-255 are</span>
<span class="co">; duplicates of 0-127 to effectively mask off bit 7, which some</span>
<span class="co">; word processors set as an internal flag).</span>
CharStatusTable label   <span class="dt">byte</span>
        REPT    <span class="dv">2</span>
        <span class="dt">db</span>      <span class="dv">39</span> dup(<span class="dv">0</span>)
        <span class="dt">db</span>      <span class="dv">1</span>               <span class="co">;apostrophe</span>
        <span class="dt">db</span>      <span class="dv">8</span> dup(<span class="dv">0</span>)
        <span class="dt">db</span>      <span class="dv">10</span> dup(<span class="dv">1</span>)       <span class="co">;0-9</span>
        <span class="dt">db</span>      <span class="dv">7</span> dup(<span class="dv">0</span>)
        <span class="dt">db</span>      <span class="dv">26</span> dup(<span class="dv">1</span>)       <span class="co">;A-Z</span>
        <span class="dt">db</span>      <span class="dv">6</span> dup(<span class="dv">0</span>)
        <span class="dt">db</span>      <span class="dv">26</span> dup(<span class="dv">1</span>)       <span class="co">;a-z</span>
        <span class="dt">db</span>      <span class="dv">5</span> dup(<span class="dv">0</span>)
        ENDM

        .code
        public  _ScanBuffer
_ScanBuffer     proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>              <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>           <span class="co">;set up local stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>              <span class="co">;preserve caller&#39;s register vars</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+Buffer]  <span class="co">;point to buffer to scan</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+WordCount]
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bx</span>]         <span class="co">;get current 32-bit word count</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bx</span><span class="dv">+2</span>]
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+CharFlag]
        <span class="kw">mov</span>     <span class="kw">al</span>,[<span class="kw">bx</span>]         <span class="co">;get current CharFlag</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+BufferLength] <span class="co">;get # of bytes to scan</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,offset CharStatusTable
<span class="fu">ScanLoop:</span>
        <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">al</span>           <span class="co">;ZF=0 if last byte was a char,</span>
                                <span class="co">; ZF=1 if not</span>
        <span class="kw">lodsb</span>                   <span class="co">;get the next byte</span>
                                <span class="co">;***doesn&#39;t change flags***</span>
        <span class="kw">xlat</span>                    <span class="co">;look up its char/not status</span>
                                <span class="co">;***doesn&#39;t change flags***</span>
        <span class="kw">jz</span>      ScanLoopBottom  <span class="co">;don&#39;t count a word if last byte was</span>
                                <span class="co">; not a character</span>
        <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">al</span>           <span class="co">;last byte was a character; is the</span>
                                <span class="co">; current byte a character?</span>
        <span class="kw">jz</span>      CountWord       <span class="co">;no, so count a word</span>
<span class="fu">ScanLoopBottom:</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>              <span class="co">;count down buffer length</span>
        <span class="kw">jnz</span>     ScanLoop
<span class="fu">Done:</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+CharFlag]
        <span class="kw">mov</span>     [<span class="kw">si</span>],<span class="kw">al</span>         <span class="co">;set new CharFlag</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+WordCount]
        <span class="kw">mov</span>     [<span class="kw">bx</span>],<span class="kw">di</span>         <span class="co">;set new word count</span>
        <span class="kw">mov</span>     [<span class="kw">bx</span><span class="dv">+2</span>],<span class="kw">dx</span>

        <span class="kw">pop</span>     <span class="kw">di</span>              <span class="co">;restore caller&#39;s register vars</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>              <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>

        <span class="kw">align</span>   <span class="dv">2</span>
<span class="fu">CountWord:</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="dv">1</span>            <span class="co">;increment the word count</span>
        <span class="kw">adc</span>     <span class="kw">dx</span>,<span class="dv">0</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>              <span class="co">;count down buffer length</span>
        <span class="kw">jnz</span>     ScanLoop
        <span class="kw">jmp</span>     Done
_ScanBuffer     endp
        end</code></pre>
<p>Listing 16.4 features several interesting tricks. First, it uses <code>LODSB</code> and <code>XLAT</code> in succession, a very neat way to get a pointed-to byte, advance the pointer, and look up the value indexed by the byte in a table, all with just two instruction bytes. (Interestingly, Listing 16.4 would probably run quite a bit better still on an 8088, where <code>LODSB</code> and <code>XLAT</code> have a greater advantage over conventional instructions. On the 486 and Pentium, however, <code>LODSB</code> and <code>XLAT</code> lose much of their appeal, and should be replaced with <code>MOV</code> instructions.) Better yet, <code>LODSB</code> and <code>XLAT</code> don’t alter the flags, so the Zero flag status set before <code>LODSB</code> is still around to be tested after <code>XLAT</code> .</p>
<p>Finally, if you look closely, you will see that Listing 16.4 jumps out of the loop to increment the word count in the case where a word is actually found, with a duplicate of the loop-bottom code placed after the code that increments the word count, to avoid an extra branch back into the loop; this replaces the more intuitive approach of jumping around the incrementing code to the loop bottom when a word isn’t found. Although this incurs a branch every time a word is found, a word is typically found only once every 5 or 6 bytes; on average, then, a branch is saved about two-thirds of the time. This is an excellent example of how understanding the nature of the data you’re processing allows you to optimize in ways the compiler can’t. <em>Know your data!</em></p>
<p>So, gosh, Listing 16.4 is the best word-counting code in the universe, right? Not hardly. If there’s one thing my years of toil in this vale of silicon have taught me, it’s that there’s never a lack of potential for further optimization. <em>Never!</em> Off the top of my head, I can think of at least three ways to speed up Listing 16.4; and, since Turbo Profiler reports that even in Listing 16.4, 88 percent of the time is spent scanning the buffer (as opposed to reading the file), there’s potential for those further optimizations to improve performance significantly. (However, it is true that when access is performed to a hard rather than RAM disk, disk access jumps to about half of overall execution time.) One possible optimization is unrolling the loop, although that is truly a last resort because it tends to make further changes extremely difficult.</p>
<blockquote>
<p><img src="images/i.jpg" /> Exhaust all other optimizations before unrolling loops.</p>
</blockquote>
</section>
</section>
<section id="challenges-and-hazards" class="level3">
<h3><a href="#challenges-and-hazards">Challenges and Hazards</a></h3>
<p>The challenge I put to the readers of <em>PC TECHNIQUES</em> was to write a faster module to replace Listing 16.4. The author of the code that counted the words in my secret test file fastest on my 20 MHz cached 386 would be the winner and receive Numerous Valuable Prizes.</p>
<p>No listings were to be longer than 200 lines. No complete programs were to be accepted; submissions had to be plug-compatible with Listing 16.4. (This was to encourage people not to waste time optimizing outside the inner loop.) Finally, the code had to produce the same results as Listing 16.4; I didn’t want to see functions that approximated the word count by dividing the number of characters by six instead of counting actual words!</p>
<p>So how did the entrants in this particular challenge stack up? More than one claimed a speed-up over my assembly word-counting code of more than three times. On top of the three-times speedup over the original C code that I had already realized, we’re almost up to an order of magnitude faster. You are, of course, entitled to your own opinion, but <em>I</em> consider an order of magnitude to be significant.</p>
<p>Truth to tell, I didn’t expect a three-times speedup; around two times was what I had in mind. Which just goes to show that any code can be made faster than you’d expect, if you think about it long enough and from many different perspectives. (The most potent word-counting technique seems to be a 64K lookup table that allows handling two bytes simultaneously. This is not the sort of technique one comes up with by brute-force optimization.) Thinking (or, worse yet, boasting) that your code is the fastest possible is rollescating on a tightrope in a hurricane; you’re due for a fall, if you catch my drift. Case in point: Terje Mathisen’s word-counting program.</p>
<section id="blinding-yourself-to-a-better-approach" class="level4">
<h4><a href="#blinding-yourself-to-a-better-approach">Blinding Yourself to a Better Approach</a></h4>
<p>Not so long ago, Terje Mathisen, who I introduced earlier in this book, wrote a very fast word-counting program, and posted it on Bix. When I say it was fast, I mean <em>fast;</em> this code was optimized like nobody’s business. We’re talking top-quality code here.</p>
<p>When the topic of optimizing came up in one of the Bix conferences, Terje’s program was mentioned, and he posted the following message: “I challenge BIXens (and especially <strong>mabrash!</strong>) to speed it up significantly. I would consider 5 percent a good result.” The clear implication was, “That code is as fast as it can possibly be.”</p>
<p>Naturally, it wasn’t; there ain’t no such thing as the fastest code (TANSTATFC? I agree, it doesn’t have the ring of TANSTAAFL). I pored over Terje’s 386 native-mode code, and found the critical inner loop, which was indeed as tight as one could imagine, consisting of just a few 386 native-mode instructions. However, one of the instructions was this:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">CMP</span>   <span class="kw">DH</span>,[<span class="kw">EBX</span>+<span class="kw">EAX</span>]</code></pre>
<p>Harmless enough, save for two things. First, EBX happened to be zero at this point (a leftover from an earlier version of the code, as it turned out), so it was superfluous as a memory-addressing component; this made it possible to use base-only addressing (<code>[EAX]</code>) rather than base+index addressing (<code>[EBX+EAX]</code>), which saves a cycle on the 386. Second: Changing the instruction to <code>CMP [EAX],DH</code> saved 2 cycles—just enough, by good fortune, to speed up the whole program by 5 percent.</p>
<blockquote>
<p><img src="images/i.jpg" /> <code>CMP reg,[mem]</code> takes 6 cycles on the 386, but <code>CMP [ mem ],reg</code> takes only 5 cycles; you should always perform<code>CMP</code> with the memory operand on the left on the 386.</p>
</blockquote>
<p>(Granted, <code>CMP [*mem*],*reg*</code> is 1 cycle slower than <code>CMP *reg*,[*mem*]</code> on the 286, and they’re both the same on the 8088; in this case, though, the code was specific to the 386. In case you’re curious, both forms take 2 cycles on the 486; quite a lot faster, eh?)</p>
</section>
<section id="watch-out-for-luggable-assumptions" class="level4">
<h4><a href="#watch-out-for-luggable-assumptions">Watch Out for Luggable Assumptions!</a></h4>
<p>The first lesson to be learned here is not to lug assumptions that may no longer be valid from the 8088/286 world into the wonderful new world of 386 native-mode programming. The second lesson is that after you’ve slaved over your code for a while, you’re in no shape to see its flaws, or to be able to get the new perspectives needed to speed it up. I’ll bet Terje looked at that <code>[EBX+EAX]</code> addressing a hundred times while trying to speed up his code, but he didn’t really see what it did; instead, he saw what it was supposed to do. Mental shortcuts like this are what enable us to deal with the complexities of assembly language without overloading after about 20 instructions, but they can be a major problem when looking over familiar code.</p>
<p>The third, and most interesting, lesson is that a far more fruitful optimization came of all this, one that nicely illustrates that cycle counting is not the key to happiness, riches, and wondrous performance. After getting my 5 percent speedup, I mentioned to Terje the possibility of using a 64K lookup table. (This predated the arrival of entries for the optimization contest.) He said that he had considered it, but it didn’t seem to him to be worthwhile. He couldn’t shake the thought, though, and started to poke around, and one day, <em>voila,</em> he posted a new version of his word count program, WC50, that was <em>much</em> faster than the old version. I don’t have exact numbers, but Terje’s preliminary estimate was 80 percent faster, and word counting—<em>including</em> disk cache access time—proceeds at more than 3 MB per second on a 33 MHz 486. Even allowing for the speed of the 486, those are very impressive numbers indeed.</p>
<p>The point I want to make, though, is that the biggest optimization barrier that Terje faced was that he <em>thought</em> he had the fastest code possible. Once he opened up the possibility that there were faster approaches, and looked beyond the specific approach that he had so carefully optimized, he was able to come up with code that was a <em>lot</em> faster. Consider the incongruity of Terje’s willingness to consider a 5 percent speedup significant in light of his later near-doubling of performance.</p>
<blockquote>
<p><img src="images/i.jpg" /> Don’t get stuck in the rut of instruction-by-instruction optimization. It’s useful in key loops, but very often, a change in approach will work far greater wonders than any amount of cycle counting can.</p>
</blockquote>
<p>By the way, Terje’s WC50 program is a full-fledged counting program; it counts characters, words, and lines, can handle multiple files, and lets you specify the characters that separate words, should you so desire. Source code is provided as part of the archive WC50 comes in. All in all, it’s a nice piece of work, and you might want to take a look at it if you’re interested in really fast assembly code. I wouldn’t call it the <em>fastest</em> word-counting code, though, because I would of course never be so foolish as to call <em>anything</em> the fastest.</p>
</section>
</section>
<section id="the-astonishment-of-right-brain-optimization" class="level3">
<h3><a href="#the-astonishment-of-right-brain-optimization">The Astonishment of Right-Brain Optimization</a></h3>
<p>As it happened, the challenge I issued to my <em>PC TECHNIQUES</em> readers was a smashing success, with dozens of good entries. I certainly enjoyed it, even though I did have to look at a <em>lot</em> of tricky assembly code that I didn’t write—hard work under the best of circumstances. It was worth the trouble, though. The winning entry was an astonishing example of what assembly language can do in the right hands; on my 386, it was <em>four times</em> faster at word counting than the nice, tight assembly code I provided as a starting point—and about 13 times faster than the original C implementation. Attention, high-level language chauvinists: Is the speedup getting significant yet? Okay, maybe word counting isn’t the most critical application, but how would you like to have that kind of improvement in your compression software, or in your real-time games—or in Windows graphics?</p>
<p>The winner was David Stafford, who at the time was working for Borland International; his entry is shown in Listing 16.5. Dave Methvin, whom some of you may recall as a tech editor of the late, lamented <em>PC Tech Journal,</em> was a close second, and Mick Brown, about whom I know nothing more than that he is obviously an extremely good assembly language programmer, was a close third, as shown in Table 16.2, which precedes Listing 16.5. Those three were out ahead of the pack; the fourth-place entry, good as it was (twice as fast as my original code), was twice as slow as David’s winning entry, so you can see that David, Dave, and Mick attained a rarefied level of optimization indeed.</p>
<p>Table 16.2 has two times for each entry listed: the first value is the overall counting time, including time spent in the main program, disk I/O, and everything else; the second value is the time actually spent counting words, the time spent in <code>ScanBuffer</code> . The first value is the time perceived by the user, but the second value best reflects the quality of the optimization in each entry, since the rest of the overall execution time is fixed.</p>
<p><strong>Word-Counting Time</strong></p>
<table>
<caption>Table 16.2 The top four word-counting entries.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Overall time</th>
<th style="text-align: left;">(ScanBuffer only)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">David Stafford Listing 16.5</td>
<td style="text-align: left;">0.61 seconds</td>
<td style="text-align: left;">0.33 seconds</td>
</tr>
<tr class="even">
<td style="text-align: left;">Dave Methvin</td>
<td style="text-align: left;">0.66</td>
<td style="text-align: left;">0.39</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Mick Brown</td>
<td style="text-align: left;">0.70</td>
<td style="text-align: left;">0.41</td>
</tr>
<tr class="even">
<td style="text-align: left;">Wendell Neubert</td>
<td style="text-align: left;">0.92</td>
<td style="text-align: left;">0.65</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>For Comparison:</strong></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Michael Abrash assembly code Listing 16.1</td>
<td style="text-align: left;">1.73</td>
<td style="text-align: left;">1.44</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Michael Abrash C code Listing 16.4</td>
<td style="text-align: left;">4.70</td>
<td style="text-align: left;">4.43</td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> All times measured on a 20 MHz cached 386 DX.</p>
<p><strong>LISTING 16.5 QSCAN3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"> <span class="co">;  QSCAN3.ASM</span>
 <span class="co">;  David Stafford</span>
 
 
         COMMENT <span class="dv">$</span>
  
How it works
——————
The idea is to go through the buffer fetching each letter-pair (words
rather than bytes).  The carry flag indicates whether we are
currently <span class="kw">in</span> a (text) <span class="dt">word</span> <span class="kw">or</span> <span class="kw">not</span>.  The letter-pair fetched from the
buffer is converted to a <span class="dv">16</span>-bit address by shifting it left one bit
(losing the high bit of the second character) <span class="kw">and</span> putting the carry
flag <span class="kw">in</span> the low bit.  The high bit of the count register is set to
<span class="dv">1</span>.  Then the count register is added to the <span class="dt">byte</span> found <span class="kw">at</span> the given
address <span class="kw">in</span> a large (64K, naturally) table.  The <span class="dt">byte</span> <span class="kw">at</span> the given
address will contain a <span class="dv">1</span> <span class="kw">in</span> the high bit if the last character of the
letter-pair is a <span class="dt">word</span>-letter (alphanumeric <span class="kw">or</span> apostrophe).  This  will
set the carry flag since the high bit of the count register is also a
<span class="dv">1</span>. The low bit of the <span class="dt">byte</span> found <span class="kw">at</span> the given address will be one if
the second character of the previous letter-pair was a <span class="dt">word</span>-letter
<span class="kw">and</span> the first character of this letter-pair is <span class="kw">not</span> a <span class="dt">word</span>-letter. It
will also be <span class="dv">1</span> if the first character of this letter-pair is a
<span class="dt">word</span>-letter but the second character is <span class="kw">not</span>.  This process is
repeated.  Finally, the carry flag is saved to indicate the final
<span class="kw">in</span>-a-<span class="dt">word</span>/<span class="kw">not</span>-<span class="kw">in</span>-a-<span class="dt">word</span> status.  The count register is masked to
remove the high bit <span class="kw">and</span> the count of words remains <span class="kw">in</span> the count
register.
 Sound complicated?  You<span class="st">&#39;re right!  But it&#39;</span>s fast!
  
The beauty of this method is that no jumps are required, the
operations are fast, it requires only one table <span class="kw">and</span> the process can
be repeated (unrolled) many <span class="dt">times</span>.  QSCAN3 can read <span class="dv">256</span> bytes without
jumping.
 
         COMMEND <span class="dv">$</span>
                 .model small
                 .code
  
 Test1           macro   x,y             <span class="co">;9 or 10 bytes</span>
 Addr&amp;x:         <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+y]       <span class="co">;3 or 4 bytes</span>
                 <span class="kw">adc</span>     <span class="kw">di</span>,<span class="kw">di</span>
                 <span class="kw">or</span>      <span class="kw">ax</span>,<span class="kw">si</span>
                 <span class="kw">add</span>     <span class="kw">al</span>,[<span class="kw">di</span>]
                 endm
  
 Test2           macro   x,y              <span class="co">;7 or 8 bytes</span>
 Addr&amp;x:         <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+y]        <span class="co">;3 or 4 bytes</span>
                 <span class="kw">adc</span>     <span class="kw">di</span>,<span class="kw">di</span>
                 <span class="kw">add</span>     <span class="kw">ah</span>,[<span class="kw">di</span>]
                 endm
  
 Scan            =       <span class="dv">128</span>           <span class="co">;scan 256 bytes at a time </span>
 Buffer          =       <span class="dv">4</span>             <span class="co">;parms</span>
 BufferLength    =       <span class="dv">6</span>
 CharFlag        =       <span class="dv">8</span>
 WordCount       =       <span class="dv">10</span>
  
                 public _ScanBuffer
 _ScanBuffer     proc near
                 <span class="kw">push</span>    <span class="kw">bp</span>
                 <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>
                 <span class="kw">push</span>    <span class="kw">si</span>
                 <span class="kw">push</span>    <span class="kw">di</span>
  
                 <span class="kw">xor</span>     <span class="kw">cx</span>,<span class="kw">cx</span>
                 <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+Buffer]       <span class="co">;si = text buffer</span>
                 <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+BufferLength] <span class="co">;dx = length in bytes</span>
                 <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>                 <span class="co">;dx = length in words</span>
                 <span class="kw">jnz</span>     NormalBuf
<span class="fu"> OneByteBuf:</span>
                 <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">seg</span> WordTable
                 <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
  
                 <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+CharFlag]
                 <span class="kw">mov</span>     <span class="kw">bh</span>,[<span class="kw">di</span>]             <span class="co">;bh = old CharFlag</span>
                 <span class="kw">mov</span>     <span class="kw">bl</span>,[<span class="kw">si</span>]             <span class="co">;bl = character</span>
                 <span class="kw">add</span>     <span class="kw">bh</span>,‘A<span class="st">&#39;-1            ;make bh into character</span>
                 <span class="kw">add</span>     <span class="kw">bx</span>,<span class="kw">bx</span>               <span class="co">;prepare to index</span>
                 <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">es</span>:[<span class="kw">bx</span>]
                 <span class="kw">cbw</span>                         <span class="co">;get hi bit in ah (then bh)</span>
                 <span class="kw">shr</span>     <span class="kw">al</span>,<span class="dv">1</span>                <span class="co">;get low bit</span>
                 <span class="kw">adc</span>     <span class="kw">cx</span>,<span class="kw">cx</span>               <span class="co">;cx = 0 or 1</span>
                 <span class="kw">xchg</span>    <span class="kw">ax</span>,<span class="kw">bx</span>
                 <span class="kw">jmp</span>     CleanUp
<span class="fu"> NormalBuf:</span>
                 <span class="kw">push</span>    <span class="kw">bp</span>                  <span class="co">;(1)</span>
                 <span class="kw">pushf</span>                       <span class="co">;(2)</span>
  
                 <span class="kw">cwd</span>                         <span class="co">;dx = 0</span>
                 <span class="kw">mov</span>     <span class="kw">cl</span>,Scan
                 <span class="kw">div</span>     <span class="kw">cx</span>
                 <span class="kw">or</span>      <span class="kw">dx</span>,<span class="kw">dx</span>               <span class="co">;remainder?</span>
                 <span class="kw">jz</span>      StartAtTheTop       <span class="co">;nope, do the whole banana </span>
                 <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">dx</span>
                 <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">cx</span>               <span class="co">;adjust buf pointer</span>
                 <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">cx</span>
                 <span class="kw">inc</span>     <span class="kw">ax</span>                  <span class="co">;adjust for partial read</span>
 
<span class="fu"> StartAtTheTop:</span>  <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">dx</span>               <span class="co">;get index for start...</span>
                 <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>
                 <span class="kw">mov</span>     <span class="kw">di</span>,LoopEntry[<span class="kw">bx</span>]    <span class="co">;...address in di</span>
                 <span class="kw">xchg</span>    <span class="kw">dx</span>,<span class="kw">ax</span>               <span class="co">;dx is the loop counter</span>
                 <span class="kw">xor</span>     <span class="kw">cx</span>,<span class="kw">cx</span>               <span class="co">;total word count</span>
                 <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+CharFlag]
                 <span class="kw">mov</span>     <span class="kw">bl</span>,[<span class="kw">bx</span>]             <span class="co">;bl = old CharFlag</span>
                 <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">seg</span> WordTable
                 <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">bp</span>
                 <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">si</span>               <span class="co">;scan buffer with bp</span>
                 <span class="kw">mov</span>     <span class="kw">si</span><span class="bn">,8080h            </span><span class="co">;hi bits</span>
                 <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">si</span>               <span class="co">;init local word counter</span>
                 <span class="kw">shr</span>     <span class="kw">bl</span>,<span class="dv">1</span>                <span class="co">;carry = old CharFlag</span>
                 <span class="kw">jmp</span>     <span class="kw">di</span>
  
                 <span class="kw">align</span>   <span class="dv">2</span>
<span class="fu"> Top:</span>            <span class="kw">add</span>     <span class="kw">bx</span>,<span class="kw">bx</span>               <span class="co">;restore carry</span>
 n               =       <span class="dv">0</span>
                 rept    Scan/<span class="dv">2</span>
                 Test1   <span class="ot">%n,%n*2</span>
                 Test2   <span class="ot">%n+1,%n*2+2</span>
 n               =       n<span class="dv">+2</span>
                 endm
<span class="fu"> EndCount:</span>
                 <span class="kw">sbb</span>     <span class="kw">bx</span>,<span class="kw">bx</span>             <span class="co">;save carry</span>
  if             Scan ge <span class="dv">128</span>               <span class="co">;because al+ah may equal 128!</span>
                 <span class="kw">or</span>      <span class="kw">ax</span>,<span class="kw">si</span>
                 <span class="kw">add</span>     <span class="kw">al</span>,<span class="kw">ah</span>
                 <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">0</span>
 else
                 <span class="kw">add</span>     <span class="kw">al</span>,<span class="kw">ah</span>
                 <span class="kw">and</span>     <span class="kw">ax</span><span class="bn">,7fh            </span><span class="co">;mask</span>
 endif
                 <span class="kw">add</span>     <span class="kw">cx</span>,<span class="kw">ax</span>             <span class="co">;update word count</span>
                 <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">si</span>
                 <span class="kw">add</span>     <span class="kw">bp</span>,Scan*<span class="dv">2</span>
                 <span class="kw">dec</span>     <span class="kw">dx</span>                <span class="co">;any left?</span>
                 <span class="kw">jng</span>     Quit
                 <span class="kw">jmp</span>     Top
  
<span class="fu"> Quit:</span>           <span class="kw">popf</span>                      <span class="co">;(2) even or odd buffer?</span>
                 <span class="kw">jnc</span>     ItsEven 
                 <span class="kw">clc</span>
                 Test1   Odd,-<span class="dv">1</span>
                 <span class="kw">sbb</span>     <span class="kw">bx</span>,<span class="kw">bx</span>             <span class="co">;save carry</span>
                 <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
                 <span class="kw">adc</span>     <span class="kw">cx</span>,<span class="dv">0</span>
<span class="fu"> ItsEven:</span>
                 <span class="kw">push</span>    <span class="kw">ss</span>                <span class="co">;restore ds</span>
                 <span class="kw">pop</span>     <span class="kw">ds</span>
                 <span class="kw">pop</span>     <span class="kw">bp</span>                <span class="co">;(1)</span>
<span class="fu"> CleanUp:</span>
                 <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+WordCount]
                 <span class="kw">add</span>     [<span class="kw">si</span>],<span class="kw">cx</span>
                 <span class="kw">adc</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span><span class="dv">+2</span>],<span class="dv">0</span>
                 <span class="kw">and</span>     <span class="kw">bh</span>,<span class="dv">1</span>              <span class="co">;save only the carry flag</span>
                 <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+CharFlag]
                 <span class="kw">mov</span>     [<span class="kw">si</span>],<span class="kw">bh</span>
                 <span class="kw">pop</span>     <span class="kw">di</span>
                 <span class="kw">pop</span>     <span class="kw">si</span>
                 <span class="kw">pop</span>     <span class="kw">bp</span>
                 <span class="kw">ret</span>
 _ScanBuffer     endp
  
                 .data
 Address         macro   X
                 <span class="dt">dw</span>      Addr&amp;X
                 endm
  
 LoopEntry       label <span class="dt">word</span>
 n               =       Scan
                 REPT Scan
                 Address <span class="ot">%n MOD Scan</span>
 n               =       n - <span class="dv">1</span>
                 ENDM
  
                 .fardata WordTable
 include         qscan3.<span class="kw">inc</span>                <span class="co">;built by MAKETAB</span>
                 end</code></pre>
</section>
<section id="levels-of-optimization" class="level3">
<h3><a href="#levels-of-optimization">Levels of Optimization</a></h3>
<p>Three levels of optimization were evident in the word-counting entries I received in response to my challenge. I’d briefly describe them as “fine-tuning,” “new perspective,” and “table-driven state machine.” The latter categories produce faster code, but, by the same token, they are harder to design, harder to implement, and more difficult to understand, so they’re suitable for only the most demanding applications. (Heck, I don’t even guarantee that David Stafford’s entry works perfectly, although, knowing him, it probably does; the more complex and cryptic the code, the greater the chance for obscure bugs.)</p>
<blockquote>
<p><img src="images/i.jpg" /> Remember, optimize only when needed, and stop when further optimization will not be noticed. Optimization that’s not perceptible to the user is like buying Telly Savalas a comb; it’s not going to do any harm, but it’s nonetheless a waste of time.</p>
</blockquote>
<section id="optimization-level-1-good-code" class="level4">
<h4><a href="#optimization-level-1-good-code">Optimization Level 1: Good Code</a></h4>
<p>The first level of optimization involves fine-tuning and clever use of the instruction set. The basic framework is still the same as my code (which in turn is basically the same as that of the original C code), but that framework is implemented more efficiently.</p>
<p>One obvious level 1 optimization is using a <code>word</code> rather than <code>dword</code> counter. <code>ScanBuffer</code> can never be called upon to handle more than 64K bytes at a time, so no more than 32K words can ever be found. Given that, it’s a logical step to use <code>INC</code> rather than <code>ADD/ADC</code> to keep count, adding the tally into the full 32-bit count only upon exiting the function. Another useful optimization is aligning loop tops and other branch destinations to <code>word</code> , or better yet <code>dword</code> , boundaries.</p>
<p>Eliminating branches was very popular, as it should be on x86 processors. Branches were eliminated in a remarkable variety of ways. Many of you unrolled the loop, a technique that does pay off nicely. A word of caution: Some of you unrolled the loop by simply stacking repetitions of the inner loop one after the other, with <code>DEC CX/JZ</code> appearing after each repetition to detect the end of the buffer. Part of the point of unrolling a loop is to reduce the number of times you have to check for the end of the buffer! The trick to this is to set CX to the number of repetitions of the <em>unrolled</em> loop and count down only once each time through the unrolled loop. In order to handle repetition counts that aren’t exact multiples of the unrolling factor, you must enter the loop by branching into the middle of it to perform whatever fraction of the number of unrolled repetitions is required to make the whole thing come out right. Listing 16.5 (QSCAN3.ASM) illustrates this technique.</p>
<p>Another effective optimization is the use of <code>LODSW</code> rather than <code>LODSB</code> , thereby processing two bytes per memory access. This has the effect of unrolling the loop one time, since with <code>LODSW</code> , looping is performed at most only once every two bytes.</p>
<p>Cutting down the branches used to loop is only part of the branching story. More often than not, my original code also branched in the process of checking whether it was time to count a word. There are many ways to reduce this sort of branching; in fact, it is quite possible to eliminate it entirely. The most straightforward way to reduce such branching is to employ two loops. One loop is used to look for the end of a word when the last byte was a non-separator, and one loop is used to look for the start of a word when the last byte was a separator. This way, it’s no longer necessary to maintain a flag to indicate the state of the last byte; that state is implied by whichever loop is currently executing. This considerably simplifies and streamlines the inner loop code.</p>
<p>Listing 16.6, contributed by Willem Clements, of Granada, Spain, illustrates a variety of level 1 optimizations: the two-loop approach, the use of a 16- rather than 32-bit counter, and the use of <code>LODSW</code> . Together, these optimizations made Willem’s code nearly twice as fast as mine in Listing 16.4. A few details could stand improvement; for example, <code>AND AX,AX</code> is a shorter way to test for zero than <code>CMP AX,0</code> , and <code>ALIGN 2</code> could be used. Nonetheless, this is good code, and it’s also fairly compact and reasonably easy to understand. In short, this is an excellent example of how an hour or so of hand-optimization might accomplish significantly improved performance at a reasonable cost in complexity and time. This level of optimization is adequate for most purposes (and, in truth, is beyond the abilities of most programmers).</p>
<p><strong>Listing 16.6 OPT2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">;</span>
<span class="co">;          Opt2         Final optimization word count</span>
<span class="co">;          Written by   Michael Abrash</span>
<span class="co">;          Modified by  Willem Clements</span>
<span class="co">;                       C/ Moncayo 5,  Laurel de la Reina</span>
<span class="co">;                       18140 La Zubia</span>
<span class="co">;                       Granada, Spain</span>
<span class="co">;                       Tel 34-58-890398</span>
<span class="co">;                       Fax 34-58-224102</span>
<span class="co">;</span>
parms          <span class="kw">struc</span>
               <span class="dt">dw</span>         <span class="dv">2</span> dup(?)
buffer         <span class="dt">dw</span>         ?
bufferlength   <span class="dt">dw</span>         ?
charflag       <span class="dt">dw</span>         ?
wordcount      <span class="dt">dw</span>         ?
parms          ends
               .model     small
               .data
charstatustable label <span class="dt">byte</span>
               rept       <span class="dv">2</span>
               <span class="dt">db</span>         <span class="dv">39</span> dup(<span class="dv">0</span>)
               <span class="dt">db</span>         <span class="dv">1</span>
               <span class="dt">db</span>         <span class="dv">8</span> dup(<span class="dv">0</span>)
               <span class="dt">db</span>         <span class="dv">10</span> dup(<span class="dv">1</span>)
               <span class="dt">db</span>         <span class="dv">7</span> dup(<span class="dv">0</span>)
               <span class="dt">db</span>         <span class="dv">26</span> dup(<span class="dv">1</span>)
               <span class="dt">db</span>         <span class="dv">6</span> dup(<span class="dv">0</span>)
               <span class="dt">db</span>         <span class="dv">26</span> dup(<span class="dv">1</span>)
               <span class="dt">db</span>         <span class="dv">5</span> dup(<span class="dv">0</span>)
               endm
               .code
               public     _ScanBuffer
_ScanBuffer    proc       near
               <span class="kw">push</span>       <span class="kw">bp</span>
               <span class="kw">mov</span>        <span class="kw">bp</span>,<span class="kw">sp</span>
               <span class="kw">push</span>       <span class="kw">si</span>
               <span class="kw">push</span>       <span class="kw">di</span>
               <span class="kw">mov</span>        <span class="kw">si</span>,[<span class="kw">bp</span>+buffer]
               <span class="kw">mov</span>        <span class="kw">bx</span>,[<span class="kw">bp</span>+charflag]
               <span class="kw">mov</span>        <span class="kw">al</span>,[<span class="kw">bx</span>]
               <span class="kw">mov</span>        <span class="kw">cx</span>,[<span class="kw">bp</span>+bufferlength]
               <span class="kw">mov</span>        <span class="kw">bx</span>,offset charstatustable
               <span class="kw">xor</span>        <span class="kw">di</span>,<span class="kw">di</span>      <span class="co">; set wordcount to zero</span>
               <span class="kw">shr</span>        <span class="kw">cx</span>,<span class="dv">1</span>       <span class="co">; change count to wordcount</span>
               <span class="kw">jc</span>         oddentry   <span class="co">; odd number of bytes to process</span>
               <span class="kw">cmp</span>        <span class="kw">al</span><span class="bn">,01h     </span><span class="co">; check if last one is char</span>
               <span class="kw">jne</span>        scanloop4  <span class="co">; if not so, search for char</span>
               <span class="kw">jmp</span>        scanloop1  <span class="co">; if so, search for zero</span>
<span class="fu">oddentry:</span>      <span class="kw">xchg</span>       <span class="kw">al</span>,<span class="kw">ah</span>      <span class="co">; last one in ah</span>
               <span class="kw">lodsb</span>                 <span class="co">; get first byte</span>
               <span class="kw">inc</span>        <span class="kw">cx</span>
               <span class="kw">cmp</span>        <span class="kw">ah</span><span class="bn">,01h     </span><span class="co">; check if last one was char</span>
               <span class="kw">jne</span>        scanloop5  <span class="co">; if not so, search for char</span>
               <span class="kw">jmp</span>        scanloop2  <span class="co">; if so, search for zero</span>
<span class="co">;</span>
<span class="co">;              locate the end of a word</span>
<span class="fu">scanloop1:</span>     <span class="kw">lodsw</span>                  <span class="co">; get two chars</span>
               <span class="kw">xlat</span>                   <span class="co">; translate first</span>
               <span class="kw">xchg</span>       <span class="kw">al</span>,<span class="kw">ah</span>       <span class="co">; first in ah</span>
<span class="fu">scanloop2:</span>     <span class="kw">xlat</span>                   <span class="co">; translate second</span>
               <span class="kw">dec</span>        <span class="kw">cx</span>          <span class="co">; count down</span>
               <span class="kw">jz</span>         done1       <span class="co">; no more bytes left</span>
               <span class="kw">cmp</span>        <span class="kw">ax</span><span class="bn">,0101h    </span><span class="co">; check if two chars</span>
               <span class="kw">je</span>         scanloop1   <span class="co">; go for next two bytes</span>
               <span class="kw">inc</span>        <span class="kw">di</span>          <span class="co">; increase wordcount</span>
               <span class="kw">cmp</span>        <span class="kw">al</span><span class="bn">,01h      </span><span class="co">; check if new word started</span>
               <span class="kw">je</span>         scanloop1   <span class="co">; locate end of word</span>
<span class="co">;</span>
<span class="co">;              locate the begin of a word</span>
<span class="fu">scanloop4:</span>     <span class="kw">lodsw</span>                     <span class="co">; get two chars</span>
               <span class="kw">xlat</span>                      <span class="co">; translate first</span>
               <span class="kw">xchg</span>       <span class="kw">al</span>,<span class="kw">ah</span>          <span class="co">; first in ah</span>
<span class="fu">scanloop5:</span>     <span class="kw">xlat</span>                      <span class="co">; translate second</span>
               <span class="kw">dec</span>        <span class="kw">cx</span>             <span class="co">; count down</span>
               <span class="kw">jz</span>         done2          <span class="co">; no more bytes left</span>
               <span class="kw">cmp</span>        <span class="kw">ax</span>,<span class="dv">0</span>           <span class="co">; check if word started</span>
               <span class="kw">je</span>         scanloop4      <span class="co">; if not, locate begin</span>
               <span class="kw">cmp</span>        <span class="kw">al</span><span class="bn">,01h         </span><span class="co">; check one-letter word</span>
               <span class="kw">je</span>         scanloop1      <span class="co">; if not, locate end of word</span>
               <span class="kw">inc</span>        <span class="kw">di</span>             <span class="co">; increase wordcount</span>
               <span class="kw">jmp</span>        scanloop4      <span class="co">; locate begin of next word</span>
<span class="fu">done1:</span>         <span class="kw">cmp</span>        <span class="kw">ax</span><span class="bn">,0101h       </span><span class="co">; check if end-of-word</span>
               <span class="kw">je</span>         done           <span class="co">; if not, we have finished</span>
               <span class="kw">inc</span>        <span class="kw">di</span>             <span class="co">; increase wordcount</span>
               <span class="kw">jmp</span>        done
<span class="fu">done2:</span>         <span class="kw">cmp</span>        <span class="kw">ax</span><span class="bn">,0100h       </span><span class="co">; check for one-letter word</span>
               <span class="kw">jne</span>        done           <span class="co">; if not, we have finished</span>
               <span class="kw">inc</span>        <span class="kw">di</span>             <span class="co">; increase wordcount</span>
<span class="fu">done:</span>          <span class="kw">mov</span>        <span class="kw">si</span>,[<span class="kw">bp</span>+charflag]
               <span class="kw">mov</span>        [<span class="kw">si</span>],<span class="kw">al</span>
               <span class="kw">mov</span>        <span class="kw">bx</span>,[<span class="kw">bp</span>+wordcount]
               <span class="kw">mov</span>        <span class="kw">ax</span>,[<span class="kw">bx</span>]
               <span class="kw">mov</span>        <span class="kw">dx</span>,[<span class="kw">bx</span><span class="dv">+2</span>]
               <span class="kw">add</span>        <span class="kw">di</span>,<span class="kw">ax</span>
               <span class="kw">adc</span>        <span class="kw">dx</span>,<span class="dv">0</span>
               <span class="kw">mov</span>        [<span class="kw">bx</span>],<span class="kw">di</span>
               <span class="kw">mov</span>        [<span class="kw">bx</span><span class="dv">+2</span>],<span class="kw">dx</span>
               <span class="kw">pop</span>        <span class="kw">di</span>
               <span class="kw">pop</span>        <span class="kw">si</span>
               <span class="kw">pop</span>        <span class="kw">bp</span>
               <span class="kw">ret</span>
_ScanBuffer    endp
               end</code></pre>
</section>
</section>
<section id="level-2-a-new-perspective" class="level3">
<h3><a href="#level-2-a-new-perspective">Level 2: A New Perspective</a></h3>
<p>The second level of optimization is one of breaking out of the mode of thinking established by my original code. Some entrants clearly did exactly that. They stepped back, thought about what the code actually needed to do, rather than just improving how it already worked, and implemented code that sprang from that new perspective.</p>
<p>You can see one example of this in Listing 16.6, where Willem uses <code>CMP AX,0101H</code> to check two bytes at once. While you might think of this as nothing more than a doubling up of tests, it’s a little more than that, especially when taken together with the use of two loops. This is a break with the serial nature of the C code, a recognition that word counting is really nothing more than a state machine that transitions from the “in word” state to the “not in word” state and back, counting a word on one but not both of those transitions. Willem says, in effect, “We’re in a word; if the next two bytes are non-separators, then we’re still in a word, else we’re not in a word, so count and change to the appropriate state.” That’s really quite different from saying, as I originally did, “If the last byte was a non-separator, then if the current byte is a separator, then count a word.” Willem has moved away from the all-in-one approach, splitting the code up into state-specific chunks that are more efficient because each does only the work required in a particular state.</p>
<p>Another example of coming at the code from a new perspective is counting a word as soon as a non-separator follows a separator (at the start of the word), rather than waiting for a separator following a non-separator (at the end of the word). My friend Dan Illowsky describes the thought process leading to this approach thusly:</p>
<p><em>“I try to code as closely as possible to the real world nature of those things my program models. It seems somehow wrong to me to count the end of a word as you do when you look for a transition from a word to a non-word. A word is not a transition, it is the presence of a group of characters. Thought of this way, the code would have counted the word when it first detected the group. Had you done this, your main program would not have needed to look for the possible last transition or deal with the semantics of the value in <code>CharValue</code>.”</em></p>
<p>John Richardson, of New York, contributed a good example of the benefits of a different perspective (in this case, a hardware perspective). John eliminated all branches used for detecting word edges; the inner loop of his code is shown in Listing 16.7. As John explains it:</p>
<p><em>“My next shot was to get rid of all the branches in the loop. To do that, I reached back to my college hardware courses. I noticed that we were really looking at an edge triggered device we want to count each time the I’m a character state goes from one to zero. Remembering that XOR on two single-bit values will always return whether the bits are different or the same, I implemented a transition counter. The counter triggers every time a word begins or ends.”</em></p>
<p><strong>Listing 16.7 L16-7.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="fu">ScanLoop:</span>
        <span class="kw">lodsw</span>           <span class="co">;get the next 2 bytes (AL = first, AH = 2nd)</span>
        <span class="kw">xlat</span>            <span class="co">;look up first&#39;s char/not status</span>
        <span class="kw">xor</span>     <span class="kw">dl</span>,<span class="kw">al</span>   <span class="co">;see if there&#39;s a new char/not status</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">dx</span>   <span class="co">;we add 1 for each char/not transition</span>
        <span class="kw">mov</span>     <span class="kw">dl</span>,<span class="kw">al</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">ah</span>   <span class="co">;look at the second byte</span>
        <span class="kw">xlat</span>            <span class="co">;look up its char/not status</span>
        <span class="kw">xor</span>     <span class="kw">dl</span>,<span class="kw">al</span>   <span class="co">;see if there&#39;s a new char/not status</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">dx</span>   <span class="co">;we add 1 for each char/not transition</span>
        <span class="kw">mov</span>     <span class="kw">dl</span>,<span class="kw">al</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">jnz</span>     ScanLoop</code></pre>
<p>John later divides the transition count by two to get the word count. (Food for thought: It’s also possible to use <code>CMP</code> and <code>ADC</code> to detect words without branching.)</p>
<p>John’s approach makes it clear that word-counting is nothing more than a fairly simple state machine. The interesting part, of course, is building the fastest state machine.</p>
<section id="level-3-breakthrough" class="level4">
<h4><a href="#level-3-breakthrough">Level 3: Breakthrough</a></h4>
<p>The boundaries between the levels of optimization are not sharply defined. In a sense, level 3 optimization is just like levels 1 and 2, but more so. At level 3, one takes whatever level 2 perspective seems most promising, and implements it as efficiently as possible on the x86. Even more than at level 2, at level 3 this means breaking out of familiar patterns of thinking.</p>
<p>In the case of word counting, level 3 means building a table-driven state machine dedicated to processing a buffer of bytes into a count of words with a minimum of branching. This level of optimization strips away many of the abstractions we usually use in coding, such as loops, tests, and named variables—look back to Listing 16.5, and you’ll see what I mean. Only a few people reached this level, and I don’t think any of them did it without long, hard thinking; David Stafford’s final entry (that is, the one I present as Listing 16.5) was <em>at least</em> the fifth entry he sent me.</p>
<p>The key concept at level 3 is the use of a massive (64K) lookup table that processes byte sequences directly into word-count actions. With such a table, it’s possible to look up the appropriate action for two bytes simultaneously in just a few instructions; next, I’m going to look at the inspired and highly unusual way that David’s code, shown in Listing 16.5, does exactly that. (Before assembling Listing 16.5, you must run the C code in Listing 16.8, to generate an include file defining the 64K lookup table. When you assemble Listing 16.5, TASM will report a “location counter overflow” warning; ignore it.)</p>
<p><strong>LISTING 16.8 MAKETAB.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//  MAKETAB.C — Build QSCAN3.INC for QSCAN3.ASM</span>
 
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;ctype.h&gt;</span>
 
<span class="ot">#define ChType( c )  (((c) &amp; 0x7f) == ‘\&#39;&#39; || isalnum((c) &amp; 0x7f))</span>
 
<span class="dt">int</span> NoCarry[ <span class="dv">4</span> ] = { <span class="dv">0</span>, <span class="bn">0x80</span>, <span class="dv">1</span>, <span class="bn">0x80</span> };
<span class="dt">int</span> Carry[ <span class="dv">4</span> ]   = { <span class="dv">1</span>, <span class="bn">0x81</span>, <span class="dv">1</span>, <span class="bn">0x80</span> };
 
<span class="dt">void</span> main( <span class="dt">void</span> )
  {
  <span class="dt">int</span> ahChar, alChar, i;
  FILE *t = fopen( <span class="st">&quot;QSCAN3.INC&quot;</span>, <span class="st">&quot;wt&quot;</span> );
 
  printf( <span class="st">&quot;Building table.  Please wait...&quot;</span> );
 
  <span class="kw">for</span>( ahChar = <span class="dv">0</span>; ahChar &lt; <span class="dv">128</span>; ahChar++ )
    {
    <span class="kw">for</span>( alChar = <span class="dv">0</span>; alChar &lt; <span class="dv">256</span>; alChar++ )
      {
      i = ChType( alChar ) * <span class="dv">2</span> + ChType( ahChar );
 
      <span class="kw">if</span>( alChar % <span class="dv">8</span> == <span class="dv">0</span> )  fprintf( t, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">db %02Xh&quot;</span>, NoCarry[ i ] );
      <span class="kw">else</span>                   fprintf( t, <span class="st">&quot;,%02Xh&quot;</span>, NoCarry[ i ] );
 
      fprintf( t, <span class="st">&quot;,%02Xh&quot;</span>, Carry[ i ] );
      }
    }
 
  fclose( t );
  }</code></pre>
<p>David’s approach is simplicity itself, although his implementation arguably is not. Consider any three sequential bytes in the buffer. Those three bytes define two potential places where a word might be counted, as shown in Figure 16.1. Given the separator/non-separator states of the three bytes, you can instantly determine whether to count a word or not; you count a word if and only if somewhere in the sequence there is a non-separator followed by a separator. Note that a maximum of one word can be counted per three-byte sequence.</p>
<p>The trick, then, is to identify the separator/not statuses of each set of three bytes and turn them into a 1 (count word) or 0 (don’t count word), as quickly as possible. Assuming that the separator/not status for the first byte is in the Carry flag, this is easily accomplished by a lookup in a 64K table, based on the Carry flag and the other two bytes, as shown in Figure 16.2. (Remember that we’re counting 7-bit ASCII here, so the high bit is ignored.) Thus, David is able to add the word/not status for each pair of bytes to the main word count simply by getting the two bytes, working in the carry status from the last byte, and using the resulting value to index into the 64K table, adding in the 1 or 0 value found in that table. A sequence of <code>MOV/ADC/ADD</code> suffices to perform all word-counting tasks for a pair of bytes. Three instructions, no branches—pretty nearly perfect code.</p>
<figure>
<img src="images/16-01.jpg" alt="Figure 16.1  The two potential word count locations." /><figcaption><strong>Figure 16.1</strong>  <em>The two potential word count locations.</em></figcaption>
</figure>
<p>One detail remains to be attended to: setting the Carry flag for next time if the last byte was a non-separator. David does this in a bizarre and incredibly effective way: He presets the high bit of the count, and sets the high bit in the lookup table for those entries looked up by non-separators. When a non-separator’s lookup entry is added to the count, it will produce a carry, as desired. The high bit of the count is masked off before being added to the total count, so David is essentially using different parts of the count variables for different purposes (counting, and setting the Carry flag).</p>
<figure>
<img src="images/16-02.jpg" alt="Figure 16.2  Looking up a word count status." /><figcaption><strong>Figure 16.2</strong>  <em>Looking up a word count status.</em></figcaption>
</figure>
<p>There are a number of other interesting details in David’s code, including the unrolling of the loop 64 times, so that 256 bytes in a row are processed without a single branch. Unfortunately, I lack the space to discuss Listing 16.5 any further. Perhaps that’s not so unfortunate, after all; I’d hate to deny you the pleasure of discovering the wonders of this rather remarkable code yourself. I will say one more thing, though. The cycle count for David’s inner loop is 6.5 cycles per byte processed, and the actual measured time for his routine, overhead and all, is 7.9 cycles/byte. The original C code clocked in at around 100 cycles/byte.</p>
<p>Enough said, I trust.</p>
</section>
<section id="enough-word-counting-already" class="level4">
<h4><a href="#enough-word-counting-already">Enough Word Counting Already!</a></h4>
<p>Before I finish up this chapter, I’d like to mention that Terje Mathisen’s WC word-counting program, which I’ve mentioned previously and which is available, with source, on Bix, is in the ballpark with David’s code for performance. What’s more, Terje’s program handles 8-bit ASCII, counts lines as well as words, and supports user-definable separator sets. It’s wonderful code, well worth a look; it also happens to be a great word-counting utility. By the way, Terje builds his 64K table on the fly, at program initialization; this allows for customized tables, shrinks the size of the EXE, and, according to Terje’s calculations, takes less time than loading the table off disk as part of the EXE.</p>
<p>So, has David written the fastest possible word-counting code? Well, maybe—but I have a letter from Terry Holmes, of San Rafael, California, that calculates the theoretical maximum performance of native 386 word-counting code at 5.5 cycles/byte, which would be significantly faster than David’s code. Terry, alas, didn’t bother to implement his design, but maybe I’ll take a shot at it someday. It’d be fun, for sure—but jeez, I’ve got <em>real</em> work to do!</p>
</section>
</section>
</section>
<section id="chapter-17-the-game-of-life" class="level2">
<h2><a href="#chapter-17-the-game-of-life">Chapter 17 – The Game of Life</a></h2>
<section id="the-triumph-of-algorithmic-optimization-in-a-cellular-automata-game" class="level3">
<h3><a href="#the-triumph-of-algorithmic-optimization-in-a-cellular-automata-game">The Triumph of Algorithmic Optimization in a Cellular Automata Game</a></h3>
<p>I’ve spent a lot of my life discussing assembly language optimization, which I consider to be an important and underappreciated topic. However, I’d like to take this opportunity to point out that there is much, much more to optimization than assembly language. Assembly is essential for absolute maximum performance, but it’s not the only ingredient; necessary but not sufficient, if you catch my drift—and not even necessary, if you’re looking for improved but not maximum performance. You’ve heard it a thousand times: Optimize your algorithm first. Devise new approaches. Or, as Knuth said, <em>Premature optimization is the root of all evil.</em></p>
<p>This is, of course, old hat, stuff you know like the back of your hand. Or is it? As Jeff Duntemann pointed out to me the other day, performance programmers are made, not born. While I’m merrily gallivanting around in this book optimizing 486 pipelining and turning simple tasks into horribly complicated and terrifyingly fast state machines, many of you are still developing your basic optimization skills. I don’t want to shortchange those of you in the latter category, so in this chapter, we’ll discuss some high-level language optimizations that can be applied by mere mortals within a reasonable period of time. We’re going to examine a complete optimization process, from start to finish, and what we will find is that it’s possible to get a 50-times speed-up without using <em>one byte of assembly!</em> It’s all a matter of perspective—how you look at your code and data.</p>
</section>
<section id="conways-game" class="level3">
<h3><a href="#conways-game">Conway’s Game</a></h3>
<p>The program that we’re going to optimize is Conway’s famous Game of Life, long-ago favorite of the hackers at MIT’s AI Lab. If you’ve never seen it, let me assure you: Life is <em>neat,</em> and more than a little hypnotic. Fractals have been the hot graphics topic in recent years, but for eye-catching dazzle, Life is hard to beat.</p>
<p>Of course, eye-catching dazzle requires real-time performance—lots of pixels help too—and there’s the rub. When there are, say, 40,000 cells to process and display, a simple, straightforward implementation just doesn’t cut it, even on a 33 MHz 486. Happily, though, there are many, many ways to speed up Life, and they illustrate a variety of important optimization principles, as this chapter will show.</p>
<p>First, I’ll describe the ground rules of Life, implement a very straightforward version in C++, and then speed that version up by about eight times without using any drastically different approaches or any assembly. This may be a little tame for some of you, but be patient; for after that, we’ll haul out the big guns and move into the 30 to 40 times speed-up range. Then in the next chapter, I’ll show you how several programmers <em>really</em> floored it in taking me up on my second Optimization Challenge, which involved the Game of Life.</p>
<section id="the-rules-of-the-game" class="level4">
<h4><a href="#the-rules-of-the-game">The Rules of the Game</a></h4>
<p>The Game of Life is ridiculously simple. There is a cellmap, consisting of a rectangular matrix of cells, each of which may initially be either on or off. Each cell has eight neighbors: two horizontally, two vertically, and four diagonally. For each succeeding generation of cells, the game logic determines whether each cell will be on or off according to the following rules:</p>
<ul>
<li>If a cell is on and has either two or three neighbors that are on in the current generation, it stays on; otherwise, the cell turns off.</li>
<li>If a cell is off and has exactly three “on” neighbors in the current generation, it turns on; otherwise, it stays off. That’s all the rules there are—but they give rise to an astonishing variety of forms, including patterns that spin, march across the screen, and explode.</li>
</ul>
<p>It’s only a little more complicated to implement the Game of Life than it is to describe it. Listing 17.1, together with the display functions in Listing 17.2, is a C++ implementation of the Game of Life, and it’s very straightforward. A cellmap is an object that’s accessible through member functions to set, clear, and test cell states, and through a member function to calculate the next generation. Calculating the next generation involves nothing more than using the other member functions to set each cell to the appropriate state, given the number of neighboring on-cells and the cell’s current state. The only complication is that it’s necessary to place the next generation’s cells in another cellmap, and then copy the final result back to the original cellmap. This keeps us from corrupting the current generation’s cellmap before we’re done using it to calculate the next generation.</p>
<p>All in all, Listing 17.1 is a clean, compact, and elegant implementation of the Game of Life. Were it not that the code is as slow as molasses, we could stop right here.</p>
<p><strong>LISTING 17.1 L17-1.CPP</strong></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* C++ Game of Life implementation for any mode for which mode set</span>
<span class="co">   and draw pixel functions can be provided.</span>
<span class="co">   Tested with Borland C++ in the small model. */</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;iostream.h&gt;</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;time.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &lt;bios.h&gt;</span>
<span class="ot">#include &lt;mem.h&gt;</span>

<span class="ot">#define ON_COLOR  15       </span><span class="co">// on-cell pixel color</span>
<span class="ot">#define OFF_COLOR 0        </span><span class="co">// off-cell pixel color</span>
<span class="ot">#define MSG_LINE  10       </span><span class="co">// row for text messages</span>
<span class="ot">#define GENERATION_LINE 12 </span><span class="co">// row for generation # display</span>
<span class="ot">#define LIMIT_18_HZ  1     </span><span class="co">// set 1 for maximum frame rate = 18Hz</span>
<span class="ot">#define WRAP_EDGES   1     </span><span class="co">// set to 0 to disable wrapping around</span>
                           <span class="co">// at cell map edges</span>
<span class="kw">class</span> cellmap {
<span class="kw">private</span>:
   <span class="dt">unsigned</span> <span class="dt">char</span> *cells;
   <span class="dt">unsigned</span> <span class="dt">int</span> width;
   <span class="dt">unsigned</span> <span class="dt">int</span> width_in_bytes;
   <span class="dt">unsigned</span> <span class="dt">int</span> height;
   <span class="dt">unsigned</span> <span class="dt">int</span> length_in_bytes;
<span class="kw">public</span>:
   cellmap(<span class="dt">unsigned</span> <span class="dt">int</span> h, <span class="dt">unsigned</span> <span class="dt">int</span> v);
   ~cellmap(<span class="dt">void</span>);
   <span class="dt">void</span> copy_cells(cellmap &amp;sourcemap);
   <span class="dt">void</span> set_cell(<span class="dt">unsigned</span> <span class="dt">int</span> x, <span class="dt">unsigned</span> <span class="dt">int</span> y);
   <span class="dt">void</span> clear_cell(<span class="dt">unsigned</span> <span class="dt">int</span> x, <span class="dt">unsigned</span> <span class="dt">int</span> y);
   <span class="dt">int</span> cell_state(<span class="dt">int</span> x, <span class="dt">int</span> y);
   <span class="dt">void</span> next_generation(cellmap&amp; dest_map);
};

<span class="kw">extern</span> <span class="dt">void</span> enter_display_mode(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">void</span> exit_display_mode(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">void</span> draw_pixel(<span class="dt">unsigned</span> <span class="dt">int</span> X, <span class="dt">unsigned</span> <span class="dt">int</span> Y,
   <span class="dt">unsigned</span> <span class="dt">int</span> Color);
<span class="kw">extern</span> <span class="dt">void</span> show_text(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">char</span> *text);

<span class="co">/* Controls the size of the cell map. Must be within the capabilities</span>
<span class="co">   of the display mode, and must be limited to leave room for text</span>
<span class="co">   display at right. */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> cellmap_width = <span class="dv">96</span>;
<span class="dt">unsigned</span> <span class="dt">int</span> cellmap_height = <span class="dv">96</span>;
<span class="co">/* Width &amp; height in pixels of each cell as displayed on screen. */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> magnifier = <span class="dv">2</span>;

<span class="dt">void</span> main()
{
   <span class="dt">unsigned</span> <span class="dt">int</span> init_length, x, y, seed;
   <span class="dt">unsigned</span> <span class="dt">long</span> generation = <span class="dv">0</span>;
   <span class="dt">char</span> gen_text[<span class="dv">80</span>];
   <span class="dt">long</span> bios_time, start_bios_time;

   cellmap current_map(cellmap_height, cellmap_width);
   cellmap next_map(cellmap_height, cellmap_width);

   <span class="co">// Get the seed; seed randomly if 0 entered</span>
   cout &lt;&lt; <span class="st">&quot;Seed (0 for random seed): &quot;</span>;
   cin &gt;&gt; seed;
   <span class="kw">if</span> (seed == <span class="dv">0</span>) seed = (<span class="dt">unsigned</span>) time(NULL);

   <span class="co">// Randomly initialize the initial cell map</span>
   cout &lt;&lt; <span class="st">&quot;Initializing...&quot;</span>;
   srand(seed);
   init_length = (cellmap_height * cellmap_width) / <span class="dv">2</span>;
   <span class="kw">do</span> {
      x = random(cellmap_width);
      y = random(cellmap_height);
      next_map.set_cell(x, y);
   } <span class="kw">while</span> (—init_length);
   current_map.copy_cells(next_map); <span class="co">// put init map in current_map</span>

   enter_display_mode();

   <span class="co">// Keep recalculating and redisplaying generations until a key</span>
   <span class="co">// is pressed</span>
   show_text(<span class="dv">0</span>, MSG_LINE, <span class="st">&quot;Generation: &quot;</span>);
   start_bios_time = _bios_timeofday(_TIME_GETCLOCK, &amp;bios_time);
   <span class="kw">do</span> {
      generation++;
      sprintf(gen_text, <span class="st">&quot;%10lu&quot;</span>, generation);
      show_text(<span class="dv">1</span>, GENERATION_LINE, gen_text);
      <span class="co">// Recalculate and draw the next generation</span>
      current_map.next_generation(next_map);
      <span class="co">// Make current_map current again</span>
      current_map.copy_cells(next_map);
<span class="ot">#if LIMIT_18_HZ</span>
      <span class="co">// Limit to a maximum of 18.2 frames per second,for visibility</span>
      <span class="kw">do</span> {
         _bios_timeofday(_TIME_GETCLOCK, &amp;bios_time);
      } <span class="kw">while</span> (start_bios_time == bios_time);
      start_bios_time = bios_time;
<span class="ot">#endif</span>
   } <span class="kw">while</span> (!kbhit());
   getch();    <span class="co">// clear keypress</span>
   exit_display_mode();
   cout &lt;&lt; <span class="st">&quot;Total generations: &quot;</span> &lt;&lt; generation &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">Seed: &quot;</span> &lt;&lt;
         seed &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
}

<span class="co">/* cellmap constructor. */</span>
cellmap::cellmap(<span class="dt">unsigned</span> <span class="dt">int</span> h, <span class="dt">unsigned</span> <span class="dt">int</span> w)
{
   width = w;
   width_in_bytes = (w + <span class="dv">7</span>) / <span class="dv">8</span>;
   height = h;
   length_in_bytes = width_in_bytes * h;
   cells = <span class="kw">new</span> <span class="dt">unsigned</span> <span class="dt">char</span>[length_in_bytes];  <span class="co">// cell storage</span>
   memset(cells, <span class="dv">0</span>, length_in_bytes);  <span class="co">// clear all cells, to start</span>
}

<span class="co">/* cellmap destructor. */</span>
cellmap::~cellmap(<span class="dt">void</span>)
{
   <span class="kw">delete</span>[] cells;
}

<span class="co">/* Copies one cellmap&#39;s cells to another cellmap. Both cellmaps are</span>
<span class="co">   assumed to be the same size.  */</span>
<span class="dt">void</span> cellmap::copy_cells(cellmap &amp;sourcemap)
{
   memcpy(cells, sourcemap.cells, length_in_bytes);
}

<span class="co">/* Turns cell on. */</span>
<span class="dt">void</span> cellmap::set_cell(<span class="dt">unsigned</span> <span class="dt">int</span> x, <span class="dt">unsigned</span> <span class="dt">int</span> y)
{
   <span class="dt">unsigned</span> <span class="dt">char</span> *cell_ptr =
         cells + (y * width_in_bytes) + (x / <span class="dv">8</span>);

   *(cell_ptr) |= <span class="bn">0x80</span> &gt;&gt; (x &amp; <span class="bn">0x07</span>);
}

<span class="co">/* Turns cell off. */</span>
<span class="dt">void</span> cellmap::clear_cell(<span class="dt">unsigned</span> <span class="dt">int</span> x, <span class="dt">unsigned</span> <span class="dt">int</span> y)
{
   <span class="dt">unsigned</span> <span class="dt">char</span> *cell_ptr =
         cells + (y * width_in_bytes) + (x / <span class="dv">8</span>);

   *(cell_ptr) &amp;= ~(<span class="bn">0x80</span> &gt;&gt; (x &amp; <span class="bn">0x07</span>));
}

<span class="co">/* Returns cell state (1=on or 0=off), optionally wrapping at the</span>
<span class="co">   borders around to the opposite edge. */</span>
<span class="dt">int</span> cellmap::cell_state(<span class="dt">int</span> x, <span class="dt">int</span> y)
{
   <span class="dt">unsigned</span> <span class="dt">char</span> *cell_ptr;

<span class="ot">#if WRAP_EDGES</span>
   <span class="kw">while</span> (x &lt; <span class="dv">0</span>) x += width;     <span class="co">// wrap, if necessary</span>
   <span class="kw">while</span> (x &gt;= width) x -= width;
   <span class="kw">while</span> (y &lt; <span class="dv">0</span>) y += height;
   <span class="kw">while</span> (y &gt;= height) y -= height;
<span class="ot">#else</span>
   <span class="kw">if</span> ((x &lt; <span class="dv">0</span>) || (x &gt;= width) || (y &lt; <span class="dv">0</span>) || (y &gt;= height))
      <span class="kw">return</span> <span class="dv">0</span>;   <span class="co">// return 0 for off edges if no wrapping</span>
<span class="ot">#endif</span>
   cell_ptr = cells + (y * width_in_bytes) + (x / <span class="dv">8</span>);
   <span class="kw">return</span> (*cell_ptr &amp; (<span class="bn">0x80</span> &gt;&gt; (x &amp; <span class="bn">0x07</span>))) ? <span class="dv">1</span> : <span class="dv">0</span>;
}

<span class="co">/* Calculates the next generation of a cellmap and stores it in</span>
<span class="co">   next_map. */</span>
<span class="dt">void</span> cellmap::next_generation(cellmap&amp; next_map)
{
   <span class="dt">unsigned</span> <span class="dt">int</span> x, y, neighbor_count;

   <span class="kw">for</span> (y=<span class="dv">0</span>; y&lt;height; y++) {
      <span class="kw">for</span> (x=<span class="dv">0</span>; x&lt;width; x++) {
         <span class="co">// Figure out how many neighbors this cell has</span>
         neighbor_count = cell_state(x<span class="dv">-1</span>, y<span class="dv">-1</span>) + cell_state(x, y<span class="dv">-1</span>) +
               cell_state(x<span class="dv">+1</span>, y<span class="dv">-1</span>) + cell_state(x<span class="dv">-1</span>, y) +
               cell_state(x<span class="dv">+1</span>, y) + cell_state(x<span class="dv">-1</span>, y<span class="dv">+1</span>) +
               cell_state(x, y<span class="dv">+1</span>) + cell_state(x<span class="dv">+1</span>, y<span class="dv">+1</span>);
         <span class="kw">if</span> (cell_state(x, y) == <span class="dv">1</span>) {
            <span class="co">// The cell is on; does it stay on?</span>
            <span class="kw">if</span> ((neighbor_count != <span class="dv">2</span>) &amp;&amp; (neighbor_count != <span class="dv">3</span>)) {
               next_map.clear_cell(x, y);    <span class="co">// turn it off</span>
               draw_pixel(x, y, OFF_COLOR);
            }
         } <span class="kw">else</span> {
            <span class="co">// The cell is off; does it turn on?</span>
            <span class="kw">if</span> (neighbor_count == <span class="dv">3</span>) {
               next_map.set_cell(x, y);      <span class="co">// turn it on</span>
               draw_pixel(x, y, ON_COLOR);
            }
         }
      }
   }
}</code></pre>
<p><strong>LISTING 17.2 L17-2.CPP</strong></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* VGA mode 13h functions for Game of Life.</span>
<span class="co">   Tested with Borland C++. */</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>

<span class="ot">#define TEXT_X_OFFSET   27</span>
<span class="ot">#define SCREEN_WIDTH_IN_BYTES 320</span>

<span class="co">/* Width &amp; height in pixels of each cell. */</span>
<span class="kw">extern</span> <span class="dt">unsigned</span> <span class="dt">int</span> magnifier;

<span class="co">/* Mode 13h draw pixel function. Pixels are of width &amp; height</span>
<span class="co">   specified by magnifier. */</span>
<span class="dt">void</span> draw_pixel(<span class="dt">unsigned</span> <span class="dt">int</span> x, <span class="dt">unsigned</span> <span class="dt">int</span> y, <span class="dt">unsigned</span> <span class="dt">int</span> color)
{
<span class="ot">#define SCREEN_SEGMENT  0xA000</span>
   <span class="dt">unsigned</span> <span class="dt">char</span> far *screen_ptr;
   <span class="dt">int</span> i, j;

   FP_SEG(screen_ptr) = SCREEN_SEGMENT;
   FP_OFF(screen_ptr) =
         y * magnifier * SCREEN_WIDTH_IN_BYTES + x * magnifier;
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;magnifier; i++) {
      <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;magnifier; j++) {
         *(screen_ptr+j) = color;
      }
      screen_ptr += SCREEN_WIDTH_IN_BYTES;
   }
}

<span class="co">/* Mode 13h mode-set function. */</span>
<span class="dt">void</span> enter_display_mode()
{
   <span class="kw">union</span> REGS regset;

   regset.x.ax = <span class="bn">0x0013</span>;
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}

<span class="co">/* Text mode mode-set function. */</span>
<span class="dt">void</span> exit_display_mode()
{
   <span class="kw">union</span> REGS regset;

   regset.x.ax = <span class="bn">0x0003</span>;
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}

<span class="co">/* Text display function. Offsets text to non-graphics area of</span>
<span class="co">   screen. */</span>
<span class="dt">void</span> show_text(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">char</span> *text)
{
   gotoxy(TEXT_X_OFFSET + x, y);
   puts(text);
}</code></pre>
</section>
</section>
<section id="where-does-the-time-go" class="level3">
<h3><a href="#where-does-the-time-go">Where Does the Time Go?</a></h3>
<p>How slow is Listing 17.1? Table 17.1 shows that even on a 486, Listing 17.1 does fewer than three 96x96 generations per second. (The times in Table 17.1 are for 1,000 generations of a 96x96 cell map with <code>seed=1, LIMIT_18_HZ=0, WRAP_EDGES=1</code>, and <code>magnifier=2</code>, running on a 33 MHz 486.) Since my target is 18 generations per second with a 200x200 cellmap on a 20 MHz 386, Listing 17.1 is too slow by a rather wide margin—75 times too slow, in fact. You might say we have a little optimizing to do.</p>
<p>The first rule of optimization is: Only optimize where it matters. Use a profiler, or risk making a fool of yourself. Consider Listings 17.1 and 17.2. Where do you think the potential for significant speed-up lies? I’ll tell you one place where I thought there was considerable potential—in <code>draw_pixel()</code>. As a programmer of high-speed graphics, I figured any drawing function that was not only written in C/C++ but also recalculated the target address from scratch for each pixel would be among the first optimization targets. I also expected to get major gains out of going to a Ping-Pong arrangement so that I didn’t have to copy the new cellmap back to <code>current_map</code> after calculating the next generation.</p>
<table>
<caption>Table 17.1 Execution times for the game of life.</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">Listing 17.1</th>
<th style="text-align: left;">Listing 17.3</th>
<th style="text-align: left;">Listing 17.4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Total execution time</strong></td>
<td style="text-align: left;">340 secs</td>
<td style="text-align: left;">94 secs</td>
<td style="text-align: left;">45 secs</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cell_state()</code></td>
<td style="text-align: left;">275</td>
<td style="text-align: left;">21</td>
<td style="text-align: left;">—</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>next_generation()</code></td>
<td style="text-align: left;">60</td>
<td style="text-align: left;">14</td>
<td style="text-align: left;">40</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>count_neighbors()</code></td>
<td style="text-align: left;">—</td>
<td style="text-align: left;">54</td>
<td style="text-align: left;">—</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>draw_pixel()</code></td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>set_cell()</code></td>
<td style="text-align: left;">&lt;1</td>
<td style="text-align: left;">&lt;1</td>
<td style="text-align: left;">&lt;1</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>clear_cell()</code></td>
<td style="text-align: left;">&lt;1</td>
<td style="text-align: left;">&lt;1</td>
<td style="text-align: left;">&lt;1</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>copy_cells()</code></td>
<td style="text-align: left;">&lt;1</td>
<td style="text-align: left;">&lt;1</td>
<td style="text-align: left;">&lt;1</td>
</tr>
</tbody>
</table>
<p>I was wrong. Wrong, wrong, wrong. (But at least I was smart enough to use a profiler before actually writing any new code.) Table 17.1 shows where the time actually goes in Listings 17.1 and 17.2. As you can see, the time taken by <code>draw_pixel()</code>, <code>copy_cells()</code>, and <em>everything</em> other than calculating the next generation is nothing more than noise. We could optimize these routines right down to executing <em>instantaneously,</em> and you know what? It wouldn’t make the slightest perceptible difference in how fast the program runs. Given the present state of our Game of Life implementation, the only areas worth looking at for possible optimizations are <code>cell_state()</code> and <code>next_generation().</code></p>
<blockquote>
<p><img src="images/i.jpg" /> It’s worth noting, though, that one reason <code>draw_pixel()</code> doesn’t much affect performance is that in Listing 17.1, we’re smart enough to redraw pixels only when their states change, rather than during every generation. Detecting and eliminating redundant operations is part of knowing the nature of your data, and is a potent optimization technique that will be extremely useful a little later in this chapter.</p>
</blockquote>
</section>
<section id="the-hazards-and-advantages-of-abstraction" class="level3">
<h3><a href="#the-hazards-and-advantages-of-abstraction">The Hazards and Advantages of Abstraction</a></h3>
<p>How can we speed up <code>cell_state()</code> and <code>next_generation()</code>? I’ll tell you how <em>not</em> to do it: By writing those member functions in assembly. It’s tempting to say that <code>cell_state()</code> is taking all the time, so we need to speed it up with assembly, but what we really need to do is figure out <em>why</em> <code>cell_state()</code> is taking all the time, then address that aspect of the program directly.</p>
<p>Once you know where you need to optimize, the one word to keep in mind isn’t assembly, it’s…plastics. No, actually, it’s <em>abstraction.</em> Well-written C and especially C++ programs are highly abstract models. For example, Listing 17.1 essentially creates a new programming language in which cells are tangible things, with built-in manipulation instructions. Given the cellmap member functions, you don’t even need to know the cell storage format! This is a wonderful thing, in general; it saves programming time and bugs, and frees you to work on the application’s needs, rather than implementation details.</p>
<blockquote>
<p><img src="images/i.jpg" /> However, if you never look beneath the surface of the abstract model at the implementation details, you have no idea of what the true performance cost of various operations is, and, without that, you have largely surrendered control over performance.</p>
</blockquote>
<p>Having said that, let me hasten to add that algorithmic improvements can make a big difference even when working at a purely abstract level. For a large unordered data set, a high-level Quicksort will beat the pants off the best-implemented insertion sort you can imagine. Still, you can optimize your algorithm from here ’til doomsday, and if you have a fast algorithm running on top of a highly abstract programming model, you’ll almost certainly end up with a slow program. In Listing 17.1, the abstraction that’s killing us is that of looking at the eight neighbors with eight completely independent operations, requiring eight calls to <code>cell_state()</code> and eight calculations of cell address and cell mask. In fact, given the nature of cell storage, the eight neighbors are in a fixed relationship to one another, and the addresses and masks of all eight can generally be found very easily via hard-wired offsets and shifts once the address and mask of any one is known.</p>
<p>There’s a kicker here, though, and that’s the counting of neighbors for cells at the edge of the cellmap. When cellmap wrapping is enabled (so that the cellmap becomes essentially a toroid, with each edge joined seamlessly to the opposite edge, as opposed to having a border of off-cells), neighbors that reside on the other edge of the cellmap can’t be accessed by the standard fixed offset, as shown in Figure 17.1. So, in general, we could improve performance by hard-wiring our neighbor-counting for the bit-per-cell cellmap format, but it seems we’d need a lot of conditional code to handle wrapping, and that would slow things back down again.</p>
<figure>
<img src="images/17-01.jpg" alt="Figure 17.1  Edge-wrapping complications." /><figcaption><strong>Figure 17.1</strong>  <em>Edge-wrapping complications.</em></figcaption>
</figure>
<p>When a problem doesn’t lend itself well to optimization, make it a practice to see if you can change the problem definition to one that allows for greater efficiency. In this case, we’ll change the problem by putting padding bytes around the edge of the cellmap, and duplicating each edge of the cellmap in the padding bytes at the opposite side, as shown in Figure 17.2. That way, a hard-wired neighbor count will find exactly what it should—the opposite edge—without any special code at all.</p>
<p>But doesn’t that extra copying of the edges take time? Sure, but only a little; we can build it into the cellmap copying function, and then frankly we won’t even notice it. Avoiding tens or hundreds of thousands of calls to <code>cell_state()</code>, on the other hand, will be <em>very</em> noticeable. Listing 17.3 shows the alterations to Listing 17.1 required to implement a hard-wired neighbor-counting function. This is a minor change, in truth, implemented in about half an hour and not making the code significantly larger—but Listing 17.3 is 3.6 times faster than Listing 17.1, as shown in Table 17.1. We’re up to about 10 generations per second on a 486; not where we want to be, but it is a vast improvement.</p>
<figure>
<img src="images/17-02.jpg" alt="Figure 17.2  The padding cells solution." /><figcaption><strong>Figure 17.2</strong>  <em>The “padding cells” solution.</em></figcaption>
</figure>
<p><strong>LISTING 17.3 L17-3.CPP</strong></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* cellmap class definition, constructor, copy_cells(), set_cell(),</span>
<span class="co">   clear_cell(), cell_state(), count_neighbors(), and</span>
<span class="co">   next_generation() for fast, hard-wired neighbor count approach.</span>
<span class="co">   Otherwise, the same as Listing 17.1 */</span>

<span class="kw">class</span> cellmap {
<span class="kw">private</span>:
   <span class="dt">unsigned</span> <span class="dt">char</span> *cells;
   <span class="dt">unsigned</span> <span class="dt">int</span> width;
   <span class="dt">unsigned</span> <span class="dt">int</span> width_in_bytes;
   <span class="dt">unsigned</span> <span class="dt">int</span> height;
   <span class="dt">unsigned</span> <span class="dt">int</span> length_in_bytes;
<span class="kw">public</span>:
   cellmap(<span class="dt">unsigned</span> <span class="dt">int</span> h, <span class="dt">unsigned</span> <span class="dt">int</span> v);
   ~cellmap(<span class="dt">void</span>);
   <span class="dt">void</span> copy_cells(cellmap &amp;sourcemap);
   <span class="dt">void</span> set_cell(<span class="dt">unsigned</span> <span class="dt">int</span> x, <span class="dt">unsigned</span> <span class="dt">int</span> y);
   <span class="dt">void</span> clear_cell(<span class="dt">unsigned</span> <span class="dt">int</span> x, <span class="dt">unsigned</span> <span class="dt">int</span> y);
   <span class="dt">int</span> cell_state(<span class="dt">int</span> x, <span class="dt">int</span> y);
   <span class="dt">int</span> count_neighbors(<span class="dt">int</span> x, <span class="dt">int</span> y);
   <span class="dt">void</span> next_generation(cellmap&amp; dest_map);
};

<span class="co">/* cellmap constructor. Pads around cell storage area with 1 extra</span>
<span class="co">   byte, used for handling edge wrapping. */</span>
cellmap::cellmap(<span class="dt">unsigned</span> <span class="dt">int</span> h, <span class="dt">unsigned</span> <span class="dt">int</span> w)
{
   width = w;
   width_in_bytes = ((w + <span class="dv">7</span>) / <span class="dv">8</span>) + <span class="dv">2</span>; <span class="co">// pad each side with</span>
                                      <span class="co">// 1 extra byte</span>
   height = h;
   length_in_bytes = width_in_bytes * (h + <span class="dv">2</span>);     <span class="co">// pad top/bottom</span>
                                                   <span class="co">// with 1 extra byte</span>
   cells = <span class="kw">new</span> <span class="dt">unsigned</span> <span class="dt">char</span>[length_in_bytes];     <span class="co">// cell storage</span>
   memset(cells, <span class="dv">0</span>, length_in_bytes);              <span class="co">// clear all cells, to start</span>
}

<span class="co">/* Copies one cellmap&#39;s cells to another cellmap. If wrapping is</span>
<span class="co">   enabled, copies edge (wrap) bytes into opposite padding bytes in</span>
<span class="co">   source first, so that the padding bytes off each edge have the</span>
<span class="co">   same values as would be found by wrapping around to the opposite</span>
<span class="co">   edge. Both cellmaps are assumed to be the same size. */</span>
<span class="dt">void</span> cellmap::copy_cells(cellmap &amp;sourcemap)
{
   <span class="dt">unsigned</span> <span class="dt">char</span> *cell_ptr;
   <span class="dt">int</span> i;

<span class="ot">#if WRAP_EDGES</span>
<span class="co">// Copy left and right edges into padding bytes on right and left</span>
   cell_ptr = sourcemap.cells + width_in_bytes;
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;height; i++) {
      *cell_ptr = *(cell_ptr + width_in_bytes - <span class="dv">2</span>);
      *(cell_ptr + width_in_bytes - <span class="dv">1</span>) = *(cell_ptr + <span class="dv">1</span>);
      cell_ptr += width_in_bytes;
   }
<span class="co">// Copy top and bottom edges into padding bytes on bottom and top</span>
   memcpy(sourcemap.cells, sourcemap.cells + length_in_bytes -
         (width_in_bytes * <span class="dv">2</span>), width_in_bytes);
   memcpy(sourcemap.cells + length_in_bytes - width_in_bytes,
         sourcemap.cells + width_in_bytes, width_in_bytes);
<span class="ot">#endif</span>
   <span class="co">// Copy all cells to the destination</span>
   memcpy(cells, sourcemap.cells, length_in_bytes);
}

<span class="co">/* Turns cell on. x and y are offset by 1 byte down and to the right, to compensate for the</span>
<span class="co">padding bytes around the cellmap. */</span>
<span class="dt">void</span> cellmap::set_cell(<span class="dt">unsigned</span> <span class="dt">int</span> x, <span class="dt">unsigned</span> <span class="dt">int</span> y)
{
   <span class="dt">unsigned</span> <span class="dt">char</span> *cell_ptr =
         cells + ((y + <span class="dv">1</span>) * width_in_bytes) + ((x / <span class="dv">8</span>) + <span class="dv">1</span>);

   *(cell_ptr) |= <span class="bn">0x80</span> &gt;&gt; (x &amp; <span class="bn">0x07</span>);
}

<span class="co">/* Turns cell off. x and y are offset by 1 byte down and to the right,</span>
<span class="co">to compensate for the padding bytes around the cell map. */</span>
<span class="dt">void</span> cellmap::clear_cell(<span class="dt">unsigned</span> <span class="dt">int</span> x, <span class="dt">unsigned</span> <span class="dt">int</span> y)
{
   <span class="dt">unsigned</span> <span class="dt">char</span> *cell_ptr =
         cells + ((y + <span class="dv">1</span>) * width_in_bytes) + ((x / <span class="dv">8</span>) + <span class="dv">1</span>);

   *(cell_ptr) &amp;= ~(<span class="bn">0x80</span> &gt;&gt; (x &amp; <span class="bn">0x07</span>));
}

<span class="co">/* Returns cell state (1=on or 0=off). x and y are offset by 1 byte</span>
<span class="co">   down and to the right, to</span>
<span class="co">compensate for the padding bytes around</span>
<span class="co">   the cell map. */</span>
<span class="dt">int</span> cellmap::cell_state(<span class="dt">int</span> x, <span class="dt">int</span> y)
{
   <span class="dt">unsigned</span> <span class="dt">char</span> *cell_ptr =
         cells + ((y + <span class="dv">1</span>) * width_in_bytes) + ((x / <span class="dv">8</span>) + <span class="dv">1</span>);

   <span class="kw">return</span> (*cell_ptr &amp; (<span class="bn">0x80</span> &gt;&gt; (x &amp; <span class="bn">0x07</span>))) ? <span class="dv">1</span> : <span class="dv">0</span>;
}

<span class="co">/* Counts the number of neighboring on-cells for specified cell. */</span>
<span class="dt">int</span> cellmap::count_neighbors(<span class="dt">int</span> x, <span class="dt">int</span> y)
{
   <span class="dt">unsigned</span> <span class="dt">char</span> *cell_ptr, mask;
   <span class="dt">unsigned</span> <span class="dt">int</span> neighbor_count;

   <span class="co">// Point to upper left neighbor</span>
   cell_ptr = cells + ((y * width_in_bytes) + ((x + <span class="dv">7</span>) / <span class="dv">8</span>));
   mask = <span class="bn">0x80</span> &gt;&gt; ((x - <span class="dv">1</span>) &amp; <span class="bn">0x07</span>);
   <span class="co">// Count upper left neighbor</span>
   neighbor_count = (*cell_ptr &amp; mask) ? <span class="dv">1</span> : <span class="dv">0</span>;
   <span class="co">// Count left neighbor</span>
   <span class="kw">if</span> ((*(cell_ptr + width_in_bytes) &amp; mask)) neighbor_count++;
   <span class="co">// Count lower left neighbor</span>
   <span class="kw">if</span> ((*(cell_ptr + (width_in_bytes * <span class="dv">2</span>)) &amp; mask)) neighbor_count++;

   <span class="co">// Point to upper neighbor</span>
   <span class="kw">if</span> ((mask &gt;&gt;= <span class="dv">1</span>) == <span class="dv">0</span>) {
      mask = <span class="bn">0x80</span>;
      cell_ptr++;
   }
   <span class="co">// Count upper neighbor</span>
   <span class="kw">if</span> ((*cell_ptr &amp; mask)) neighbor_count++;
   <span class="co">// Count lower neighbor</span>
   <span class="kw">if</span> ((*(cell_ptr + (width_in_bytes * <span class="dv">2</span>)) &amp; mask))  neighbor_count++;

   <span class="co">// Point to upper right neighbor</span>
   <span class="kw">if</span> ((mask &gt;&gt;= <span class="dv">1</span>) == <span class="dv">0</span>) {
      mask = <span class="bn">0x80</span>;
      cell_ptr++;
   }
   <span class="co">// Count upper right neighbor</span>
   <span class="kw">if</span> ((*cell_ptr &amp; mask)) neighbor_count++;
   <span class="co">// Count right neighbor</span>
   <span class="kw">if</span> ((*(cell_ptr + width_in_bytes) &amp; mask)) neighbor_count++;
   <span class="co">// Count lower right neighbor</span>
   <span class="kw">if</span> ((*(cell_ptr + (width_in_bytes * <span class="dv">2</span>)) &amp; mask))  neighbor_count++;

   <span class="kw">return</span> neighbor_count;
}

<span class="co">/* Calculates the next generation of current_map and stores it in</span>
<span class="co">   next_map. */</span>
<span class="dt">void</span> cellmap::next_generation(cellmap&amp; next_map)
{
   <span class="dt">unsigned</span> <span class="dt">int</span> x, y, neighbor_count;

   <span class="kw">for</span> (y=<span class="dv">0</span>; y&lt;height; y++) {
      <span class="kw">for</span> (x=<span class="dv">0</span>; x&lt;width; x++) {
         neighbor_count = count_neighbors(x, y);
         <span class="kw">if</span> (cell_state(x, y) == <span class="dv">1</span>) {
            <span class="kw">if</span> ((neighbor_count != <span class="dv">2</span>) &amp;&amp; (neighbor_count != <span class="dv">3</span>)) {
               next_map.clear_cell(x, y);    <span class="co">// turn it off</span>
               draw_pixel(x, y, OFF_COLOR);
            }
         } <span class="kw">else</span> {
            <span class="kw">if</span> (neighbor_count == <span class="dv">3</span>) {
               next_map.set_cell(x, y);      <span class="co">// turn it on</span>
               draw_pixel(x, y, ON_COLOR);
            }
         }
      }
   }
}</code></pre>
<p>In Listing 17.3, note the padded cellmap edges, and the alteration of the member functions to compensate for the padding. Also note that the width now has to be a multiple of eight, to facilitate the process of copying the edges to the opposite padding bytes. We have decreased the generality of our Game of Life implementation in exchange for better performance. That’s a very common trade-off, as common as trading memory for performance. As a rule, the more general a program is, the slower it is. A corollary is that often (not always, but often), the more heavily optimized a program is, the more complex and the more difficult to implement it is. You can often improve performance a good deal by implementing only the level of generality you need, but at the same time decreased generality makes it more difficult to change or port the program at some later date. A Game of Life implementation, such as Listing 17.1, that’s built on <code>set_cell()</code>, <code>clear_cell()</code>, and <code>get_cell()</code> is completely general; you can change the cell storage format simply by changing the constructor and those three functions. Listing 17.3 is harder to change because <code>count_neighbors()</code> would also have to be altered, and it’s more complex than any of the other functions.</p>
<p>So, in Listing 17.3, we’ve gotten under the hood and changed the cellmap format a little, and gotten impressive results. But now <code>count_neighbors()</code> is hard-wired for optimized counting, and it’s still taking up more than half the time. Maybe now it’s time to go to assembly?</p>
<p>Not hardly.</p>
</section>
<section id="heavy-duty-c-optimization" class="level3">
<h3><a href="#heavy-duty-c-optimization">Heavy-Duty C++ Optimization</a></h3>
<p>Before we get to assembly, we still have to perform C++ optimization, then see if we can find an alternative approach that better fits the application. It would actually have made much more sense if we had looked for a new approach as our first optimization step, but I decided it would be better to cover straightforward C++ optimizations at this point, and the mind-bending stuff a little later. Right now, let’s look at some C++ optimizations; Listing 17.4 is a C++-optimized version of Listing 17.3.</p>
<p><strong>LISTING 17.4 L17-4.CPP</strong></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* next_generation(), implemented using fast, all-in-one hard-wired</span>
<span class="co">   neighbor count/update/draw function. Otherwise, the same as</span>
<span class="co">   Listing 17.3. */</span>

<span class="co">/* Calculates the next generation of current_map and stores it in</span>
<span class="co">   next_map. */</span>
<span class="dt">void</span> cellmap::next_generation(cellmap&amp; next_map)
{
   <span class="dt">unsigned</span> <span class="dt">int</span> x, y, neighbor_count;
   <span class="dt">unsigned</span> <span class="dt">int</span> width_in_bytesX2 = width_in_bytes &lt;&lt; <span class="dv">1</span>;
   <span class="dt">unsigned</span> <span class="dt">char</span> *cell_ptr, *current_cell_ptr, mask, current_mask;
   <span class="dt">unsigned</span> <span class="dt">char</span> *base_cell_ptr, *row_cell_ptr, base_mask;
   <span class="dt">unsigned</span> <span class="dt">char</span> *dest_cell_ptr = next_map.cells;

   <span class="co">// Process all cells in the current cellmap</span>
   row_cell_ptr = cells;      <span class="co">// point to upper left neighbor of</span>
                              <span class="co">// first cell in cell map</span>
   <span class="kw">for</span> (y=<span class="dv">0</span>; y&lt;height; y++) { <span class="co">// repeat for each row of cells</span>
      <span class="co">// Cell pointer and cell bit mask for first cell in row</span>
      base_cell_ptr = row_cell_ptr; <span class="co">// to access upper left neighbor</span>
      base_mask = <span class="bn">0x01</span>;             <span class="co">// of first cell in row</span>
      <span class="kw">for</span> (x=<span class="dv">0</span>; x&lt;width; x++) {     <span class="co">// repeat for each cell in row</span>
         <span class="co">// First, count neighbors</span>
         <span class="co">// Point to upper left neighbor of current cell</span>
         cell_ptr = base_cell_ptr;  <span class="co">// pointer and bit mask for</span>
         mask = base_mask;          <span class="co">// upper left neighbor</span>
         <span class="co">// Count upper left neighbor</span>
         neighbor_count = (*cell_ptr &amp; mask) ? <span class="dv">1</span> : <span class="dv">0</span>;
         <span class="co">// Count left neighbor</span>
         <span class="kw">if</span> ((*(cell_ptr + width_in_bytes) &amp; mask)) neighbor_count++;
         <span class="co">// Count lower left neighbor</span>
         <span class="kw">if</span> ((*(cell_ptr + width_in_bytesX2) &amp; mask))
neighbor_count++;
         <span class="co">// Point to upper neighbor</span>
         <span class="kw">if</span> ((mask &gt;&gt;= <span class="dv">1</span>) == <span class="dv">0</span>) {
            mask = <span class="bn">0x80</span>;
            cell_ptr++;
         }
         <span class="co">// Remember where to find the current cell</span>
         current_cell_ptr = cell_ptr + width_in_bytes;
         current_mask = mask;
         <span class="co">// Count upper neighbor</span>
         <span class="kw">if</span> ((*cell_ptr &amp; mask)) neighbor_count++;
         <span class="co">// Count lower neighbor</span>
         <span class="kw">if</span> ((*(cell_ptr + width_in_bytesX2) &amp; mask))
               neighbor_count++;
         <span class="co">// Point to upper right neighbor</span>
         <span class="kw">if</span> ((mask &gt;&gt;= <span class="dv">1</span>) == <span class="dv">0</span>) {
            mask = <span class="bn">0x80</span>;
            cell_ptr++;
         }
         <span class="co">// Count upper right neighbor</span>
         <span class="kw">if</span> ((*cell_ptr &amp; mask)) neighbor_count++;
         <span class="co">// Count right neighbor</span>
         <span class="kw">if</span> ((*(cell_ptr + width_in_bytes) &amp; mask))  neighbor_count++;
         <span class="co">// Count lower right neighbor</span>
         <span class="kw">if</span> ((*(cell_ptr + width_in_bytesX2) &amp; mask))
               neighbor_count++;
         <span class="kw">if</span> (*current_cell_ptr &amp; current_mask) {
            <span class="kw">if</span> ((neighbor_count != <span class="dv">2</span>) &amp;&amp; (neighbor_count != <span class="dv">3</span>)) {
               *(dest_cell_ptr + (current_cell_ptr - cells)) &amp;=
                     ~current_mask;    <span class="co">// turn off cell</span>
               draw_pixel(x, y, OFF_COLOR);
            }
         } <span class="kw">else</span> {
            <span class="kw">if</span> (neighbor_count == <span class="dv">3</span>) {
               *(dest_cell_ptr + (current_cell_ptr - cells)) |=
                     current_mask;     <span class="co">// turn on cell</span>
               draw_pixel(x, y, ON_COLOR);
            }
         }
         <span class="co">// Advance to the next cell on row</span>
         <span class="kw">if</span> ((base_mask &gt;&gt;= <span class="dv">1</span>) == <span class="dv">0</span>) {
            base_mask = <span class="bn">0x80</span>;
            base_cell_ptr++;  <span class="co">// advance to the next cell byte</span>
         }
      }
      row_cell_ptr += width_in_bytes;  <span class="co">// point to start of next row</span>
   }
}</code></pre>
<p>Listing 17.4 and Listing 17.3 are functionally the same; the only difference lies in how <code>next_generation()</code> is implemented. (Only <code>next_generation()</code> is shown in Listing 17.4; the program is otherwise identical to Listing 17.3.) Listing 17.4 applies the following optimizations to <code>next_generation()</code>:</p>
<p>The neighbor-counting code is brought into <code>next_generation</code>, eliminating many function calls and from-scratch address/mask calculations; all multiplies are eliminated by using pointers and addition; and all cells are accessed directly via pointers and masks, eliminating all remaining function calls and from-scratch address/mask calculations.</p>
<p>The net effect of these optimizations is that Listing 17.4 is more than twice as fast as Listing 17.3; we’ve achieved the desired 18 generations per second, albeit only on a 486, and only at 96x96. (The <code>#define</code> that enables code limiting the speed to 18 Hz, which seemed ridiculous in Listing 17.1, is actually useful for keeping the generations from iterating too quickly when Listing 17.4 is running on a 486, especially with a small cellmap like 48x48.) We’ve sped things up by about eight times so far; we need to increase our speed another ten times to reach our goal of 200x200 at 18 generations per second on a 20 MHz 386.</p>
<p>It’s undoubtedly possible to improve the performance of Listing 17.4 further by fine-tuning the code, but no tremendous improvement is possible that way.</p>
<blockquote>
<p><img src="images/i.jpg" /> Once you’ve reached the point of fine-tuning pointer usage and register variables and the like in C or C++, you’ve become compiler-dependent; you therefore might as well go to assembly and get the real McCoy.</p>
</blockquote>
<p>We’re still not ready for assembly, though; what we need is a new perspective that lends itself to vastly better performance in C++. The Life program in the next section is <em>three to seven times</em> faster than Listing 17.4—and it’s still in C++.</p>
<p>How is this possible? Here are some hints:</p>
<ul>
<li>After a few dozen generations, most of the cellmap consists of cells in the off state.</li>
<li>There are many possible cellmap representations other than one bit-per-pixel.</li>
<li>Cells change state relatively infrequently.</li>
</ul>
</section>
<section id="bringing-in-the-right-brain" class="level3">
<h3><a href="#bringing-in-the-right-brain">Bringing In the Right Brain</a></h3>
<p>In the previous section, we saw how a C++ program could be sped up about eight times simply by rearranging the data and code in straightforward ways. Now we’re going to see how right-brain non-linear optimization can speed things up by another four times—and make the code <em>simpler.</em></p>
<p>Now <em>that’s</em> Zen code optimization.</p>
<p>I have two objectives to achieve in the remainder of this chapter. First, I want to show that optimization consists of many levels, from assembly language up to conceptual design, and that assembly language kicks in pretty late in the optimization process. Second, I want to encourage you to saturate your brain with everything you know about any particular optimization problem, then make space for your right brain to solve the problem.</p>
<section id="re-examining-the-task" class="level4">
<h4><a href="#re-examining-the-task">Re-Examining the Task</a></h4>
<p>Earlier in this chapter, we looked at a straightforward Game of Life implementation, then increased performance considerably by making the implementation a little less abstract and a little less general. We made a small change to the cellmap format, adding padding bytes off the edges so that pointer arithmetic would always work, but the major optimizations were moving the critical code into a single loop and using pointers rather than member functions whenever possible. In other words, we took what we already knew and made it more efficient.</p>
<p>Now it’s time to re-examine the nature of this programming task from the ground up, looking for things that we <em>don’t</em> yet know. Let’s take a moment to review what the Game of Life consists of. The basic task is evolving a new generation, and that’s done by looking at the number of “on” neighbors a cell has and the cell’s own state. If a cell is on, and two or three neighbors are on, then the cell stays on; otherwise, an on-cell is turned off. If a cell is off and exactly three neighbors are on, then the cell is turned on; otherwise, an off-cell stays off. That’s all there is to it. As any fool can see, the trick is to arrange things so that we can count neighbors and check the cell state as quickly as possible. Large lookup tables, oddly encoded cellmaps, and lots of bit-twiddling assembly code spring to mind as possible approaches. Can’t you just feel your adrenaline start to pump?</p>
<blockquote>
<p><img src="images/i.jpg" /> Relax. Step back. Try to divine the true nature of the problem. The object is not to count neighbors and check cell states as quickly as possible; that’s just one possible implementation. The object is to determine when a cell’s state must be changed and to change it appropriately, and that’s what we need to do as quickly as possible.</p>
</blockquote>
<p>What difference does that new perspective make? Let’s approach it this way. What does a typical cellmap look like? As it happens, after a few generations, the vast majority of cells are off. In fact, the vast majority of cells are not only off but are entirely surrounded by off-cells. Also, cells change state infrequently; in any given generation after the first few, most cells remain in the same state as in the previous generation.</p>
<p>Do you see where I’m heading? Do you hear a whisper of inspiration from your right brain? The original implementation stored cell states as 1-bits (on), or 0-bits (off). For each generation and for each cell, it counted the states of the eight neighbors, for an average of eight operations per cell per generation. Suppose, now, that on average 10 percent of cells change state from one generation to the next. (The actual percentage is even lower, but this will do for illustration.) Suppose also that we change the cell map format to store a byte rather than a bit for each cell, with the byte storing not only the cell state but also the count of neighboring on-cells for that cell. Figure 17.3 shows this format. Then, rather than counting neighbors each time, we could just look at the neighbor count in the cell and operate directly from that.</p>
<p>But what about the overhead needed to maintain the neighbor counts? Well, each time a cell changes state, eight operations would be needed to update the counts in the eight neighboring cells. But this happens only once every ten cells, on average—so the cost of this approach is only one-tenth that of the original approach!</p>
<p><em>Know your data.</em></p>
<figure>
<img src="images/17-03.jpg" alt="Figure 17.3  New cell format." /><figcaption><strong>Figure 17.3</strong>  <em>New cell format.</em></figcaption>
</figure>
</section>
<section id="acting-on-what-we-know" class="level4">
<h4><a href="#acting-on-what-we-know">Acting on What We Know</a></h4>
<p>Once we’ve changed the cellmap format to store neighbor counts as well as states, with a byte for each cell, we can get another performance boost by again examining what we know about our data. I said earlier that most cells are off during any given generation. This means that most cells have no neighbors that are on. Since the cell map representation for an off-cell that has no neighbors is a zero byte, we can skip over scads of unchanged cells at a pop simply by scanning for non-zero bytes. This is much faster than explicitly testing cell states and neighbor counts, and lends itself beautifully to assembly language implementation as <code>REPZ SCASB</code> or (with a little cleverness) <code>REPZ SCASW</code>. (Unfortunately, there’s no C library function that can scan memory for the next byte that’s non-zero.)</p>
<p>Listing 17.5 is a Game of Life implementation that uses the neighbor-count cell map format and scans for non-zero bytes. On a 20 MHz 386, Listing 17.5 is about 4.5 times faster at calculating generations (that is, the generation engine is 4.5 times faster; I’m ignoring the time consumed by drawing and text display) than Listing 17.4, which is no slouch. On a 33 MHz 486, Listing 17.5 is about 3.5 times faster than Listing 17.4. This is true even though Listing 17.5 must be compiled using the large model. Imagine that—getting a four times speed-up while switching from the small model to the large model!</p>
<p><strong>LISTING 17.5 L17-5.CPP</strong></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* C++ Game of Life implementation for any mode for which mode set</span>
<span class="co">   and draw pixel functions can be provided. The cellmap stores the</span>
<span class="co">   neighbor count for each cell as well as the state of each cell;</span>
<span class="co">   this allows very fast next-state determination. Edges always wrap</span>
<span class="co">   in this implementation.</span>
<span class="co">   Tested with Borland C++. To run, link with Listing 17.2</span>
<span class="co">   in the large model. */</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;iostream.h&gt;</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;time.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &lt;bios.h&gt;</span>
<span class="ot">#include &lt;mem.h&gt;</span>

<span class="ot">#define ON_COLOR  15       </span><span class="co">// on-cell pixel color</span>
<span class="ot">#define OFF_COLOR 0        </span><span class="co">// off-cell pixel color</span>
<span class="ot">#define MSG_LINE  10       </span><span class="co">// row for text messages</span>
<span class="ot">#define GENERATION_LINE 12 </span><span class="co">// row for generation # display</span>
<span class="ot">#define LIMIT_18_HZ  0     </span><span class="co">// set 1 to to maximum frame rate = 18Hz</span>

<span class="kw">class</span> cellmap {
<span class="kw">private</span>:
   <span class="dt">unsigned</span> <span class="dt">char</span> *cells;
   <span class="dt">unsigned</span> <span class="dt">char</span> *temp_cells;
   <span class="dt">unsigned</span> <span class="dt">int</span> width;
   <span class="dt">unsigned</span> <span class="dt">int</span> height;
   <span class="dt">unsigned</span> <span class="dt">int</span> length_in_bytes;
<span class="kw">public</span>:
   cellmap(<span class="dt">unsigned</span> <span class="dt">int</span> h, <span class="dt">unsigned</span> <span class="dt">int</span> v);
   ~cellmap(<span class="dt">void</span>);
   <span class="dt">void</span> set_cell(<span class="dt">unsigned</span> <span class="dt">int</span> x, <span class="dt">unsigned</span> <span class="dt">int</span> y);
   <span class="dt">void</span> clear_cell(<span class="dt">unsigned</span> <span class="dt">int</span> x, <span class="dt">unsigned</span> <span class="dt">int</span> y);
   <span class="dt">int</span> cell_state(<span class="dt">int</span> x, <span class="dt">int</span> y);
   <span class="dt">int</span> count_neighbors(<span class="dt">int</span> x, <span class="dt">int</span> y);
   <span class="dt">void</span> next_generation(<span class="dt">void</span>);
   <span class="dt">void</span> init(<span class="dt">void</span>);
};

<span class="kw">extern</span> <span class="dt">void</span> enter_display_mode(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">void</span> exit_display_mode(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">void</span> draw_pixel(<span class="dt">unsigned</span> <span class="dt">int</span> X, <span class="dt">unsigned</span> <span class="dt">int</span> Y,
   <span class="dt">unsigned</span> <span class="dt">int</span> Color);
<span class="kw">extern</span> <span class="dt">void</span> show_text(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">char</span> *text);

<span class="co">/* Controls the size of the cell map. Must be within the capabilities</span>
<span class="co">   of the display mode, and must be limited to leave room for text</span>
<span class="co">   display at right. */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> cellmap_width = <span class="dv">96</span>;
<span class="dt">unsigned</span> <span class="dt">int</span> cellmap_height = <span class="dv">96</span>;

<span class="co">/* Width &amp; height in pixels of each cell. */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> magnifier = <span class="dv">2</span>;

<span class="co">/* Randomizing seed */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> seed;

<span class="dt">void</span> main()
{
   <span class="dt">unsigned</span> <span class="dt">long</span> generation = <span class="dv">0</span>;
   <span class="dt">char</span> gen_text[<span class="dv">80</span>];
   <span class="dt">long</span> bios_time, start_bios_time;

   cellmap current_map(cellmap_height, cellmap_width);

   current_map.init();  <span class="co">// randomly initialize cell map</span>

   enter_display_mode();

   <span class="co">// Keep recalculating and redisplaying generations until any key</span>
   <span class="co">// is pressed</span>
   show_text(<span class="dv">0</span>, MSG_LINE, <span class="st">&quot;Generation: &quot;</span>);
   start_bios_time = _bios_timeofday(_TIME_GETCLOCK, &amp;bios_time);
   <span class="kw">do</span> {
      generation++;
      sprintf(gen_text, <span class="st">&quot;%10lu&quot;</span>, generation);
      show_text(<span class="dv">1</span>, GENERATION_LINE, gen_text);
      <span class="co">// Recalculate and draw the next generation</span>
      current_map.next_generation();
<span class="ot">#if LIMIT_18_HZ</span>
      <span class="co">// Limit to a maximum of 18.2 frames per second, for visibility</span>
      <span class="kw">do</span> {
         _bios_timeofday(_TIME_GETCLOCK, &amp;bios_time);
      } <span class="kw">while</span> (start_bios_time == bios_time);
      start_bios_time = bios_time;
<span class="ot">#endif</span>
   } <span class="kw">while</span> (!kbhit());

   getch();    <span class="co">// clear keypress</span>
   exit_display_mode();
   cout &lt;&lt; <span class="st">&quot;Total generations: &quot;</span> &lt;&lt; generation &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">Seed: &quot;</span> &lt;&lt;
         seed &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
}

<span class="co">/* cellmap constructor. */</span>
cellmap::cellmap(<span class="dt">unsigned</span> <span class="dt">int</span> h, <span class="dt">unsigned</span> <span class="dt">int</span> w)
{
   width = w;
   height = h;
   length_in_bytes = w * h;
   cells = <span class="kw">new</span> <span class="dt">unsigned</span> <span class="dt">char</span>[length_in_bytes];  <span class="co">// cell storage</span>
   temp_cells = <span class="kw">new</span> <span class="dt">unsigned</span> <span class="dt">char</span>[length_in_bytes]; <span class="co">// temp cell storage</span>
   <span class="kw">if</span> ( (cells == NULL) || (temp_cells == NULL) ) {
      printf(<span class="st">&quot;Out of memory</span><span class="ch">\n</span><span class="st">&quot;</span>);
      exit(<span class="dv">1</span>);
   }
   memset(cells, <span class="dv">0</span>, length_in_bytes);  <span class="co">// clear all cells, to start</span>
}

<span class="co">/* cellmap destructor. */</span>
cellmap::~cellmap(<span class="dt">void</span>)
{
   <span class="kw">delete</span>[] cells;
   <span class="kw">delete</span>[] temp_cells;
}

<span class="co">/* Turns an off-cell on, incrementing the on-neighbor count for the</span>
<span class="co">   eight neighboring cells. */</span>
<span class="dt">void</span> cellmap::set_cell(<span class="dt">unsigned</span> <span class="dt">int</span> x, <span class="dt">unsigned</span> <span class="dt">int</span> y)
{
   <span class="dt">unsigned</span> <span class="dt">int</span> w = width, h = height;
   <span class="dt">int</span> xoleft, xoright, yoabove, yobelow;
   <span class="dt">unsigned</span> <span class="dt">char</span> *cell_ptr = cells + (y * w) + x;

   <span class="co">// Calculate the offsets to the eight neighboring cells,</span>
   <span class="co">// accounting for wrapping around at the edges of the cell map</span>
   <span class="kw">if</span> (x == <span class="dv">0</span>)
      xoleft = w - <span class="dv">1</span>;
   <span class="kw">else</span>
      xoleft = -<span class="dv">1</span>;
   <span class="kw">if</span> (y == <span class="dv">0</span>)
      yoabove = length_in_bytes - w;
   <span class="kw">else</span>
      yoabove = -w;
   <span class="kw">if</span> (x == (w - <span class="dv">1</span>))
      xoright = -(w - <span class="dv">1</span>);
   <span class="kw">else</span>
      xoright = <span class="dv">1</span>;
   <span class="kw">if</span> (y == (h - <span class="dv">1</span>))
      yobelow = -(length_in_bytes - w);
   <span class="kw">else</span>
      yobelow = w;

   *(cell_ptr) |= <span class="bn">0x01</span>;
   *(cell_ptr + yoabove + xoleft) += <span class="dv">2</span>;
   *(cell_ptr + yoabove) += <span class="dv">2</span>;
   *(cell_ptr + yoabove + xoright) += <span class="dv">2</span>;
   *(cell_ptr + xoleft) += <span class="dv">2</span>;
   *(cell_ptr + xoright) += <span class="dv">2</span>;
   *(cell_ptr + yobelow + xoleft) += <span class="dv">2</span>;
   *(cell_ptr + yobelow) += <span class="dv">2</span>;
   *(cell_ptr + yobelow + xoright) += <span class="dv">2</span>;
}

<span class="co">/* Turns an on-cell off, decrementing the on-neighbor count for the</span>
<span class="co">   eight neighboring cells. */</span>
<span class="dt">void</span> cellmap::clear_cell(<span class="dt">unsigned</span> <span class="dt">int</span> x, <span class="dt">unsigned</span> <span class="dt">int</span> y)
{
   <span class="dt">unsigned</span> <span class="dt">int</span> w = width, h = height;
   <span class="dt">int</span> xoleft, xoright, yoabove, yobelow;
   <span class="dt">unsigned</span> <span class="dt">char</span> *cell_ptr = cells + (y * w) + x;

   <span class="co">// Calculate the offsets to the eight neighboring cells,</span>
   <span class="co">// accounting for wrapping around at the edges of the cell map</span>
   <span class="kw">if</span> (x == <span class="dv">0</span>)
      xoleft = w - <span class="dv">1</span>;
   <span class="kw">else</span>
      xoleft = -<span class="dv">1</span>;
   <span class="kw">if</span> (y == <span class="dv">0</span>)
      yoabove = length_in_bytes - w;
   <span class="kw">else</span>
      yoabove = -w;
   <span class="kw">if</span> (x == (w - <span class="dv">1</span>))
      xoright = -(w - <span class="dv">1</span>);
   <span class="kw">else</span>
      xoright = <span class="dv">1</span>;
   <span class="kw">if</span> (y == (h - <span class="dv">1</span>))
      yobelow = -(length_in_bytes - w);
   <span class="kw">else</span>
      yobelow = w;

   *(cell_ptr) &amp;= ~<span class="bn">0x01</span>;
   *(cell_ptr + yoabove + xoleft) -= <span class="dv">2</span>;
   *(cell_ptr + yoabove ) -= <span class="dv">2</span>;
   *(cell_ptr + yoabove + xoright) -= <span class="dv">2</span>;
   *(cell_ptr + xoleft) -= <span class="dv">2</span>;
   *(cell_ptr + xoright) -= <span class="dv">2</span>;
   *(cell_ptr + yobelow + xoleft) -= <span class="dv">2</span>;
   *(cell_ptr + yobelow) -= <span class="dv">2</span>;
   *(cell_ptr + yobelow + xoright) -= <span class="dv">2</span>;
}

<span class="co">/* Returns cell state (1=on or 0=off). */</span>
<span class="dt">int</span> cellmap::cell_state(<span class="dt">int</span> x, <span class="dt">int</span> y)
{
   <span class="dt">unsigned</span> <span class="dt">char</span> *cell_ptr;

   cell_ptr = cells + (y * width) + x;
   <span class="kw">return</span> *cell_ptr &amp; <span class="bn">0x01</span>;
}

<span class="co">/* Calculates and displays the next generation of current_map */</span>
<span class="dt">void</span> cellmap::next_generation()
{
   <span class="dt">unsigned</span> <span class="dt">int</span> x, y, count;
   <span class="dt">unsigned</span> <span class="dt">int</span> h = height, w = width;
   <span class="dt">unsigned</span> <span class="dt">char</span> *cell_ptr, *row_cell_ptr;

   <span class="co">// Copy to temp map, so we can have an unaltered version from</span>
   <span class="co">// which to work</span>
   memcpy(temp_cells, cells, length_in_bytes);

   <span class="co">// Process all cells in the current cell map</span>
   cell_ptr = temp_cells;     <span class="co">// first cell in cell map</span>
   <span class="kw">for</span> (y=<span class="dv">0</span>; y&lt;h; y++) {      <span class="co">// repeat for each row of cells</span>
   <span class="co">// Process all cells in the current row of the cell map</span>
      x = <span class="dv">0</span>;
      <span class="kw">do</span> {        <span class="co">// repeat for each cell in row</span>
                  <span class="co">// Zip quickly through as many off-cells with no</span>
                  <span class="co">// neighbors as possible</span>
         <span class="kw">while</span> (*cell_ptr == <span class="dv">0</span>) {
            cell_ptr++; <span class="co">// advance to the next cell</span>
            <span class="kw">if</span> (++x &gt;= w) <span class="kw">goto</span> RowDone;
         }
         <span class="co">// Found a cell that&#39;s either on or has on-neighbors,</span>
         <span class="co">// so see if its state needs to be changed</span>
         count = *cell_ptr &gt;&gt; <span class="dv">1</span>; <span class="co">// # of neighboring on-cells</span>
         <span class="kw">if</span> (*cell_ptr &amp; <span class="bn">0x01</span>) {
            <span class="co">// Cell is on; turn it off if it doesn&#39;t have</span>
            <span class="co">// 2 or 3 neighbors</span>
            <span class="kw">if</span> ((count != <span class="dv">2</span>) &amp;&amp; (count != <span class="dv">3</span>)) {
               clear_cell(x, y);
               draw_pixel(x, y, OFF_COLOR);
            }
         } <span class="kw">else</span> {
            <span class="co">// Cell is off; turn it on if it has exactly 3 neighbors</span>
            <span class="kw">if</span> (count == <span class="dv">3</span>) {
               set_cell(x, y);
               draw_pixel(x, y, ON_COLOR);
            }
         }
         <span class="co">// Advance to the next cell</span>
         cell_ptr++; <span class="co">// advance to the next cell byte</span>
      } <span class="kw">while</span> (++x &lt; w);
RowDone:
   }
}

<span class="co">/* Randomly initializes the cellmap to about 50% on-pixels. */</span>
<span class="dt">void</span> cellmap::init()
{
   <span class="dt">unsigned</span> <span class="dt">int</span> x, y, init_length;

   <span class="co">// Get the seed; seed randomly if 0 entered</span>
   cout &lt;&lt; <span class="st">&quot;Seed (0 for random seed): &quot;</span>;
   cin &gt;&gt; seed;
   <span class="kw">if</span> (seed == <span class="dv">0</span>) seed = (<span class="dt">unsigned</span>) time(NULL);

   <span class="co">// Randomly initialize the initial cell map to 50% on-pixels</span>
   <span class="co">// (actually generally fewer, because some coordinates will be</span>
   <span class="co">// randomly selected more than once)</span>
   cout &lt;&lt; <span class="st">&quot;Initializing...&quot;</span>;
   srand(seed);
   init_length = (height * width) / <span class="dv">2</span>;
   <span class="kw">do</span> {
      x = random(width);
      y = random(height);
      <span class="kw">if</span> (cell_state(x, y) == <span class="dv">0</span>) {
         set_cell(x, y);
      }
   } <span class="kw">while</span> (—init_length);
}</code></pre>
<p>The large model is actually not necessary for the 96x96 cellmap in Listing 17.5. However, I was actually more interested in seeing a fast 200x200 cellmap, and two 200x200 cellmaps can’t fit in a single segment. (This can easily be worked around in assembly language for cellmaps up to a segment in size; beyond that size, cellmap scanning becomes pretty complex, although it can still be efficiently implemented with some clever programming.)</p>
<p>Anyway, using the large model helps illustrate that it’s the data representation and the data processing approach you choose that matter most. Optimization details like memory models and segments and in-line functions and assembly language are important but secondary. Let your mind roam creatively before you start coding. Otherwise, you may find you’re writing well-tuned slow code, which is by no means the same thing as fast code.</p>
<p>Take a close look at Listing 17.5. You will see that it’s quite a bit simpler than Listing 17.4. To some extent, that’s because I decided to hard-wire the program to wrap around from one edge of the cellmap to the other (it’s much more interesting that way), but the main reason is that it’s a lot easier to work with the neighbor-count model. There’s no complex mask and pointer management, and the only thing that <em>really</em> needs to be optimized is scanning for zero bytes. (And, in fact, I haven’t optimized even that because it’s done in a C++ loop; it should really be <code>REPZ SCASB</code>.)</p>
<p>In truth, none of the code in Listing 17.5 is particularly well-optimized, and, as I noted, the program must be compiled with the large model for large cellmaps. Also, of course, the entire program is still in C++; note well that there’s not a whit of assembly here.</p>
<blockquote>
<p><img src="images/i.jpg" /> We’ve gotten more than a 30-times speedup simply by removing a little of the abstraction that C++ encourages, and by storing and processing the data in a manner appropriate for the typical nature of the data itself. In other words, we’ve done some linear, left-brained optimization (using pointers and reducing calls) and some non-linear, right-brained optimization (understanding the real problem and listening for the creative whisper of non-obvious solutions).</p>
</blockquote>
<p>No doubt we could get another two to five times improvement with good assembly code—but that’s dwarfed by a 30-times improvement, so optimization at a conceptual level <em>must</em> come first.</p>
</section>
<section id="the-challenge-that-ate-my-life" class="level4">
<h4><a href="#the-challenge-that-ate-my-life">The Challenge That Ate My Life</a></h4>
<p>The most recent optimization challenge I laid my community of readers was to write the fastest possible Game of Life generation engine. By “engine” I meant that I didn’t care about time spent in input or output, only time consumed by the call to <strong>next-generation.</strong> The time spent updating the cellmap was what I wanted people to concentrate on.</p>
<p>Here are the rules I laid down for the challenge:</p>
<ul>
<li>Readers could modify any code in Listing 17.5, except the main loop, as well as change the cell map representation any way they liked. However, the code had to produce exactly the same output as Listing 17.5 under all circumstances in order to be eligible to win.</li>
<li>Engine code had to be less than 400 lines long <em>in total,</em> excluding the video-related code shown in Listing 17.2.</li>
<li>Submissions had to compile/assemble with Borland C++ (in either C++ or C mode, as desired) and/or TASM.</li>
<li>All submissions had to handle cellmaps at least 200x200 in size.</li>
<li>Assembly language could of course be used to speed up any part of the program. C rather than C++ was legal as well, so long as entered implementations produced the same results as Listing 17.5 and 17.2 together and were less than 400 lines long.</li>
<li>All entries would be timed on the same 33 MHz 486 with a 256K external cache.</li>
</ul>
<p>That was the challenge I put to the readers. Little did I realize the challenge it would lay on <em>me:</em> Entries poured in from the four corners of the globe. Some were plain, some were brilliant, some were, well, berserk. Many didn’t even work. But all had to be gone through, examined for adherence to the rules, read, compiled, linked, run, and judged. I learned a lot—about a lot of things, not the least of which was the process (or maybe the wisdom) of laying down challenges to readers.</p>
<p>Who won? What did I learn? To find out, read on.</p>
</section>
</section>
</section>
<section id="chapter-18-its-a-plain-wonderful-life" class="level2">
<h2><a href="#chapter-18-its-a-plain-wonderful-life">Chapter 18 – It’s a plain Wonderful Life</a></h2>
<section id="optimization-beyond-the-pale" class="level3">
<h3><a href="#optimization-beyond-the-pale">Optimization beyond the Pale</a></h3>
<p>When I was in high school, my gym teacher had us run a race around the soccer field, or rather, around a course marked with cones that roughly outlined the shape of the field. I quickly settled into second place behind Dwight Chamberlin. We cruised around the field, and when we came to the far corner, Dwight cut across the corner, inside a cone placed awkwardly far out from the others. I followed, and everyone else cut inside the cone too—except the pear-shaped kid bringing up the rear, who plodded his way around every single cone on his way to finishing about half a lap behind. When the laggard finally crossed the finish line, the coach named him the winner, to my considerable irritation. After all, the object was to see who could run the fastest, wasn’t it?</p>
<p>Actually, it wasn’t. The object was to see who could run the fastest according to the limitations placed upon the contest. This is a crucial distinction, although usually taken for granted. Would it have been legitimate if I had cut across the middle of the field? If I had ridden a bike? If I had broken the world record for the 100 meters by dropping 100 meters from a plane? Competition has meaning only within a carefully circumscribed arena.</p>
<p>Why am I telling you this? First, because it is a useful lesson for programming.</p>
<blockquote>
<p><img src="images/i.jpg" /> All programming is performed within limitations, some of which can be bent or changed, but many of which cannot. You cannot change the maximum memory bandwidth of a VGA, or the maximum instruction execution rate of a 486. That is why the stunning 3D demos you see at SIGGRAPH have only passing relevance to everyday life on the desktop. A rule that Intel’s chip designers cannot break is 8086 compatibility, much as I’m sure they’d like to, but of course the flip side is that although RISC chips are technically superior, they command but a small fraction of the market; raw performance is not the arena of competition. Similarly, you will often be unable to change the specifications for the software you implement.</p>
</blockquote>
</section>
<section id="breaking-the-rules" class="level3">
<h3><a href="#breaking-the-rules">Breaking the Rules</a></h3>
<p>The other reason for the anecdote has to do with the way my second Optimization Challenge worked itself out. If you’ll recall from the last chapter, the challenge I made to the readers of <em>PC TECHNIQUES</em> was to devise the fastest possible version of the Game of Life cellular automata simulation game. I gave an example, laid out the rules, and stood aside. Good thing, too. <em>Apres moi, le deluge….</em></p>
<p>And when the dust had settled, I was left with the uneasy realization that every submitted entry broke the rules. <em>Every single entry</em>. The rules clearly stated that submitted code must produce <em>exactly the same output</em> as my example implementation under all circumstances in order to be eligible to win. I do not think that there can be any question about what “exactly the same output” means. It means the same pixels, in the same colors, at the same places on the screen at the same points in all the Life simulations that the original code was capable of running. Period. And not one of the entries met that standard. Some submitted listings were more than 400 lines long. Some didn’t display the generation number at the right side of the screen, didn’t draw the same pixel colors, or didn’t bother with magnification. Some had bugs. Some didn’t support all possible cellmap widths and heights up to 200x200, requiring widths and heights that were specific multiples of a number of cells that lent itself to a particular implementation.</p>
<p>This last mission is, in a way, a brilliant approach, as evidenced by the fact that it yielded the two fastest submissions, but it is not within the rules of the contest. Some of the rule-breaking was major, some very minor, and some had nothing to do with the Life engine itself, but the rules were clear; where was I to draw the line if not with exact compliance? And I was fully prepared to draw that line rigorously, disqualifying some mind-bending submissions in order to let lesser but fully compliant entries win—until I realized that there <em>were</em> no fully compliant entries.</p>
<p>Given which, I heaved a sigh of relief, threw away the rules, and picked a winner in the true spirit of the contest: raw speed. Two winners, in fact: Peter Klerings, a programmer for Turck GmbH in Munich, Germany, whose entry just plain runs like a bat out of hell, and David Stafford (who was also the winner of my first Optimization Challenge), of Borland International, whose entry is slightly slower mainly because he didn’t optimize the drawing part of the program, in full accordance with the contest rules, which specifically excluded drawing time from consideration. Unfortunately, Peter’s generation code and drawing code are so tightly intertwined that it is impossible to separate them, and hence not really possible to figure out whose generation engine is faster. Anyway, at 180 to 200 generations per second, including drawing time, for 200x200 cellmaps (and in the neighborhood of <em>1000</em> gps for 96x96 cellmaps, the size of my original implementation), they’re the fastest submissions I received. They’re both more than an order of magnitude faster than my final optimized C++ Life implementation shown in Chapter 17, and more than 300 times faster than my original, perfectly functional Life implementation. Not 300 percent—300 <em>times</em>. Cell generations scud across the screen like clouds, and walkers shoot out like bullets. Each is a worthy winner, and I feel confident that the true objective of the challenge has been met: pure, breathtaking <em>speed</em>.</p>
<p>Notwithstanding, <em>mea culpa</em>. The next time I lay a challenge, I will define the rules with scrupulous care. Even so, this was much more than just another cycle-counting contest. We’re fortunate enough to be privy to a startling demonstration of the power of the best optimizer anyone has yet devised—you. (That’s the general “you”; I realize that the specific “you” may or may not be quite up to the optimizing level of the specific “David Stafford” or “Peter Klerings.”)</p>
<p>Onward to the code.</p>
</section>
<section id="table-driven-magic" class="level3">
<h3><a href="#table-driven-magic">Table-Driven Magic</a></h3>
<p>David Stafford won my first Optimization Challenge by means of a huge look-up table and an incredible state machine driven by that table. The table didn’t cause David’s entry to exceed the line limit because David’s submission included code to generate the table on the fly as part of the build process. David has done himself one better this time with his QLIFE program; not only does his build process generate a 64K table, but it also generates virtually all his code, consisting of 17,000-plus lines of assembly language spanning another 64K. What David has done is write the equivalent of a bitblt compiler for the Game of Life; one might in fact call it a Life compiler. What David’s code generates is still a general-purpose program; it takes arbitrary seed values, and can run for an arbitrary number of generations, so it’s not as if David simply hardwired the instructions to draw each successive screen. However, it’s a general-purpose program that is exquisitely tailored to the task it needs to perform.</p>
<p>All the pieces of QLIFE are shown in Listings 18.1 through 18.5, as follows: Listing 18.1 is BUILD.BAT, the batch file used to build QLIFE; Listing 18.2 is LCOMP.C, the program used to generate the assembler code and data file QLIFE.ASM; Listing 18.3 is MAIN.C, the main program for QLIFE; Listing 18.4 is VIDEO.C, the video-related functions, and Listing 18.5 is LIFE.H, the header file. The following sidebar contains David’s build instructions, exactly as he wrote them. I certainly won’t have room to discuss all the marvelous intricacies of David’s code; I suggest you look over these listings until you understand them thoroughly (it took me a day to pick them apart) because there’s a lot of neat stuff in there, and it’s an approach to performance programming that operates at a more efficient, tightly integrated level than you may ever see again. One hint: It helps a <em>lot</em> to build and run LCOMP.C, redirect its output to QLIFE.ASM, and look at the assembly code in that file. This code is the entirety of David’s generation engine, and it’s almost impossible to visualize its operation without actually seeing it.</p>
<blockquote>
<p>How To Build Qlife</p>
<p>QLIFE is written for Borland C++, but it shouldn’t be too difficult to convert it to work with Microsoft C++. To build QLIFE, run the BUILD.BAT batch file with the size of the life grid on the command line (see below). The command-line options are:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">WIDTH 32</td>
<td style="text-align: left;">Sets the width of the life grid to 96 cells (divided by 3).</td>
</tr>
<tr class="even">
<td style="text-align: left;">HEIGHT 96</td>
<td style="text-align: left;">Sets the height of the life grid to 96 cells.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NOCOUNTER</td>
<td style="text-align: left;">Turns off the generation counter (optional).</td>
</tr>
<tr class="even">
<td style="text-align: left;">NODRAW</td>
<td style="text-align: left;">Turns off drawing of the cell map (optional).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">GEN 1000</td>
<td style="text-align: left;">Calculates 1,000 generations (optional).</td>
</tr>
</tbody>
</table>
<p>These <em>must</em> be in uppercase. For example, the minimum you really need is “WIDTH 40 HEIGHT 120.” I used “WIDTH 46 HEIGHT 138 NOCOUNTER NODRAW GEN 7000” during testing.</p>
<p>If you have selected the GEN option, you will have to press a key to exit QLIFE when it is finished. This is so I could visually compare the result of N generations under QLIFE with N generations under Abrash’s original life program. You should be aware that the program from the listing contains a small bug, which may make it appear that they do not generate identical results. The original program does not display a cell until it changes, so if a cell is alive on the first generation and never dies, then it will never be displayed. This bug is not present in QLIFE.</p>
<p>You should have no trouble running QLIFE with cell grids up to 210x200.</p>
<p>You <em>must</em> have a VGA and at least a 386 to run QLIFE. The 386 features that it uses are not integral to the algorithm (they’re a convenience for the code), so feel free to modify QLIFE to run on earlier CPUs if you wish. QLIFE works best if you have a large CPU cache (256K is recommended).</p>
<p>—<em>David Stafford</em></p>
</blockquote>
<p><strong>LISTING 18.1 BUILD.BAT</strong></p>
<pre class="bat"><code>bcc -v -D%1=%2;%2=%3;%3=%4;%4=%5;%5=%6;%6=%7;%7=%8;%8 lcomp.c
lcomp &gt; qlife.asm
tasmx /mx /kh30000 qlife
bcc -v -D%1=%2;%2=%3;%3=%4;%4=%5;%5=%6;%6=%7;%7=%8;%8 qlife.obj main.c video.c</code></pre>
<p><strong>LISTING 18.2 LCOMP.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// LCOMP.C</span>
<span class="co">//</span>
<span class="co">// Life compiler, ver 1.3</span>
<span class="co">//</span>
<span class="co">// David Stafford</span>
<span class="co">//</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &quot;life.h&quot;</span>

<span class="ot">#define LIST_LIMIT (46 * 138)  </span><span class="co">// when we need to use es:</span>

<span class="dt">int</span> Old, New, Edge, Label;
<span class="dt">char</span> Buf[ <span class="dv">20</span> ];

<span class="dt">void</span> Next1( <span class="dt">void</span> )
  {
  <span class="dt">char</span> *Seg = <span class="st">&quot;&quot;</span>;

  <span class="kw">if</span>( WIDTH * HEIGHT &gt; LIST_LIMIT )  Seg = <span class="st">&quot;es:&quot;</span>;

  printf( <span class="st">&quot;mov  bp,%s[si]</span><span class="ch">\n</span><span class="st">&quot;</span>, Seg );
  printf( <span class="st">&quot;add  si,2</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  dh,[bp+1]</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;and  dh,0FEh</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;jmp  dx</span><span class="ch">\n</span><span class="st">&quot;</span> );
  }

<span class="dt">void</span> Next2( <span class="dt">void</span> )
  {
  printf( <span class="st">&quot;mov  bp,es:[si]</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;add  si,2</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  dh,[bp+1]</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;or   dh,1</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;jmp  dx</span><span class="ch">\n</span><span class="st">&quot;</span> );
  }

<span class="dt">void</span> BuildMaps( <span class="dt">void</span> )
  {
  <span class="dt">unsigned</span> <span class="dt">short</span> i, j, Size, x = <span class="dv">0</span>, y, N1, N2, N3, C1, C2, C3;

  printf( <span class="st">&quot;_DATA segment ‘DATA&#39;</span><span class="ch">\n</span><span class="st">align 2</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;public _CellMap</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;_CellMap label word</span><span class="ch">\n</span><span class="st">&quot;</span> );

  <span class="kw">for</span>( j = <span class="dv">0</span>; j &lt; HEIGHT; j++ )
    {
    <span class="kw">for</span>( i = <span class="dv">0</span>; i &lt; WIDTH; i++ )
      {
      <span class="kw">if</span>( i == <span class="dv">0</span> || i == WIDTH<span class="dv">-1</span> || j == <span class="dv">0</span> || j == HEIGHT<span class="dv">-1</span> )
        {
        printf( <span class="st">&quot;dw 8000h</span><span class="ch">\n</span><span class="st">&quot;</span> );
        }
      <span class="kw">else</span>
        {
        printf( <span class="st">&quot;dw 0</span><span class="ch">\n</span><span class="st">&quot;</span> );
        }
      }
    }

  printf( <span class="st">&quot;ChangeCell dw 0</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;_RowColMap label word</span><span class="ch">\n</span><span class="st">&quot;</span> );

  <span class="kw">for</span>( j = <span class="dv">0</span>; j &lt; HEIGHT; j++ )
    {
    <span class="kw">for</span>( i = <span class="dv">0</span>; i &lt; WIDTH; i++ )
      {
      printf( <span class="st">&quot;dw 0%02x%02xh</span><span class="ch">\n</span><span class="st">&quot;</span>, j, i * <span class="dv">3</span> );
      }
    }

  <span class="kw">if</span>( WIDTH * HEIGHT &gt; LIST_LIMIT )
    {
    printf( <span class="st">&quot;Change1 dw offset _CHANGE:_ChangeList1</span><span class="ch">\n</span><span class="st">&quot;</span> );
    printf( <span class="st">&quot;Change2 dw offset _CHANGE:_ChangeList2</span><span class="ch">\n</span><span class="st">&quot;</span> );
    printf( <span class="st">&quot;ends</span><span class="ch">\n\n</span><span class="st">&quot;</span> );
    printf( <span class="st">&quot;_CHANGE segment para public ‘FAR_DATA&#39;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    }
  <span class="kw">else</span>
    {
    printf( <span class="st">&quot;Change1 dw offset DGROUP:_ChangeList1</span><span class="ch">\n</span><span class="st">&quot;</span> );
    printf( <span class="st">&quot;Change2 dw offset DGROUP:_ChangeList2</span><span class="ch">\n</span><span class="st">&quot;</span> );
    }

  Size = WIDTH * HEIGHT + <span class="dv">1</span>;

  printf( <span class="st">&quot;public _ChangeList1</span><span class="ch">\n</span><span class="st">_ChangeList1 label word</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;dw %d dup (offset DGROUP:ChangeCell)</span><span class="ch">\n</span><span class="st">&quot;</span>, Size );
  printf( <span class="st">&quot;public _ChangeList2</span><span class="ch">\n</span><span class="st">_ChangeList2 label word</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;dw %d dup (offset DGROUP:ChangeCell)</span><span class="ch">\n</span><span class="st">&quot;</span>, Size );
  printf( <span class="st">&quot;ends</span><span class="ch">\n\n</span><span class="st">&quot;</span> );

  printf( <span class="st">&quot;_LDMAP segment para public ‘FAR_DATA&#39;</span><span class="ch">\n</span><span class="st">&quot;</span> );

  <span class="kw">do</span>
    {
    <span class="co">// Current cell states</span>
    C1 = (x &amp; <span class="bn">0x0800</span>) &gt;&gt; <span class="dv">11</span>;
    C2 = (x &amp; <span class="bn">0x0400</span>) &gt;&gt; <span class="dv">10</span>;
    C3 = (x &amp; <span class="bn">0x0200</span>) &gt;&gt; <span class="dv">9</span>;

    <span class="co">// Neighbor counts</span>
    N1 = (x &amp; <span class="bn">0x01C0</span>) &gt;&gt; <span class="dv">6</span>;
    N2 = (x &amp; <span class="bn">0x0038</span>) &gt;&gt; <span class="dv">3</span>;
    N3 = (x &amp; <span class="bn">0x0007</span>);

    y = x &amp; <span class="bn">0x8FFF</span>;  <span class="co">// Preserve all but the next generation states</span>

    <span class="kw">if</span>(  C1 &amp;&amp; ((N1 + C2 == <span class="dv">2</span>) || (N1 + C2 == <span class="dv">3</span>)) )
      {
      y |= <span class="bn">0x4000</span>;
      }

    <span class="kw">if</span>( !C1 &amp;&amp;  (N1 + C2 == <span class="dv">3</span>) )
      {
      y |= <span class="bn">0x4000</span>;
      }

    <span class="kw">if</span>(  C2 &amp;&amp; ((N2 + C1 + C3 == <span class="dv">2</span>) || (N2 + C1 + C3 == <span class="dv">3</span>)) )
      {
      y |= <span class="bn">0x2000</span>;
      }

    <span class="kw">if</span>( !C2 &amp;&amp;  (N2 + C1 + C3 == <span class="dv">3</span>) )
      {
      y |= <span class="bn">0x2000</span>;
      }

    <span class="kw">if</span>(  C3 &amp;&amp; ((N3 + C2 == <span class="dv">2</span>) || (N3 + C2 == <span class="dv">3</span>)) )
      {
      y |= <span class="bn">0x1000</span>;
      }

    <span class="kw">if</span>( !C3 &amp;&amp;  (N3 + C2 == <span class="dv">3</span>) )
      {
      y |= <span class="bn">0x1000</span>;
      }

    printf( <span class="st">&quot;db 0%02xh</span><span class="ch">\n</span><span class="st">&quot;</span>, y &gt;&gt; <span class="dv">8</span> );
    }
  <span class="kw">while</span>( ++x != <span class="dv">0</span> );

  printf( <span class="st">&quot;ends</span><span class="ch">\n\n</span><span class="st">&quot;</span> );
  }

<span class="dt">void</span> GetUpAndDown( <span class="dt">void</span> )
  {
  printf( <span class="st">&quot;mov  ax,[bp+_RowColMap-_CellMap]</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;or   ah,ah</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  dx,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, DOWN );
  printf( <span class="st">&quot;mov  cx,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, WRAPUP );
  printf( <span class="st">&quot;jz   short D%d</span><span class="ch">\n</span><span class="st">&quot;</span>, Label );
  printf( <span class="st">&quot;cmp  ah,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, HEIGHT - <span class="dv">1</span> );
  printf( <span class="st">&quot;mov  cx,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, UP );
  printf( <span class="st">&quot;jb   short D%d</span><span class="ch">\n</span><span class="st">&quot;</span>, Label );
  printf( <span class="st">&quot;mov  dx,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, WRAPDOWN );
  printf( <span class="st">&quot;D%d:</span><span class="ch">\n</span><span class="st">&quot;</span>, Label );
  }

<span class="dt">void</span> FirstPass( <span class="dt">void</span> )
  {
  <span class="dt">char</span> *Op;
  <span class="dt">unsigned</span> <span class="dt">short</span> UpDown = <span class="dv">0</span>;

  printf( <span class="st">&quot;org 0%02x00h</span><span class="ch">\n</span><span class="st">&quot;</span>, (Edge &lt;&lt; <span class="dv">7</span>) + (New &lt;&lt; <span class="dv">4</span>) + (Old &lt;&lt; <span class="dv">1</span>) );

  <span class="co">// reset cell</span>
  printf( <span class="st">&quot;xor  byte ptr [bp+1],0%02xh</span><span class="ch">\n</span><span class="st">&quot;</span>, (New ^ Old) &lt;&lt; <span class="dv">1</span> );

  <span class="co">// get the screen address and update the display</span>
  <span class="ot">#ifndef NODRAW</span>
  printf( <span class="st">&quot;mov  al,160</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  bx,[bp+_RowColMap-_CellMap]</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mul  bh</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;add  ax,ax</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  bh,0</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;add  bx,ax</span><span class="ch">\n</span><span class="st">&quot;</span> );    <span class="co">// bx = screen offset</span>

  <span class="kw">if</span>( ((New ^ Old) &amp; <span class="dv">6</span>) == <span class="dv">6</span> )
    {
    printf( <span class="st">&quot;mov  word ptr fs:[bx],0%02x%02xh</span><span class="ch">\n</span><span class="st">&quot;</span>,
            (New &amp; <span class="dv">2</span>) ? <span class="dv">15</span> : <span class="dv">0</span>,
            (New &amp; <span class="dv">4</span>) ? <span class="dv">15</span> : <span class="dv">0</span> );

    <span class="kw">if</span>( (New ^ Old) &amp; <span class="dv">1</span> )
      {
      printf( <span class="st">&quot;mov  byte ptr fs:[bx+2],%s</span><span class="ch">\n</span><span class="st">&quot;</span>,
              (New &amp; <span class="dv">1</span>) ? <span class="st">&quot;15&quot;</span> : <span class="st">&quot;dl&quot;</span> );
      }
    }
  <span class="kw">else</span>
    {
    <span class="kw">if</span>( ((New ^ Old) &amp; <span class="dv">3</span>) == <span class="dv">3</span> )
      {
      printf( <span class="st">&quot;mov  word ptr fs:[bx+1],0%02x%02xh</span><span class="ch">\n</span><span class="st">&quot;</span>,
              (New &amp; <span class="dv">1</span>) ? <span class="dv">15</span> : <span class="dv">0</span>,
              (New &amp; <span class="dv">2</span>) ? <span class="dv">15</span> : <span class="dv">0</span> );
      }
    <span class="kw">else</span>
      {
      <span class="kw">if</span>( (New ^ Old) &amp; <span class="dv">2</span> )
        {
        printf( <span class="st">&quot;mov  byte ptr fs:[bx+1],%s</span><span class="ch">\n</span><span class="st">&quot;</span>,
                (New &amp; <span class="dv">2</span>) ? <span class="st">&quot;15&quot;</span> : <span class="st">&quot;dl&quot;</span> );
        }

      <span class="kw">if</span>( (New ^ Old) &amp; <span class="dv">1</span> )
        {
        printf( <span class="st">&quot;mov  byte ptr fs:[bx+2],%s</span><span class="ch">\n</span><span class="st">&quot;</span>,
                (New &amp; <span class="dv">1</span>) ? <span class="st">&quot;15&quot;</span> : <span class="st">&quot;dl&quot;</span> );
        }
      }

    <span class="kw">if</span>( (New ^ Old) &amp; <span class="dv">4</span> )
      {
      printf( <span class="st">&quot;mov  byte ptr fs:[bx],%s</span><span class="ch">\n</span><span class="st">&quot;</span>,
              (New &amp; <span class="dv">4</span>) ? <span class="st">&quot;15&quot;</span> : <span class="st">&quot;dl&quot;</span> );
      }
    }
  <span class="ot">#endif</span>

  <span class="kw">if</span>( (New ^ Old) &amp; <span class="dv">4</span> )  UpDown += (New &amp; <span class="dv">4</span>) ? <span class="bn">0x48</span> : -<span class="bn">0x48</span>;
  <span class="kw">if</span>( (New ^ Old) &amp; <span class="dv">2</span> )  UpDown += (New &amp; <span class="dv">2</span>) ? <span class="bn">0x49</span> : -<span class="bn">0x49</span>;
  <span class="kw">if</span>( (New ^ Old) &amp; <span class="dv">1</span> )  UpDown += (New &amp; <span class="dv">1</span>) ? <span class="bn">0x09</span> : -<span class="bn">0x09</span>;

  <span class="kw">if</span>( Edge )
    {
    GetUpAndDown();  <span class="co">// ah = row, al = col, cx = up, dx = down</span>

    <span class="kw">if</span>( (New ^ Old) &amp; <span class="dv">4</span> )
      {
      printf( <span class="st">&quot;mov  di,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, WRAPLEFT );      <span class="co">// di = left</span>
      printf( <span class="st">&quot;cmp  al,0</span><span class="ch">\n</span><span class="st">&quot;</span> );
      printf( <span class="st">&quot;je   short L%d</span><span class="ch">\n</span><span class="st">&quot;</span>, Label );
      printf( <span class="st">&quot;mov  di,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, LEFT );
      printf( <span class="st">&quot;L%d:</span><span class="ch">\n</span><span class="st">&quot;</span>, Label );

      <span class="kw">if</span>( New &amp; <span class="dv">4</span> )  Op = <span class="st">&quot;inc&quot;</span>;
      <span class="kw">else</span>           Op = <span class="st">&quot;dec&quot;</span>;

      printf( <span class="st">&quot;%s  word ptr [bp+di]</span><span class="ch">\n</span><span class="st">&quot;</span>, Op );
      printf( <span class="st">&quot;add  di,cx</span><span class="ch">\n</span><span class="st">&quot;</span> );
      printf( <span class="st">&quot;%s  word ptr [bp+di]</span><span class="ch">\n</span><span class="st">&quot;</span>, Op );
      printf( <span class="st">&quot;sub  di,cx</span><span class="ch">\n</span><span class="st">&quot;</span> );
      printf( <span class="st">&quot;add  di,dx</span><span class="ch">\n</span><span class="st">&quot;</span> );
      printf( <span class="st">&quot;%s  word ptr [bp+di]</span><span class="ch">\n</span><span class="st">&quot;</span>, Op );
      }

    <span class="kw">if</span>( (New ^ Old) &amp; <span class="dv">1</span> )
      {
      printf( <span class="st">&quot;mov  di,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, WRAPRIGHT );      <span class="co">// di = right</span>
      printf( <span class="st">&quot;cmp  al,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, (WIDTH - <span class="dv">1</span>) * <span class="dv">3</span> );
      printf( <span class="st">&quot;je   short R%d</span><span class="ch">\n</span><span class="st">&quot;</span>, Label );
      printf( <span class="st">&quot;mov  di,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, RIGHT );
      printf( <span class="st">&quot;R%d:</span><span class="ch">\n</span><span class="st">&quot;</span>, Label );

      <span class="kw">if</span>( New &amp; <span class="dv">1</span> )  Op = <span class="st">&quot;add&quot;</span>;
      <span class="kw">else</span>           Op = <span class="st">&quot;sub&quot;</span>;

      printf( <span class="st">&quot;%s   word ptr [bp+di],40h</span><span class="ch">\n</span><span class="st">&quot;</span>, Op );
      printf( <span class="st">&quot;add  di,cx</span><span class="ch">\n</span><span class="st">&quot;</span> );
      printf( <span class="st">&quot;%s   word ptr [bp+di],40h</span><span class="ch">\n</span><span class="st">&quot;</span>, Op );
      printf( <span class="st">&quot;sub  di,cx</span><span class="ch">\n</span><span class="st">&quot;</span> );
      printf( <span class="st">&quot;add  di,dx</span><span class="ch">\n</span><span class="st">&quot;</span> );
      printf( <span class="st">&quot;%s   word ptr [bp+di],40h</span><span class="ch">\n</span><span class="st">&quot;</span>, Op );
      }

    printf( <span class="st">&quot;mov  di,cx</span><span class="ch">\n</span><span class="st">&quot;</span> );
    printf( <span class="st">&quot;add  word ptr [bp+di],%d</span><span class="ch">\n</span><span class="st">&quot;</span>, UpDown );
    printf( <span class="st">&quot;mov  di,dx</span><span class="ch">\n</span><span class="st">&quot;</span> );
    printf( <span class="st">&quot;add  word ptr [bp+di],%d</span><span class="ch">\n</span><span class="st">&quot;</span>, UpDown );

    printf( <span class="st">&quot;mov  dl,0</span><span class="ch">\n</span><span class="st">&quot;</span> );
    }
  <span class="kw">else</span>
    {
    <span class="kw">if</span>( (New ^ Old) &amp; <span class="dv">4</span> )
      {
      <span class="kw">if</span>( New &amp; <span class="dv">4</span> )  Op = <span class="st">&quot;inc&quot;</span>;
      <span class="kw">else</span>           Op = <span class="st">&quot;dec&quot;</span>;

      printf( <span class="st">&quot;%s  byte ptr [bp+%d]</span><span class="ch">\n</span><span class="st">&quot;</span>, Op, LEFT );
      printf( <span class="st">&quot;%s  byte ptr [bp+%d]</span><span class="ch">\n</span><span class="st">&quot;</span>, Op, UPPERLEFT );
      printf( <span class="st">&quot;%s  byte ptr [bp+%d]</span><span class="ch">\n</span><span class="st">&quot;</span>, Op, LOWERLEFT );
      }

    <span class="kw">if</span>( (New ^ Old) &amp; <span class="dv">1</span> )
      {
      <span class="kw">if</span>( New &amp; <span class="dv">1</span> )  Op = <span class="st">&quot;add&quot;</span>;
      <span class="kw">else</span>           Op = <span class="st">&quot;sub&quot;</span>;

      printf( <span class="st">&quot;%s  word ptr [bp+%d],40h</span><span class="ch">\n</span><span class="st">&quot;</span>, Op, RIGHT );
      printf( <span class="st">&quot;%s  word ptr [bp+%d],40h</span><span class="ch">\n</span><span class="st">&quot;</span>, Op, UPPERRIGHT );
      printf( <span class="st">&quot;%s  word ptr [bp+%d],40h</span><span class="ch">\n</span><span class="st">&quot;</span>, Op, LOWERRIGHT );
      }

    <span class="kw">if</span>( abs( UpDown ) &gt; <span class="dv">1</span> )
      {
      printf( <span class="st">&quot;add  word ptr [bp+%d],%d</span><span class="ch">\n</span><span class="st">&quot;</span>, UP, UpDown );
      printf( <span class="st">&quot;add  word ptr [bp+%d],%d</span><span class="ch">\n</span><span class="st">&quot;</span>, DOWN, UpDown );
      }
    <span class="kw">else</span>
      {
      <span class="kw">if</span>( UpDown == <span class="dv">1</span> )  Op = <span class="st">&quot;inc&quot;</span>;
      <span class="kw">else</span>               Op = <span class="st">&quot;dec&quot;</span>;

      printf( <span class="st">&quot;%s  byte ptr [bp+%d]</span><span class="ch">\n</span><span class="st">&quot;</span>, Op, UP   );
      printf( <span class="st">&quot;%s  byte ptr [bp+%d]</span><span class="ch">\n</span><span class="st">&quot;</span>, Op, DOWN );
      }
    }

  Next1();
  }

<span class="dt">void</span> Test( <span class="dt">char</span> *Offset, <span class="dt">char</span> *Str )
  {
  printf( <span class="st">&quot;mov  bx,[bp+%s]</span><span class="ch">\n</span><span class="st">&quot;</span>, Offset );
  printf( <span class="st">&quot;cmp  bh,[bx]</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;jnz  short FIX_%s%d</span><span class="ch">\n</span><span class="st">&quot;</span>, Str, Label );
  printf( <span class="st">&quot;%s%d:</span><span class="ch">\n</span><span class="st">&quot;</span>, Str, Label );
  }

<span class="dt">void</span> Fix( <span class="dt">char</span> *Offset, <span class="dt">char</span> *Str, <span class="dt">int</span> JumpBack )
  {
  printf( <span class="st">&quot;FIX_%s%d:</span><span class="ch">\n</span><span class="st">&quot;</span>, Str, Label );
  printf( <span class="st">&quot;mov  bh,[bx]</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  [bp+%s],bx</span><span class="ch">\n</span><span class="st">&quot;</span>, Offset );

  <span class="kw">if</span>( *Offset != ‘0&#39; )  printf( <span class="st">&quot;lea  ax,[bp+%s]</span><span class="ch">\n</span><span class="st">&quot;</span>, Offset );
  <span class="kw">else</span>                  printf( <span class="st">&quot;mov  ax,bp</span><span class="ch">\n</span><span class="st">&quot;</span> );

  printf( <span class="st">&quot;stosw</span><span class="ch">\n</span><span class="st">&quot;</span> );

  <span class="kw">if</span>( JumpBack )  printf( <span class="st">&quot;jmp  short %s%d</span><span class="ch">\n</span><span class="st">&quot;</span>, Str, Label );
  }

<span class="dt">void</span> SecondPass( <span class="dt">void</span> )
  {
  printf( <span class="st">&quot;org 0%02x00h</span><span class="ch">\n</span><span class="st">&quot;</span>,
          (Edge &lt;&lt; <span class="dv">7</span>) + (New &lt;&lt; <span class="dv">4</span>) + (Old &lt;&lt; <span class="dv">1</span>) + <span class="dv">1</span> );

  <span class="kw">if</span>( Edge )
    {
    <span class="co">// finished with second pass</span>
    <span class="kw">if</span>( New == <span class="dv">7</span> &amp;&amp; Old == <span class="dv">0</span> )
      {
      printf( <span class="st">&quot;cmp  bp,offset DGROUP:ChangeCell</span><span class="ch">\n</span><span class="st">&quot;</span> );
      printf( <span class="st">&quot;jne  short NotEnd</span><span class="ch">\n</span><span class="st">&quot;</span> );
      printf( <span class="st">&quot;mov  word ptr es:[di],offset DGROUP:ChangeCell</span><span class="ch">\n</span><span class="st">&quot;</span> );
      printf( <span class="st">&quot;pop  di si bp ds</span><span class="ch">\n</span><span class="st">&quot;</span> );
      printf( <span class="st">&quot;mov  ChangeCell,0</span><span class="ch">\n</span><span class="st">&quot;</span> );
      printf( <span class="st">&quot;retf</span><span class="ch">\n</span><span class="st">&quot;</span> );
      printf( <span class="st">&quot;NotEnd:</span><span class="ch">\n</span><span class="st">&quot;</span> );
      }

    GetUpAndDown();  <span class="co">// ah = row, al = col, cx = up, dx = down</span>

    printf( <span class="st">&quot;push si</span><span class="ch">\n</span><span class="st">&quot;</span> );
    printf( <span class="st">&quot;mov  si,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, WRAPLEFT );    <span class="co">// si = left</span>
    printf( <span class="st">&quot;cmp  al,0</span><span class="ch">\n</span><span class="st">&quot;</span> );
    printf( <span class="st">&quot;je   short L%d</span><span class="ch">\n</span><span class="st">&quot;</span>, Label );
    printf( <span class="st">&quot;mov  si,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, LEFT );
    printf( <span class="st">&quot;L%d:</span><span class="ch">\n</span><span class="st">&quot;</span>, Label );

    Test( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;LEFT&quot;</span> );
    printf( <span class="st">&quot;add  si,cx</span><span class="ch">\n</span><span class="st">&quot;</span> );
    Test( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;UPPERLEFT&quot;</span> );
    printf( <span class="st">&quot;sub  si,cx</span><span class="ch">\n</span><span class="st">&quot;</span> );
    printf( <span class="st">&quot;add  si,dx</span><span class="ch">\n</span><span class="st">&quot;</span> );
    Test( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;LOWERLEFT&quot;</span> );

    printf( <span class="st">&quot;mov  si,cx</span><span class="ch">\n</span><span class="st">&quot;</span> );
    Test( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;UP&quot;</span> );
    printf( <span class="st">&quot;mov  si,dx</span><span class="ch">\n</span><span class="st">&quot;</span> );
    Test( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;DOWN&quot;</span> );

    printf( <span class="st">&quot;cmp  byte ptr [bp+_RowColMap-_CellMap],%d</span><span class="ch">\n</span><span class="st">&quot;</span>,
            (WIDTH - <span class="dv">1</span>) * <span class="dv">3</span> );

    printf( <span class="st">&quot;mov  si,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, WRAPRIGHT );    <span class="co">// si = right</span>
    printf( <span class="st">&quot;je   short R%d</span><span class="ch">\n</span><span class="st">&quot;</span>, Label );
    printf( <span class="st">&quot;mov  si,%d</span><span class="ch">\n</span><span class="st">&quot;</span>, RIGHT );
    printf( <span class="st">&quot;R%d:</span><span class="ch">\n</span><span class="st">&quot;</span>, Label );

    Test( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;RIGHT&quot;</span> );
    printf( <span class="st">&quot;add  si,cx</span><span class="ch">\n</span><span class="st">&quot;</span> );
    Test( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;UPPERRIGHT&quot;</span> );
    printf( <span class="st">&quot;sub  si,cx</span><span class="ch">\n</span><span class="st">&quot;</span> );
    printf( <span class="st">&quot;add  si,dx</span><span class="ch">\n</span><span class="st">&quot;</span> );
    Test( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;LOWERRIGHT&quot;</span> );
    }
  <span class="kw">else</span>
    {
    Test( itoa( LEFT, Buf, <span class="dv">10</span> ), <span class="st">&quot;LEFT&quot;</span> );
    Test( itoa( UPPERLEFT, Buf, <span class="dv">10</span> ), <span class="st">&quot;UPPERLEFT&quot;</span> );
    Test( itoa( LOWERLEFT, Buf, <span class="dv">10</span> ), <span class="st">&quot;LOWERLEFT&quot;</span> );
    Test( itoa( UP, Buf, <span class="dv">10</span> ), <span class="st">&quot;UP&quot;</span> );
    Test( itoa( DOWN, Buf, <span class="dv">10</span> ), <span class="st">&quot;DOWN&quot;</span> );
    Test( itoa( RIGHT, Buf, <span class="dv">10</span> ), <span class="st">&quot;RIGHT&quot;</span> );
    Test( itoa( UPPERRIGHT, Buf, <span class="dv">10</span> ), <span class="st">&quot;UPPERRIGHT&quot;</span> );
    Test( itoa( LOWERRIGHT, Buf, <span class="dv">10</span> ), <span class="st">&quot;LOWERRIGHT&quot;</span> );
    }

  <span class="kw">if</span>( New == Old )  Test( <span class="st">&quot;0&quot;</span>, <span class="st">&quot;CENTER&quot;</span> );

  <span class="kw">if</span>( Edge )  printf( <span class="st">&quot;pop  si</span><span class="ch">\n</span><span class="st">&quot;</span> <span class="st">&quot;mov  dl,0</span><span class="ch">\n</span><span class="st">&quot;</span> );

  Next2();

  <span class="kw">if</span>( Edge )
    {
    Fix( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;LEFT&quot;</span>,       <span class="dv">1</span> );
    Fix( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;UPPERLEFT&quot;</span>,  <span class="dv">1</span> );
    Fix( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;LOWERLEFT&quot;</span>,  <span class="dv">1</span> );
    Fix( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;UP&quot;</span>,         <span class="dv">1</span> );
    Fix( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;DOWN&quot;</span>,       <span class="dv">1</span> );
    Fix( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;RIGHT&quot;</span>,      <span class="dv">1</span> );
    Fix( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;UPPERRIGHT&quot;</span>, <span class="dv">1</span> );
    Fix( <span class="st">&quot;si&quot;</span>, <span class="st">&quot;LOWERRIGHT&quot;</span>, New == Old );
    }
  <span class="kw">else</span>
    {
    Fix( itoa( LEFT, Buf, <span class="dv">10</span> ),       <span class="st">&quot;LEFT&quot;</span>,       <span class="dv">1</span> );
    Fix( itoa( UPPERLEFT, Buf, <span class="dv">10</span> ),  <span class="st">&quot;UPPERLEFT&quot;</span>,  <span class="dv">1</span> );
    Fix( itoa( LOWERLEFT, Buf, <span class="dv">10</span> ),  <span class="st">&quot;LOWERLEFT&quot;</span>,  <span class="dv">1</span> );
    Fix( itoa( UP, Buf, <span class="dv">10</span> ),         <span class="st">&quot;UP&quot;</span>,         <span class="dv">1</span> );
    Fix( itoa( DOWN, Buf, <span class="dv">10</span> ),       <span class="st">&quot;DOWN&quot;</span>,       <span class="dv">1</span> );
    Fix( itoa( RIGHT, Buf, <span class="dv">10</span> ),      <span class="st">&quot;RIGHT&quot;</span>,      <span class="dv">1</span> );
    Fix( itoa( UPPERRIGHT, Buf, <span class="dv">10</span> ), <span class="st">&quot;UPPERRIGHT&quot;</span>, <span class="dv">1</span> );
    Fix( itoa( LOWERRIGHT, Buf, <span class="dv">10</span> ), <span class="st">&quot;LOWERRIGHT&quot;</span>, New == Old );
    }

  <span class="kw">if</span>( New == Old )  Fix( <span class="st">&quot;0&quot;</span>, <span class="st">&quot;CENTER&quot;</span>, <span class="dv">0</span> );

  <span class="kw">if</span>( Edge )  printf( <span class="st">&quot;pop  si</span><span class="ch">\n</span><span class="st">&quot;</span> <span class="st">&quot;mov  dl,0</span><span class="ch">\n</span><span class="st">&quot;</span> );

  Next2();
  }

<span class="dt">void</span> main( <span class="dt">void</span> )
  {
  <span class="dt">char</span> *Seg = <span class="st">&quot;ds&quot;</span>;

  BuildMaps();

  printf( <span class="st">&quot;DGROUP group _DATA</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;LIFE segment ‘CODE&#39;</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;assume cs:LIFE,ds:DGROUP,ss:DGROUP,es:NOTHING</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;.386C</span><span class="ch">\n</span><span class="st">&quot;</span> <span class="st">&quot;public _NextGen</span><span class="ch">\n\n</span><span class="st">&quot;</span> );

  <span class="kw">for</span>( Edge = <span class="dv">0</span>; Edge &lt;= <span class="dv">1</span>; Edge++ )
    {
    <span class="kw">for</span>( New = <span class="dv">0</span>; New &lt; <span class="dv">8</span>; New++ )
      {
      <span class="kw">for</span>( Old = <span class="dv">0</span>; Old &lt; <span class="dv">8</span>; Old++ )
        {
        <span class="kw">if</span>( New != Old )  FirstPass();  Label++;
        SecondPass();                   Label++;
        }
      }
    }

  <span class="co">// finished with first pass</span>
  printf( <span class="st">&quot;org  0</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  si,Change1</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  di,Change2</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  Change1,di</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  Change2,si</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  ChangeCell,0F000h</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  ax,seg _LDMAP</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  ds,ax</span><span class="ch">\n</span><span class="st">&quot;</span> );
  Next2();

  <span class="co">// entry point</span>
  printf( <span class="st">&quot;_NextGen: push ds bp si di</span><span class="ch">\n</span><span class="st">&quot;</span> <span class="st">&quot;cld</span><span class="ch">\n</span><span class="st">&quot;</span> );

  <span class="kw">if</span>( WIDTH * HEIGHT &gt; LIST_LIMIT )  Seg = <span class="st">&quot;seg _CHANGE&quot;</span>;

  printf( <span class="st">&quot;mov  ax,%s</span><span class="ch">\n</span><span class="st">&quot;</span>, Seg );
  printf( <span class="st">&quot;mov  es,ax</span><span class="ch">\n</span><span class="st">&quot;</span> );

  <span class="ot">#ifndef NODRAW</span>
  printf( <span class="st">&quot;mov  ax,0A000h</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  fs,ax</span><span class="ch">\n</span><span class="st">&quot;</span> );
  <span class="ot">#endif</span>

  printf( <span class="st">&quot;mov  si,Change1</span><span class="ch">\n</span><span class="st">&quot;</span> );
  printf( <span class="st">&quot;mov  dl,0</span><span class="ch">\n</span><span class="st">&quot;</span> );
  Next1();

  printf( <span class="st">&quot;LIFE ends</span><span class="ch">\n</span><span class="st">end</span><span class="ch">\n</span><span class="st">&quot;</span> );
  }</code></pre>
<p><strong>LISTING 18.3 MAIN.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// MAIN.C</span>
<span class="co">//</span>
<span class="co">// David Stafford</span>
<span class="co">//</span>

<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;time.h&gt;</span>
<span class="ot">#include &lt;bios.h&gt;</span>
<span class="ot">#include &quot;life.h&quot;</span>

<span class="co">// functions in VIDEO.C</span>
<span class="dt">void</span> enter_display_mode( <span class="dt">void</span> );
<span class="dt">void</span> exit_display_mode( <span class="dt">void</span> );
<span class="dt">void</span> show_text( <span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">char</span> *text );

<span class="dt">void</span> InitCellmap( <span class="dt">void</span> )
  {
  <span class="dt">unsigned</span> <span class="dt">int</span> i, j, t, x, y, init;

  <span class="kw">for</span>( init = (HEIGHT * WIDTH * <span class="dv">3</span>) / <span class="dv">2</span>; init; init— )
    {
    x = random( WIDTH * <span class="dv">3</span> );
    y = random( HEIGHT );

    CellMap[ (y * WIDTH) + x / <span class="dv">3</span> ] |= <span class="bn">0x1000</span> &lt;&lt; (<span class="dv">2</span> - (x % <span class="dv">3</span>));
    }

  <span class="kw">for</span>( i = j = <span class="dv">0</span>; i &lt; WIDTH * HEIGHT; i++ )
    {
    <span class="kw">if</span>( CellMap[ i ] &amp; <span class="bn">0x7000</span> )
      {
      ChangeList1[ j++ ] = (<span class="dt">short</span>)&amp;CellMap[ i ];
      }
    }

  NextGen();   <span class="co">// Set cell states, prime the pump.</span>
  }

<span class="dt">void</span> main( <span class="dt">void</span> )
  {
  <span class="dt">unsigned</span> <span class="dt">long</span> generation = <span class="dv">0</span>;
  <span class="dt">char</span> gen_text[ <span class="dv">80</span> ];
  <span class="dt">long</span> start_time, end_time;
  <span class="dt">unsigned</span> <span class="dt">int</span> seed;

  printf( <span class="st">&quot;Seed (0 for random seed): &quot;</span> );
  scanf( <span class="st">&quot;%d&quot;</span>, &amp;seed );
  <span class="kw">if</span>( seed == <span class="dv">0</span> )  seed = (<span class="dt">unsigned</span>) time(NULL);
  srand( seed );

  <span class="ot">#ifndef NODRAW</span>
  enter_display_mode();
  show_text( <span class="dv">0</span>, <span class="dv">10</span>, <span class="st">&quot;Generation:&quot;</span> );
  <span class="ot">#endif</span>

  InitCellmap();       <span class="co">// randomly initialize cell map</span>

  _bios_timeofday( _TIME_GETCLOCK, &amp;start_time );

  <span class="kw">do</span>
    {
    NextGen();
    generation++;

    <span class="ot">#ifndef NOCOUNTER</span>
    sprintf( gen_text, <span class="st">&quot;%10lu&quot;</span>, generation );
    show_text( <span class="dv">0</span>, <span class="dv">12</span>, gen_text );
    <span class="ot">#endif</span>
    }
  <span class="ot">#ifdef GEN</span>
  <span class="kw">while</span>( generation &lt; GEN );
  <span class="ot">#else</span>
  <span class="kw">while</span>( !kbhit() );
  <span class="ot">#endif</span>

  _bios_timeofday( _TIME_GETCLOCK, &amp;end_time );
  end_time -= start_time;

  <span class="ot">#ifndef NODRAW</span>
  getch();    <span class="co">// clear keypress</span>
  exit_display_mode();
  <span class="ot">#endif</span>

  printf( <span class="st">&quot;Total generations: %ld</span><span class="ch">\n</span><span class="st">Seed: %u</span><span class="ch">\n</span><span class="st">&quot;</span>, generation, seed );
  printf( <span class="st">&quot;%ld ticks</span><span class="ch">\n</span><span class="st">&quot;</span>, end_time );
  printf( <span class="st">&quot;Time: %f generations/second</span><span class="ch">\n</span><span class="st">&quot;</span>,
          (<span class="dt">double</span>)generation / (<span class="dt">double</span>)end_time * <span class="fl">18.2</span> );
  }</code></pre>
<p><strong>LISTING 18.4 VIDEO.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* VGA mode 13h functions for Game of Life.</span>
<span class="co">   Tested with Borland C++. */</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>

<span class="ot">#define TEXT_X_OFFSET   28</span>
<span class="ot">#define SCREEN_WIDTH_IN_BYTES 320</span>

<span class="ot">#define SCREEN_SEGMENT  0xA000</span>

<span class="co">/* Mode 13h mode-set function. */</span>
<span class="dt">void</span> enter_display_mode()
{
   <span class="kw">union</span> REGS regset;

   regset.x.ax = <span class="bn">0x0013</span>;
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}

<span class="co">/* Text mode mode-set function. */</span>
<span class="dt">void</span> exit_display_mode()
{
   <span class="kw">union</span> REGS regset;

   regset.x.ax = <span class="bn">0x0003</span>;
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}

<span class="co">/* Text display function. Offsets text to non-graphics area of</span>
<span class="co">   screen. */</span>
<span class="dt">void</span> show_text(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">char</span> *text)
{
   gotoxy(TEXT_X_OFFSET + x, y);
   puts(text);
}</code></pre>
<p><strong>LISTING 18.5 LIFE.H</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> far NextGen( <span class="dt">void</span> );

<span class="kw">extern</span> <span class="dt">unsigned</span> <span class="dt">short</span> CellMap[];
<span class="kw">extern</span> <span class="dt">unsigned</span> <span class="dt">short</span> far ChangeList1[];

<span class="ot">#define LEFT        (-2)</span>
<span class="ot">#define RIGHT       (+2)</span>
<span class="ot">#define UP          (WIDTH * LEFT)</span>
<span class="ot">#define DOWN        (WIDTH * RIGHT)</span>
<span class="ot">#define UPPERLEFT   (UP + LEFT)</span>
<span class="ot">#define UPPERRIGHT  (UP + RIGHT)</span>
<span class="ot">#define LOWERLEFT   (DOWN + LEFT)</span>
<span class="ot">#define LOWERRIGHT  (DOWN + RIGHT)</span>
<span class="ot">#define WRAPLEFT    (RIGHT * (WIDTH - 1))</span>
<span class="ot">#define WRAPRIGHT   (LEFT  * (WIDTH - 1))</span>
<span class="ot">#define WRAPUP      (DOWN  * (HEIGHT - 1))</span>
<span class="ot">#define WRAPDOWN    (UP    * (HEIGHT - 1))</span></code></pre>
</section>
<section id="keeping-track-of-change-with-a-change-list" class="level3">
<h3><a href="#keeping-track-of-change-with-a-change-list">Keeping Track of Change with a Change List</a></h3>
<p>In my earlier optimizations to the Game of Life, described in the last chapter, I noted that most cells in a Life cellmap are dead, and in most cases all the neighbors are dead as well. This observation enabled me to get a major speed-up by scanning the cellmap for the few non-zero bytes (cells that were either alive or have neighbors that are alive). Although that was a big improvement, it still required my code to touch every cell to check its state. David has improved on this by maintaining a <em>change list;</em> that is, a list of pointers to cells that change in the current generation. Only those cells and their neighbors need to be checked or touched in any way in order to create the next generation, saving a great many instructions and also a great many cache misses due to the fact that cellmaps are too big to fit into the 486’s internal cache. During a given generation, David runs down the list of cells that changed from the previous generation to make the changes for this generation, and in the process generates the change list for the next generation.</p>
<p>That’s the overall approach, but this being David Stafford, it’s not that simple, of course. I’ll let him tell you how his implementation works in his own words. (I’ve edited David’s text a bit, and added my own comments in square brackets, so blame me for any errors.)</p>
<p>“Each three cells in the life grid are packed into two bytes, as shown in Figure 18.1. So, it is convenient if the width of the cell array is an even multiple of three. There’s nothing in the algorithm that prevents it from supporting any arbitrary size, but the code is a bit simpler this way. So if you want a 200x200 grid, I recommend just using a 201x200 grid, and be happy with the extra free column. Otherwise the edge wrapping code gets more complex.</p>
<p>“Since every cell has from zero to eight neighbors, you may be wondering how I can manage to keep track of them with only three bits. Each cell really has only a maximum of seven neighbors since we only need to keep track of neighbors <em>outside</em> of the current cell word. That is, if cell ‘B’ changes state then we don’t need to reflect this in the neighbor counts of cells ‘A’ and ‘C.’ Updating is made a little faster. [In other words, when David picks up a word representing three cells, each of the three cells has at least one of the other cells in that word as a neighbor, and the state of that neighbor is stored right in that word, as shown in Figure 18.1. Therefore, the neighbor count for a given cell never needs to reflect more than seven neighbors, because at least one of the eight neighbors’ states is already encoded in the word.]</p>
<figure>
<img src="images/18-01.jpg" alt="Figure 18.1  Cell triplet storage." /><figcaption><strong>Figure 18.1</strong>  <em>Cell triplet storage.</em></figcaption>
</figure>
<p>“The basic idea is to maintain a ‘change list.’ This is an array of pointers into the cell array. Each change list element points to a word which changes in the next generation. This way we don’t have to waste time scanning every cell since most of them do not change. Two passes are made through the change list. The first pass updates the cell display on the screen, sets the life/death status of each cell for this new generation, and updates the neighbor counts for the adjacent cells. There are some efficiencies gained by using cell triplets rather than individual cells since we usually don’t need to set all eight neighbors. [Again, the neighbor counts for cells in the same word are implied by the states of those cells.] The second pass sets the next-generation states for the cells and their neighbors, and in the process builds the change list for the next generation.</p>
<p>“Processing each word is a little complex but very fast. A 64K block of code exists with routines on each 256-byte boundary. Generally speaking, the entry point corresponds to the high byte of the cell word. This byte contains the life/death values and a bit to indicate if this is an edge condition. During the first pass we take the cell triplet word, AND it with 0XFE00, and jump to that address. During the second pass we take the cell triplet word, AND it with 0xFE00, OR it with 0x0100, and jump to that address. [Therefore, there are 128 possible jump targets on the first pass, and 128 more on the second, all on 256-byte boundaries and all keyed off the high 7 bits of the cell triplet state; because bit 8 of the jump index is 0 on the first pass and 1 on the second, there is no conflict. The lower bit isn’t needed for other purposes because only the edge flag bit and the six life/death state bits matter for jumping into David’s state machine. The other nine bits, the bits used for the neighbor counts, are used only in the next step.]</p>
<p>“Determining which changes must be made to a cell triplet is easy and surprisingly quick. There’s no counting! Instead, I use a 64K lookup table indexed by the cell triplet itself. The value of the lookup table entry is equal to what the high byte should be in the next generation. If this value is equal to the current high byte, then no changes are necessary to the cell. Otherwise it is placed in the change list. Look at the code in the <code>Test()</code> and <code>Fix()</code> functions to see how this is done.” [This step is as important as it is obscure. David has a 64K table organized so that if you use a word describing a cell triplet as a lookup index, the byte you will read will be the state of the high byte for the next generation. In other words, David’s table is constructed so that the edge flag bit, the life/death states, and the three neighbor count fields form an index to a byte describing the next generation state for that triplet. In practice, only the next generation field of the cell changes. Then, if another change to a nearby cell tries to nudge that cell into changing again, David’s code sees that the desired state is already set, and does not add that cell to the change list again.]</p>
<p>Segment usage in David’s assembly code is summarized in Listing 18.6.</p>
<p><strong>LISTING 18.6 QLIFE Assembly Segment Usage</strong></p>
<pre><code>CS : 64K code (table of routines on 256 byte boundaries)
DS : DGROUP (1st pass) / 64K cell life/death classification table (second pass)
ES : Change list
SS : DGROUP; the life cell grid and row/column table
FS : Video segment
GS : Unused</code></pre>
<section id="a-laypersons-overview-of-qlife" class="level4">
<h4><a href="#a-laypersons-overview-of-qlife">A Layperson’s Overview of QLIFE</a></h4>
<p>Most likely, you’re scratching your head right now in bemusement. I don’t blame you; I felt the same way myself at first. It’s actually pretty simple, though, once you have the hang of it. Basically, David runs down the change list, visiting every cell that’s due to change in this generation, setting it to the new state, drawing it in the new state, and adjusting the counts of all its neighbors. David has a separate assembly routine for every possible change of state for a cell triplet, and he jumps to the proper routine by taking the cell triplet word, masking off the lower 9 bits, and jumping to the address where the appropriate code to perform that particular change of state resides. He does this for every entry in the change list. When this is completed, the current generation has been drawn and updated.</p>
<p>Now David runs down the change list again to generate the change list for the next generation. In this case, for every changed cell triplet, David looks at that triplet and all affected neighbors to see which will change in the next generation. He tests for this condition by using each potentially changed cell triplet word as an index into the aforementioned lookup table of new states. If the current state matches the appropriate state for the next generation, then there’s nothing to do and the cell is not added to the change list. If the states don’t match, then the cell is added to the change list, and the appropriate state for the next generation is set in the cell triplet. David checks the minimum possible number of cells for change by branching to code that checks only the relevant cells around each cell triplet in the current change list; that branching is accomplished by taking the cell triplet word, masking off the lower 9 bits, setting bit 8 to a 1-bit, and branching to the routine at that address. As with everything in this amazing program, this represents the least possible work to accomplish the desired result—just three instructions:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">dh</span>,[<span class="kw">bp</span><span class="dv">+1</span>]
<span class="kw">or</span> <span class="kw">dh</span>,<span class="dv">1</span>
<span class="kw">jmp</span> <span class="kw">dx</span></code></pre>
<p>These suffice to select the proper, minimum-work code to process the next cell triplet that has changed, and all potentially affected neighbors. For all the size of David’s code, it has an astonishing economy of effort, as execution glides through the change list without a wasted instruction.</p>
<p>Alas, I don’t have the room to discuss Peter Klerings’ equally remarkable Life implementation here. I’ll close this chapter with a quote from Terje Mathisen, one of the finest optimizers it has ever been my pleasure to meet, who, after looking over David’s and Peter’s entries, said, “This has been an eye-opening experience for me. I honestly thought I had the fastest possible approach.” TANSTATFC.</p>
<p>There Ain’t No Such Thing As the Fastest Code.</p>
</section>
</section>
</section>
<section id="chapter-19-pentium-not-the-same-old-song" class="level2">
<h2><a href="#chapter-19-pentium-not-the-same-old-song">Chapter 19 – Pentium: Not the Same Old Song</a></h2>
<section id="learning-a-whole-different-set-of-optimization-rules" class="level3">
<h3><a href="#learning-a-whole-different-set-of-optimization-rules">Learning a Whole Different Set of Optimization Rules</a></h3>
<p>I can still remember the day I did my first 8088 programming. I had just moved over from the distantly related Z80, so the 8088 wasn’t totally alien, but it was nonetheless an incredibly exciting processor. The 8088’s instruction set was vastly more powerful and varied than the Z80’s, and as someone who thrives on puzzles of all sorts, from crosswords to Freecell to jigsaws to assembly language optimization, I was delighted to find that the 8088 made the optimization universe an order of magnitude more complicated—and correspondingly more interesting.</p>
<p>Well, the years went by and the Z80 just died, and 8088 optimization got ever more complex and intriguing as I discovered the hazards of the 8088’s cycle-eaters. By the time 1989 rolled around, I had written <em>Zen of Assembly Language</em>, in which I described all that I had learned about the 8088 and concluded that 8088 optimization was a black art of infinite subtlety. Unfortunately, by that time the 286 was the standard, with the 386 coming on strong, and if the 286 was less amenable to hand optimization than the 8088 (and it surely was), then the 386 was downright unfriendly. Sure, assembly optimization could buy some performance on the 386, but only 20, 30, 40 percent or so—a far cry from the 100 to 400 percent of the 8088. At the same time, compiler technology was improving quickly, and the days of hand tuning seemed numbered.</p>
<p>Happily, the 486 traveled to the beat of a different drum. The 486 had some interesting internal pipeline hazards, as well as an internal cache that made cycle counting more meaningful than ever before, and careful code massaging sometimes yielded startling results. Nonetheless, the 486 was still too simple to mark a return to the golden age of optimization.</p>
</section>
<section id="the-return-of-optimization-as-art" class="level3">
<h3><a href="#the-return-of-optimization-as-art">The Return of Optimization as Art</a></h3>
<p>Then the Pentium came around, and filled our code with optimization hazards, and life was good again. The Pentium has two execution pipelines and enough rules and exceptions to those rules to bring joy to the heart of the hardest-core assembly junkie. For a change, Intel documented most of the Pentium optimization rules and spread the word about them, so we don’t have to go through as much spelunking of the Pentium as with its predecessors. They’ve done this, I suspect, largely because more than any previous x86 processor, the Pentium’s performance is highly dependent on properly optimized code.</p>
<p>In the worst case, where the second execution pipe is dormant most of the time, the Pentium won’t perform all that much better than a 486 at the same clock speed. In the best case, where the second pipe is heavily used and the Pentium’s other advantages (such as branch prediction, write-back cache, 64-bit full speed external bus, and dual 8K caches) can kick in, the Pentium can be more than twice as fast as a 486. In a critical inner loop, hand optimization can double or even triple performance over 486-optimized code—and that’s on top of the sorts of algorithmic and design optimizations that are routinely performed on any processor. Good compilers can make a big difference on the Pentium, too, but there are some gotchas there, to which I’ll return later.</p>
<p>It’s been a long time coming, but hard-core, big-payoff assembly language optimization is back in style, and for the rest of this book I’ll be delving into the Byzantine wonders of the Pentium. In this chapter, I’ll do a quick overview, then cover a variety of smaller Pentium optimization topics. In the next chapter, I’ll tackle the 900-pound gorilla of Pentium optimization: superscalar (dual execution pipe) programming. Trust me, this’ll be fun.</p>
<p>Listen, do you want to know a secret? This lead-in has been brought to you with the help of “classic rock”—another way of saying “music Baby Boomers listened to back when they cared more about music than 401Ks and regular flossing.” There are so many of us Boomers that our music, even the worst of it, will never go away. When we’re 90 years old, propped up in our Kraftmatic adjustable beds and surfing the 5,000-channel information superhighway from one infomercial to the next, the sound system in the retirement community will be piping in a Muzak version of “Louie, Louie,” while on the holovid Country Joe McDonald and the Fish pitch Preparation H. I can hardly wait.</p>
<p>Gimme a “P”….</p>
</section>
<section id="the-pentium-an-overview" class="level3">
<h3><a href="#the-pentium-an-overview">The Pentium: An Overview</a></h3>
<p>Architecturally, the Pentium is vastly different in many ways from the 486, but most of those differences are transparent to programmers. After all, the whole idea behind the Pentium is that it runs the same code as previous x86 processors, but faster; otherwise, Intel could have made a faster, cheaper RISC processor. Still, knowledge of the Pentium’s architecture is useful for understanding exactly how code will perform, and a few of the architectural differences are most decidedly <em>not</em> transparent to performance programmers.</p>
<p>The Pentium is essentially one full 486 execution unit (EU), plus a second stripped-down 486 EU, on a single chip. The first EU is referred to as the U execution pipe, or <em>U-pipe;</em> the second, more limited one is called the <em>V-pipe</em>. The two pipes are capable of executing instructions simultaneously, have separate write buffers, and can even access the data cache simultaneously (although with certain limitations that I’ll discuss in the next chapter), so on the Pentium it is possible to execute two instructions, even instructions that access memory, in a single clock. The cycle times for instruction execution in a given pipe (both pipes process instructions at the same speed) are comparable to those for the 486, although some instructions—notably <code>MUL</code>, the repeated string instructions, and some of the shifts and rotates—have gotten faster.</p>
<p>My first thought upon hearing of the Pentium’s dual pipes was to wonder how often the prefetch queue stalls for lack of instruction bytes, given that the demand for instruction bytes can be twice that of the 486. The answer is: rarely indeed, and then only because the code is not in the internal cache. The 486 has a single 8K cache that stores both code and data, and prefetching can stall if data fetching doesn’t allow time for prefetching to occur (although this rarely happens in practice).</p>
<blockquote>
<p><img src="images/i.jpg" /> The Pentium, on the other hand, has two separate 8K caches, one for code and one for data, so code prefetches can never collide with data fetches; the prefetch queue can stall only when the code being fetched isn’t in the internal code cache.</p>
</blockquote>
<p>(And yes, self-modifying code still works; as with all Pentium changes, the dual caches introduce no incompatibilities with 386/486 code.) Also, because the code and data caches are separate, code can’t be driven out of the cache in a tight loop that accesses a lot of data, unlike the 486. In addition, the Pentium expands the 486’s 32-byte prefetch queue to 128 bytes. In conjunction with the branch prediction feature (described next), which allows the Pentium to prefetch properly at most branches, this larger prefetch queue means that the Pentium’s two pipes should be better fed than those of any previous x86 processor.</p>
<section id="crossing-cache-lines" class="level4">
<h4><a href="#crossing-cache-lines">Crossing Cache Lines</a></h4>
<p>There are three other characteristics of the Pentium that make for a healthy supply of instruction bytes. One is that the Pentium can prefetch instructions across cache lines. Unlike the 486, where there is a 3-cycle penalty for branching to an instruction that spans a cache line, there’s no such penalty on the Pentium. The second is that the cache line size (the number of bytes fetched from the external cache or main memory on a cache miss) on the Pentium is 32 bytes, twice the size of the 486’s cache line, so a cache miss causes a longer run of instructions to be placed in the cache than on the 486. The third is that the Pentium’s external bus is twice as wide as the 486’s, at 64 bits, and runs twice as fast, at 66 MHz, so the Pentium can fetch both instruction and data bytes from the external cache four times as fast as the 486.</p>
<blockquote>
<p><img src="images/i.jpg" /> Even when the Pentium is running flat-out with both pipes in use, it can generally consume only about twice as many bytes as the 486; so the ratio of external memory bandwidth to processing power is much improved, although real-world performance is heavily dependent on the size and speed of the external cache.</p>
</blockquote>
<p>The upshot of all this is that at the same clock speed, with code and data that are mostly in the internal caches, the Pentium maxes out somewhere around twice as fast as a 486. (When the caches are missed a lot, the Pentium can get as much as three to four times faster, due to the superior external bus and bigger caches.) Most of this won’t affect how you program, but it is useful to know that you don’t have to worry about instruction fetching. It’s also useful to know the sizes of the caches because a high cache hit rate is crucial to Pentium performance. Cache misses are vastly slower than cache hits (anywhere from two to 50 or more times as slow, depending on the speed of the external cache and whether the external cache misses as well), and the Pentium can’t use the V-pipe on code that hasn’t already been executed out of the cache at least once. This means that it is <em>very</em> important to get the working sets of critical loops to fit in the internal caches.</p>
<p>One change in the Pentium that you definitely do have to worry about is superscalar execution. Utilization of the V-pipe can range from near zero percent to 100 percent, depending on the code being executed, and careful rearrangement of code can have amazing effects. Maxing out V-pipe use is not a trivial task; I’ll spend all of the next chapter discussing it so as to have time to cover it properly. In the meantime, two good references for superscalar programming and other Pentium information are Intel’s <em>Pentium Processor User’s Manual: Volume 3: Architecture and Programming Manual</em> (ISBN 1-55512-195-0; Intel order number 241430-001), and the article “Optimizing Pentium Code” by Mike Schmidt, in <em>Dr. Dobb’s Journal</em> for January 1994.</p>
</section>
<section id="cache-organization" class="level4">
<h4><a href="#cache-organization">Cache Organization</a></h4>
<p>There are two other interesting changes in the Pentium’s cache organization. First, the cache is two-way set-associative, whereas the 486 is four-way set-associative. The details of this don’t matter, but simply put, this, combined with the 32-byte cache line size, means that the Pentium has somewhat coarser granularity in both space and time than the 486 in terms of packing bytes into the cache, although the total cache space is now bigger. There’s nothing you can do about this, but it may make it a little harder to get a loop’s working set into the cache. Second, the internal cache can now be configured (by the BIOS or OS; you won’t have to worry about it) for write-back rather than write-through operation. This means that writes to the internal data cache don’t necessarily get propagated to the external bus until other demands for cache space force the data out of the cache, making repeated writes to memory variables such as loop counters cheaper on average than on the 486, although not as cheap as registers.</p>
<p>As a final note on Pentium architecture for this chapter, the pipeline stalls (what Intel calls AGIs, for <em>Address Generation Interlocks</em>) that I discussed earlier in this book (see Chapter 12) are still present in the Pentium. In fact, they’re there in spades on the Pentium; the two pipelines mean that an AGI can now slow down execution of an instruction that’s <em>three</em> instructions away from the AGI (because four instructions can execute in two cycles). So, for example, the code sequence</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">add</span> <span class="kw">edx</span>,<span class="dv">4</span>     <span class="co">;U-pipe cycle 1</span>
<span class="kw">mov</span> <span class="kw">ecx</span>,[<span class="kw">ebx</span>] <span class="co">;V-pipe cycle 1</span>
<span class="kw">add</span> <span class="kw">ebx</span>,<span class="dv">4</span>     <span class="co">;U-pipe cycle 2</span>
<span class="kw">mov</span> [<span class="kw">edx</span>],<span class="kw">ecx</span> <span class="co">;V-pipe cycle 3</span>
              <span class="co">; due to AGI</span>
              <span class="co">; (would have been</span>
              <span class="co">; V-pipe cycle 2)</span></code></pre>
<p>takes three cycles rather than the two cycles it should take, because EDX was modified on cycle 1 and an attempt was made to use it on cycle two, before the AGI had time to clear—even though there are two instructions between the instructions that are actually involved in the AGI. Rearranging the code like</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">ecx</span>,[<span class="kw">ebx</span>]   <span class="co">;U-pipe cycle 1</span>
<span class="kw">add</span> <span class="kw">ebx</span>,<span class="dv">4</span>       <span class="co">;V-pipe cycle 1</span>
<span class="kw">mov</span> [<span class="kw">edx</span><span class="dv">+4</span>],<span class="kw">ecx</span> <span class="co">;U-pipe cycle 2</span>
<span class="kw">add</span> <span class="kw">edx</span>,<span class="dv">4</span>       <span class="co">;V-pipe cycle 2</span></code></pre>
<p>makes it functionally identical, but cuts the cycles to 2—a 50 percent improvement. Clearly, avoiding AGIs becomes a much more challenging and rewarding game in a superscalar world, one to which I’ll return in the next chapter.</p>
</section>
</section>
<section id="faster-addressing-and-more" class="level3">
<h3><a href="#faster-addressing-and-more">Faster Addressing and More</a></h3>
<p>I’ll spend the rest of this chapter covering a variety of Pentium optimization tips. For starters, effective address calculations (that is, the addition and scaling required to calculate a memory operand’s address, as for example in <code>MOV EAX,[EBX+ECX*2+4]</code>) never take any extra cycles on the Pentium (other than possibly an AGI cycle), even for the use of base+index addressing (as in <code>MOV [ESI+EDI],EAX</code>) or scaling (*2, *4, or *8, as in <code>INC ARRAY[ESI*4]</code>). On the 486, both of the latter cases cause a 1-cycle penalty. The faster effective address calculations have the side effect of making <code>LEA</code> very attractive as an arithmetic instruction. <code>LEA</code> can add any two registers, one of which can be multiplied by one, two, four, or eight, plus a constant value, and can store the result in any register—all in one cycle, apart from AGIs. Not only that, but as we’ll see in the next chapter, <code>LEA</code> can go through either pipe, whereas <code>SHL</code> can only go through the U-pipe, so <code>LEA</code> is often a superior choice for multiplication by three, four, five, eight, or nine. (<code>ADD</code> is the best choice for multiplication by two.) If you use <code>LEA</code> for arithmetic, do remember that unlike <code>ADD</code> and <code>SHL</code>, it doesn’t modify any flags.</p>
<p>As on the 486, memory operands should not cross any more alignment boundaries than absolutely necessary. Word operands should be word-aligned, dword operands should be dword-aligned, and qword operands (double-precision variables) should be qword-aligned. Spanning a dword boundary, as in</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">ebx</span>,<span class="dv">3</span>
 :
<span class="kw">mov</span> <span class="kw">eax</span>,[<span class="kw">ebx</span>]</code></pre>
<p>costs three cycles. On the other hand, as noted above, branch targets can now span cache lines with impunity, so on the Pentium there’s no good argument for the paragraph (that is, 16-byte) alignment that Intel recommends for 486 jump targets. The 32-byte alignment might make for slightly more efficient Pentium cache usage, but would make code much bigger overall.</p>
<blockquote>
<p><img src="images/i.jpg" /> In fact, given that most jump targets aren’t in performance-critical code, it’s hard to make a compelling argument for aligning branch targets even on the 486. I’d say that no alignment (except possibly where you know a branch target lies in a key loop), or at most dword alignment (for the 386) is plenty, and can shrink code size considerably.</p>
</blockquote>
<p>Instruction prefixes are awfully expensive; avoid them if you can. (These include size and addressing prefixes, segment overrides, <code>LOCK</code>, and the 0FH prefixes that extend the instruction set with instructions such as <code>MOVSX</code>. The exceptions are conditional jumps, a fast special case.) At a minimum, a prefix byte generally takes an extra cycle and shuts down the V-pipe for that cycle, effectively costing as much as two normal instructions (although prefix cycles can overlap with previous multicycle instructions, or AGIs, as on the 486). This means that using 32-bit addressing or 32-bit operands in a 16-bit segment, or vice versa, makes for bigger code that’s significantly slower. So, for example, you should generally avoid 16-bit variables (shorts, in C) in 32-bit code, although if using 32-bit variables where they’re not needed makes your data space get a lot bigger, you may want to stick with shorts, especially since longs use the cache less efficiently than shorts. The trade-off depends on the amount of data and the number of instructions that reference that data. (eight-bit variables, such as chars, have no extra overhead and can be used freely, although they may be less desirable than longs for compilers that tend to promote variables to longs when performing calculations.) Likewise, you should if possible avoid putting data in the code segment and referring to it with a CS: prefix, or otherwise using segment overrides.</p>
<p><code>LOCK</code> is a particularly costly instruction, especially on multiprocessor machines, because it locks the bus and requires that the hardware be brought into a synchronized state. The cost varies depending on the processor and system, but <code>LOCK</code> can make an <code>INC [*mem*]</code> instruction (which normally takes 3 cycles) 5, 10, or more cycles slower. Most programmers will never use <code>LOCK</code> on purpose—it’s primarily an operating system instruction—but there’s a hidden gotcha here because the <code>XCHG</code> instruction always locks the bus when used with a memory operand.</p>
<blockquote>
<p><img src="images/i.jpg" /> <code>XCHG</code> is a tempting instruction that’s often used in assembly language; for example, exchanging with video memory is a popular way to read and write VGA memory in a single instruction—but it’s now a bad idea. As it happens, on the 486 and Pentium, using <code>MOV</code>s to read and write memory is faster, anyway; and even on the 486, my measurements indicate a five-cycle tax for <code>LOCK</code> in general, and a nine-cycle execution time for <code>XCHG</code> with memory. Avoid <code>XCHG</code> with memory if you possibly can.</p>
</blockquote>
<p>As with the 486, don’t use <code>ENTER</code> or <code>LEAVE</code>, which are slower than the equivalent discrete instructions. Also, start using <code>TEST *reg,reg*</code> instead of <code>AND *reg,reg*</code> or <code>OR *reg,reg*</code> to test whether a register is zero. The reason, as we’ll see in Chapter 21, is that <code>TEST</code>, unlike <code>AND</code> and <code>OR</code>, never modifies the target register. Although in this particular case <code>AND</code> and <code>OR</code> don’t modify the target register either, the Pentium has no way of knowing that ahead of time, so if <code>AND</code> or <code>OR</code> goes through the U-pipe, the Pentium may have to shut down the V-pipe for a cycle to avoid potential dependencies on the result of the <code>AND</code> or <code>OR</code>. <code>TEST</code> suffers from no such potential dependencies.</p>
</section>
<section id="branch-prediction" class="level3">
<h3><a href="#branch-prediction">Branch Prediction</a></h3>
<p>One brand-spanking-new feature of the Pentium is <em>branch prediction</em>, whereby the Pentium tries to guess, based on past history, which way (or, for conditional jumps, whether or not), your code will jump at each branch, and prefetches along the likelier path. If the guess is correct, the branch or fall-through takes only 1 cycle—2 cycles less than a branch and the same as a fall-through on the 486; if the guess is wrong, the branch or fall-through takes 4 or 5 cycles (if it executes in the U- or V-pipe, respectively)—1 or 2 cycles more than a branch and 3 or 4 cycles more than a fall-through on the 486.</p>
<blockquote>
<p><img src="images/i.jpg" /> Branch prediction is unprecedented in the x86, and fundamentally alters the nature of pedal-to-the-metal optimization, for the simple reason that it renders unrolled loops largely obsolete. Rare indeed is the loop that can’t afford to spare even 1 or 0 (yes, zero!) cycles per iteration for loop counting, and that’s how low the cost can go for maintaining a loop on the Pentium.</p>
</blockquote>
<p>Also, unrolled loops are bigger than normal loops, so there are extra (and expensive) cache misses the first time through the loop if the entire loop isn’t already in the cache; then, too, an unrolled loop will shoulder other code out of the internal and external caches. If in a critical loop you absolutely need the time taken by the loop control instructions, or if you need an extra register that can be freed by unrolling a loop, then by all means unroll the loop. Don’t expect the sort of speed-up you get from this on the 486 or especially the 386, though, and watch out for the cache effects.</p>
<p>You may well wonder exactly <em>when</em> the Pentium correctly predicts branching. Alas, this is one area that Intel has declined to document, beyond saying that you should endeavor to fall through branches when you have a choice. That’s good advice on every other x86 processor, anyway, so it’s well worth following. Also, it’s a pretty safe bet that in a tight loop, the Pentium will start guessing the right branch direction at the bottom of the loop pretty quickly, so you can treat loop branches as one-cycle instructions.</p>
<p>It’s an equally safe bet that it’s a bad move to have in a loop a conditional branch that goes both ways on a random basis; it’s hard to see how the Pentium could consistently predict such branches correctly, and mispredicted branches are more expensive than they might appear to be. Not only does a mispredicted branch take 4 or 5 cycles, but the Pentium can potentially execute as many as 8 or 10 instructions in that time—3 times as many as the 486 can execute during its branch time—so correct branch prediction (or eliminating branch instructions, if possible) is very important in inner loops. Note that on the 486 you can count on a branch to take 1 cycle when it falls through, but on the Pentium you can’t be sure whether it will take 1 or either 4 or 5 cycles on any given iteration.</p>
<blockquote>
<p><img src="images/i.jpg" /> As things currently stand, branch prediction is an annoyance for assembly language optimization because it’s impossible to be certain exactly how code will perform until you measure it, and even then it’s difficult to be sure exactly where the cycles went. All I can say is try to fall through branches if possible, and try to be consistent in your branching if not.</p>
</blockquote>
</section>
<section id="miscellaneous-pentium-topics" class="level3">
<h3><a href="#miscellaneous-pentium-topics">Miscellaneous Pentium Topics</a></h3>
<p>The Pentium has all the instructions of the 486, plus a few new ones. One much-needed instruction that has finally made it into the instruction set is <code>CPUID</code>, which allows your code to determine what processor it’s running on. <code>CPUID</code> is 15 years late, but at least it’s finally here. Another new instruction is <code>CMPXCHG8B</code>, which does a compare and conditional exchange on a qword. <code>CMPXCHG8B</code> doesn’t seem to me to be a particularly useful instruction, but I’m sure Intel wouldn’t have added it without a reason; if you know of a use for it, please pass it along to me.</p>
<section id="versus-pentium-optimization" class="level4">
<h4><a href="#versus-pentium-optimization">486 versus Pentium Optimization</a></h4>
<p>Many Pentium optimizations help, or at least don’t hurt, on the 486. Many, but not all—and many <em>do</em> hurt on the 386. As I discuss various Pentium optimizations, I will attempt to note the effects on the 486 as well, but doing this in complete detail would double the sizes of these discussions and make them hard to follow. In general, I’d recommend reserving Pentium optimization for your most critical code, and even there, it’s a good idea to have at least two code paths, one for the 386 and one for the 486/Pentium. It’s also a good idea to time your code on a 486 before and after Pentium-optimizing it, to make sure you haven’t hurt performance on what will be, after all, by far the most important processor over the next couple of years.</p>
<p>With that in mind, is optimizing for the Pentium even worthwhile today? That depends on your application and its market—but if you want absolutely the best possible performance for your DOS and Windows apps on the fastest hardware, Pentium optimization can make your code <em>scream</em>.</p>
</section>
<section id="going-superscalar" class="level4">
<h4><a href="#going-superscalar">Going Superscalar</a></h4>
<p>In the next chapter, we’ll look into the single biggest element of Pentium performance, cranking up the Pentium’s second execution pipe. This is the area in which compiler technology is most touted for the Pentium, the two thoughts apparently being that (1) most existing code is in C, so recompiling to use the second pipe better is an automatic win, and (2) it’s so complicated to optimize Pentium code that only a compiler can do it well. The first point is a reasonable one, but it does suffer from one flaw for large programs, in that Pentium-optimized code is larger than 486- or 386-optimized code, for reasons that will become apparent in the next chapter. Larger code means more cache misses and more page faults; and while most of the code in any program is not critical to performance, compilers optimize code indiscriminately.</p>
<p>The result is that Pentium compiler optimization not only expands code, but can be less beneficial than expected or even slower in some cases. What makes more sense is enabling Pentium optimization <em>only</em> for key code. Better yet, you could hand-tune the most important code—and yes, you can absolutely do a better job with a small, critical loop than any PC compiler I’ve ever seen, or expect to see. Sure, you keep hearing how great each new compiler generation is, and compilers certainly have improved; but they play by the same rules we do, and we’re more flexible and know more about what we’re doing—and now we have the wonderfully complex and powerful Pentium upon which to loose our carbon-based optimizers.</p>
<p>A compiler that generates better code than a good assembly programmer? That’ll be the day.</p>
</section>
</section>
</section>
<section id="chapter-20-pentium-rules" class="level2">
<h2><a href="#chapter-20-pentium-rules">Chapter 20 – Pentium Rules</a></h2>
<section id="how-your-carbon-based-optimizer-can-put-the-super-in-superscalar" class="level3">
<h3><a href="#how-your-carbon-based-optimizer-can-put-the-super-in-superscalar">How Your Carbon-Based Optimizer Can Put the “Super” in Superscalar</a></h3>
<p>At the 1983 West Coast Computer Faire, my friend Dan Illowsky, Andy Greenberg (co-author of Wizardry, at that time the best-selling computer game ever), and I had an animated discussion about starting a company in the then-budding world of microcomputer software. One hot new software category at the time was educational software, and one of the hottest new educational software companies was Spinnaker Software. Andy used Spinnaker as an example of a company that had been aimed at a good market and started up properly, and was succeeding as a result. Dan didn’t buy this; his point was that Spinnaker had been given a bundle of money to get off the ground, and was growing only by spending a lot of that money in order to move its products. “Heck,” said Dan, “I could get that kind of market share too if I gave away a fifty-dollar bill with each of my games.”</p>
<p>Remember, this was a time when a program, two diskette drives (for duplicating disks), and a couple of ads were enough to start a company, and, in fact, Dan built a very successful game company out of not much more than that. (I’ll never forget coming to visit one day and finding his apartment stuffed literally to the walls and ceiling with boxes of diskettes and game packages; he had left a narrow path to the computer so his wife and his mother could get in there to duplicate disks.) Back then, the field was wide open, with just about every competent programmer thinking of striking out on his or her own to try to make their fortune, and Dan and Andy and I were no exceptions. In short, we were having a perfectly normal conversation, and Dan’s comment was both appropriate, and, in retrospect, accurate.</p>
<p>Appropriate, save for one thing: We were having this conversation while walking through a low-rent section of Market Street in San Francisco at night. A bum sitting against a nearby building overheard Dan, and rose up, shouting in a quavering voice loud enough to wake the dead, “Fifty-dollar bill! Fifty-dollar bill! He’s giving away fifty-dollar bills!” We ignored him; undaunted, he followed us for a good half mile, stopping every few feet to bellow “fifty-dollar bill!” No one else seemed to notice, and no one hassled us, but I was mighty happy to get to the sanctuary of the Fairmont Hotel and slip inside.</p>
<p>The point is, most actions aren’t inherently good or bad; it’s all a matter of context. If Dan had uttered the words “fifty-dollar bill” on the West Coast Faire’s show floor, no one would have batted an eye. If he had said it in a slightly worse part of town than he did, we might have learned just how fast the three of us could run.</p>
<p>Similarly, there’s no such thing as inherently fast code, only fast code in context. At the moment, the context is the Pentium, and the truth is that a sizable number of the x86 optimization tricks that you and I have learned over the past ten years are obsolete on the Pentium. True, the Pentium contains what amounts to about one-and-a-half 486s, but, as we’ll see shortly, that doesn’t mean that optimized Pentium code looks much like optimized 486 code, or that fast 486 code runs particularly well on a Pentium. (Fast Pentium code, on the other hand, does tend to run well on the 486; the only major downsides are that it’s larger, and that the <code>FXCH</code> instruction, which is largely free on the Pentium, is expensive on the 486.) So discard your x86 preconceptions as we delve into superscalar optimization for this one-of-a-kind processor.</p>
</section>
<section id="an-instruction-in-every-pipe" class="level3">
<h3><a href="#an-instruction-in-every-pipe">An Instruction in Every Pipe</a></h3>
<p>In the last chapter, we took a quick tour of the Pentium’s architecture, and started to look into the Pentium’s optimization rules. Now we’re ready to get to the key rules, those having to do with the Pentium’s most unique and powerful feature, the ability to execute more than one instruction per cycle. This is known as <em>superscalar execution</em>, and has heretofore been the sole province of fast RISC CPUs. The Pentium has two integer execution units, called the <em>U-pipe</em> and the <em>V-pipe</em>, which can execute two separate instructions simultaneously, potentially doubling performance—but only under the proper conditions. (There is also a separate floating-point execution unit that I won’t have the space to cover in this book.) Your job, as a performance programmer, is to understand the conditions needed for superscalar performance and make sure they’re met, and that’s what this and the next chapters are all about.</p>
<p>The two pipes are not independent processors housed in a single chip; that is, the Pentium is not like having two 486s in a single computer. Rather, the two pipes are integral, parallel parts of the same processor. They operate on the same instruction stream, with the V-pipe simply executing the next instruction that the U-pipe would have handled, as shown in Figure 20.1. What the Pentium does, pure and simple, is execute a single instruction stream and, whenever possible, take the next two waiting instructions and execute both at once, rather than one after the other.</p>
<p>The U-pipe is the more capable of the two pipes, able to execute any instruction in the Pentium’s instruction set. (A number of instructions actually use both pipes at once. Logically, though, you can think of such instructions as U-pipe instructions, and of the Pentium optimization model as one in which the U-pipe is able to execute all instructions and is always active, with the objective being to keep the V-pipe also working as much of the time as possible.) The U-pipe is generally similar to a full 486 in terms of both capabilities and instruction cycle counts. The V-pipe is a 486 subset, able to execute simple instructions such as <code>MOV</code> and <code>ADD</code>, but unable to handle <code>MUL, DIV</code>, string instructions, any sort of rotation or shift, or even <code>ADC</code> or <code>SBB</code>.</p>
<figure>
<img src="images/20-01.jpg" alt="Figure 20.1  The Pentium’s two pipes." /><figcaption><strong>Figure 20.1</strong>  <em>The Pentium’s two pipes.</em></figcaption>
</figure>
<p>Getting two instructions executing simultaneously in the two pipes is trickier than it sounds, not only because the V-pipe can handle only a relatively small subset of the Pentium’s instruction set, but also because those instructions that the V-pipe can handle are able to pair only with certain U-pipe instructions. For example, <code>MOVSD</code> uses both pipes, so no instruction can be executed in parallel with <code>MOVSD</code>.</p>
<blockquote>
<p><img src="images/i.jpg" /> The use of both pipes does make <code>MOVSD</code> nearly twice as fast on the Pentium as on the 486, but it’s nonetheless slower than using equivalent simpler instructions that allow for superscalar execution. Stick to the Pentium’s RISC-like instructions—the pairable instructions I’ll discuss next—when you’re seeking maximum performance, with just a few exceptions such as <code>REP MOVS</code> and <code>REP STOS</code>.</p>
</blockquote>
<p>Trickier yet, register contention can shut down the V-pipe on any given cycle, and Address Generation Interlocks (AGIs) can stall either pipe at any time, as we’ll see in the next chapter.</p>
<p>The key to Pentium optimization is to view execution as a stream of instructions going through the U- and V-pipes, and to eliminate, as much as possible, instruction mixes that take the V-pipe out of action. In practice, this is not too difficult. The only hard part is keeping in mind the long list of rules governing instruction pairing. The place to begin is with the set of instructions that can go through the V-pipe.</p>
</section>
<section id="v-pipe-capable-instructions" class="level3">
<h3><a href="#v-pipe-capable-instructions">V-Pipe-Capable Instructions</a></h3>
<p>Any instruction can go through the U-pipe, and, for practical purposes, the U-pipe is always executing instructions. (The exceptions are when the U-pipe execution unit is waiting for instruction or data bytes after a cache miss, and when a U-pipe instruction finishes before a paired V-pipe instruction, as I’ll discuss below.) Only the instructions shown in Table 20.1 can go through the V-pipe. In addition, the V-pipe can execute a separate instruction only when one of the instructions listed in Table 20.2 is executing in the U-pipe; superscalar execution is not possible while any instruction not listed in Table 20.2 is executing in the U-pipe. So, for example, if you use <code>SHR EDX,CL</code>, which takes 4 cycles to execute, no other instructions can execute during those 4 cycles; if, on the other hand, you use <code>SHR EDX,10</code>, it will take 1 cycle to execute in the U-pipe, and another instruction can potentially execute concurrently in the V-pipe. (As you can see, similar instruction sequences can have vastly different performance characteristics on the Pentium.)</p>
<p>Basically, after the current instruction or pair of instructions is finished (that is, once neither the U- nor V-pipe is executing anything), the Pentium sends the next instruction through the U-pipe. If the instruction after the one in the U-pipe is an instruction the V-pipe can handle, if the instruction in the U-pipe is pairable, and if register contention doesn’t occur, then the V-pipe starts executing that instruction, as shown in Figure 20.2. Otherwise, the second instruction waits until the first instruction is done, then executes in the U-pipe, possibly pairing with the next instruction in line if all pairing conditions are met.</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">MOV</span>      reg,reg          (<span class="dv">1</span> cycle)
         mem,reg          (<span class="dv">1</span> cycle)
         reg,mem          (<span class="dv">1</span> cycle)
         reg,immediate    (<span class="dv">1</span> cycle)
         mem,immediate    (<span class="dv">1</span> cycle)†

<span class="kw">AND</span>/<span class="kw">OR</span>/<span class="kw">XOR</span>/<span class="kw">ADD</span>/<span class="kw">SUB</span>   reg,reg         (<span class="dv">1</span> cycle)
                     mem,reg         (<span class="dv">3</span> cycles)
                     reg,mem         (<span class="dv">2</span> cycles)
                     reg,immediate   (<span class="dv">1</span> cycle)
                     mem,immediate   (<span class="dv">3</span> cycles)†

<span class="kw">INC</span>/<span class="kw">DEC</span>  reg     (<span class="dv">1</span> cycle)
         mem     (<span class="dv">3</span> cycles)

<span class="kw">CMP</span>      reg,reg         (<span class="dv">1</span> cycle)
         mem,reg         (<span class="dv">2</span> cycles)
         reg,mem         (<span class="dv">2</span> cycles)
         reg,immediate   (<span class="dv">1</span> cycle)
         mem,immediate   (<span class="dv">2</span> cycles)†

<span class="kw">TEST</span>     reg,reg         (<span class="dv">1</span> cycle)
         <span class="kw">EAX</span>,immediate   (<span class="dv">1</span> cycle)

<span class="kw">PUSH</span>/<span class="kw">POP</span> reg             (<span class="dv">1</span> cycle)
         immediate       (<span class="dv">1</span> cycle)

<span class="kw">LEA</span>      reg,mem         (<span class="dv">1</span> cycle)

JCC     near       (<span class="dv">1</span> cycle if predicted correctly<span class="co">;</span>
                    <span class="dv">5</span> cycles otherwise <span class="kw">in</span> V-pipe,
                    <span class="dv">4</span> cycles otherwise <span class="kw">in</span> U-pipe)

<span class="kw">JMP</span>/<span class="kw">CALL</span> near      (<span class="dv">1</span> cycle if predicted correctly<span class="co">;</span>
                    <span class="dv">3</span> cycles otherwise)</code></pre>
<p>† Can’t execute in V-pipe if address contains a displacement</p>
<p><strong>Table 20.1 Instructions that can execute in the V-pipe.</strong></p>
<p>The list of instructions the V-pipe can handle is not very long, and the list of U-pipe pairable instructions is not much longer, but these actually constitute the bulk of the instructions used in PC software. As a result, a fair amount of pairing happens even in normal, non-Pentium-optimized code. This fact, plus the 64-bit 66 MHz bus, branch prediction, dual 8K internal caches, and other Pentium features, together mean that a Pentium is considerably faster than a 486 at the same clock speed, even without Pentium-specific optimization, contrary to some reports.</p>
<p>Besides, almost all operations can be performed by combinations of pairable instructions. For example, <code>PUSH [*mem*]</code> is not on either list, but both <code>MOV *reg*,[*mem*]</code> and <code>PUSH *reg*</code> are, and those two instructions can be used to push a value stored in memory. In fact, given the proper instruction stream, the discrete instructions can perform this operation effectively in just 1 cycle (taking one-half of each of 2 cycles, for 2*0.5 = 1 cycle total execution time), as shown in Figure 20.3—a full cycle <em>faster</em> than <code>PUSH [*mem*]</code>, which takes 2 cycles.</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">MOV</span>      reg,reg           (<span class="dv">1</span> cycle)
         mem,reg           (<span class="dv">1</span> cycle)
         reg,mem           (<span class="dv">1</span> cycle)
         reg,immediate     (<span class="dv">1</span> cycle)
         mem,immediate     (<span class="dv">1</span> cycle)†

<span class="kw">AND</span>/<span class="kw">OR</span>/<span class="kw">XOR</span>/<span class="kw">ADD</span>/<span class="kw">SUB</span>/<span class="kw">ADC</span>/<span class="kw">SBB</span>  reg,reg         (<span class="dv">1</span> cycle)
                            mem,reg         (<span class="dv">3</span> cycles)
                            reg,mem         (<span class="dv">2</span> cycles)
                            reg,immediate   (<span class="dv">1</span> cycle)
                            mem,immediate   (<span class="dv">3</span> cycles)†

<span class="kw">INC</span>/<span class="kw">DEC</span>  reg     (<span class="dv">1</span> cycle)
         mem     (<span class="dv">3</span> cycles)

<span class="kw">CMP</span>      reg,reg         (<span class="dv">1</span> cycle)
         mem,reg         (<span class="dv">2</span> cycles)
         reg,mem         (<span class="dv">2</span> cycles)
         reg,immediate   (<span class="dv">1</span> cycle)
         mem,immediate   (<span class="dv">2</span> cycles)†

<span class="kw">TEST</span>     reg,reg         (<span class="dv">1</span> cycle)
         <span class="kw">EAX</span>,immediate   (<span class="dv">1</span> cycle)

<span class="kw">PUSH</span>/<span class="kw">POP</span> reg             (<span class="dv">1</span> cycle)
         immediate       (<span class="dv">1</span> cycle)

<span class="kw">LEA</span>      reg,mem         (<span class="dv">1</span> cycle)

<span class="kw">SHL</span>/<span class="kw">SHR</span>/<span class="kw">SAL</span>/<span class="kw">SAR</span>  reg,immediate   (<span class="dv">1</span> cycle)††

<span class="kw">ROL</span>/<span class="kw">ROR</span>/<span class="kw">RCL</span>/<span class="kw">RCR</span>  reg,<span class="dv">1</span>           (<span class="dv">1</span> cycle)</code></pre>
<p>† Can’t pair if address contains a displacement<br /> †† Includes shift-by-1 forms of instructions</p>
<p><strong>Table 20.2 Instructions that, when executed in the U-pipe, allow V-pipe-executable instructions to execute simultaneously (pair) in the V-pipe.</strong></p>
<blockquote>
<p><img src="images/i.jpg" /> A fundamental rule of Pentium optimization is that it pays to break complex instructions into equivalent simple instructions, then shuffle the simple instructions for maximum use of the V-pipe. This is true partly because most of the pairable instructions are simple instructions, and partly because breaking instructions into pieces allows more freedom to rearrange code to avoid the AGIs and register contention I’ll discuss in the next chapter.</p>
</blockquote>
<figure>
<img src="images/20-02.jpg" alt="Figure 20.2  Instruction flow through the two pipes." /><figcaption><strong>Figure 20.2</strong>  <em>Instruction flow through the two pipes.</em></figcaption>
</figure>
<p>One downside of this “RISCification” (turning complex instructions into simple, RISC-like ones) of Pentium-optimized code is that it makes for substantially larger code. For example,</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">push</span> <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">esi</span>]</code></pre>
<p>is one byte smaller than this sequence:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">eax</span>,[<span class="kw">esi</span>]
<span class="kw">push</span> <span class="kw">eax</span></code></pre>
<figure>
<img src="images/20-03.jpg" alt="Figure 20.3  Pushing a value from memory effectively in one cycle." /><figcaption><strong>Figure 20.3</strong>  <em>Pushing a value from memory effectively in one cycle.</em></figcaption>
</figure>
<p>A more telling example is the following</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">add</span> [MemVar],<span class="kw">eax</span></code></pre>
<p>versus the equivalent:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">edx</span>,[MemVar]
<span class="kw">add</span>  <span class="kw">edx</span>,<span class="kw">eax</span>
<span class="kw">mov</span>  [MemVar],<span class="kw">edx</span></code></pre>
<p>The single complex instruction takes 3 cycles and is 6 bytes long; with proper sequencing, interleaving the simple instructions with other instructions that don’t use EDX or <code>Mem Var</code>, the three-instruction sequence can be reduced to 1.5 cycles, but it is <em>14</em> bytes long.</p>
<blockquote>
<p><img src="images/i.jpg" /> It’s not unusual for Pentium optimization to approximately double both performance and code size at the same time. In an important loop, go for performance and ignore the size, but on a program-wide basis, the size bears watching.</p>
</blockquote>
</section>
<section id="lockstep-execution" class="level3">
<h3><a href="#lockstep-execution">Lockstep Execution</a></h3>
<p>You may wonder why anyone would bother breaking <code>ADD [MemVar],EAX</code> into three instructions, given that this instruction can go through either pipe with equal ease. The answer is that while the memory-accessing instructions other than <code>MOV, PUSH</code>, and <code>POP</code> listed in Table 20.1 (that is, <code>INC/DEC [*mem*], ADD/SUB/XOR/AND/OR/CMP/ADC/SBB *reg*,[*mem*]</code>, and <code>ADD/SUB/XOR/AND/OR/CMP/ADC/SBB [*mem*],*reg/immed*</code>) can be paired, they do not provide the 100 percent overlap that we seek. If you look at Tables 20.1 and 20.2, you will see that instructions taking from 1 to 3 cycles can pair. However, any pair of instructions goes through the two pipes in lockstep. This means, for example, that if <code>ADD [EBX],EDX</code> is going through the U-pipe, and <code>INC EAX</code> is going through the V-pipe, the V-pipe will be idle for 2 of the 3 cycles that the U-pipe takes to execute its instruction, as shown in Figure 20.4. Out of the theoretical 6 cycles of work that can be done during this time, we actually get only 4 cycles of work, or 67 percent utilization. Even though these instructions pair, then, this sequence fails to make maximum use of the Pentium’s horsepower.</p>
<p>The key here is that when two instructions pair, both execution units are tied up until both instructions have finished (which means at least for the amount of time required for the longer of the two to execute, plus possibly some extra cycles for pairable instructions that can’t fully overlap, as described below). The logical conclusion would seem to be that we should strive to pair instructions of the same lengths, but that is often not correct.</p>
<blockquote>
<p><img src="images/i.jpg" /> The actual rule is that we should strive to pair one-cycle instructions (or, at most, two-cycle instructions, but not three-cycle instructions), which in turn leads to the corollary that we should, in general, use mostly one-cycle instructions when optimizing.</p>
</blockquote>
<figure>
<img src="images/20-04.jpg" alt="Figure 20.4  Lockstep execution and idle time in the V-pipe." /><figcaption><strong>Figure 20.4</strong>  <em>Lockstep execution and idle time in the V-pipe.</em></figcaption>
</figure>
<p>Here’s why. The Pentium is fully capable of handling instructions that use memory operands in either pipe, or, if necessary, in both pipes at once. Each pipe has its own write FIFO, which buffers the last few writes and takes care of writing the data out while the Pentium continues processing. The Pentium also has a write-back internal data cache, so data that is frequently changed doesn’t have to be written to external memory (which is much slower than the cache) very often. This combination means that unless you write large blocks of data at a high speed, the Pentium should be able to keep up with both pipes’ memory writes without stalling execution.</p>
<p>The Pentium is also designed to satisfy both pipes’ needs for reading memory operands with little waiting. The data cache is constructed so that both pipes can read from the cache <em>on the same cycle</em>. This feat is accomplished by organizing the data cache as eight-banked memory, as shown in Figure 20.5, with each 32-byte cache line consisting of 8 dwords, 1 in each bank. The banks are independent of one another, so as long as the desired data is in the cache and the U- and V-pipes don’t try to read from the same bank on the same cycle, both pipes can read memory operands on the same cycle. (If there is a cache bank collision, the V-pipe instruction stalls for one cycle.)</p>
<p>Normally, you won’t pay close attention to which of the eight dword banks your paired memory accesses fall in—that’s just too much work—but you might want to watch out for simultaneously read addresses that have the same values for address</p>
<figure>
<img src="images/20-05.jpg" alt="Figure 20.5  The Pentium’s eight bank data cache." /><figcaption><strong>Figure 20.5</strong>  <em>The Pentium’s eight bank data cache.</em></figcaption>
</figure>
<p>bits 2, 3, and 4 (fall in the same bank) in tight loops, and you should also avoid sequences like</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">bl</span>,[<span class="kw">esi</span>]
<span class="kw">mov</span>  <span class="kw">bh</span>,[<span class="kw">esi</span><span class="dv">+1</span>]</code></pre>
<p>because both operands will generally be in the same bank. An alternative is to place another instruction between the two instructions that access the same bank, as in this sequence:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">bl</span>,[<span class="kw">esi</span>]
<span class="kw">mov</span>  <span class="kw">edi</span>,<span class="kw">edx</span>
<span class="kw">mov</span>  <span class="kw">bh</span>,[<span class="kw">esi</span><span class="dv">+1</span>]</code></pre>
<p>By the way, the reason a code sequence that takes two instructions to load a single word is attractive in a 32-bit segment is because it takes only one cycle when the two instructions can be paired with other instructions; by contrast, the obvious way of loading BX</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">bx</span>,[<span class="kw">esi</span>]</code></pre>
<p>takes 1.5 to two cycles because the size prefix can’t pair, as described below. This is yet another example of how different Pentium optimization can be from everything we’ve learned about its predecessors.</p>
<p>The problem with pairing non-single-cycle instructions arises when a pipe executes an instruction other than <code>MOV</code> that has an explicit memory operand. (I’ll call these <em>complex memory instructions</em>. They’re the only pairable instructions, other than branches, that take more than one cycle.) We’ve already seen that, because instructions go through the pipes in lockstep, if one pipe executes a complex memory instruction such as <code>ADD EAX,[EBX]</code> while the other pipe executes a single-cycle instruction, the pipe with the faster instruction will sit idle for part of the time, wasting cycles. You might think that if both pipes execute complex instructions of the same length, then neither would lie idle, but that turns out to not always be the case. Two two-cycle instructions (instructions with register destination operands) can indeed pair and execute in two cycles, so it’s okay to pair two instructions such as these:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">add</span> <span class="kw">esi</span>,[SourceSkip]        <span class="co">;U-pipe cycles 1 and 2</span>
<span class="kw">add</span> <span class="kw">edi</span>,[DestinationSkip]   <span class="co">;V-pipe cycles 1 and 2</span></code></pre>
<p>However, this beneficial pairing does not extend to non-<code>MOV</code> instructions with explicit memory destination operands, such as <strong>ADD [EBX],EAX</strong>. The Pentium executes only one such memory instruction at a time; if two memory-destination complex instructions get paired, first the U-pipe instruction is executed, and then the V-pipe instruction, with only one cycle of overlap, as shown in Figure 20.6. I don’t know for sure, but I’d guess that this is to guarantee that the two pipes will never perform out-of-order access to any given memory location. Thus, even though <code>AND [EBX],AL</code> pairs with <code>AND [ECX],DL</code>, the two instructions take 5 cycles in all to execute, and 4 cycles of idle time—2 in the U-pipe and 2 in the V-pipe, out of 10 cycles in all—are incurred in the process.</p>
<figure>
<img src="images/20-06.jpg" alt="Figure 20.6  Non-overlapped lockstep execution." /><figcaption><strong>Figure 20.6</strong>  <em>Non-overlapped lockstep execution.</em></figcaption>
</figure>
<figure>
<img src="images/20-07.jpg" alt="Figure 20.7  Interleaving simple instructions for maximum performance." /><figcaption><strong>Figure 20.7</strong>  <em>Interleaving simple instructions for maximum performance.</em></figcaption>
</figure>
<p>The solution is to break the instructions into simple instructions and interleave them, as shown in Figure 20.7, which accomplishes the same task in 3 cycles, with no idle cycles whatsoever. Figure 20.7 is a good example of what optimized Pentium code generally looks like: mostly one-cycle instructions, mixed together so that at least two operations are in progress at once. It’s not the easiest code to read or write, but it’s the only way to get both pipes running at capacity.</p>
</section>
<section id="superscalar-notes" class="level3">
<h3><a href="#superscalar-notes">Superscalar Notes</a></h3>
<p>You may well ask why it’s necessary to interleave operations, as is done in Figure 20.7. It seems simpler just to turn</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">and</span> [<span class="kw">ebx</span>],<span class="kw">al</span></code></pre>
<p>into</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>   <span class="kw">dl</span>,[<span class="kw">ebx</span>]
<span class="kw">and</span>   <span class="kw">dl</span>,<span class="kw">al</span>
<span class="kw">mov</span>   [<span class="kw">ebx</span>],<span class="kw">dl</span></code></pre>
<p>and be done with it. The problem here is one of dependency. Before the Pentium can execute <code>AND DL,AL,</code>, it must first know what is in DL, and it can’t know that until it loads DL from the address pointed to by EBX. Therefore, <code>AND DL,AL</code> can’t happen until the cycle after <code>MOV DL,[EBX]</code> executes. Likewise, the result can’t be stored until the cycle after <code>AND DL,AL</code> has finished. This means that these instructions, as written, can’t possibly pair, so the sequence takes the same three cycles as <code>AND [EBX],AL</code>. (Now it should be clear why <code>AND [EBX]</code>, AL takes 3 cycles.) Consequently, it’s necessary to interleave these instructions with instructions that use other registers, so this set of operations can execute in one pipe while the other, unrelated set executes in the other pipe, as is done in Figure 20.7.</p>
<p>What we’ve just seen is the read-after-write form of the superscalar hazard known as <em>register contention</em>. I’ll return to the subject of register contention in the next chapter; in the remainder of this chapter I’d like to cover a few short items about superscalar execution.</p>
<section id="register-starvation" class="level4">
<h4><a href="#register-starvation">Register Starvation</a></h4>
<p>The above examples should make it pretty clear that effective superscalar programming puts a lot of strain on the Pentium’s relatively small register set. There are only seven general-purpose registers (I strongly suggest using EBP in critical loops), and it does not help to have to sacrifice one of those registers for temporary storage on each complex memory operation; in pre-superscalar days, we used to employ those handy CISC memory instructions to do all that stuff without using any extra registers.</p>
<blockquote>
<p><img src="images/i.jpg" /> More problematic still is that for maximum pairing, you’ll typically have two operations proceeding at once, one in each pipe, and trying to keep two operations in registers at once is difficult indeed. There’s not much to be done about this, other than clever and Spartan register usage, but be aware that it’s a major element of Pentium performance programming.</p>
</blockquote>
<p>Also be aware that prefixes of every sort, with the sole exception of the 0FH prefix on non-short conditional jumps, always execute in the U-pipe, and that Intel’s documentation indicates that no pairing can happen while a prefix byte executes. (As I’ll discuss in the next chapter, my experiments indicate that this rule doesn’t always apply to multiple-cycle instructions, but you still won’t go far wrong by assuming that the above rule is correct and trying to eliminate prefix bytes.) A prefix byte takes one cycle to execute; after that cycle, the actual prefixed instruction itself will go through the U-pipe, and if it and the following instruction are mutually pairable, then they will pair. Nonetheless, prefix bytes are very expensive, effectively taking at least as long as two normal instructions, and possibly, if a prefixed instruction could otherwise have paired in the V-pipe with the previous instruction, taking as long as three normal instructions, as shown in Figure 20.8.</p>
<p>Finally, bear in mind that if the instructions being executed have not already been executed at least once since they were loaded into the internal cache, they can pair only if the first (U-pipe) instruction is not only pairable but also exactly 1 byte long, a category that includes only <code>INC *reg*, DEC *reg*, PUSH *reg*</code>, and <code>POP *reg*</code>. Knowing this can help you understand why sometimes, timing reveals that your code runs slower than it seems it should, although this will generally occur only when the cache working set for the code you’re timing is on the order of 8K or more—an awful lot of code to try to optimize.</p>
<p>It should be excruciatingly clear by this point that you <em>must</em> time your Pentium-optimized code if you’re to have any hope of knowing if your optimizations are working as well as you think they are; there are just too many details involved for you to be sure your optimizations are working properly without checking. My most basic optimization rule has always been to grab the Zen timer and <em>measure actual performance</em>—and nowhere is this more true than on the Pentium. Don’t believe it until you measure it!</p>
<figure>
<img src="images/20-08.jpg" alt="Figure 20.8  Prefix delays." /><figcaption><strong>Figure 20.8</strong>  <em>Prefix delays.</em></figcaption>
</figure>
</section>
</section>
</section>
<section id="chapter-21-unleashing-the-pentiums-v-pipe" class="level2">
<h2><a href="#chapter-21-unleashing-the-pentiums-v-pipe">Chapter 21 – Unleashing the Pentium’s V-Pipe</a></h2>
<section id="focusing-on-keeping-both-pentium-pipes-full" class="level3">
<h3><a href="#focusing-on-keeping-both-pentium-pipes-full">Focusing on Keeping Both Pentium Pipes Full</a></h3>
<p>The other day, my daughter suggested that we each draw the prettiest picture we could, then see whose was prettier. I won’t comment on who won, except to note that apparently a bolt of lightning zipping toward a moose with antlers that bear an unfortunate resemblance to a propeller beanie isn’t going to win me any scholarships to art school, if you catch my drift. Anyway, my drawing happened to feature the word “chartreuse” (because it rhymed with “moose” and “Zeus”—hence the lightning; more than that I am not at liberty to divulge), and she wanted to know if the moose was actually chartreuse. I had to admit that I didn’t know, so we went to the dictionary, whereupon we learned that chartreuse is a pale apple-green color. Then she brought up the Windows Control Panel, pointed to the selection of predefined colors, and asked, “Which of those is chartreuse?”—and I realized that I <em>still</em> didn’t know.</p>
<p>Some things can be described perfectly with words, but others just have to be experienced. Color is one such category, and Pentium optimization is another. I’ve spent the last two chapters detailing the rules for Pentium optimization, and I’ll spend half of this one doing so, as well. That’s good; without understanding the fundamentals, we have no chance of optimizing well. It’s not enough, though. We also need to look at a real-world example of Pentium optimization in action, and we’ll do that later in this chapter; after which, you should go out and do some Pentium optimization on your own. Optimization is one of those things that you can learn a lot about from reading, but ultimately it has to sink into your pores as you do it—especially Pentium optimization because the Pentium is perhaps the most complex (and rewarding) chip to optimize for that I’ve ever seen.</p>
<p>In the last chapter, we explored the dual-execution-pipe nature of the Pentium, and learned which instructions could pair (execute simultaneously) in which pipes. Now we’re ready to look at AGIs and register contention—two hazards that can prevent otherwise properly written code from taking full advantage of the Pentium’s two pipes, and can thereby keep your code from pushing the Pentium to maximum performance.</p>
</section>
<section id="address-generation-interlocks" class="level3">
<h3><a href="#address-generation-interlocks">Address Generation Interlocks</a></h3>
<p>The Pentium is advertised as having a five-stage pipeline for each of its execution units. All this means is that at any given time, up to five instructions are in various stages of execution in each pipe; this overlapping of execution is done for speed, so each instruction doesn’t have to wait until the previous one has finished. The only way that the Pentium’s pipelining directly affects the way you program is in the areas of AGIs and register dependencies.</p>
<p>AGIs are <em>Address Generation Interlocks</em>, a fancy way of saying that if a register is used to address memory, as is EBX in this instruction</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> [<span class="kw">ebx</span>],<span class="kw">eax</span></code></pre>
<p>and the value of the register is not set far enough ahead for the Pentium to perform the addressing calculations before the instruction needs the address, then the Pentium will stall the pipe in which the instruction is executing until the value becomes available and the addressing calculations have been performed. Remember, also, that instructions execute in lockstep on the Pentium, so if one pipe stalls for a cycle, making its instruction take one cycle longer, that extends by one cycle the time until the other pipe can begin its next instruction, as well.</p>
<p>The rule for AGIs is simple: If you modify any part of a register during a cycle, you cannot use that register to address memory during either that cycle or the next cycle. If you try to do this, the Pentium will simply stall the instruction that tries to use that register to address memory until two cycles after the register was modified. This was true on the 486 as well, but the Pentium’s new twist is that since more than one instruction can execute in a single cycle, an AGI can stall an instruction that’s as many as three instructions away from the changing of the addressing register, as shown in Figure 21.1, and an AGI can also cause a stall that costs as many as three instructions, as shown in Figure 21.2. This means that AGIs are both much easier to cause and potentially more expensive than on the 486, and you must keep a sharp eye out for them. It also means that it’s often worth calculating a memory pointer several instructions ahead of its actual use. Unfortunately, this tends to extend the lifetimes of pointer registers to span a greater number of instructions, making the Pentium’s relatively small register set seem even smaller.</p>
<figure>
<img src="images/21-01.jpg" alt="Figure 21.1  An AGI can stall up to three instructions later." /><figcaption><strong>Figure 21.1</strong>  <em>An AGI can stall up to three instructions later.</em></figcaption>
</figure>
<p>As an example of a sort of AGI that’s new to the Pentium, consider the following test for a NULL pointer, followed by the use of the pointer if it’s not NULL:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">push</span> <span class="kw">ebx</span>          <span class="co">;U-pipe cycle 1</span>
<span class="kw">mov</span>  <span class="kw">ebx</span>,[<span class="dt">Ptr</span>]    <span class="co">;V-pipe cycle 1</span>
<span class="kw">and</span>  <span class="kw">ebx</span>,<span class="kw">ebx</span>      <span class="co">;U-pipe cycle 2</span>
<span class="kw">jz</span>   <span class="dt">short</span> IsNull <span class="co">;V-pipe cycle 2</span>
<span class="kw">mov</span>  <span class="kw">eax</span>,[<span class="kw">ebx</span>]    <span class="co">;U-pipe cycle 3 AGI stall</span>
<span class="kw">mov</span>  <span class="kw">edx</span>,[<span class="kw">ebp</span><span class="dv">-8</span>]  <span class="co">;V-pipe cycle 3 lockstep idle</span>
                  <span class="co">;U-pipe cycle 4 mov eax,[ebx]</span>
                  <span class="co">;V-pipe cycle 4 mov edx,[ebp-8]</span></code></pre>
<p>This commonplace code loses a U-pipe cycle to the AGI caused by <code>AND EBX,EBX</code>, followed by the attempt two instructions later to use EBX to point to memory. The code loses a V-pipe cycle as well, because lockstep execution won’t let the next V-pipe instruction execute until the paired U-pipe instruction that suffered the AGI finishes. The solution is to use <code>TEST EBX,EBX</code> instead of <code>AND; TEST</code> can’t modify EBX, so no AGI occurs. Sure, <code>AND EBX,EBX</code> doesn’t modify EBX either, but the Pentium doesn’t know that, so it has to insert the AGI.</p>
<figure>
<img src="images/21-02.jpg" alt="Figure 21.2  An AGI can cost as many as 3 cycles." /><figcaption><strong>Figure 21.2</strong>  <em>An AGI can cost as many as 3 cycles.</em></figcaption>
</figure>
<p>As on the 486, you should keep a careful eye out for AGIs involving the stack pointer. Implicit modifiers of ESP, such as <code>PUSH</code> and <code>POP</code>, are special-cased so you don’t have to worry about AGIs. However, if you explicitly modify ESP with this instruction</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">sub</span> <span class="kw">esp</span><span class="bn">,100h</span></code></pre>
<p>for example, or with the popular</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">esp</span>,<span class="kw">ebp</span></code></pre>
<p>you can then get AGIs if you attempt to use ESP to address memory, either explicitly with instructions like this one</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">moveax,[<span class="kw">esp</span>+20h]</code></pre>
<p>or via <code>PUSH</code>, <code>POP</code>, or other instructions that implicitly use ESP as an addressing register.</p>
<p>On the 486, any instruction that had both a constant value and an addressing displacement, such as</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">ebp</span><span class="dv">+16</span>],<span class="dv">1</span></code></pre>
<p>suffered a 1-cycle penalty, taking a total of 2 cycles. Such instructions take only one cycle on the Pentium, but they cannot pair, so they’re still the most expensive sort of <code>MOV</code>. Knowing this can speed up something as simple as zeroing two memory variables, as in</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">sub</span> <span class="kw">eax</span>,<span class="kw">eax</span>        <span class="co">;U-pipe 1</span>
                   <span class="co">;any V-pipe pairable</span>
                   <span class="co">; instruction can go here,</span>
                   <span class="co">; or SUB could be in V-pipe</span>
<span class="kw">mov</span> [MemVar1],<span class="kw">eax</span>  <span class="co">;U-pipe 2</span>
<span class="kw">mov</span> [MemVar2],<span class="kw">eax</span>  <span class="co">;V-pipe 2</span></code></pre>
<p>which should never be slower and should potentially be 0.5 cycles faster, and six bytes smaller than this sequence:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> [MemVar1],<span class="dv">0</span> <span class="co">;U-pipe 1</span>
<span class="kw">mov</span> [MemVar2],<span class="dv">0</span> <span class="co">;U-pipe 2</span></code></pre>
<p>Note, however, that my experiments thus far indicate that the two writes in the first case don’t actually pair (possibly because the memory variables have never been read into the internal cache), so you might want to insert an instruction between the two <code>MOV</code>s—and, of course, this is yet another reason why you should always measure your code’s actual performance.</p>
</section>
<section id="register-contention" class="level3">
<h3><a href="#register-contention">Register Contention</a></h3>
<p>Finally, we come to the last major component of superscalar optimization: register contention. The basic premise here is simple: You can’t use the same register in two inherently sequential ways in a single cycle. For example, you can’t execute</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">inc</span> <span class="kw">eax</span>     <span class="co">;U-pipe cycle 1</span>
            <span class="co">;V-pipe idle cycle 1</span>
            <span class="co">; due to dependency</span>
<span class="kw">and</span> <span class="kw">ebx</span>,<span class="kw">eax</span> <span class="co">;U-pipe cycle 2</span></code></pre>
<p>in a single cycle; <code>AND EBX,EAX</code> can’t execute until the value in EAX is known, and that can’t happen until <code>INC EAX</code> is done. Consequently, the V-pipe idles while <code>INC EAX</code> executes in the U-pipe. We saw this in the last chapter when we discussed splitting instructions into simple instructions, and it is by far the most common sort of register contention, known as read-after-write register contention. Read-after-write register contention is the primary reason we have to interleave independent operations in order to get maximum V-pipe usage.</p>
<p>The other sort of register contention is known as write-after-write. Write-after-write register contention happens when two instructions try to write to the same register on the same cycle. While that may not seem like a particularly useful operation in general, it can happen when subregisters are being set, as in the following</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">sub</span> <span class="kw">eax</span>,<span class="kw">eax</span>   <span class="co">;U-pipe cycle 1</span>
              <span class="co">;V-pipe idle cycle 1</span>
              <span class="co">; due to register contention</span>
<span class="kw">mov</span> <span class="kw">al</span>,[Var]  <span class="co">;U-pipe cycle 2</span></code></pre>
<p>where an attempt is made to set both EAX and its AL subregister on the same cycle. Write-after-write contention implies that the two instructions comprising the above substitute for <code>MOVZX</code> should have at least one unrelated instruction between them when <code>SUB EAX,EAX</code> executes in the V-pipe.</p>
<section id="exceptions-to-register-contention" class="level4">
<h4><a href="#exceptions-to-register-contention">Exceptions to Register Contention</a></h4>
<p>Intel has special-cased some very useful exceptions to register contention. Happily, write-after-read operations do <em>not</em> cause contention. Such operations, as in</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">eax</span>,<span class="kw">edx</span> <span class="co">;U-pipe cycle 1</span>
<span class="kw">sub</span> <span class="kw">edx</span>,edxX <span class="co">;V-pipe cycle 1</span></code></pre>
<p>are free of charge.</p>
<p>Also, stack-related instructions that modify ESP only implicitly (without ESP as part of any explicit operand) do not cause AGIs, and neither do they cause register contention with other instructions that use ESP only implicitly; such instructions include <code>PUSH *reg/immed*, POP *reg*</code>, and <code>CALL</code>. (However, these instructions do cause register contention on ESP—but not AGIs—with instructions that use ESP explicitly, such as <code>MOV EAX,[ESP+4]</code>.) Without this special case, the following sequence would hardly use the V-pipe at all:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>  <span class="kw">eax</span>,[MemVar] <span class="co">;U-pipe cycle 1</span>
<span class="kw">push</span> <span class="kw">esi</span>          <span class="co">;V-pipe cycle 1</span>
<span class="kw">push</span> <span class="kw">eax</span>          <span class="co">;U-pipe cycle 2</span>
<span class="kw">push</span> <span class="kw">edi</span>          <span class="co">;V-pipe cycle 2</span>
<span class="kw">push</span> <span class="kw">ebx</span>          <span class="co">;U-pipe cycle 3</span>
<span class="kw">call</span> FooTilde     <span class="co">;V-pipe cycle 3</span></code></pre>
<p>But in fact, all the instructions pair, even though ESP is modified five times in the space of six instructions.</p>
<p>The final register-contention special case is both remarkable and remarkably important. There is exactly one sort of instruction that can pair only in the V-pipe: branches. Any near call or conditional or unconditional near jump can execute in the V-pipe paired with any pairable U-pipe instruction, as illustrated by this sequence:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="fu">LoopTop:</span>
   <span class="kw">mov</span> [<span class="kw">esi</span>],<span class="kw">eax</span> <span class="co">;U-pipe cycle 1</span>
   <span class="kw">add</span> <span class="kw">esi</span>,<span class="dv">4</span>     <span class="co">;V-pipe cycle 1</span>
   <span class="kw">dec</span> <span class="kw">ecx</span>       <span class="co">;U-pipe cycle 2</span>
   <span class="kw">jnz</span> LoopTop   <span class="co">;V-pipe cycle 2</span></code></pre>
<p>Branches can’t pair in the U-pipe; a branch that executes in the U-pipe runs alone, with the V-pipe idle. If a call or jump is correctly predicted by the Pentium’s branch prediction circuitry (as discussed in the last chapter), it executes in a single cycle, pairing if it runs in the V-pipe; if mispredicted, conditional jumps take 4 cycles in the U-pipe and 5 cycles in the V-pipe, and mispredicted calls and unconditional jumps take 3 cycles in either pipe. Note that <code>RET</code> can’t pair.</p>
</section>
</section>
<section id="whos-in-first" class="level3">
<h3><a href="#whos-in-first">Who’s in First?</a></h3>
<p>One of the trickiest things about superscalar optimization is that a given instruction stream can execute at a different speed depending on the pipe where it starts execution, because which instruction goes through the U-pipe first determines which of the following instructions will be able to pair. If we take the last example and add one more instruction, the other instructions will go through different pipes than previously, and cause the loop as a whole to take 50 percent longer, even though we only added 25 percent more cycles:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="fu">LoopTop:</span>
   <span class="kw">inc</span> <span class="kw">edx</span>           <span class="co">;U-pipe cycle 1</span>
   <span class="kw">mov</span> [<span class="kw">esi</span>],<span class="kw">eax</span>     <span class="co">;V-pipe cycle 1</span>
   <span class="kw">add</span> <span class="kw">esi</span>,<span class="dv">4</span>         <span class="co">;U-pipe cycle 2</span>
   <span class="kw">dec</span> <span class="kw">ecx</span>           <span class="co">;V-pipe cycle 2</span>
   <span class="kw">jnz</span> LoopTop       <span class="co">;U-pipe cycle 3</span>
                     <span class="co">;V-pipe idle cycle 3</span>
                     <span class="co">; because JNZ can&#39;t</span>
                     <span class="co">; pair in the U-pipe</span></code></pre>
<p>It’s actually not hard to figure out which instructions go through which pipes; just back up until you find an instruction that can’t pair or can only go through the U-pipe, and work forward from there, given the knowledge that that instruction executes in the U-pipe. The easiest thing to look for is branches. All branch target instructions execute in the U-pipe, as do all instructions after conditional branches that fall through. Instructions with prefix bytes are generally good U-pipe markers, although they’re expensive instructions that should be avoided whenever possible, and have at least one aberration with regard to pipe usage, as discussed below. Shifts, rotates, <code>ADC, SBB</code>, and all other instructions not listed in Table 20.1 in the last chapter are likewise U-pipe markers.</p>
</section>
<section id="pentium-optimization-in-action" class="level3">
<h3><a href="#pentium-optimization-in-action">Pentium Optimization in Action</a></h3>
<p>Now, let’s take a look at one of the simplest, tightest pieces of code imaginable, and see what our new Pentium perspective reveals. Listing 21.1 shows a loop implementing the TCP/IP checksum, a 16-bit checksum that wraps carries around to the low bit so that the result is endian-independent. This makes it easy to perform checksums on blocks of data regardless of the endian characteristics of the machines on which those blocks are generated and received. (Thanks to fellow performance enthusiast Terje Mathisen for suggesting this checksum as fertile ground for Pentium optimization, in the ibm.pc/fast.code forum on Bix.) The loop in Listing 21.1 consists of exactly five instructions; it’s hard to imagine that there’s a lot of performance to be wrung from this snippet, right?</p>
<p><strong>LISTING 21.1 L21-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Calculates TCP/IP (16-bit carry-wrapping) checksum for buffer</span>
<span class="co">;  starting at ESI, of length ECX words.</span>
<span class="co">; Returns checksum in AX.</span>
<span class="co">; ECX and ESI destroyed.</span>
<span class="co">; All cycle counts assume 32-bit protected mode.</span>
<span class="co">; Assumes buffer length &gt; 0.</span>
<span class="co">; Note that timing indicates that the pipe sequence and</span>
<span class="co">;  cycle counts shown (based on documented execution rules)</span>
<span class="co">;  differ from the actual execution sequence and cycle counts;</span>
<span class="co">;  this loop has been measured to execute in 5 cycles; apparently,</span>
<span class="co">;  the 1st half of ADD somehow pairs with the prefix byte, or the</span>
<span class="co">;  refix byte gets executed ahead of time.</span>

        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>           <span class="co">;initialize the checksum</span>

<span class="fu">ckloop:</span>
        <span class="kw">add</span>     <span class="kw">ax</span>,[<span class="kw">esi</span>]        <span class="co">;cycle 1 U-pipe prefix byte</span>
                                <span class="co">;cycle 1 V-pipe idle (no pairing w/prefix)</span>
                                <span class="co">;cycle 2 U-pipe 1st half of ADD</span>
                                <span class="co">;cycle 2 V-pipe idle (register contention)</span>
                                <span class="co">;cycle 3 U-pipe 2nd half of ADD</span>
                                <span class="co">;cycle 3 V-pipe idle (register contention)</span>
        <span class="kw">adc</span>     <span class="kw">ax</span>,<span class="dv">0</span>            <span class="co">;cycle 4 U-pipe prefix byte</span>
                                <span class="co">;cycle 4 V-pipe idle (no pairing w/prefix)</span>
                                <span class="co">;cycle 5 U-pipe ADC AX,0</span>
        <span class="kw">add</span>     <span class="kw">esi</span>,<span class="dv">2</span>           <span class="co">;cycle 5 V-pipe</span>
        <span class="kw">dec</span>     <span class="kw">ecx</span>             <span class="co">;cycle 6 U-pipe</span>
        <span class="kw">jnz</span>     ckloop          <span class="co">;cycle 6 V-pipe</span></code></pre>
<p>Wrong, wrong, wrong! As detailed in Listing 21.1, this loop should take 6 cycles per checksummed word in 32-bit protected mode, a ridiculously high number for the Pentium. (You’ll see why I say “should take,” not “takes,” shortly.) We should lose 2 cycles in each pipe to the two size prefixes (because the <code>ADD</code>s are 16-bit operations in a 32-bit segment), and another 2 cycles because of register contention that arises when <code>ADC AX,0</code> has to wait for the result of <code>ADD AX,[ESI]</code>. Then, too, even though <code>DEC</code> and <code>JNZ</code> can pair and the branch prediction for <code>JNZ</code> is presumably correct virtually all the time, they do take a full cycle, and maybe we can do something about that as well.</p>
<p>The first thing to do is to time the code in Listing 21.1 to verify our analysis. When I unleashed the Zen timer on Listing 21.1, I found, to my surprise, that the code actually takes only five cycles per checksum word processed, not six. A little more experimentation revealed that adding a size prefix to the two-cycle <code>ADD EAX,[ESI]</code> instruction doesn’t cost anything, certainly not the one full cycle in each pipe that a prefix is supposed to take. More experimentation showed that prefix bytes do cost the documented extra cycle when used with one-cycle instructions such as <code>MOV</code>. At this point, my preliminary conclusion is that prefixes can pair with the first cycle of at least some multiple-cycle instructions. Determining exactly why this happens will take further research on my part, but the most important conclusion is that you <em>must</em> measure your code!</p>
<p>The first, obvious thing we can do to Listing 21.1 is change <code>ADC AX,0</code> to <code>ADC EAX,0</code>, eliminating a prefix byte and saving a full cycle. Now we’re down from five to four cycles. What next?</p>
<p>Listing 21.2 shows one interesting alternative that doesn’t really buy us anything. Here, we’ve eliminated all size prefixes by doing byte-sized <code>MOVs</code> and <code>ADDs</code>, but because the size prefix on <code>ADD  AX,[ESI]</code>, for whatever reason, didn’t cost anything in Listing 21.1, our efforts are to no avail—Listing 21.2 still takes 4 cycles per checksummed word. What’s worth noting about Listing 21.2 is the extent to which the code is broken into simple instructions and reordered so as to avoid size prefixes, register contention, AGIs, and data bank conflicts (the latter because both <code>[ESI]</code> and <code>[ESI+1]</code> are in the same cache data bank, as discussed in the last chapter).</p>
<p><strong>LISTING 21.2 L21-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Calculates TCP/IP (16-bit carry-wrapping) checksum for buffer</span>
<span class="co">;  starting at ESI, of length ECX words.</span>
<span class="co">; Returns checksum in AX.</span>
<span class="co">; High word of EAX, DX, ECX and ESI destroyed.</span>
<span class="co">; All cycle counts assume 32-bit protected mode.</span>
<span class="co">; Assumes buffer length &gt; 0.</span>

        <span class="kw">sub</span>     <span class="kw">eax</span>,<span class="kw">eax</span>         <span class="co">;initialize the checksum</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">esi</span>]        <span class="co">;first word to checksum</span>
        <span class="kw">dec</span>     <span class="kw">ecx</span>             <span class="co">;we&#39;ll do 1 checksum outside the loop</span>
        <span class="kw">jz</span>      <span class="dt">short</span> ck<span class="kw">loope</span>nd <span class="co">;only 1 checksum to do</span>
        <span class="kw">add</span>     <span class="kw">esi</span>,<span class="dv">2</span>           <span class="co">;point to the next word to checksum</span>

<span class="fu">ckloop:</span>
        <span class="kw">add</span>     <span class="kw">al</span>,<span class="kw">dl</span>           <span class="co">;cycle 1 U-pipe</span>
        <span class="kw">mov</span>     <span class="kw">dl</span>,[<span class="kw">esi</span>]        <span class="co">;cycle 1 V-pipe</span>
        <span class="kw">adc</span>     <span class="kw">ah</span>,<span class="kw">dh</span>           <span class="co">;cycle 2 U-pipe</span>
        <span class="kw">mov</span>     <span class="kw">dh</span>,[<span class="kw">esi</span><span class="dv">+1</span>]      <span class="co">;cycle 2 V-pipe</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="dv">0</span>           <span class="co">;cycle 3 U-pipe</span>
        <span class="kw">add</span>     <span class="kw">esi</span>,<span class="dv">2</span>           <span class="co">;cycle 3 V-pipe</span>
        <span class="kw">dec</span>     <span class="kw">ecx</span>             <span class="co">;cycle 4 U-pipe</span>
        <span class="kw">jnz</span>     ckloop          <span class="co">;cycle 4 V-pipe</span>

<span class="fu">ckloopend:</span>
        <span class="kw">add</span>     <span class="kw">ax</span>,<span class="kw">dx</span>           <span class="co">;checksum the last word</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="dv">0</span></code></pre>
<p>Listing 21.3 is a more sophisticated attempt to speed up the checksum calculation. Here we see a hallmark of Pentium optimization: two operations (the checksumming of the current and next pair of words) interleaved together to allow both pipes to run at near maximum capacity. Another hallmark that’s apparent in Listing 21.3 is that Pentium-optimized code tends to use more registers and require more instructions than 486-optimized code. Again, note the careful mixing of byte-sized reads to avoid AGIs, register contention, and cache bank collisions, in particular the way in which the byte reads of memory are interspersed with the additions to avoid register contention, and the placement of <code>ADD ESI,4</code> to avoid an AGI.</p>
<p><strong>LISTING 21.3 L21-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Calculates TCP/IP (16-bit carry-wrapping) checksum for buffer</span>
<span class="co">;  starting at ESI, of length ECX words.</span>
<span class="co">; Returns checksum in AX.</span>
<span class="co">; High word of EAX, BX, EDX, ECX and ESI destroyed.</span>
<span class="co">; All cycle counts assume 32-bit protected mode.</span>
<span class="co">; Assumes buffer length &gt; 0.</span>

        <span class="kw">sub</span>     <span class="kw">eax</span>,<span class="kw">eax</span>            <span class="co">;initialize the checksum</span>
        <span class="kw">sub</span>     <span class="kw">edx</span>,<span class="kw">edx</span>            <span class="co">;prepare for later ORing</span>
        <span class="kw">shr</span>     <span class="kw">ecx</span>,<span class="dv">1</span>              <span class="co">;we&#39;ll do two words per loop</span>
        <span class="kw">jnc</span>     <span class="dt">short</span> ck<span class="kw">loops</span>etup  <span class="co">;even number of words</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">esi</span>]           <span class="co">;do the odd word</span>
        <span class="kw">jz</span>      <span class="dt">short</span> ckloopdone   <span class="co">;no more words to checksum</span>
        <span class="kw">add</span>     <span class="kw">esi</span>,<span class="dv">2</span>              <span class="co">;point to the next word</span>
<span class="fu">ckloopsetup:</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">esi</span>]           <span class="co">;load most of 1st word to</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,[<span class="kw">esi</span><span class="dv">+2</span>]         <span class="co">; checksum (last byte loaded in loop)</span>
        <span class="kw">dec</span>     <span class="kw">ecx</span>                <span class="co">;any more dwords to checksum?</span>
        <span class="kw">jz</span>    <span class="dt">short</span> ck<span class="kw">loope</span>nd      <span class="co">;no</span>

<span class="fu">ckloop:</span>
        <span class="kw">mov</span>     <span class="kw">bh</span>,[<span class="kw">esi</span><span class="dv">+3</span>]      <span class="co">;cycle 1 U-pipe</span>
        <span class="kw">add</span>     <span class="kw">esi</span>,<span class="dv">4</span>           <span class="co">;cycle 1 V-pipe</span>
        <span class="kw">shl</span>     <span class="kw">ebx</span>,<span class="dv">16</span>          <span class="co">;cycle 2 U-pipe</span>
                                <span class="co">;cycle 2 V-pipe idle</span>
                                <span class="co">; (register contention)</span>
        <span class="kw">or</span>      <span class="kw">ebx</span>,<span class="kw">edx</span>         <span class="co">;cycle 3 U-pipe</span>
        <span class="kw">mov</span>     <span class="kw">dl</span>,[<span class="kw">esi</span>]        <span class="co">;cycle 3 V-pipe</span>
        <span class="kw">add</span>     <span class="kw">eax</span>,<span class="kw">ebx</span>         <span class="co">;cycle 4 U-pipe</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,[<span class="kw">esi</span><span class="dv">+2</span>]      <span class="co">;cycle 4 V-pipe</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="dv">0</span>           <span class="co">;cycle 5 U-pipe</span>
        <span class="kw">mov</span>     <span class="kw">dh</span>,[<span class="kw">esi</span><span class="dv">+1</span>]      <span class="co">;cycle 5 V-pipe</span>
        <span class="kw">dec</span>     <span class="kw">ecx</span>             <span class="co">;cycle 6 U-pipe</span>
        <span class="kw">jnz</span>     ckloop          <span class="co">;cycle 6 V-pipe</span>

<span class="fu">ckloopend:</span>
        <span class="kw">mov</span>     <span class="kw">bh</span>,[<span class="kw">esi</span><span class="dv">+3</span>]      <span class="co">;checksum the last dword</span>
           <span class="kw">add</span>   <span class="kw">ax</span>,<span class="kw">dx</span>
           <span class="kw">adc</span>   <span class="kw">ax</span>,<span class="kw">bx</span>
           <span class="kw">adc</span>   <span class="kw">ax</span>,<span class="dv">0</span>

        <span class="kw">mov</span>         <span class="kw">edx</span>,<span class="kw">eax</span>         <span class="co">;compress the 32-bit checksum</span>
        <span class="kw">shr</span>         <span class="kw">edx</span>,<span class="dv">16</span>          <span class="co">; into a 16-bit checksum</span>
        <span class="kw">add</span>         <span class="kw">ax</span>,<span class="kw">dx</span>
        <span class="kw">adc</span>         <span class="kw">eax</span>,<span class="dv">0</span>
<span class="fu">ckloopdone:</span></code></pre>
<p>The checksum loop in Listing 21.3 takes longer than the loop in Listing 21.2, at 6 cycles versus 4 cycles for Listing 21.2—but Listing 21.3 does two checksum operations in those 6 cycles, so we’ve cut the time per checksum addition from 4 to 3 cycles. You might think that this small an improvement doesn’t justify the additional complexity of Listing 21.3, but it is a one-third speedup, well worth it if this is a critical loop—and, in general, if it isn’t critical, there’s no point in hand-tuning it. That’s why I haven’t bothered to try to optimize the non-inner-loop code in Listing 21.3; it’s only executed once per checksum, so it’s unlikely that a cycle or two saved there would make any real-world difference.</p>
<p>Listing 21.3 could be made a bit faster yet with some loop unrolling, but that would make the code quite a bit more complex for relatively little return. Instead, why not make the code more complex and get a <em>big</em> return? Listing 21.4 does exactly that by loading one dword at a time to eliminate both the word prefix of Listing 21.1 and the multiple byte-sized accesses of Listing 21.3. An obvious drawback to this is the considerable complexity needed to ensure that the dword accesses are dword-aligned (remember that unaligned dword accesses cost three cycles each), and to handle buffer lengths that aren’t dword multiples. I’ve handled these problems by requiring that the buffer be dword-aligned and a dword multiple in length, which is of course not always the case in the real world. However, the point of these listings is to illustrate Pentium optimization—dword issues, being non-inner-loop stuff, are solvable details that aren’t germane to the main focus. In any case, the complexity and assumptions are well justified by the performance of this code: three cycles per loop, or 1.5 cycles per checksummed word, more than three times the speed of the original code. Again, note that the actual order in which the instructions are arranged is dictated by the various optimization hazards of the Pentium.</p>
<p><strong>LISTING 21.4 L21-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Calculates TCP/IP (16-bit carry-wrapping) checksum for buffer</span>
<span class="co">;  starting at ESI, of length ECX words.</span>
<span class="co">; Returns checksum in AX.</span>
<span class="co">; High word of EAX, ECX, EDX, and ESI destroyed.</span>
<span class="co">; All cycle counts assume 32-bit protected mode.</span>
<span class="co">; Assumes buffer starts on a dword boundary, is a dword multiple</span>
<span class="co">; in length, and length &gt; 0.</span>

        <span class="kw">sub</span>     <span class="kw">eax</span>,<span class="kw">eax</span>         <span class="co">;initialize the checksum</span>
        <span class="kw">shr</span>     <span class="kw">ecx</span>,<span class="dv">1</span>           <span class="co">;we&#39;ll do two words per loop</span>
        <span class="kw">mov</span>     <span class="kw">edx</span>,[<span class="kw">esi</span>]       <span class="co">;preload the first dword</span>
        <span class="kw">add</span>     <span class="kw">esi</span>,<span class="dv">4</span>           <span class="co">;point to the next dword</span>
        <span class="kw">dec</span>     <span class="kw">ecx</span>             <span class="co">;we&#39;ll do 1 checksum outside the loop</span>
        <span class="kw">jz</span>      <span class="dt">short</span> ck<span class="kw">loope</span>nd <span class="co">;only 1 checksum to do</span>

<span class="fu">ckloop:</span>
        <span class="kw">add</span>     <span class="kw">eax</span>,<span class="kw">edx</span>         <span class="co">;cycle 1 U-pipe</span>
        <span class="kw">mov</span>     <span class="kw">edx</span>,[<span class="kw">esi</span>]       <span class="co">;cycle 1 V-pipe</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="dv">0</span>           <span class="co">;cycle 2 U-pipe</span>
        <span class="kw">add</span>     <span class="kw">esi</span>,<span class="dv">4</span>           <span class="co">;cycle 2 V-pipe</span>
        <span class="kw">dec</span>     <span class="kw">ecx</span>             <span class="co">;cycle 3 U-pipe</span>
        <span class="kw">jnz</span>     ckloop          <span class="co">;cycle 3 V-pipe</span>

<span class="fu">ckloopend:</span>
        <span class="kw">add</span>     <span class="kw">eax</span>,<span class="kw">edx</span>         <span class="co">;checksum the last dword</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="dv">0</span>
        <span class="kw">mov</span>     <span class="kw">edx</span>,<span class="kw">eax</span>         <span class="co">;compress the 32-bit checksum</span>
        <span class="kw">shr</span>     <span class="kw">edx</span>,<span class="dv">16</span>          <span class="co">; into a 16-bit checksum</span>
        <span class="kw">add</span>     <span class="kw">ax</span>,<span class="kw">dx</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="dv">0</span></code></pre>
<p>Listing 21.5 improves upon Listing 21.4 by processing 2 dwords per loop, thereby bringing the time per checksummed word down to exactly 1 cycle. Listing 21.5 basically does nothing but unroll Listing 21.4’s loop one time, demonstrating that the venerable optimization technique of loop unrolling still has some life left in it on the Pentium. The cost for this is, as usual, increased code size and complexity, and the use of more registers.</p>
<p><strong>LISTING 21.5 L21-5.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Calculates TCP/IP (16-bit carry-wrapping) checksum for buffer</span>
<span class="co">;  starting at ESI, of length ECX words.</span>
<span class="co">; Returns checksum in AX.</span>
<span class="co">; High word of EAX, EBX, ECX, EDX, and ESI destroyed.</span>
<span class="co">; All cycle counts assume 32-bit protected mode.</span>
<span class="co">; Assumes buffer starts on a dword boundary, is a dword multiple</span>
<span class="co">;  in length, and length &gt; 0.</span>

        <span class="kw">sub</span>     <span class="kw">eax</span>,<span class="kw">eax</span>          <span class="co">;initialize the checksum</span>
        <span class="kw">shr</span>     <span class="kw">ecx</span>,<span class="dv">2</span>            <span class="co">;we&#39;ll do two dwords per loop</span>
        <span class="kw">jnc</span>     <span class="dt">short</span> noodddword <span class="co">;is there an odd dword in buffer?</span>
        <span class="kw">mov</span>     <span class="kw">eax</span>,[<span class="kw">esi</span>]        <span class="co">;checksum the odd dword</span>
        <span class="kw">jz</span>      <span class="dt">short</span> ckloopdone <span class="co">;no, done</span>
        <span class="kw">add</span>     <span class="kw">esi</span>,<span class="dv">4</span>            <span class="co">;point to the next dword</span>
<span class="fu">noodddword:</span>
        <span class="kw">mov</span>     <span class="kw">edx</span>,[<span class="kw">esi</span>]       <span class="co">;preload the first dword</span>
        <span class="kw">mov</span>     <span class="kw">ebx</span>,[<span class="kw">esi</span><span class="dv">+4</span>]     <span class="co">;preload the second dword</span>
        <span class="kw">dec</span>     <span class="kw">ecx</span>             <span class="co">;we&#39;ll do 1 checksum outside the loop</span>
        <span class="kw">jz</span>      <span class="dt">short</span> ck<span class="kw">loope</span>nd <span class="co">;only 1 checksum to do</span>
        <span class="kw">add</span>     <span class="kw">esi</span>,<span class="dv">8</span>           <span class="co">;point to the next dword</span>

<span class="fu">ckloop:</span>
        <span class="kw">add</span>     <span class="kw">eax</span>,<span class="kw">edx</span>         <span class="co">;cycle 1 U-pipe</span>
        <span class="kw">mov</span>     <span class="kw">edx</span>,[<span class="kw">esi</span>]       <span class="co">;cycle 1 V-pipe</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="kw">ebx</span>         <span class="co">;cycle 2 U-pipe</span>
        <span class="kw">mov</span>     <span class="kw">ebx</span>,[<span class="kw">esi</span><span class="dv">+4</span>]     <span class="co">;cycle 2 V-pipe</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="dv">0</span>           <span class="co">;cycle 3 U-pipe</span>
        <span class="kw">add</span>     <span class="kw">esi</span>,<span class="dv">8</span>           <span class="co">;cycle 3 V-pipe</span>
        <span class="kw">dec</span>     <span class="kw">ecx</span>             <span class="co">;cycle 4 U-pipe</span>
        <span class="kw">jnz</span>     ckloop          <span class="co">;cycle 4 V-pipe</span>

<span class="fu">ckloopend:</span>
        <span class="kw">add</span>     <span class="kw">eax</span>,<span class="kw">edx</span>         <span class="co">;checksum the last two dwords</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="kw">ebx</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="dv">0</span>
<span class="fu">ckloopdone:</span>
        <span class="kw">mov</span>     <span class="kw">edx</span>,<span class="kw">eax</span>         <span class="co">;compress the 32-bit checksum</span>
        <span class="kw">shr</span>     <span class="kw">edx</span>,<span class="dv">16</span>          <span class="co">; into a 16-bit checksum</span>
        <span class="kw">add</span>     <span class="kw">ax</span>,<span class="kw">dx</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="dv">0</span></code></pre>
<p>Listing 21.5 is undeniably intricate code, and not the sort of thing one would choose to write as a matter of course. On the other hand, it’s five times as fast as the tight, seemingly-speedy loop in Listing 21.1 (and six times as fast as Listing 21.1 would have been if the prefix byte had behaved as expected). That’s an awful lot of speed to wring out of a five-instruction loop, and the TCP/IP checksum is, in fact, used by network software, an area in which a five-times speedup might make a significant difference in overall system performance.</p>
<p>I don’t claim that Listing 21.5 is the fastest possible way to do a TCP/IP checksum on a Pentium; in fact, it isn’t. Unrolling the loop one more time, together with a trick of Terje’s that uses <code>LEA</code> to advance ESI (neither <code>LEA</code> nor <code>DEC</code> affects the carry flag, allowing Terje to add the carry from the previous loop iteration into the next iteration’s checksum via <code>ADC</code>), produces a version that’s a full 33 percent faster. Nonetheless, Listings 21.1 through 21.5 illustrate many of the techniques and considerations in Pentium optimization. Hand-optimization for the Pentium isn’t simple, and requires careful measurement to check the efficacy of your optimizations, so reserve it for when you really, really need it—but when you need it, you need it <em>bad</em>.</p>
<section id="a-quick-note-on-the-386-and-486" class="level4">
<h4><a href="#a-quick-note-on-the-386-and-486">A Quick Note on the 386 and 486</a></h4>
<p>I’ve mentioned that Pentium-optimized code does fine on the 486, but not always so well on the 386. On a 486, Listing 21.1 runs at 9 cycles per checksummed word, and Listing 21.5 runs at 2.5 cycles per checksummed word, a healthy 3.6-times speedup. On a 386, Listing 21.1 runs at 22 cycles per word; Listing 21.5 runs at 7 cycles per word, a 3.1-times speedup. As is often the case, Pentium optimization helped the other processors, but not as much as it helped the Pentium, and less on the 386 than on the 486.</p>
</section>
</section>
</section>
<section id="chapter-22-zenning-and-the-flexible-mind" class="level2">
<h2><a href="#chapter-22-zenning-and-the-flexible-mind">Chapter 22 – Zenning and the Flexible Mind</a></h2>
<section id="taking-a-spin-through-what-youve-learned" class="level3">
<h3><a href="#taking-a-spin-through-what-youve-learned">Taking a Spin through What You’ve Learned</a></h3>
<p>And so we come to the end of our journey; for now, at least. What follows is a modest bit of optimization, one which originally served to show readers of <em>Zen of Assembly Language</em> that they had learned more than just bits and pieces of knowledge; that they had also begun to learn how to apply the flexible mind—unconventional, broadly integrative thinking—to approaching high-level optimization at the algorithmic and program design levels. You, of course, need no such reassurance, having just spent 21 chapters learning about the flexible mind in many guises, but I think you’ll find this example instructive nonetheless. Try to stay ahead as the level of optimization rises from instruction elimination to instruction substitution to more creative solutions that involve broader understanding and redesign. We’ll start out by compacting individual instructions and bits of code, but by the end we’ll come up with a solution that involves the very structure of the subroutine, with each instruction carefully integrated into a remarkably compact whole. It’s a neat example of how optimization operates at many levels, some much less determininstic than others—and besides, it’s just plain fun.</p>
<p>Enjoy!</p>
</section>
<section id="zenning" class="level3">
<h3><a href="#zenning">Zenning</a></h3>
<p>In Jeff Duntemann’s excellent book <em>Borland Pascal From Square One</em> (Random House, 1993), there’s a small assembly subroutine that’s designed to be called from a Turbo Pascal program in order to fill the screen or a systemscreen buffer with a specified character/attribute pair in text mode. This subroutine involves only 21 instructions and works perfectly well; however, with what we know, we can compact the subroutine tremendously and speed it up a bit as well. To coin a verb, we can “Zen” this already-tight assembly code to an astonishing degree. In the process, I hope you’ll get a feel for how advanced your assembly skills have become.</p>
<p>Jeff’s original code follows as Listing 22.1 (with some text converted to lowercase in order to match the style of this book), but the comments are mine.</p>
<p><strong>LISTING 22.1 L22-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">OnStack      <span class="kw">struc</span>      <span class="co">;data that&#39;s stored on the stack after PUSH BP</span>
OldBP        <span class="dt">dw</span>   ?     <span class="co">;caller&#39;s BP</span>
RetAddr      <span class="dt">dw</span>   ?     <span class="co">;return address</span>
Filler       <span class="dt">dw</span>   ?     <span class="co">;character to fill the buffer with</span>
Attrib       <span class="dt">dw</span>   ?     <span class="co">;attribute to fill the buffer with</span>
BufSize      <span class="dt">dw</span>   ?     <span class="co">;number of character/attribute pairs to fill</span>
BufOfs       <span class="dt">dw</span>   ?     <span class="co">;buffer offset</span>
BufSeg       <span class="dt">dw</span>   ?     <span class="co">;buffer segment</span>
EndMrk       <span class="dt">db</span>   ?     <span class="co">;marker for the end of the stack frame</span>
OnStack      ends
<span class="co">;</span>
ClearS       proc near
     <span class="kw">push</span>    <span class="kw">bp</span>                         <span class="co">;save caller&#39;s BP</span>
     <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>                      <span class="co">;point to stack frame</span>
     <span class="kw">cmp</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BufSeg,<span class="dv">0</span>     <span class="co">;skip the fill if a null</span>
    <span class="kw">jne</span>      Start                      <span class="co">; pointer is passed</span>
    <span class="kw">cmp</span>      <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BufOfs,<span class="dv">0</span>
    <span class="kw">je</span>       Bye
<span class="fu">Start:</span> <span class="kw">cld</span>                           <span class="co">;make STOSW count up</span>
    <span class="kw">mov</span>      <span class="kw">ax</span>,[<span class="kw">bp</span>].Attrib          <span class="co">;load AX with attribute parameter</span>
    <span class="kw">and</span>      <span class="kw">ax</span><span class="bn">,0ff00h               </span><span class="co">;prepare for merging with fill char</span>
    <span class="kw">mov</span>      <span class="kw">bx</span>,[<span class="kw">bp</span>].Filler          <span class="co">;load BX with fill char</span>
    <span class="kw">and</span>      <span class="kw">bx</span><span class="bn">,0ffh                 </span><span class="co">;prepare for merging with attribute</span>
    <span class="kw">or</span>       <span class="kw">ax</span>,<span class="kw">bx</span>                   <span class="co">;combine attribute and fill char</span>
    <span class="kw">mov</span>      <span class="kw">bx</span>,[<span class="kw">bp</span>].BufOfs          <span class="co">;load DI with target buffer offset</span>
    <span class="kw">mov</span>      <span class="kw">di</span>,<span class="kw">bx</span>
    <span class="kw">mov</span>      <span class="kw">bx</span>,[<span class="kw">bp</span>].BufSeg          <span class="co">;load ES with target buffer segment</span>
    <span class="kw">mov</span>      <span class="kw">es</span>,<span class="kw">bx</span>
    <span class="kw">mov</span>      <span class="kw">cx</span>,[<span class="kw">bp</span>].BufSize         <span class="co">;load CX with buffer size</span>
    rep      <span class="kw">stosw</span>                   <span class="co">;fill the buffer</span>
<span class="fu">Bye:</span><span class="kw">mov</span>      <span class="kw">sp</span>,<span class="kw">bp</span>                   <span class="co">;restore original stack pointer</span>
    <span class="kw">pop</span>      <span class="kw">bp</span>                      <span class="co">; and caller&#39;s BP</span>
    <span class="kw">ret</span>      EndMrk-RetAddr<span class="dv">-2</span>        <span class="co">;return, clearing the parms from the stack</span>
ClearS       endp</code></pre>
<p>The first thing you’ll notice about Listing 22.1 is that <code>ClearS</code> uses a <code>REP STOSW</code> instruction. That means that we’re not going to improve performance by any great amount, no matter how clever we are. While we can eliminate some cycles, the bulk of the work in <code>ClearS</code> is done by that one repeated string instruction, and there’s no way to improve on that.</p>
<p>Does that mean that Listing 22.1 is as good as it can be? Hardly. While the speed of <code>ClearS</code> is very good, there’s another side to the optimization equation: size. The whole of <code>ClearS</code> is 52 bytes long as it stands—but, as we’ll see, that size is hardly set in stone.</p>
<p>Where do we begin with <code>ClearS</code>? For starters, there’s an instruction in there that serves no earthly purpose—<code>MOV SP,BP</code>. SP is guaranteed to be equal to BP at that point anyway, so why reload it with the same value? Removing that instruction saves us two bytes.</p>
<p>Well, that was certainly easy enough! We’re not going to find any more totally non-functional instructions in <code>ClearS</code>, however, so let’s get on to some serious optimizing. We’ll look first for cases where we know of better instructions for particular tasks than those that were chosen. For example, there’s no need to load any register, whether segment or general, through BX; we can eliminate two instructions by loading ES and DI directly as shown in Listing 22.2.</p>
<p><strong>LISTING 22.2 L22-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">ClearS        proc near
      <span class="kw">push</span>    <span class="kw">bp</span>                        <span class="co">;save caller&#39;s BP</span>
      <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>                     <span class="co">;point to stack frame</span>
      <span class="kw">cmp</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BufSeg,<span class="dv">0</span>    <span class="co">;skip the fill if a null</span>
      <span class="kw">jne</span>     Start                     <span class="co">; pointer is passed</span>
      <span class="kw">cmp</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BufOfs,<span class="dv">0</span>
      <span class="kw">je</span>      Bye
<span class="fu">Start:</span> <span class="kw">cld</span>                              <span class="co">;make STOSW count up</span>
      <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>].Attrib            <span class="co">;load AX with attribute parameter</span>
      <span class="kw">and</span>     <span class="kw">ax</span><span class="bn">,0ff00h                 </span><span class="co">;prepare for merging with fill char</span>
      <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].Filler            <span class="co">;load BX with fill char</span>
      <span class="kw">and</span>      <span class="kw">bx</span><span class="bn">,0ffh                  </span><span class="co">;prepare for merging with attribute</span>
      <span class="kw">or</span>       <span class="kw">ax</span>,<span class="kw">bx</span>                    <span class="co">;combine attribute and fill char</span>
     <span class="kw">mov</span>       <span class="kw">di</span>,[<span class="kw">bp</span>].BufOfs           <span class="co">;load DI with target buffer offset</span>
     <span class="kw">mov</span>       <span class="kw">es</span>,[<span class="kw">bp</span>].BufSeg           <span class="co">;load ES with target buffer segment</span>
     <span class="kw">mov</span>       <span class="kw">cx</span>,[<span class="kw">bp</span>].BufSize          <span class="co">;load CX with buffer size</span>
     rep       <span class="kw">stosw</span>                    <span class="co">;fill the buffer</span>
<span class="fu">Bye:</span>
     <span class="kw">pop</span>       <span class="kw">bp</span>                       <span class="co">;restore caller&#39;s BP</span>
     <span class="kw">ret</span>       EndMrk-RetAddr<span class="dv">-2</span>         <span class="co">;return, clearing the parms from the stack</span>
ClearS         endp</code></pre>
<p>(The <code>OnStack</code> structure definition doesn’t change in any of our examples, so I’m not going clutter up this chapter by reproducing it for each new version of <code>ClearS</code>.)</p>
<p>Okay, loading ES and DI directly saves another four bytes. We’ve squeezed a total of 6 bytes—about 11 percent—out of <code>ClearS</code>. What next?</p>
<p>Well, <code>LES</code> would serve better than two <code>MOV</code> instructions for loading ES and DI as shown in Listing 22.3.</p>
<p><strong>LISTING 22.3 L22-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">ClearS         proc near
      <span class="kw">push</span>     <span class="kw">bp</span>                       <span class="co">;save caller&#39;s BP</span>
      <span class="kw">mov</span>      <span class="kw">bp</span>,<span class="kw">sp</span>                    <span class="co">;point to stack frame</span>
      <span class="kw">cmp</span>      <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BufSeg,<span class="dv">0</span>   <span class="co">;skip the fill if a null</span>
      <span class="kw">jne</span>      Start                    <span class="co">; pointer is passed</span>
      <span class="kw">cmp</span>      <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BufOfs,<span class="dv">0</span>
      <span class="kw">je</span>       Bye
<span class="fu">Start:</span> <span class="kw">cld</span>                              <span class="co">;make STOSW count up</span>
      <span class="kw">mov</span>      <span class="kw">ax</span>,[<span class="kw">bp</span>].Attrib           <span class="co">;load AX with attribute parameter</span>
      <span class="kw">and</span>      <span class="kw">ax</span><span class="bn">,0ff00h                </span><span class="co">;prepare for merging with fill char</span>
      <span class="kw">mov</span>      <span class="kw">bx</span>,[<span class="kw">bp</span>].Filler           <span class="co">;load BX with fill char</span>
      <span class="kw">and</span>      <span class="kw">bx</span><span class="bn">,0ffh                  </span><span class="co">;prepare for merging with attribute</span>
      <span class="kw">or</span>       <span class="kw">ax</span>,<span class="kw">bx</span>                    <span class="co">;combine attribute and fill char</span>
     <span class="kw">les</span>       <span class="kw">di</span>,<span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BufOfs <span class="co">;load ES:DI with target buffer</span>
                                        <span class="co">;segment:offset</span>
      <span class="kw">mov</span>      <span class="kw">cx</span>,[<span class="kw">bp</span>].BufSize          <span class="co">;load CX with buffer size</span>
      rep      <span class="kw">stosw</span>                    <span class="co">;fill the buffer</span>
<span class="fu">Bye:</span>
      <span class="kw">pop</span>      <span class="kw">bp</span>                       <span class="co">;restore caller&#39;s BP</span>
      <span class="kw">ret</span>      EndMrk-RetAddr<span class="dv">-2</span>         <span class="co">;return, clearing the parms from the stack</span>
ClearS         endp</code></pre>
<p>That’s good for another three bytes. We’re down to 43 bytes, and counting.</p>
<p>We can save 3 more bytes by clearing the low and high bytes of AX and BX, respectively, by using <code>SUB *reg8,reg8*</code> rather than ANDing 16-bit values as shown in Listing 22.4.</p>
<p><strong>LISTING 22.4 L22-4.ASM</strong></p>
<pre><code>ClearS         proc near
      push     bp                       ;save caller&#39;s BP
      mov      bp,sp                    ;point to stack frame
      cmp      word ptr [bp].BufSeg,0   ;skip the fill if a null
      jne      Start                    ; pointer is passed
      cmp      word ptr [bp].BufOfs,0
      je       Bye
Start: cld                              ;make STOSW count up
      mov      ax,[bp].Attrib           ;load AX with      attribute parameter
      sub      al,al                    ;prepare for merging with fill char
      mov      bx,[bp].Filler           ;load BX with fill char
      sub      bh,bh                    ;prepare for merging with attribute
      or       ax,bx                    ;combine attribute and fill char
      les      di,dword ptr [bp].BufOfs ;load ES:DI with target buffer
                                        ;segment:offset
      mov      cx,[bp].BufSize          ;load CX with buffer size
      rep      stosw                    ;fill the buffer
Bye:
      pop      bp                       ;restore caller&#39;s BP
      ret      EndMrk-RetAddr-2         ;return, clearing the parms from the stack
ClearS         endp</code></pre>
<p>Now we’re down to 40 bytes—more than 20 percent smaller than the original code. That’s pretty much it for simple instruction optimizations. Now let’s look for instruction optimizations.</p>
<p>It seems strange to load a word value into AX and then throw away AL. Likewise, it seems strange to load a word value into BX and then throw away BH. However, those steps are necessary because the two modified word values are ORed into a single character/attribute word value that is then used to fill the target buffer.</p>
<p>Let’s step back and see what this code really <em>does</em>, though. All it does in the end is load one byte addressed relative to BP into AH and another byte addressed relative to BP into AL. Heck, we can just do that directly! Presto—we’ve saved another 6 bytes, and turned two word-sized memory accesses into byte-sized memory accesses as well. Listing 22.5 shows the new code.</p>
<p><strong>LISTING 22.5 L22-5.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">ClearS         proc near
      <span class="kw">push</span>     <span class="kw">bp</span>                       <span class="co">;save caller&#39;s BP</span>
      <span class="kw">mov</span>      <span class="kw">bp</span>,<span class="kw">sp</span>                    <span class="co">;point to stack frame</span>
      <span class="kw">cmp</span>      <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BufSeg,<span class="dv">0</span>   <span class="co">;skip the fill if a null</span>
      <span class="kw">jne</span>      Start                    <span class="co">; pointer is passed</span>
      <span class="kw">cmp</span>      <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BufOfs,<span class="dv">0</span>
      <span class="kw">je</span>       Bye
<span class="fu">Start:</span> <span class="kw">cld</span>                              <span class="co">;make STOSW count up</span>
      <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].Attrib[<span class="dv">1</span>]<span class="co">;load AH with attribute</span>
      <span class="kw">mov</span>      <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].Filler  <span class="co">;load AL with fill char</span>
      <span class="kw">les</span>      <span class="kw">di</span>,<span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BufOfs <span class="co">;load ES:DI with target buffer segment:offset</span>
      <span class="kw">mov</span>      <span class="kw">cx</span>,[<span class="kw">bp</span>].BufSize          <span class="co">;load CX with buffer size</span>
      rep      <span class="kw">stosw</span>                    <span class="co">;fill the buffer</span>
<span class="fu">Bye:</span>
      <span class="kw">pop</span>      <span class="kw">bp</span>                       <span class="co">;restore caller&#39;s BP</span>
      <span class="kw">ret</span>      EndMrk-RetAddr<span class="dv">-2</span>         <span class="co">;return, clearing the parms from the stack</span>
ClearS         endp</code></pre>
<p>(We could get rid of yet another instruction by having the calling code pack both the attribute and the fill value into the same word, but that’s not part of the specification for this particular routine.)</p>
<p>Another nifty instruction-rearrangement trick saves 6 more bytes. <code>ClearS</code> checks to see whether the far pointer is null (zero) at the start of the routine…then loads and uses that same far pointer later on. Let’s get that pointer into registers and keep it there; that way we can check to see whether it’s null with a single comparison, and can use it later without having to reload it from memory. This technique is shown in Listing 22.6.</p>
<p><strong>LISTING 22.6 L22-6.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">ClearS         proc near
      <span class="kw">push</span>     <span class="kw">bp</span>                       <span class="co">;save caller&#39;s BP</span>
      <span class="kw">mov</span>      <span class="kw">bp</span>,<span class="kw">sp</span>                    <span class="co">;point to stack frame</span>
      <span class="kw">les</span>      <span class="kw">di</span>,<span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BufOfs <span class="co">;load ES:DI with target buffer;segment:offset</span>
      <span class="kw">mov</span>      <span class="kw">ax</span>,<span class="kw">es</span>                    <span class="co">;put segment where we can test it</span>
      <span class="kw">or</span>       <span class="kw">ax</span>,<span class="kw">di</span>                    <span class="co">;is it a null pointer?</span>
      <span class="kw">je</span>       Bye                      <span class="co">;yes, so we&#39;re done</span>
<span class="fu">Start:</span> <span class="kw">cld</span>                              <span class="co">;make STOSW count up</span>
      <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].Attrib[<span class="dv">1</span>]<span class="co">;load AH with attribute</span>
      <span class="kw">mov</span>      <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].Filler  <span class="co">;load AL with fill char</span>
      <span class="kw">mov</span>      <span class="kw">cx</span>,[<span class="kw">bp</span>].BufSize          <span class="co">;load CX with buffer size</span>
      rep      <span class="kw">stosw</span>                    <span class="co">;fill the buffer</span>
<span class="fu">Bye:</span>
      <span class="kw">pop</span>      <span class="kw">bp</span>                       <span class="co">;restore caller&#39;s BP</span>
      <span class="kw">ret</span>      EndMrk-RetAddr<span class="dv">-2</span>         <span class="co">;return, clearing the parms from the stack</span>
ClearS         endp</code></pre>
<p>Well. Now we’re down to 28 bytes, having reduced the size of this subroutine by nearly 50 percent. Only 13 instructions remain. Realistically, how much smaller can we make this code?</p>
<p>About one-third smaller yet, as it turns out—but in order to do that, we must stretch our minds and use the 8088’s instructions in unusual ways. Let me ask you this: What do most of the instructions in the current version of <code>ClearS</code> do?</p>
<p>They either load parameters from the stack frame or set up the registers so that the parameters can be accessed. Mind you, there’s nothing wrong with the stack-frame-oriented instructions used in <code>ClearS</code>; those instructions access the stack frame in a highly efficient way, exactly as the designers of the 8088 intended, and just as the code generated by a high-level language would. That means that we aren’t going to be able to improve the code if we don’t bend the rules a bit.</p>
<p>Let’s think…the parameters are sitting on the stack, and most of our instruction bytes are being used to read bytes off the stack with BP-based addressing…we need a more efficient way to address the stack…<em>the stack</em>…THE STACK!</p>
<p>Ye gods! That’s easy—we can use the <em>stack pointer</em> to address the stack rather than BP. While it’s true that the stack pointer can’t be used for <em>mod-reg-rm</em> addressing, as BP can, it <em>can</em> be used to pop data off the stack—and <code>POP</code> is a one-byte instruction. Instructions don’t get any shorter than that.</p>
<p>There is one detail to be taken care of before we can put our plan into action: The return address—the address of the calling code—is on top of the stack, so the parameters we want can’t be reached with <code>POP</code>. That’s easily solved, however—we’ll just pop the return address into an unused register, then branch through that register when we’re done, as we learned to do in Chapter 14. As we pop the parameters, we’ll also be removing them from the stack, thereby neatly avoiding the need to discard them when it’s time to return.</p>
<p>With that problem dealt with, Listing 22.7 shows the Zenned version of <code>ClearS</code>.</p>
<p><strong>LISTING 22.7 L22-7.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">ClearS         procnear
      <span class="kw">pop</span>      <span class="kw">dx</span>                  <span class="co">;get the return address</span>
      <span class="kw">pop</span>      <span class="kw">ax</span>                  <span class="co">;put fill char into AL</span>
      <span class="kw">pop</span>      <span class="kw">bx</span>                  <span class="co">;get the attribute</span>
      <span class="kw">mov</span>      <span class="kw">ah</span>,<span class="kw">bh</span>               <span class="co">;put attribute into AH</span>
      <span class="kw">pop</span>      <span class="kw">cx</span>                  <span class="co">;get the buffer size</span>
      <span class="kw">pop</span>      <span class="kw">di</span>                  <span class="co">;get the offset of the buffer origin</span>
      <span class="kw">pop</span>      <span class="kw">es</span>                  <span class="co">;get the segment of the buffer origin</span>
      <span class="kw">mov</span>      <span class="kw">bx</span>,<span class="kw">es</span>               <span class="co">;put the segment where we can test it</span>
      <span class="kw">or</span>       <span class="kw">bx</span>,<span class="kw">di</span>               <span class="co">;null pointer?</span>
      <span class="kw">je</span>       Bye                 <span class="co">;yes, so we&#39;re done</span>
      <span class="kw">cld</span>                          <span class="co">;make STOSW count up</span>
      rep      <span class="kw">stosw</span>               <span class="co">;do the string store</span>
<span class="fu">Bye:</span>
      <span class="kw">jmp</span>      <span class="kw">dx</span>                  <span class="co">;return to the calling code</span>
ClearS         endp</code></pre>
<p>At long last, we’re down to the bare metal. This version of <code>ClearS</code> is just 19 bytes long. That’s just 37 percent as long as the original version, <em>without any change whatsoever in the functionality that <code>ClearS</code> makes available to the calling code</em>. The code is bound to run a bit faster too, given that there are far fewer instruction bytes and fewer memory accesses.</p>
<p>All in all, the Zenned version of <code>ClearS</code> is a vast improvement over the original. Probably not the best possible implementation—<em>never say never!</em>—but an awfully good one.</p>
</section>
</section>
</section>
<section id="part-ii" class="level1">
<h1><a href="#part-ii">Part II</a></h1>
<section id="chapter-23-bones-and-sinew" class="level2">
<h2><a href="#chapter-23-bones-and-sinew">Chapter 23 – Bones and Sinew</a></h2>
<section id="at-the-very-heart-of-standard-pc-graphics" class="level3">
<h3><a href="#at-the-very-heart-of-standard-pc-graphics">At the Very Heart of Standard PC Graphics</a></h3>
<p>The VGA is unparalleled in the history of computer graphics, for it is by far the most widely-used graphics standard ever, the closest we may ever come to a <em>lingua franca</em> of computer graphics. No other graphics standard has even come close to the 50,000,000 or so VGAs in use today, and virtually every PC compatible sold today has full VGA compatibility built in. There are, of course, a variety of graphics accelerators that outperform the standard VGA, and indeed, it is becoming hard to find a plain vanilla VGA anymore—but there is no standard for accelerators, and every accelerator contains a true-blue VGA at its core.</p>
<p>What that means is that if you write your programs for the VGA, you’ll have the largest possible market for your software. In order for graphics-based software to succeed, however, it must perform well. Wringing the best performance from the VGA is no simple task, and it’s <em>impossible</em> unless you really understand how the VGA works—unless you have the internals down cold. This book is about PC graphics at many levels, but high performance is the foundation for all that is to come, so it is with the inner workings of the VGA that we will begin our exploration of PC graphics.</p>
<p>The first eight chapters of Part II is a guided tour of the heart of the VGA; after you’ve absorbed what we’ll cover in this and the next seven chapters, you’ll have the foundation for understanding just about everything the VGA can do, including the fabled Mode X and more. As you read through these first chapters, please keep in mind that the <em>really</em> exciting stuff—animation, 3-D, blurry-fast lines and circles and polygons—has to wait until we have the fundamentals out of the way. So hold on and follow along, and before you know it the fireworks will be well underway.</p>
<p>We’ll start our exploration with a quick overview of the VGA, and then we’ll dive right in and get a taste of what the VGA can do.</p>
</section>
<section id="the-vga" class="level3">
<h3><a href="#the-vga">The VGA</a></h3>
<p>The VGA is the baseline adapter for modern IBM PC compatibles, present in virtually every PC sold today or in the last several years. (Note that the VGA is often nothing more than a chip on a motherboard, with some memory, a DAC, and maybe a couple of glue chips; nonetheless, I’ll refer to it as an adapter from now on for simplicity.) It guarantees that every PC is capable of documented resolutions up to 640x480 (with 16 possible colors per pixel) and 320x200 (with 256 colors per pixel), as well as undocumented—but nonetheless thoroughly standard—resolutions up to 360x480 in 256-color mode, as we’ll see in Chapters 31-34 and 47-49. In order for a video adapter to claim VGA compatibility, it must support all the features and code discussed in this book (with a very few minor exceptions that I’ll note)—and my experience is that just about 100 percent of the video hardware currently shipping or shipped since 1990 is in fact VGA compatible. Therefore, VGA code will run on nearly all of the 50,000,000 or so PC compatibles out there, with the exceptions being almost entirely obsolete machines from the 1980s. This makes good VGA code and VGA programming expertise valuable commodities indeed.</p>
<p>Right off the bat, I’d like to make one thing perfectly clear: The VGA is hard—sometimes <em>very</em> hard—to program for good performance. Hard, but not impossible—and that’s why I like this odd board. It’s a throwback to an earlier generation of micros, when inventive coding and a solid understanding of the hardware were the best tools for improving performance. Increasingly, faster processors and powerful coprocessors are seen as the solution to the sluggish software produced by high-level languages and layers of interface and driver code, and that’s surely a valid approach. However, there are tens of millions of VGAs installed right now, in machines ranging from 6-MHz 286s to 90-MHz Pentiums. What’s more, because the VGAs are generally 8- or at best 16-bit devices, and because of display memory wait states, a faster processor isn’t as much of a help as you’d expect. The upshot is that only a seasoned performance programmer who understands the VGA through and through can drive the board to its fullest potential.</p>
<p>Throughout this book, I’ll explore the VGA by selecting a specific algorithm or feature and implementing code to support it on the VGA, examining aspects of the VGA architecture as they become relevant. You’ll get to see VGA features in context, where they are more comprehensible than in IBM’s somewhat arcane documentation, and you’ll get working code to use or to modify to meet your needs.</p>
<p>The prime directive of VGA programming is that there’s rarely just one way to program the VGA for a given purpose. Once you understand the tools the VGA provides, you’ll be able to combine them to generate the particular synergy your application needs. My VGA routines are not intended to be taken as gospel, or to show “best” implementations, but rather to start you down the road to understanding the VGA.</p>
<p>Let’s begin.</p>
</section>
<section id="an-introduction-to-vga-programming" class="level3">
<h3><a href="#an-introduction-to-vga-programming">An Introduction to VGA Programming</a></h3>
<p>Most discussions of the VGA start out with a traditional “Here’s a block diagram of the VGA” approach, with lists of registers and statistics. I’ll get to that eventually, but you can find it in IBM’s VGA documentation and several other books. Besides, it’s numbing to read specifications and explanations, and the VGA is an exciting adapter, the kind that makes you want to get your hands dirty probing under the hood, to write some nifty code just to see what the board can do. What’s more, the best way to understand the VGA is to see it work, so let’s jump right into a sample of the VGA in action, getting a feel for the VGA’s architecture in the process.</p>
<p>Listing 23.1 is a sample VGA program that pans around an animated 16-color medium-resolution (640x350) playfield. There’s a lot packed into this code; I’m going to focus on the VGA-specific aspects so we don’t get sidetracked. I’m not going to explain how the ball is animated, for example; we’ll get to animation starting in Chapter 42. What I will do is cover each of the VGA features used in this program—the virtual screen, vertical and horizontal panning, color plane manipulation, multi-plane block copying, and page flipping—at a conceptual level, letting the code itself demonstrate the implementation details. We’ll return to many of these concepts in more depth later in this book.</p>
</section>
<section id="at-the-core" class="level3">
<h3><a href="#at-the-core">At the Core</a></h3>
<p>A little background is necessary before we’re ready to examine Listing 23.1. The VGA is built around four functional blocks, named the CRT Controller (CRTC), the Sequence Controller (SC), the Attribute Controller (AC), and the Graphics Controller (GC). The single-chip VGA could have been designed to treat the registers for all the blocks as one large set, addressed at one pair of I/O ports, but in the EGA, each of these blocks was a separate chip, and the legacy of EGA compatibility is why each of these blocks has a separate set of registers and is addressed at different I/O ports in the VGA.</p>
<p>Each of these blocks has a sizable complement of registers. It is not particularly important that you understand why a given block has a given register; all the registers together make up the programming interface, and it is the entire interface that is of interest to the VGA programmer. However, the means by which most VGA registers are addressed makes it necessary for you to remember which registers are in which blocks.</p>
<p>Most VGA registers are addressed as <em>internally indexed</em> registers. The internal address of the register is written to a given block’s Index register, and then the data for that register is written to the block’s Data register. For example, GC register 8, the Bit Mask register, is set to 0FFH by writing 8 to port 3CEH, the GC Index register, and then writing 0FFH to port 3CFH, the GC Data register. Internal indexing makes it possible to address the 9 GC registers through only two ports, and allows the entire VGA programming interface to be squeezed into fewer than a dozen ports. The downside is that two I/O operations are required to access most VGA registers.</p>
<p>The ports used to control the VGA are shown in Table 23.1. The CRTC, SC, and GC Data registers are located at the addresses of their respective Index registers plus one. However, the AC Index and Data registers are located at the same address, 3C0H. The function of this port toggles on every <code>OUT</code> to 3C0H, and resets to Index mode (in which the Index register is programmed by the next <code>OUT</code> to 3C0H) on every read from the Input Status 1 register (3DAH when the VGA is in a color mode,</p>
<table>
<caption>Table 1.1 The Ports through which the VGA is controlled.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Register</th>
<th style="text-align: left;">Address</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">AC Index/Data register</td>
<td style="text-align: left;">3C0H (write with toggle)</td>
</tr>
<tr class="even">
<td style="text-align: left;">AC Index register</td>
<td style="text-align: left;">3C0H (read)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">AC Data register</td>
<td style="text-align: left;">3C1H (read)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Miscellaneous Output register</td>
<td style="text-align: left;">3C2H (write)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">3CCH (read)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Input Status 0 register</td>
<td style="text-align: left;">3C2H (read)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SC Index register</td>
<td style="text-align: left;">3C4H (read/write)</td>
</tr>
<tr class="even">
<td style="text-align: left;">SC Data register</td>
<td style="text-align: left;">3C5H (read/write)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">GC Index register</td>
<td style="text-align: left;">3CEH (read/write)</td>
</tr>
<tr class="even">
<td style="text-align: left;">GC Data register</td>
<td style="text-align: left;">3CFH (read/write)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CRTC Index register</td>
<td style="text-align: left;">3B4H/3D4H (read/write)</td>
</tr>
<tr class="even">
<td style="text-align: left;">CRTC Data register</td>
<td style="text-align: left;">3B5H/3D5H (read/write)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Input Status 1 register/AC Index/Data reset</td>
<td style="text-align: left;">3 BAH/3DAH (read)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Feature Control</td>
<td style="text-align: left;">3BAH/3DAH (write)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">3CAH (read)</td>
</tr>
</tbody>
</table>
<p>3BAH in monochrome modes). Note that all CRTC registers are addressed at either 3DXH or 3BXH, the former in color modes and the latter in monochrome modes. This provides compatibility with the register addressing of the now-vanished Color/Graphics Adapter and Monochrome Display Adapter.</p>
<p>The method used in the VGA BIOS to set registers is to point DX to the desired Index register, load AL with the index, perform a byte <code>OUT</code>, increment DX to point to the Data register (except in the case of the AC, where DX remains the same), load AL with the desired data, and perform a byte <code>OUT</code>. A handy shortcut is to point DX to the desired Index register, load AL with the index, load AH with the data, and perform a word <code>OUT</code>. Since the high byte of the <code>OUT</code> value goes to port DX+1, this is equivalent to the first method but is faster. However, this technique does not work for programming the AC Index and Data registers; both AC registers are addressed at 3C0H, so two separate byte <code>OUT</code>s must be used to program the AC. (Actually, word <code>OUT</code>s to the AC do work in the EGA, but not in the VGA, so they shouldn’t be used.) As mentioned above, you must be sure which mode—Index or Data—the AC is in before you do an <code>OUT</code> to 3C0H; you can read the Input Status 1 register at any time to force the AC to Index mode.</p>
<p>How safe is the word-<code>OUT</code> method of addressing VGA registers? I have, in the past, run into adapter/computer combinations that had trouble with word <code>OUT</code>s; however, all such problems I am aware of have been fixed. Moreover, a great deal of graphics software now uses word <code>OUT</code>s, so any computer or VGA that doesn’t properly support word <code>OUT</code>s could scarcely be considered a clone at all.</p>
<blockquote>
<p><img src="images/i.jpg" /> A speed tip: The setting of each chip’s Index register remains the same until it is reprogrammed. This means that in cases where you are setting the same internal register repeatedly, you can set the Index register to point to that internal register once, then write to the Data register multiple times. For example, the Bit Mask register (GC register 8) is often set repeatedly inside a loop when drawing lines. The standard code for this is:</p>
<pre><code>MOV     DX,03CEH  ;point to GC Index register
MOV     AL,8      ;internal index of Bit Mask register
OUT     DX,AX     ;AH contains Bit Mask register setting</code></pre>
<p>Alternatively, the GC Index register could initially be set to point to the Bit Mask register with</p>
<pre><code>MOV     DX,03CEH  ;point to GC Index register
MOV     AL,8      ;internal index of Bit Mask register
OUT     DX,AL     ;set GC Index register
INC     DX        ;point to GC Data register&gt; </code></pre>
<p>and then the Bit Mask register could be set repeatedly with the byte-size <code>OUT</code> instruction</p>
<pre><code>OUT     DX,AL     ;AL contains Bit Mask register setting</code></pre>
<p>which is generally faster (and never slower) than a word-sized <code>OUT</code>, and which does not require AH to be set, freeing up a register. Of course, this method only works if the GC Index register remains unchanged throughout the loop.</p>
</blockquote>
<section id="linear-planes-and-true-vga-modes" class="level4">
<h4><a href="#linear-planes-and-true-vga-modes">Linear Planes and True VGA Modes</a></h4>
<p>The VGA’s memory is organized as four 64K planes. Each of these planes is a linear bitmap; that is, each byte from a given plane controls eight adjacent pixels on the screen, the next byte controls the next eight pixels, and so on to the end of the scan line. The next byte then controls the first eight pixels of the next scan line, and so on to the end of the screen.</p>
<p>The VGA adds a powerful twist to linear addressing; the logical width of the screen in VGA memory need not be the same as the physical width of the display. The programmer is free to define all or part of the VGA’s large memory map as a logical screen of up to 4,080 pixels in width, and then use the physical screen as a window onto any part of the logical screen. What’s more, a virtual screen can have any logical height up to the capacity of VGA memory. Such a virtual screen could be used to store a spreadsheet or a CAD/CAM drawing, for instance. As we will see shortly, the VGA provides excellent hardware for moving around the virtual screen; taken together, the virtual screen and the VGA’s smooth panning capabilities can generate very impressive effects.</p>
<p>All four linear planes are addressed in the same 64K memory space starting at A000:0000. Consequently, there are four bytes at any given address in VGA memory. The VGA provides special hardware to assist the CPU in manipulating all four planes, in parallel, with a single memory access, so that the programmer doesn’t have to spend a great deal of time switching between planes. Astute use of this VGA hardware allows VGA software to as much as quadruple performance by processing the data for all the planes in parallel.</p>
<p>Each memory plane provides one bit of data for each pixel. The bits for a given pixel from each of the four planes are combined into a nibble that serves as an address into the VGA’s palette RAM, which maps the one of 16 colors selected by display memory into any one of 64 colors, as shown in Figure 23.1. All sixty-four mappings for all 16 colors are independently programmable. (We’ll discuss the VGA’s color capabilities in detail starting in Chapter 33.)</p>
<p>The VGA BIOS supports several graphics modes (modes 4, 5, and 6) in which VGA memory appears not to be organized as four linear planes. These modes exist for CGA compatibility only, and are not true VGA graphics modes; use them when you need CGA-type operation and ignore them the rest of the time. The VGA’s special features are most powerful in true VGA modes, and it is on the 16-color true-VGA modes (modes 0DH (320x200), 0EH (640x200), 10H (640x350), and 12H (640x480)) that I will concentrate in this part of the book. There is also a 256-color mode, mode 13H, that appears to be a single linear plane, but, as we will see in Chapters 31-34 and 47-49 of this book, that’s a polite fiction—and discarding that fiction gives us an opportunity to unleash the power of the VGA’s hardware for vastly better performance. VGA text modes, which feature soft fonts, are another matter entirely, upon which we’ll touch from time to time.</p>
<figure>
<img src="images/23-01.jpg" alt="Figure 23.1  Video data from memory to pixel." /><figcaption><strong>Figure 23.1</strong>  <em>Video data from memory to pixel.</em></figcaption>
</figure>
<p>With that background out of the way, we can get on to the sample VGA program shown in Listing 23.1. I suggest you run the program before continuing, since the explanations will mean far more to you if you’ve seen the features in action.</p>
<p><strong>LISTING 23.1 L23-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Sample VGA program.</span>
<span class="co">; Animates four balls bouncing around a playfield by using</span>
<span class="co">; page flipping. Playfield is panned smoothly both horizontally</span>
<span class="co">; and vertically.</span>
<span class="co">; By Michael Abrash.</span>
<span class="co">;</span>
stack   <span class="kw">segment</span> para stack <span class="st">&#39;STACK&#39;</span>
        <span class="dt">db</span>      <span class="dv">512</span> dup(?)
stack   ends
<span class="co">;</span>
MEDRES_VIDEO_MODE       <span class="dt">equ</span>     <span class="dv">0</span>       <span class="co">;define for 640x350 video mode</span>
                                        <span class="co">; comment out for 640x200 mode</span>
VIDEO_SEGMENT   <span class="dt">equ</span><span class="bn">     0a000h          </span><span class="co">;display memory segment for</span>
                                        <span class="co">; true VGA graphics modes</span>
LOGICAL_SCREEN_WIDTH    <span class="dt">equ</span>     <span class="dv">672</span>/<span class="dv">8</span>   <span class="co">;width in bytes and height in scan</span>
LOGICAL_SCREEN_HEIGHT   <span class="dt">equ</span>     <span class="dv">384</span>     <span class="co">; lines of the virtual screen</span>
                                        <span class="co">; we&#39;ll work with</span>
PAGE0           <span class="dt">equ</span>     <span class="dv">0</span>       <span class="co">;flag for page 0 when page flipping</span>
PAGE1           <span class="dt">equ</span>     <span class="dv">1</span>       <span class="co">;flag for page 1 when page flipping</span>
PAGE0_OFFSET    <span class="dt">equ</span>     <span class="dv">0</span>       <span class="co">;start offset of page 0 in VGA memory</span>
PAGE1_OFFSET    <span class="dt">equ</span>     LOGICAL_SCREEN_WIDTH * LOGICAL_SCREEN_HEIGHT
                                <span class="co">;start offset of page 1 (both pages</span>
                                <span class="co">; are 672x384 virtual screens)</span>
BALL_WIDTH      <span class="dt">equ</span>     <span class="dv">24</span>/<span class="dv">8</span>    <span class="co">;width of ball in display memory bytes</span>
BALL_HEIGHT     <span class="dt">equ</span>     <span class="dv">24</span>      <span class="co">;height of ball in scan lines</span>
BLANK_OFFSET    <span class="dt">equ</span>     PAGE1_OFFSET * <span class="dv">2</span>        <span class="co">;start of blank image</span>
                                                <span class="co">; in VGA memory</span>
BALL_OFFSET     <span class="dt">equ</span>     BLANK_OFFSET + (BALL_WIDTH * BALL_HEIGHT)
                                <span class="co">;start offset of ball image in VGA memory</span>
NUM_BALLS       <span class="dt">equ</span>     <span class="dv">4</span>       <span class="co">;number of balls to animate</span>
<span class="co">;</span>
<span class="co">; VGA register equates.</span>
<span class="co">;</span>
SC_INDEX        <span class="dt">equ</span><span class="bn">     3c4h    </span><span class="co">;SC index register</span>
MAP_MASK        <span class="dt">equ</span>     <span class="dv">2</span>       <span class="co">;SC map mask register</span>
GC_INDEX        <span class="dt">equ</span><span class="bn">     3ceh    </span><span class="co">;GC index register</span>
GC_MODE         <span class="dt">equ</span>     <span class="dv">5</span>       <span class="co">;GC mode register</span>
CRTC_INDEX      <span class="dt">equ</span><span class="bn">     03d4h   </span><span class="co">;CRTC index register</span>
START_ADDRESS_HIGH <span class="dt">equ</span><span class="bn">  0ch     </span><span class="co">;CRTC start address high byte</span>
START_ADDRESS_LOW <span class="dt">equ</span><span class="bn">   0dh     </span><span class="co">;CRTC start address low byte</span>
CRTC_OFFSET     <span class="dt">equ</span><span class="bn">     13h     </span><span class="co">;CRTC offset register</span>
INPUT_STATUS_1  <span class="dt">equ</span><span class="bn">     03dah   </span><span class="co">;VGA status register</span>
VSYNC_MASK      <span class="dt">equ</span><span class="bn">     08h     </span><span class="co">;vertical sync bit in status register 1</span>
DE_MASK         <span class="dt">equ</span><span class="bn">     01h     </span><span class="co">;display enable bit in status register 1</span>
AC_INDEX        <span class="dt">equ</span><span class="bn">     03c0h   </span><span class="co">;AC index register</span>
HPELPAN         <span class="dt">equ</span><span class="bn">     20h </span><span class="kw">OR</span><span class="bn"> 13h   </span><span class="co">;AC horizontal pel panning register</span>
                                     <span class="co">; (bit 7 is high to keep palette RAM</span>
                                     <span class="co">; addressing on)</span>
dseg    <span class="kw">segment</span> para <span class="kw">common</span> <span class="st">&#39;DATA&#39;</span>
CurrentPage             <span class="dt">db</span>      PAGE1           <span class="co">;page to draw to</span>
CurrentPageOffset       <span class="dt">dw</span>      PAGE1_OFFSET
<span class="co">;</span>
<span class="co">; Four plane&#39;s worth of multicolored ball image.</span>
<span class="co">;</span>
BallPlane0Image label   <span class="dt">byte</span>            <span class="co">;blue plane image</span>
        <span class="dt">db</span><span class="bn">      000h, </span>03ch<span class="bn">, 000h, </span>001h<span class="bn">, 0ffh, </span>080h
        <span class="dt">db</span><span class="bn">      007h, </span>0ffh<span class="bn">, 0e0h, </span>00fh<span class="bn">, 0ffh, </span>0f0h
        <span class="dt">db</span>      <span class="dv">4</span> * <span class="dv">3</span> dup(000h)
        <span class="dt">db</span><span class="bn">      07fh, </span>0ffh<span class="bn">, 0feh, </span>0ffh<span class="bn">, 0ffh, </span>0ffh
        <span class="dt">db</span><span class="bn">      0ffh, </span>0ffh<span class="bn">, 0ffh, </span>0ffh<span class="bn">, 0ffh, </span>0ffh
        <span class="dt">db</span>      <span class="dv">4</span> * <span class="dv">3</span> dup(000h)
        <span class="dt">db</span><span class="bn">      07fh, </span>0ffh<span class="bn">, 0feh, </span>03fh<span class="bn">, 0ffh, </span>0fch
        <span class="dt">db</span><span class="bn">      03fh, </span>0ffh<span class="bn">, 0fch, </span>01fh<span class="bn">, 0ffh, </span>0f8h
        <span class="dt">db</span>      <span class="dv">4</span> * <span class="dv">3</span> dup(000h)
BallPlane1Image label   <span class="dt">byte</span>            <span class="co">;green plane image</span>
        <span class="dt">db</span>      <span class="dv">4</span> * <span class="dv">3</span> dup(000h)
        <span class="dt">db</span><span class="bn">      01fh, </span>0ffh<span class="bn">, 0f8h, </span>03fh<span class="bn">, 0ffh, </span>0fch
        <span class="dt">db</span><span class="bn">      03fh, </span>0ffh<span class="bn">, 0fch, </span>07fh<span class="bn">, 0ffh, </span>0feh
        <span class="dt">db</span><span class="bn">      07fh, </span>0ffh<span class="bn">, 0feh, </span>0ffh<span class="bn">, 0ffh, </span>0ffh
        <span class="dt">db</span><span class="bn">      0ffh, </span>0ffh<span class="bn">, 0ffh, </span>0ffh<span class="bn">, 0ffh, </span>0ffh
        <span class="dt">db</span>      <span class="dv">8</span> * <span class="dv">3</span> dup(000h)
        <span class="dt">db</span><span class="bn">      00fh, </span>0ffh<span class="bn">, 0f0h, </span>007h<span class="bn">, 0ffh, </span>0e0h
        <span class="dt">db</span><span class="bn">      001h, </span>0ffh<span class="bn">, 080h, </span>000h<span class="bn">, 03ch, </span>000h
BallPlane2Image label   <span class="dt">byte</span>            <span class="co">;red plane image</span>
        <span class="dt">db</span>      <span class="dv">12</span> * <span class="dv">3</span> dup(000h)
        <span class="dt">db</span><span class="bn">      0ffh, </span>0ffh<span class="bn">, 0ffh, </span>0ffh<span class="bn">, 0ffh, </span>0ffh
        <span class="dt">db</span><span class="bn">      0ffh, </span>0ffh<span class="bn">, 0ffh, </span>07fh<span class="bn">, 0ffh, </span>0feh
        <span class="dt">db</span><span class="bn">      07fh, </span>0ffh<span class="bn">, 0feh, </span>03fh<span class="bn">, 0ffh, </span>0fch
        <span class="dt">db</span><span class="bn">      03fh, </span>0ffh<span class="bn">, 0fch, </span>01fh<span class="bn">, 0ffh, </span>0f8h
        <span class="dt">db</span><span class="bn">      00fh, </span>0ffh<span class="bn">, 0f0h, </span>007h<span class="bn">, 0ffh, </span>0e0h
        <span class="dt">db</span><span class="bn">      001h, </span>0ffh<span class="bn">, 080h, </span>000h<span class="bn">, 03ch, </span>000h
BallPlane3Image label   <span class="dt">byte</span>            <span class="co">;intensity on for all planes,</span>
                                        <span class="co">; to produce high-intensity colors</span>
        <span class="dt">db</span><span class="bn">      000h, </span>03ch<span class="bn">, 000h, </span>001h<span class="bn">, 0ffh, </span>080h
        <span class="dt">db</span><span class="bn">      007h, </span>0ffh<span class="bn">, 0e0h, </span>00fh<span class="bn">, 0ffh, </span>0f0h
        <span class="dt">db</span><span class="bn">      01fh, </span>0ffh<span class="bn">, 0f8h, </span>03fh<span class="bn">, 0ffh, </span>0fch
        <span class="dt">db</span><span class="bn">      03fh, </span>0ffh<span class="bn">, 0fch, </span>07fh<span class="bn">, 0ffh, </span>0feh
        <span class="dt">db</span><span class="bn">      07fh, </span>0ffh<span class="bn">, 0feh, </span>0ffh<span class="bn">, 0ffh, </span>0ffh
        <span class="dt">db</span><span class="bn">      0ffh, </span>0ffh<span class="bn">, 0ffh, </span>0ffh<span class="bn">, 0ffh, </span>0ffh
        <span class="dt">db</span><span class="bn">      0ffh, </span>0ffh<span class="bn">, 0ffh, </span>0ffh<span class="bn">, 0ffh, </span>0ffh
        <span class="dt">db</span><span class="bn">      0ffh, </span>0ffh<span class="bn">, 0ffh, </span>07fh<span class="bn">, 0ffh, </span>0feh
        <span class="dt">db</span><span class="bn">      07fh, </span>0ffh<span class="bn">, 0feh, </span>03fh<span class="bn">, 0ffh, </span>0fch
        <span class="dt">db</span><span class="bn">      03fh, </span>0ffh<span class="bn">, 0fch, </span>01fh<span class="bn">, 0ffh, </span>0f8h
        <span class="dt">db</span><span class="bn">      00fh, </span>0ffh<span class="bn">, 0f0h, </span>007h<span class="bn">, 0ffh, </span>0e0h
        <span class="dt">db</span><span class="bn">      001h, </span>0ffh<span class="bn">, 080h, </span>000h<span class="bn">, 03ch, </span>000h
<span class="co">;</span>
BallX           <span class="dt">dw</span>      <span class="dv">15</span>, <span class="dv">50</span>, <span class="dv">40</span>, <span class="dv">70</span>          <span class="co">;array of ball x coords</span>
BallY           <span class="dt">dw</span>      <span class="dv">40</span>, <span class="dv">200</span>, <span class="dv">110</span>, <span class="dv">300</span>       <span class="co">;array of ball y coords</span>
LastBallX       <span class="dt">dw</span>      <span class="dv">15</span>, <span class="dv">50</span>, <span class="dv">40</span>, <span class="dv">70</span>          <span class="co">;previous ball x coords</span>
LastBallY       <span class="dt">dw</span>      <span class="dv">40</span>, <span class="dv">100</span>, <span class="dv">160</span>, <span class="dv">30</span>        <span class="co">;previous ball y coords</span>
BallXInc        <span class="dt">dw</span>      <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>              <span class="co">;x move factors for ball</span>
BallYInc        <span class="dt">dw</span>      <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">8</span>              <span class="co">;y move factors for ball</span>
BallRep         <span class="dt">dw</span>      <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>              <span class="co">;# times to keep moving</span>
                                                <span class="co">; ball according to current</span>
                                                <span class="co">; increments</span>
BallControl     <span class="dt">dw</span>      Ball0Control, Ball1Control     <span class="co">;pointers to current</span>
                <span class="dt">dw</span>      Ball2Control, Ball3Control     <span class="co">; locations in ball</span>
                                                       <span class="co">; control strings</span>
BallControlString     <span class="dt">dw</span>    Ball0Control, Ball1Control <span class="co">;pointers to</span>
                      <span class="dt">dw</span>    Ball2Control, Ball3Control <span class="co">; start of ball</span>
                                                       <span class="co">; control strings</span>
<span class="co">;</span>
<span class="co">; Ball control strings.</span>
<span class="co">;</span>
Ball0Control    label   <span class="dt">word</span>
        <span class="dt">dw</span>      <span class="dv">10</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">10</span>, -<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">10</span>, -<span class="dv">1</span>, -<span class="dv">4</span>, <span class="dv">10</span>, <span class="dv">1</span>, -<span class="dv">4</span>, <span class="dv">0</span>
Ball1Control    label   <span class="dt">word</span>
        <span class="dt">dw</span>      <span class="dv">12</span>, -<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">28</span>, -<span class="dv">1</span>, -<span class="dv">1</span>, <span class="dv">12</span>, <span class="dv">1</span>, -<span class="dv">1</span>, <span class="dv">28</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>
Ball2Control    label   <span class="dt">word</span>
        <span class="dt">dw</span>      <span class="dv">20</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">40</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">20</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">0</span>
Ball3Control    label   <span class="dt">word</span>
        <span class="dt">dw</span>      <span class="dv">8</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">52</span>, -<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">44</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>
<span class="co">;</span>
<span class="co">; Panning control string.</span>
<span class="co">;</span>
ifdef MEDRES_VIDEO_MODE
PanningControlString    <span class="dt">dw</span>      <span class="dv">32</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">34</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">32</span>, -<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">34</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">0</span>
else
PanningControlString    <span class="dt">dw</span>      <span class="dv">32</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">184</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">32</span>, -<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">184</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">0</span>
endif
PanningControl  <span class="dt">dw</span>      PanningControlString   <span class="co">;pointer to current location</span>
                                               <span class="co">; in panning control string</span>
PanningRep      <span class="dt">dw</span>      <span class="dv">1</span>      <span class="co">;# times to pan according to current</span>
                               <span class="co">; panning increments</span>
PanningXInc     <span class="dt">dw</span>      <span class="dv">1</span>      <span class="co">;x panning factor</span>
PanningYInc     <span class="dt">dw</span>      <span class="dv">0</span>      <span class="co">;y panning factor</span>
HPan            <span class="dt">db</span>      <span class="dv">0</span>      <span class="co">;horizontal pel panning setting</span>
PanningStartOffset <span class="dt">dw</span>   <span class="dv">0</span>      <span class="co">;start offset adjustment to produce vertical</span>
                               <span class="co">; panning &amp; coarse horizontal panning</span>
dseg    ends
<span class="co">;</span>
<span class="co">; Macro to set indexed register P2 of chip with index register</span>
<span class="co">; at P1 to AL.</span>
<span class="co">;</span>
SETREG  macro   P1, P2
        <span class="kw">mov</span>     <span class="kw">dx</span>,P1
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">al</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,P2
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>
        endm
<span class="co">;</span>
cseg    <span class="kw">segment</span> para public <span class="st">&#39;CODE&#39;</span>
        assume  <span class="kw">cs</span>:cseg, <span class="kw">ds</span>:dseg
start   proc    near
        <span class="kw">mov</span>     <span class="kw">ax</span>,dseg
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Select graphics mode.</span>
<span class="co">;</span>
ifdef MEDRES_VIDEO_MODE
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,010h</span>
else
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0eh</span>
endif
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
<span class="co">; ES always points to VGA memory.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,VIDEO_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Draw border around playfield in both pages.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,PAGE0_OFFSET
        <span class="kw">call</span>    DrawBorder      <span class="co">;page 0 border</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,PAGE1_OFFSET
        <span class="kw">call</span>    DrawBorder      <span class="co">;page 1 border</span>
<span class="co">;</span>
<span class="co">; Draw all four plane&#39;s worth of the ball to undisplayed VGA memory.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,01h          </span><span class="co">;enable plane 0</span>
        SETREG  SC_INDEX, MAP_MASK
        <span class="kw">mov</span>     <span class="kw">si</span>,offset BallPlane0Image
        <span class="kw">mov</span>     <span class="kw">di</span>,BALL_OFFSET
        <span class="kw">mov</span>     <span class="kw">cx</span>,BALL_WIDTH * BALL_HEIGHT
        rep <span class="kw">movsb</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,02h          </span><span class="co">;enable plane 1</span>
        SETREG  SC_INDEX, MAP_MASK
        <span class="kw">mov</span>     <span class="kw">si</span>,offset BallPlane1Image
        <span class="kw">mov</span>     <span class="kw">di</span>,BALL_OFFSET
        <span class="kw">mov</span>     <span class="kw">cx</span>,BALL_WIDTH * BALL_HEIGHT
        rep <span class="kw">movsb</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,04h          </span><span class="co">;enable plane 2</span>
        SETREG  SC_INDEX, MAP_MASK
        <span class="kw">mov</span>     <span class="kw">si</span>,offset BallPlane2Image
        <span class="kw">mov</span>     <span class="kw">di</span>,BALL_OFFSET
        <span class="kw">mov</span>     <span class="kw">cx</span>,BALL_WIDTH * BALL_HEIGHT
        rep <span class="kw">movsb</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,08h          </span><span class="co">;enable plane 3</span>
        SETREG  SC_INDEX, MAP_MASK
        <span class="kw">mov</span>     <span class="kw">si</span>,offset BallPlane3Image
        <span class="kw">mov</span>     <span class="kw">di</span>,BALL_OFFSET
        <span class="kw">mov</span>     <span class="kw">cx</span>,BALL_WIDTH * BALL_HEIGHT
        rep <span class="kw">movsb</span>
<span class="co">;</span>
<span class="co">; Draw a blank image the size of the ball to undisplayed VGA memory.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0fh                 </span><span class="co">;enable all memory planes, since the</span>
        SETREG  SC_INDEX, MAP_MASK     <span class="co">; blank has to erase all planes</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,BLANK_OFFSET
        <span class="kw">mov</span>     <span class="kw">cx</span>,BALL_WIDTH * BALL_HEIGHT
        <span class="kw">sub</span>     <span class="kw">al</span>,<span class="kw">al</span>
        rep <span class="kw">stosb</span>
<span class="co">;</span>
<span class="co">; Set VGA to write mode 1, for block copying ball and blank images.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_MODE
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">;point GC Index to GC Mode register</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>              <span class="co">;point to GC Data register</span>
        <span class="kw">jmp</span>     <span class="dv">$</span>+<span class="dv">2</span>             <span class="co">;delay to let bus settle</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>           <span class="co">;get current state of GC Mode</span>
        <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">not</span> <span class="dv">3</span>        <span class="co">;clear the write mode bits</span>
        <span class="kw">or</span>      <span class="kw">al</span>,<span class="dv">1</span>            <span class="co">;set the write mode field to 1</span>
        <span class="kw">jmp</span>     <span class="dv">$</span>+<span class="dv">2</span>             <span class="co">;delay to let bus settle</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Set VGA offset register in words to define logical screen width.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,LOGICAL_SCREEN_WIDTH / <span class="dv">2</span>
        SETREG  CRTC_INDEX, CRTC_OFFSET
<span class="co">;</span>
<span class="co">; Move the balls by erasing each ball, moving it, and</span>
<span class="co">; redrawing it, then switching pages when they&#39;re all moved.</span>
<span class="co">;</span>
<span class="fu">BallAnimationLoop:</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,( NUM_BALLS * <span class="dv">2</span> ) - <span class="dv">2</span>
<span class="fu">EachBallLoop:</span>
<span class="co">;</span>
<span class="co">; Erase old image of ball in this page (at location from one more earlier).</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,BLANK_OFFSET <span class="co">;point to blank image</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[LastBallX+<span class="kw">bx</span>]
        <span class="kw">mov</span>     <span class="kw">dx</span>,[LastBallY+<span class="kw">bx</span>]
        <span class="kw">call</span>    DrawBall
<span class="co">;</span>
<span class="co">; Set new last ball location.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[BallX+<span class="kw">bx</span>]
        <span class="kw">mov</span>     [LastballX+<span class="kw">bx</span>],<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[BallY+<span class="kw">bx</span>]
        <span class="kw">mov</span>     [LastballY+<span class="kw">bx</span>],<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Change the ball movement values if it&#39;s time to do so.</span>
<span class="co">;</span>
        <span class="kw">dec</span>     [BallRep+<span class="kw">bx</span>]           <span class="co">;has current repeat factor run out?</span>
        <span class="kw">jnz</span>     MoveBall
        <span class="kw">mov</span>     <span class="kw">si</span>,[BallControl+<span class="kw">bx</span>]    <span class="co">;it&#39;s time to change movement values</span>
        <span class="kw">lodsw</span>                          <span class="co">;get new repeat factor from</span>
                                       <span class="co">; control string</span>
        <span class="kw">and</span>     <span class="kw">ax</span>,<span class="kw">ax</span>                  <span class="co">;at end of control string?</span>
        <span class="kw">jnz</span>     SetNewMove
        <span class="kw">mov</span>     <span class="kw">si</span>,[BallControlString+<span class="kw">bx</span>]       <span class="co">;reset control string</span>
        <span class="kw">lodsw</span>                           <span class="co">;get new repeat factor</span>
<span class="fu">SetNewMove:</span>
        <span class="kw">mov</span>     [BallRep+<span class="kw">bx</span>],<span class="kw">ax</span>         <span class="co">;set new movement repeat factor</span>
        <span class="kw">lodsw</span>                           <span class="co">;set new x movement increment</span>
        <span class="kw">mov</span>     [BallXInc+<span class="kw">bx</span>],<span class="kw">ax</span>
        <span class="kw">lodsw</span>                           <span class="co">;set new y movement increment</span>
        <span class="kw">mov</span>     [BallYInc+<span class="kw">bx</span>],<span class="kw">ax</span>
        <span class="kw">mov</span>     [BallControl+<span class="kw">bx</span>],<span class="kw">si</span>     <span class="co">;save new control string pointer</span>
<span class="co">;</span>
<span class="co">; Move the ball.</span>
<span class="co">;</span>
<span class="fu">MoveBall:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[BallXInc+<span class="kw">bx</span>]
        <span class="kw">add</span>     [BallX+<span class="kw">bx</span>],<span class="kw">ax</span>           <span class="co">;move in x direction</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[BallYInc+<span class="kw">bx</span>]
        <span class="kw">add</span>     [BallY+<span class="kw">bx</span>],<span class="kw">ax</span>           <span class="co">;move in y direction</span>
<span class="co">;</span>
<span class="co">; Draw ball at new location.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,BALL_OFFSET  <span class="co">;point to ball&#39;s image</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[BallX+<span class="kw">bx</span>]
        <span class="kw">mov</span>     <span class="kw">dx</span>,[BallY+<span class="kw">bx</span>]
        <span class="kw">call</span>    DrawBall
<span class="co">;</span>
        <span class="kw">dec</span>     <span class="kw">bx</span>
        <span class="kw">dec</span>     <span class="kw">bx</span>
        <span class="kw">jns</span>     EachBallLoop

<span class="co">;</span>
<span class="co">; Set up the next panning state (but don&#39;t program it into the</span>
<span class="co">; VGA yet).</span>
<span class="co">;</span>
        <span class="kw">call</span>    AdjustPanning

<span class="co">;</span>
<span class="co">; Wait for display enable (pixel data being displayed) so we know</span>
<span class="co">; we&#39;re nowhere near vertical sync, where the start address gets</span>
<span class="co">; latched and used.</span>
<span class="co">;</span>
        <span class="kw">call</span>    WaitDisplayEnable
<span class="co">;</span>
<span class="co">; Flip to the new page by changing the start address.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[CurrentPageOffset]
        <span class="kw">add</span>     <span class="kw">ax</span>,[PanningStartOffset]
        <span class="kw">push</span>    <span class="kw">ax</span>
        SETREG  CRTC_INDEX, START_ADDRESS_LOW
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [CurrentPageOffset<span class="dv">+1</span>]
        <span class="kw">pop</span>     <span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">ah</span>
        SETREG  CRTC_INDEX, START_ADDRESS_HIGH
<span class="co">;</span>
<span class="co">; Wait for vertical sync so the new start address has a chance</span>
<span class="co">; to take effect.</span>
<span class="co">;</span>
        <span class="kw">call</span>    WaitVSync
<span class="co">;</span>
<span class="co">; Set horizontal panning now, just as new start address takes effect.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,[HPan]
        <span class="kw">mov</span>     <span class="kw">dx</span>,INPUT_STATUS_1
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>                   <span class="co">;reset AC addressing to index reg</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,AC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,HPELPAN
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                   <span class="co">;set AC index to pel pan reg</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,[HPan]
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                   <span class="co">;set new pel panning</span>
<span class="co">;</span>
<span class="co">; Flip the page to draw to to the undisplayed page.</span>
<span class="co">;</span>
        <span class="kw">xor</span>     [CurrentPage],<span class="dv">1</span>
        <span class="kw">jnz</span>     IsPage1
        <span class="kw">mov</span>     [CurrentPageOffset],PAGE0_OFFSET
        <span class="kw">jmp</span>     <span class="dt">short</span> EndFlipPage
<span class="fu">IsPage1:</span>
        <span class="kw">mov</span>     [CurrentPageOffset],PAGE1_OFFSET
<span class="fu">EndFlipPage:</span>
<span class="co">;</span>
<span class="co">; Exit if a key&#39;s been hit.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">int</span><span class="bn">     16h</span>
        <span class="kw">jnz</span>     Done
        <span class="kw">jmp</span>     BallAnimationLoop
<span class="co">;</span>
<span class="co">; Finished, clear key, reset screen mode and exit.</span>
<span class="co">;</span>
<span class="fu">Done:</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">0</span>    <span class="co">;clear key</span>
        <span class="kw">int</span><span class="bn">     16h</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dv">3</span>    <span class="co">;reset to text mode</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch  </span><span class="co">;exit to DOS</span>
        <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
start   endp
<span class="co">;</span>
<span class="co">; Routine to draw a ball-sized image to all planes, copying from</span>
<span class="co">; offset SI in VGA memory to offset CX,DX (x,y) in VGA memory in</span>
<span class="co">; the current page.</span>
<span class="co">;</span>
DrawBall        proc    near
        <span class="kw">mov</span>     <span class="kw">ax</span>,LOGICAL_SCREEN_WIDTH
        <span class="kw">mul</span>     <span class="kw">dx</span>      <span class="co">;offset of start of top image scan line</span>
        <span class="kw">add</span>     <span class="kw">ax</span>,<span class="kw">cx</span>   <span class="co">;offset of upper left of image</span>
        <span class="kw">add</span>     <span class="kw">ax</span>,[CurrentPageOffset]  <span class="co">;offset of start of page</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,BALL_HEIGHT
        <span class="kw">push</span>    <span class="kw">ds</span>
        <span class="kw">push</span>    <span class="kw">es</span>
        <span class="kw">pop</span>     <span class="kw">ds</span>      <span class="co">;move from VGA memory to VGA memory</span>
<span class="fu">DrawBallLoop:</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,BALL_WIDTH
        rep <span class="kw">movsb</span>       <span class="co">;draw a scan line of image</span>
        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">add</span>     <span class="kw">di</span>,LOGICAL_SCREEN_WIDTH <span class="co">;point to next destination scan line</span>
        <span class="kw">dec</span>     <span class="kw">bp</span>
        <span class="kw">jnz</span>     DrawBallLoop
        <span class="kw">pop</span>     <span class="kw">ds</span>
        <span class="kw">ret</span>
DrawBall        endp
<span class="co">;</span>
<span class="co">; Wait for the leading edge of vertical sync pulse.</span>
<span class="co">;</span>
WaitVSync       proc    near
        <span class="kw">mov</span>     <span class="kw">dx</span>,INPUT_STATUS_1
<span class="fu">WaitNotVSyncLoop:</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span>,VSYNC_MASK
        <span class="kw">jnz</span>     WaitNotVSyncLoop
<span class="fu">WaitVSyncLoop:</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span>,VSYNC_MASK
        <span class="kw">jz</span>      WaitVSyncLoop
        <span class="kw">ret</span>
WaitVSync       endp

<span class="co">;</span>
<span class="co">; Wait for display enable to happen (pixels to be scanned to</span>
<span class="co">; the screen, indicating we&#39;re in the middle of displaying a frame).</span>
<span class="co">;</span>
WaitDisplayEnable       proc    near
        <span class="kw">mov</span>     <span class="kw">dx</span>,INPUT_STATUS_1
<span class="fu">WaitDELoop:</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span>,DE_MASK
        <span class="kw">jnz</span>     WaitDELoop
        <span class="kw">ret</span>
WaitDisplayEnable       endp

<span class="co">;</span>
<span class="co">; Perform horizontal/vertical panning.</span>
<span class="co">;</span>
AdjustPanning   proc    near
        <span class="kw">dec</span>     [PanningRep]    <span class="co">;time to get new panning values?</span>
        <span class="kw">jnz</span>     DoPan
        <span class="kw">mov</span>     <span class="kw">si</span>,[PanningControl]     <span class="co">;point to current location in</span>
                                        <span class="co">; panning control string</span>
        <span class="kw">lodsw</span>                           <span class="co">;get panning repeat factor</span>
        <span class="kw">and</span>     <span class="kw">ax</span>,<span class="kw">ax</span>                   <span class="co">;at end of panning control string?</span>
        <span class="kw">jnz</span>     SetnewPanValues
        <span class="kw">mov</span>     <span class="kw">si</span>,offset PanningControlString  <span class="co">;reset to start of string</span>
        <span class="kw">lodsw</span>                           <span class="co">;get panning repeat factor</span>
<span class="fu">SetNewPanValues:</span>
        <span class="kw">mov</span>     [PanningRep],<span class="kw">ax</span>         <span class="co">;set new panning repeat value</span>
        <span class="kw">lodsw</span>
        <span class="kw">mov</span>     [PanningXInc],<span class="kw">ax</span>        <span class="co">;horizontal panning value</span>
        <span class="kw">lodsw</span>
        <span class="kw">mov</span>     [PanningYInc],<span class="kw">ax</span>        <span class="co">;vertical panning value</span>
        <span class="kw">mov</span>     [PanningControl],<span class="kw">si</span>     <span class="co">;save current location in panning</span>
                                        <span class="co">; control string</span>
<span class="co">;</span>
<span class="co">; Pan according to panning values.</span>
<span class="co">;</span>
<span class="fu">DoPan:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[PanningXInc]        <span class="co">;horizontal panning</span>
        <span class="kw">and</span>     <span class="kw">ax</span>,<span class="kw">ax</span>
        <span class="kw">js</span>      PanLeft                 <span class="co">;negative means pan left</span>
        <span class="kw">jz</span>      CheckVerticalPan
        <span class="kw">mov</span>     <span class="kw">al</span>,[HPan]
        <span class="kw">inc</span>     <span class="kw">al</span>                      <span class="co">;pan right; if pel pan reaches</span>
        <span class="kw">cmp</span>     <span class="kw">al</span>,<span class="dv">8</span>                    <span class="co">; 8, it&#39;s time to move to the</span>
        <span class="kw">jb</span>      SetHPan                 <span class="co">; next byte with a pel pan of 0</span>
        <span class="kw">sub</span>     <span class="kw">al</span>,<span class="kw">al</span>                   <span class="co">; and a start offset that&#39;s one</span>
        <span class="kw">inc</span>     [PanningStartOffset]    <span class="co">; higher</span>
        <span class="kw">jmp</span>     <span class="dt">short</span> SetHPan
<span class="fu">PanLeft:</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,[HPan]
        <span class="kw">dec</span>     <span class="kw">al</span>                      <span class="co">;pan left; if pel pan reaches -1,</span>
        <span class="kw">jns</span>     SetHPan                 <span class="co">; it&#39;s time to move to the next</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dv">7</span>                    <span class="co">; byte with a pel pan of 7 and a</span>
        <span class="kw">dec</span>     [PanningStartOffset]    <span class="co">; start offset that&#39;s one lower</span>
<span class="fu">SetHPan:</span>
        <span class="kw">mov</span>     [HPan],<span class="kw">al</span>               <span class="co">;save new pel pan value</span>
<span class="fu">CheckVerticalPan:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[PanningYInc]        <span class="co">;vertical panning</span>
        <span class="kw">and</span>     <span class="kw">ax</span>,<span class="kw">ax</span>
        <span class="kw">js</span>      PanUp                   <span class="co">;negative means pan up</span>
        <span class="kw">jz</span>      EndPan
        <span class="kw">add</span>     [PanningStartOffset],LOGICAL_SCREEN_WIDTH
                                        <span class="co">;pan down by advancing the start</span>
                                        <span class="co">; address by a scan line</span>
        <span class="kw">jmp</span>     <span class="dt">short</span> EndPan
<span class="fu">PanUp:</span>
        <span class="kw">sub</span>     [PanningStartOffset],LOGICAL_SCREEN_WIDTH
                                        <span class="co">;pan up by retarding the start</span>
                                        <span class="co">; address by a scan line</span>
<span class="fu">EndPan:</span>
        <span class="kw">ret</span>
<span class="co">;</span>
<span class="co">; Draw textured border around playfield that starts at DI.</span>
<span class="co">;</span>
DrawBorder      proc    near
<span class="co">;</span>
<span class="co">; Draw the left border.</span>
<span class="co">;</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,LOGICAL_SCREEN_HEIGHT / <span class="dv">16</span>
<span class="fu">DrawLeftBorderLoop:</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ch          </span><span class="co">;select red color for block</span>
        <span class="kw">call</span>    DrawBorderBlock
        <span class="kw">add</span>     <span class="kw">di</span>,LOGICAL_SCREEN_WIDTH * <span class="dv">8</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0eh          </span><span class="co">;select yellow color for block</span>
        <span class="kw">call</span>    DrawBorderBlock
        <span class="kw">add</span>     <span class="kw">di</span>,LOGICAL_SCREEN_WIDTH * <span class="dv">8</span>
        <span class="kw">loop</span>    DrawLeftBorderLoop
        <span class="kw">pop</span>     <span class="kw">di</span>
<span class="co">;</span>
<span class="co">; Draw the right border.</span>
<span class="co">;</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">add</span>     <span class="kw">di</span>,LOGICAL_SCREEN_WIDTH - <span class="dv">1</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,LOGICAL_SCREEN_HEIGHT / <span class="dv">16</span>
<span class="fu">DrawRightBorderLoop:</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0eh          </span><span class="co">;select yellow color for block</span>
        <span class="kw">call</span>    DrawBorderBlock
        <span class="kw">add</span>     <span class="kw">di</span>,LOGICAL_SCREEN_WIDTH * <span class="dv">8</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ch          </span><span class="co">;select red color for block</span>
        <span class="kw">call</span>    DrawBorderBlock
        <span class="kw">add</span>     <span class="kw">di</span>,LOGICAL_SCREEN_WIDTH * <span class="dv">8</span>
        <span class="kw">loop</span>    DrawRightBorderLoop
        <span class="kw">pop</span>     <span class="kw">di</span>
<span class="co">;</span>
<span class="co">; Draw the top border.</span>
<span class="co">;</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,(LOGICAL_SCREEN_WIDTH - <span class="dv">2</span>) / <span class="dv">2</span>
<span class="fu">DrawTopBorderLoop:</span>
        <span class="kw">inc</span>     <span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0eh          </span><span class="co">;select yellow color for block</span>
        <span class="kw">call</span>    DrawBorderBlock
        <span class="kw">inc</span>     <span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ch          </span><span class="co">;select red color for block</span>
        <span class="kw">call</span>    DrawBorderBlock
        <span class="kw">loop</span>    DrawTopBorderLoop
        <span class="kw">pop</span>     <span class="kw">di</span>
<span class="co">;</span>
<span class="co">; Draw the bottom border.</span>
<span class="co">;</span>
        <span class="kw">add</span>     <span class="kw">di</span>,(LOGICAL_SCREEN_HEIGHT - <span class="dv">8</span>) * LOGICAL_SCREEN_WIDTH
        <span class="kw">mov</span>     <span class="kw">cx</span>,(LOGICAL_SCREEN_WIDTH - <span class="dv">2</span>) / <span class="dv">2</span>
<span class="fu">DrawBottomBorderLoop:</span>
        <span class="kw">inc</span>     <span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ch          </span><span class="co">;select red color for block</span>
        <span class="kw">call</span>    DrawBorderBlock
        <span class="kw">inc</span>     <span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0eh          </span><span class="co">;select yellow color for block</span>
        <span class="kw">call</span>    DrawBorderBlock
        <span class="kw">loop</span>    DrawBottomBorderLoop
        <span class="kw">ret</span>
DrawBorder      endp
<span class="co">;</span>
<span class="co">; Draws an 8x8 border block in color in AL at location DI.</span>
<span class="co">; DI preserved.</span>
<span class="co">;</span>
DrawBorderBlock proc    near
        <span class="kw">push</span>    <span class="kw">di</span>
        SETREG  SC_INDEX, MAP_MASK
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ffh</span>
        rept <span class="dv">8</span>
        <span class="kw">stosb</span>
        <span class="kw">add</span>     <span class="kw">di</span>,LOGICAL_SCREEN_WIDTH - <span class="dv">1</span>
        endm
        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">ret</span>
DrawBorderBlock endp
AdjustPanning   endp
cseg    ends
        end     start</code></pre>
</section>
<section id="smooth-panning" class="level4">
<h4><a href="#smooth-panning">Smooth Panning</a></h4>
<p>The first thing you’ll notice upon running the sample program is the remarkable smoothness with which the display pans from side-to-side and up-and-down. That the display can pan at all is made possible by two VGA features: 256K of display memory and the virtual screen capability. Even the most memory-hungry of the VGA modes, mode 12H (640x480), uses only 37.5K per plane, for a total of 150K out of the total 256K of VGA memory. The medium-resolution mode, mode 10H (640x350), requires only 28K per plane, for a total of 112K. Consequently, there is room in VGA memory to store more than two full screens of video data in mode 10H (which the sample program uses), and there is room in all modes to store a larger virtual screen than is actually displayed. In the sample program, memory is organized as two virtual screens, each with a resolution of 672x384, as shown in Figure 23.2. The area of the virtual screen actually displayed at any given time is selected by setting the display memory address at which to begin fetching video data; this is set by way of the start address registers (Start Address High, CRTC register 0CH, and Start Address Low, CRTC register 0DH). Together these registers make up a 16-bit display memory address at which the CRTC begins fetching data at the beginning of each video frame. Increasing the start address causes higher-memory areas of the virtual screen to be displayed. For example, the Start Address High register could be set to 80H and the Start Address Low register could be set to 00H in order to cause the display screen to reflect memory starting at offset 8000H in each plane, rather than at the default offset of 0.</p>
<figure>
<img src="images/23-02.jpg" alt="Figure 23.2  Video memory organization for Listing 23.1." /><figcaption><strong>Figure 23.2</strong>  <em>Video memory organization for Listing 23.1.</em></figcaption>
</figure>
<p>The logical height of the virtual screen is defined by the amount of VGA memory available. As the VGA scans display memory for video data, it progresses from the start address toward higher memory one scan line at a time, until the frame is completed. Consequently, if the start address is increased, lines farther toward the bottom of the virtual screen are displayed; in effect, the virtual screen appears to scroll up on the physical screen.</p>
<p>The logical width of the virtual screen is defined by the Offset register (CRTC register 13H), which allows redefinition of the number of words of display memory considered to make up one scan line. Normally, 40 words of display memory constitute a scan line; after the CRTC scans these 40 words for 640 pixels worth of data, it advances 40 words from the start of that scan line to find the start of the next scan line in memory. This means that displayed scan lines are contiguous in memory. However, the Offset register can be set so that scan lines are logically wider (or narrower, for that matter) than their displayed width. The sample program sets the Offset register to 2AH, making the logical width of the virtual screen 42 words, or 42 * 2 * 8 = 672 pixels, as contrasted with the actual width of the mode 10h screen, 40 words or 640 pixels. The logical height of the virtual screen in the sample program is 384; this is accomplished simply by reserving 84 * 384 contiguous bytes of VGA memory for the virtual screen, where 84 is the virtual screen width in bytes and 384 is the virtual screen height in scan lines.</p>
<p>The start address is the key to panning around the virtual screen. The start address registers select the row of the virtual screen that maps to the top of the display; panning down a scan line requires only that the start address be increased by the logical scan line width in bytes, which is equal to the Offset register times two. The start address registers select the column that maps to the left edge of the display as well, allowing horizontal panning, although in this case only relatively coarse byte-sized adjustments—panning by eight pixels at a time—are supported.</p>
<p>Smooth horizontal panning is provided by the Horizontal Pel Panning register, AC register 13H, working in conjunction with the start address. Up to 7 pixels worth of single pixel panning of the displayed image to the left is performed by increasing the Horizontal Pel Panning register from 0 to 7. This exhausts the range of motion possible via the Horizontal Pel Panning register; the next pixel’s worth of smooth panning is accomplished by incrementing the start address by one and resetting the Horizontal Pel Panning register to 0. Smooth horizontal panning should be viewed as a series of fine adjustments in the 8-pixel range between coarse byte-sized adjustments.</p>
<p>A horizontal panning oddity: Alone among VGA modes, text mode (in most cases) has 9 dots per character clock. Smooth panning in this mode requires cycling the Horizontal Pel Panning register through the values 8, 0, 1, 2, 3, 4, 5, 6, and 7. 8 is the “no panning” setting.</p>
<p>There is one annoying quirk about programming the AC. When the AC Index register is set, only the lower five bits are used as the internal index. The next most significant bit, bit 5, controls the source of the video data sent to the monitor by the VGA. When bit 5 is set to 1, the output of the palette RAM, derived from display memory, controls the displayed pixels; this is normal operation. When bit 5 is 0, video data does not come from the palette RAM, and the screen becomes a solid color. The only time bit 5 of the AC Index register should be 0 is during the setting of a palette RAM register, since the CPU is only able to write to palette RAM when bit 5 is 0. (Some VGAs do not enforce this, but you should always set bit 5 to 0 before writing to the palette RAM just to be safe.) Immediately after setting palette RAM, however, 20h (or any other value with bit 5 set to 1) should be written to the AC Index register to restore normal video, and at all other times bit 5 should be set to 1.</p>
<blockquote>
<p><img src="images/i.jpg" /> By the way, palette RAM can be set via the BIOS video interrupt (interrupt 10H), function 10H. Whenever an VGA function can be performed reasonably well through a BIOS function, as it can in the case of setting palette RAM, it should be, both because there is no point in reinventing the wheel and because the BIOS may well mask incompatibilities between the IBM VGA and VGA clones.</p>
</blockquote>
</section>
<section id="color-plane-manipulation" class="level4">
<h4><a href="#color-plane-manipulation">Color Plane Manipulation</a></h4>
<p>The VGA provides a considerable amount of hardware assistance for manipulating the four display memory planes. Two features illustrated by the sample program are the ability to control which planes are written to by a CPU write and the ability to copy four bytes—one from each plane—with a single CPU read and a single CPU write.</p>
<p>The Map Mask register (SC register 2) selects which planes are written to by CPU writes. If bit 0 of the Map Mask register is 1, then each byte written by the CPU will be written to VGA memory plane 0, the plane that provides the video data for the least significant bit of the palette RAM address. If bit 0 of the Map Mask register is 0, then CPU writes will not affect plane 0. Bits 1, 2, and 3 of the Map Mask register similarly control CPU access to planes 1, 2, and 3, respectively. Any of the 16 possible combinations of enabled and disabled planes can be selected. Beware, however, of writing to an area of memory that is not zeroed. Planes that are disabled by the Map Mask register are not altered by CPU writes, so old and new images can mix on the screen, producing unwanted color effects as, say, three planes from the old image mix with one plane from the new image. The sample program solves this by ensuring that the memory written to is zeroed. A better way to set all planes at once is provided by the set/reset capabilities of the VGA, which I’ll cover in Chapter 25.</p>
<p>The sample program writes the image of the colored ball to VGA memory by enabling one plane at a time and writing the image of the ball for that plane. Each image is written to the same VGA addresses; only the destination plane, selected by the Map Mask register, is different. You might think of the ball’s image as consisting of four colored overlays, which together make up a multicolored image. The sample program writes a blank image to VGA memory by enabling all planes and writing a block of zero bytes; the zero bytes are written to all four VGA planes simultaneously.</p>
<p>The images are written to a nondisplayed portion of VGA memory in order to take advantage of a useful VGA hardware feature, the ability to copy all four planes at once. As shown by the image-loading code discussed above, four different sets of reads and writes—and several <code>OUT</code>s as well—are required to copy a multicolored image into VGA memory as would be needed to draw the same image into a non-planar pixel buffer. This causes unacceptably slow performance, all the more so because the wait states that occur on accesses to VGA memory make it very desirable to minimize display memory accesses, and because <code>OUT</code>s tend to be very slow.</p>
<p>The solution is to take advantage of the VGA’s write mode 1, which is selected via bits 0 and 1 of the GC Mode register (GC register 5). (Be careful to preserve bits 2-7 when setting bits 0 and 1, as is done in Listing 23.1.) In write mode 1, a single <code>CPU</code> read loads the addressed byte from all four planes into the VGA’s four internal latches, and a single <code>CPU</code> write writes the contents of the latches to the four planes. During the write, the byte written by the <code>CPU</code> is irrelevant.</p>
<p>The sample program uses write mode 1 to copy the images that were previously drawn to the high end of VGA memory into a desired area of display memory, all in a single block copy operation. This is an excellent way to keep the number of reads, writes, and OUTs required to manipulate the VGA’s display memory low enough to allow real-time drawing.</p>
<p>The Map Mask register can still mask out planes in write mode 1. All four planes are copied in the sample program because the Map Mask register is still 0Fh from when the blank image was created.</p>
<p>The animated images appear to move a bit jerkily because they are byte-aligned and so must move a minimum of 8 pixels horizontally. This is easily solved by storing rotated versions of all images in VGA memory, and then in each instance drawing the correct rotation for the pixel alignment at which the image is to be drawn; we’ll see this technique in action in Chapter 49.</p>
<p>Don’t worry if you’re not catching everything in this chapter on the first pass; the VGA is a complicated beast, and learning about it is an iterative process. We’ll be going over these features again, in different contexts, over the course of the rest of this book.</p>
</section>
<section id="page-flipping" class="level4">
<h4><a href="#page-flipping">Page Flipping</a></h4>
<p>When animated graphics are drawn directly on the screen, with no intermediate frame-composition stage, the image typically flickers and/or ripples, an unavoidable result of modifying display memory at the same time that it is being scanned for video data. The display memory of the VGA makes it possible to perform page flipping, which eliminates such problems. The basic premise of page flipping is that one area of display memory is displayed while another is being modified. The modifications never affect an area of memory as it is providing video data, so no undesirable side effects occur. Once the modification is complete, the modified buffer is selected for display, causing the screen to change to the new image in a single frame’s time, typically 1/60th or 1/70th of a second. The other buffer is then available for modification.</p>
<p>As described above, the VGA has 64K per plane, enough to hold two pages and more in 640x350 mode 10H, but not enough for two pages in 640x480 mode 12H. For page flipping, two non-overlapping areas of display memory are needed. The sample program uses two 672x384 virtual pages, each 32,256 bytes long, one starting at A000:0000 and the other starting at A000:7E00. Flipping between the pages is as simple as setting the start address registers to point to one display area or the other—but, as it turns out, that’s not as simple as it sounds.</p>
<p>The timing of the switch between pages is critical to achieving flicker-free animation. It is essential that the program never be modifying an area of display memory as that memory is providing video data. Achieving this is surprisingly complicated on the VGA, however.</p>
<p>The problem is as follows. The start address is latched by the VGA’s internal circuitry exactly once per frame, typically (but not always on all clones) at the start of the vertical sync pulse. The vertical sync status is, in fact, available as bit 3 of the Input Status 0 register, addressable at 3BAH (in monochrome modes) or 3DAH (color). Unfortunately, by the time the vertical sync status is observed by a program, the start address for the next frame has already been latched, having happened the instant the vertical sync pulse began. That means that it’s no good to wait for vertical sync to begin, then set the new start address; if we did that, we’d have to wait until the <em>next</em> vertical sync pulse to start drawing, because the page wouldn’t flip until then.</p>
<p>Clearly, what we want is to set the new start address, then wait for the start of the vertical sync pulse, at which point we can be sure the page has flipped. However, we can’t just set the start address and wait, because we might have the extreme misfortune to set one of the start address registers before the start of vertical sync and the other after, resulting in mismatched halves of the start address and a nasty jump of the displayed image for one frame.</p>
<p>One possible solution to this problem is to pick a second page start address that has a 0 value for the lower byte, so only the Start Address High register ever needs to be set, but in the sample program in Listing 23.1 I’ve gone for generality and always set both bytes. To avoid mismatched start address bytes, the sample program waits for pixel data to be displayed, as indicated by the Display Enable status; this tells us we’re somewhere in the displayed portion of the frame, far enough away from vertical sync so we can be sure the new start address will get used at the next vertical sync. Once the Display Enable status is observed, the program sets the new start address, waits for vertical sync to happen, sets the new pel panning state, and then continues drawing. Don’t worry about the details right now; page flipping will come up again, at considerably greater length, in later chapters.</p>
<blockquote>
<p><img src="images/i.jpg" /> As an interesting side note, be aware that if you run DOS software under a multitasking environment such as Windows NT, timeslicing delays can make mismatched start address bytes or mismatched start address and pel panning settings much more likely, for the graphics code can be interrupted at any time. This is also possible, although much less likely, under non-multitasking environments such as DOS, because strategically placed interrupts can cause the same sorts of problems there. For maximum safety, you should disable interrupts around the key portions of your page-flipping code, although here we run into the problem that if interrupts are disabled from the time we start looking for Display Enable until we set the Pel Panning register, they will be off for far too long, and keyboard, mouse, and network events will potentially be lost. Also, disabling interrupts won’t help in true multitasking environments, which never let a program hog the entire CPU. This is one reason that pel panning, although indubitably flashy, isn’t widely used and should be reserved for only those cases where it’s absolutely necessary.</p>
</blockquote>
<p>Waiting for the sync pulse has the side effect of causing program execution to synchronize to the VGA’s frame rate of 60 or 70 frames per second, depending on the display mode. This synchronization has the useful consequence of causing the program to execute at the same speed on any CPU that can draw fast enough to complete the drawing in a single frame; the program just idles for the rest of each frame that it finishes before the VGA is finished displaying the previous frame.</p>
<p>An important point illustrated by the sample program is that while the VGA’s display memory is far larger and more versatile than is the case with earlier adapters, it is nonetheless a limited resource and must be used judiciously. The sample program uses VGA memory to store two 672x384 virtual pages, leaving only 1024 bytes free to store images. In this case, the only images needed are a colored ball and a blank block with which to erase it, so there is no problem, but many applications require dozens or hundreds of images. The tradeoffs between virtual page size, page flipping, and image storage must always be kept in mind when designing programs for the VGA.</p>
<p>To see the program run in 640x200 16-color mode, comment out the <code>EQU</code> line for <code>MEDRES_VIDEO_MODE</code>.</p>
</section>
</section>
<section id="the-hazards-of-vga-clones" class="level3">
<h3><a href="#the-hazards-of-vga-clones">The Hazards of VGA Clones</a></h3>
<p>Earlier, I said that any VGA that doesn’t support the features and functionality covered in this book can’t properly be called VGA compatible. I also noted that there are some exceptions, however, and we’ve just come to the most prominent one. You see, all VGAs really <em>are</em> compatible with the IBM VGA’s functionality when it comes to drawing pixels into display memory; all the write modes and read modes and set/reset capabilities and everything else involved with manipulating display memory really does work in the same way on all VGAs and VGA clones. That compatibility isn’t as airtight when it comes to scanning pixels out of display memory and onto the screen in certain infrequently-used ways, however.</p>
<p>The areas of incompatibility of which I’m aware are illustrated by the sample program, and may in fact have caused you to see some glitches when you ran Listing 23.1. The problem, which arises only on certain VGAs, is that some settings of the Row Offset register cause some pixels to be dropped or displaced to the wrong place on the screen; often, this happens only in conjunction with certain start address settings. (In my experience, only VRAM (Video RAM)-based VGAs exhibit this problem, no doubt due to the way that pixel data is fetched from VRAM in large blocks.) Panning and large virtual bitmaps can be made to work reliably, by careful selection of virtual bitmap sizes and start addresses, but it’s difficult; that’s one of the reasons that most commercial software does not use these features, although a number of games do. The upshot is that if you’re going to use oversized virtual bitmaps and pan around them, you should take great care to test your software on a wide variety of VRAM- and DRAM-based VGAs.</p>
</section>
<section id="just-the-beginning" class="level3">
<h3><a href="#just-the-beginning">Just the Beginning</a></h3>
<p>That pretty well covers the important points of the sample VGA program in Listing 23.1. There are many VGA features we didn’t even touch on, but the object was to give you a feel for the variety of features available on the VGA, to convey the flexibility and complexity of the VGA’s resources, and in general to give you an initial sense of what VGA programming is like. Starting with the next chapter, we’ll begin to explore the VGA systematically, on a more detailed basis.</p>
</section>
<section id="the-macro-assembler" class="level3">
<h3><a href="#the-macro-assembler">The Macro Assembler</a></h3>
<p>The code in this book is written in both C and assembly. I think C is a good development environment, but I believe that often the best code (although not necessarily the easiest to write or the most reliable) is written in assembly. This is especially true of graphics code for the x86 family, given segments, the string instructions, and the asymmetric and limited register set, and for real-time programming of a complex board like the VGA, there’s really no other choice for the lowest-level code.</p>
<p>Before I’m deluged with protests from C devotees, let me add that the majority of my productive work is done in C; no programmer is immune to the laws of time, and C is simply a more time-efficient environment in which to develop, particularly when working in a programming team. In this book, however, we’re after the <em>sine qua non</em> of PC graphics—performance—and we can’t get there from here without a fair amount of assembly language.</p>
<p>Now that we know what the VGA looks like in broad strokes and have a sense of what VGA programming is like, we can start looking at specific areas in depth. In the next chapter, we’ll take a look at the hardware assistance the VGA provides the CPU during display memory access. There are four latches and four ALUs in those chips, along with some useful masks and comparators, and it’s that hardware that’s the difference between sluggish performance and making the VGA get up and dance.</p>
</section>
</section>
<section id="chapter-24-parallel-processing-with-the-vga" class="level2">
<h2><a href="#chapter-24-parallel-processing-with-the-vga">Chapter 24 – Parallel Processing with the VGA</a></h2>
<section id="taking-on-graphics-memory-four-bytes-at-a-time" class="level3">
<h3><a href="#taking-on-graphics-memory-four-bytes-at-a-time">Taking on Graphics Memory Four Bytes at a Time</a></h3>
<p>This heading refers to the ability of the VGA chip to manipulate up to four bytes of display memory at once. In particular, the VGA provides four ALUs (Arithmetic Logic Units) to assist the CPU during display memory writes, and this hardware is a tremendous resource in the task of manipulating the VGA’s sizable frame buffer. The ALUs are actually only one part of the surprisingly complex data flow architecture of the VGA, but since they’re involved in almost all memory access operations, they’re a good place to begin.</p>
</section>
<section id="vga-programming-alus-and-latches" class="level3">
<h3><a href="#vga-programming-alus-and-latches">VGA Programming: ALUs and Latches</a></h3>
<p>I’m going to begin our detailed tour of the VGA at the heart of the flow of data through the VGA: the four ALUs built into the VGA’s Graphics Controller (GC) circuitry. The ALUs (one for each display memory plane) are capable of ORing, ANDing, and XORing CPU data and display memory data together, as well as masking off some or all of the bits in the data from affecting the final result. All the ALUs perform the same logical operation at any given time, but each ALU operates on a different display memory byte.</p>
<p>Recall that the VGA has four display memory planes, with one byte in each plane at any given display memory address. All four display memory bytes operated on are read from and written to the same address, but each ALU operates on a byte that was read from a different plane and writes the result to that plane. This arrangement allows four display memory bytes to be modified by a single CPU write (which must often be preceded by a single CPU read, as we will see). The benefit is vastly improved performance; if the CPU had to select each of the four planes in turn via <code>OUT</code>s and perform the four logical operations itself, VGA performance would slow to a crawl.</p>
<p>Figure 24.1 is a simplified depiction of data flow around the ALUs. Each ALU has a matching latch, which holds the byte read from the corresponding plane during the last CPU read from display memory, even if that particular plane wasn’t the plane that the CPU actually read on the last read access. (Only one byte can be read by the CPU with a single display memory read; the plane supplying the byte is selected by the Read Map register. However, the bytes at the specified address in all four planes are always read when the CPU reads display memory, and those four bytes are stored in their respective latches.)</p>
<p>Each ALU logically combines the byte written by the CPU and the byte stored in the matching latch, according to the settings of bits 3 and 4 of the Data Rotate register (and the Bit Mask register as well, which I’ll cover next time), and then writes the result to display memory. It is most important to understand that neither ALU operand comes directly from display memory. The temptation is to think of the ALUs as combining CPU data and the contents of the display memory address being written to, but they actually combine CPU data and the contents of the last display memory location read, which need not be the location being modified. The most common application of the ALUs is indeed to modify a given display memory location, but doing so requires a read from that location to load the latches before the write that modifies it. Omission of the read results in a write operation that logically combines CPU data n with whatever data happens to be in the latches from the last read, which is normally undesirable.</p>
<figure>
<img src="images/24-01.jpg" alt="Figure 24.1  VGA ALU data flow." /><figcaption><strong>Figure 24.1</strong>  <em>VGA ALU data flow.</em></figcaption>
</figure>
<p>Occasionally, however, the independence of the latches from the display memory location being written to can be used to great advantage. The latches can be used to perform 4-byte-at-a-time (one byte from each plane) block copying; in this application, the latches are loaded with a read from the source area and written unmodified to the destination area. The latches can be written unmodified in one of two ways: By selecting write mode 1 (for an example of this, see the last chapter), or by setting the Bit Mask register to 0 so only the latched bits are written.</p>
<p>The latches can also be used to draw a fairly complex area fill pattern, with a different bit pattern used to fill each plane. The mechanism for this is as follows: First, generate the desired pattern across all planes at any display memory address. Generating the pattern requires a separate write operation for each plane, so that each plane’s byte will be unique. Next, read that memory address to store the pattern in the latches. The contents of the latches can now be written to memory any number of times by using either write mode 1 or the bit mask, since they will not change until a read is performed. If the fill pattern does not require a different bit pattern for each plane—that is, if the pattern is black and white—filling can be performed more easily by simply fanning the CPU byte out to all four planes with write mode 0. The set/reset registers can be used in conjunction with fanning out the data to support a variety of two-color patterns. More on this in Chapter 25.</p>
<p>The sample program in Listing 24.1 fills the screen with horizontal bars, then illustrates the operation of each of the four ALU logical functions by writing a vertical 80-pixel-wide box filled with solid, empty, and vertical and horizontal bar patterns over that background using each of the functions in turn. When observing the output of the sample program, it is important to remember that all four vertical boxes are drawn with <em>exactly</em> the same code—only the logical function that is in effect differs from box to box.</p>
<p>All graphics in the sample program are done in black-and-white by writing to all planes, in order to show the operation of the ALUs most clearly. Selective enabling of planes via the Map Mask register and/or set/reset would produce color effects; in that case, the operation of the logical functions must be evaluated on a plane-by-plane basis, since only the enabled planes would be affected by each operation.</p>
<p><strong>LISTING 24.1 L24-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate operation of ALUs and latches of the VGA&#39;s</span>
<span class="co">;  Graphics Controller.  Draws a variety of patterns against</span>
<span class="co">;  a horizontally striped background, using each of the 4 available</span>
<span class="co">;  logical functions (data unmodified, AND, OR, XOR) in turn to combine</span>
<span class="co">;  the images with the background.</span>
<span class="co">; By Michael Abrash.</span>
<span class="co">;</span>
stack   <span class="kw">segment</span> para stack ‘STACK<span class="st">&#39;</span>
        <span class="dt">db</span>      <span class="dv">512</span> dup(?)
stack   ends
<span class="co">;</span>
VGA_VIDEO_SEGMENT       <span class="dt">equ</span><span class="bn">     0a000h  </span><span class="co">;VGA display memory segment</span>
SCREEN_HEIGHT           <span class="dt">equ</span>     <span class="dv">350</span>
SCREEN_WIDTH_IN_BYTES   <span class="dt">equ</span>     <span class="dv">80</span>
DEMO_AREA_HEIGHT        <span class="dt">equ</span>     <span class="dv">336</span>     <span class="co">;# of scan lines in area</span>
                                        <span class="co">; logical function operation</span>
                                        <span class="co">; is demonstrated in</span>
DEMO_AREA_WIDTH_IN_BYTES <span class="dt">equ</span>    <span class="dv">40</span>      <span class="co">;width in bytes of area</span>
                                        <span class="co">; logical function operation</span>
                                        <span class="co">; is demonstrated in</span>
VERTICAL_BOX_WIDTH_IN_BYTES <span class="dt">equ</span> <span class="dv">10</span>      <span class="co">;width in bytes of the box used to</span>
                                        <span class="co">; demonstrate each logical function</span>
<span class="co">;</span>
<span class="co">; VGA register equates.</span>
<span class="co">;</span>
GC_INDEX        <span class="dt">equ</span><span class="bn">     3ceh    </span><span class="co">;GC index register</span>
GC_ROTATE       <span class="dt">equ</span>     <span class="dv">3</span>       <span class="co">;GC data rotate/logical function</span>
                                <span class="co">; register index</span>
GC_MODE         <span class="dt">equ</span>     <span class="dv">5</span>       <span class="co">;GC mode register index</span>
<span class="co">;</span>
dseg    <span class="kw">segment</span> para <span class="kw">common</span> ‘DATA<span class="st">&#39;</span>
<span class="co">;</span>
<span class="co">; String used to label logical functions.</span>
<span class="co">;</span>
LabelString     label   <span class="dt">byte</span>
        <span class="dt">db</span>      ‘UNMODIFIED    <span class="kw">AND</span>       <span class="kw">OR</span>        <span class="kw">XOR</span>   <span class="st">&#39;</span>
LABEL_STRING_LENGTH     <span class="dt">equ</span>     <span class="dv">$</span>-LabelString
<span class="co">;</span>
<span class="co">; Strings used to label fill patterns.</span>
<span class="co">;</span>
FillPatternFF   <span class="dt">db</span>      ‘Fill Pattern: 0FFh<span class="st">&#39;</span>
FILL_PATTERN_FF_LENGTH  <span class="dt">equ</span>     <span class="dv">$</span> - FillPatternFF
FillPattern00   <span class="dt">db</span>      ‘Fill Pattern: 000h<span class="st">&#39;</span>
FILL_PATTERN_00_LENGTH  <span class="dt">equ</span>     <span class="dv">$</span> - FillPattern00
FillPatternVert <span class="dt">db</span>      ‘Fill Pattern: Vertical Bar<span class="st">&#39;</span>
FILL_PATTERN_VERT_LENGTH        <span class="dt">equ</span>     <span class="dv">$</span> - FillPatternVert
FillPatternHorz <span class="dt">db</span>      ‘Fill Pattern: Horizontal Bar<span class="st">&#39;</span>
FILL_PATTERN_HORZ_LENGTH <span class="dt">equ</span>    <span class="dv">$</span> - FillPatternHorz
<span class="co">;</span>
dseg    ends
<span class="co">;</span>
<span class="co">; Macro to set indexed register INDEX of GC chip to SETTING.</span>
<span class="co">;</span>
SETGC   macro   INDEX, SETTING
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">ax</span>,(SETTING <span class="kw">SHL</span> <span class="dv">8</span>) <span class="kw">OR</span> INDEX
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>
        endm
<span class="co">;</span>
<span class="co">;</span>
<span class="co">; Macro to call BIOS write string function to display text string</span>
<span class="co">;  TEXT_STRING, of length TEXT_LENGTH, at location ROW,COLUMN.</span>
<span class="co">;</span>
TEXT_UP macro   TEXT_STRING, TEXT_LENGTH, ROW, COLUMN
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,13h                  </span><span class="co">;BIOS write string function</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,offset TEXT_STRING   <span class="co">;ES:BP points to string</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,TEXT_LENGTH
        <span class="kw">mov</span>     <span class="kw">dx</span>,(ROW <span class="kw">SHL</span> <span class="dv">8</span>) <span class="kw">OR</span> COLUMN        <span class="co">;position</span>
        <span class="kw">sub</span>     <span class="kw">al</span>,<span class="kw">al</span>           <span class="co">;string is chars only, cursor not moved</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,<span class="dv">7</span>            <span class="co">;text attribute is white (light gray)</span>
        <span class="kw">int</span><span class="bn">     10h</span>
        endm
<span class="co">;</span>
cseg    <span class="kw">segment</span> para public ‘CODE<span class="st">&#39;</span>
        assume  <span class="kw">cs</span>:cseg, <span class="kw">ds</span>:dseg
start   proc    near
        <span class="kw">mov</span>     <span class="kw">ax</span>,dseg
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Select 640x350 graphics mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,010h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
<span class="co">; ES points to VGA memory.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,VGA_VIDEO_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Draw background of horizontal bars.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SCREEN_HEIGHT/<span class="dv">4</span>
                                <span class="co">;# of bars to draw (each 4 pixels high)</span>
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>           <span class="co">;start at offset 0 in display memory</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0ffffh       </span><span class="co">;fill pattern for light areas of bars</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,DEMO_AREA_WIDTH_IN_BYTES / <span class="dv">2</span> <span class="co">;length of each bar</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,SCREEN_WIDTH_IN_BYTES - DEMO_AREA_WIDTH_IN_BYTES
        <span class="kw">mov</span>     <span class="kw">bp</span>,(SCREEN_WIDTH_IN_BYTES * <span class="dv">3</span>) - DEMO_AREA_WIDTH_IN_BYTES
<span class="fu">BackgroundLoop:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">bx</span>           <span class="co">;length of bar</span>
    rep <span class="kw">stosw</span>                   <span class="co">;draw top half of bar</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">si</span>           <span class="co">;point to start of bottom half of bar</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">bx</span>           <span class="co">;length of bar</span>
    rep <span class="kw">stosw</span>                   <span class="co">;draw bottom half of bar</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">bp</span>           <span class="co">;point to start of top of next bar</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">jnz</span>     BackgroundLoop
<span class="co">;</span>
<span class="co">; Draw vertical boxes filled with a variety of fill patterns</span>
<span class="co">;  using each of the 4 logical functions in turn.</span>
<span class="co">;</span>
        SETGC   GC_ROTATE, <span class="dv">0</span>            <span class="co">;select data unmodified</span>
                                        <span class="co">; logical function...</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="dv">0</span>
        <span class="kw">call</span>    DrawVerticalBox         <span class="co">;...and draw box</span>
<span class="co">;</span>
        SETGC   GC_ROTATE<span class="bn">, 08h          </span><span class="co">;select AND logical function...</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="dv">10</span>
        <span class="kw">call</span>    DrawVerticalBox         <span class="co">;...and draw box</span>
<span class="co">;</span>
        SETGC   GC_ROTATE<span class="bn">, 10h          </span><span class="co">;select OR logical function...</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="dv">20</span>
        <span class="kw">call</span>    DrawVerticalBox         <span class="co">;...and draw box</span>
<span class="co">;</span>
        SETGC   GC_ROTATE<span class="bn">, 18h          </span><span class="co">;select XOR logical function...</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="dv">30</span>
        <span class="kw">call</span>    DrawVerticalBox         <span class="co">;...and draw box</span>
<span class="co">;</span>
<span class="co">; Reset the logical function to data unmodified, the default state.</span>
<span class="co">;</span>
        SETGC   GC_ROTATE, <span class="dv">0</span>
<span class="co">;</span>
<span class="co">; Label the screen.</span>
<span class="co">;</span>
        <span class="kw">push</span>    <span class="kw">ds</span>
        <span class="kw">pop</span>     <span class="kw">es</span>      <span class="co">;strings we&#39;ll display are passed to BIOS</span>
                        <span class="co">; by pointing ES:BP to them</span>
<span class="co">;</span>
<span class="co">; Label the logical functions, using the VGA BIOS&#39;s</span>
<span class="co">;  write string function.</span>
<span class="co">;</span>
        TEXT_UP LabelString, LABEL_STRING_LENGTH, <span class="dv">24</span>, <span class="dv">0</span>
<span class="co">;</span>
<span class="co">; Label the fill patterns, using the VGA BIOS&#39;s</span>
<span class="co">;  write string function.</span>
<span class="co">;</span>
        TEXT_UP FillPatternFF, FILL_PATTERN_FF_LENGTH, <span class="dv">3</span>, <span class="dv">42</span>
        TEXT_UP FillPattern00, FILL_PATTERN_00_LENGTH, <span class="dv">9</span>, <span class="dv">42</span>
        TEXT_UP FillPatternVert, FILL_PATTERN_VERT_LENGTH, <span class="dv">15</span>, <span class="dv">42</span>
        TEXT_UP FillPatternHorz, FILL_PATTERN_HORZ_LENGTH, <span class="dv">21</span>, <span class="dv">42</span>
<span class="co">;</span>
<span class="co">; Wait until a key&#39;s been hit to reset screen mode &amp; exit.</span>
<span class="co">;</span>
<span class="fu">WaitForKey:</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">int</span><span class="bn">     16h</span>
        <span class="kw">jz</span>      WaitForKey
<span class="co">;</span>
<span class="co">; Finished.  Clear key, reset screen mode and exit.</span>
<span class="co">;</span>
<span class="fu">Done:</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">0</span>    <span class="co">;clear key that we just detected</span>
        <span class="kw">int</span><span class="bn">     16h</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dv">3</span>    <span class="co">;reset to text mode</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch  </span><span class="co">;exit to DOS</span>
        <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
start   endp
<span class="co">;</span>
<span class="co">; Subroutine to draw a box 80x336 in size, using currently selected</span>
<span class="co">;  logical function, with upper left corner at the display memory offset</span>
<span class="co">;  in DI.  Box is filled with four patterns.  Top quarter of area is</span>
<span class="co">;  filled with 0FFh (solid) pattern, next quarter is filled with 00h</span>
<span class="co">;  (empty) pattern, next quarter is filled with 33h (double pixel wide</span>
<span class="co">;  vertical bar) pattern, and bottom quarter is filled with double pixel</span>
<span class="co">;  high horizontal bar pattern.</span>
<span class="co">;</span>
<span class="co">; Macro to draw a column of the specified width in bytes, one-quarter</span>
<span class="co">;  of the height of the box, with the specified fill pattern.</span>
<span class="co">;</span>
DRAW_BOX_QUARTER        macro   FILL, WIDTH
        local   RowLoop, ColumnLoop
        <span class="kw">mov</span>     <span class="kw">al</span>,FILL                 <span class="co">;fill pattern</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,DEMO_AREA_HEIGHT / <span class="dv">4</span> <span class="co">;1/4 of the full box height</span>
<span class="fu">RowLoop:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,WIDTH
<span class="fu">ColumnLoop:</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">es</span>:[<span class="kw">di</span>]      <span class="co">;load display memory contents into</span>
                                <span class="co">; GC latches (we don&#39;t actually care</span>
                                <span class="co">; about value read into AH)</span>
        <span class="kw">stosb</span>                   <span class="co">;write pattern, which is logically</span>
                                <span class="co">; combined with latch contents for each</span>
                                <span class="co">; plane and then written to display</span>
                                <span class="co">; memory</span>
        <span class="kw">loop</span>    ColumnLoop
        <span class="kw">add</span>     <span class="kw">di</span>,SCREEN_WIDTH_IN_BYTES - WIDTH
                                <span class="co">;point to start of next line down in box</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">jnz</span>     RowLoop
        endm
<span class="co">;</span>
DrawVerticalBox proc    near
        DRAW_BOX_QUARTER<span class="bn">        0ffh, </span>VERTICAL_BOX_WIDTH_IN_BYTES
                                        <span class="co">;first fill pattern: solid fill</span>
        DRAW_BOX_QUARTER        <span class="dv">0</span>, VERTICAL_BOX_WIDTH_IN_BYTES
                                        <span class="co">;second fill pattern: empty fill</span>
        DRAW_BOX_QUARTER<span class="bn">        033h, </span>VERTICAL_BOX_WIDTH_IN_BYTES
                                        <span class="co">;third fill pattern: double-pixel</span>
                                        <span class="co">; wide vertical bars</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,DEMO_AREA_HEIGHT / <span class="dv">4</span> / <span class="dv">4</span>
                                <span class="co">;fourth fill pattern: horizontal bars in</span>
                                <span class="co">; sets of 4 scan lines</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,VERTICAL_BOX_WIDTH_IN_BYTES  <span class="co">;width of fill area</span>
<span class="fu">HorzBarLoop:</span>
        <span class="kw">dec</span>     <span class="kw">ax</span>              <span class="co">;0ffh fill (smaller to do word than byte DEC)</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">si</span>           <span class="co">;width to fill</span>
<span class="fu">HBLoop1:</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,<span class="kw">es</span>:[<span class="kw">di</span>]      <span class="co">;load latches (don&#39;t care about value)</span>
        <span class="kw">stosb</span>                   <span class="co">;write solid pattern, through ALUs</span>
        <span class="kw">loop</span>    HBLoop1
        <span class="kw">add</span>     <span class="kw">di</span>,SCREEN_WIDTH_IN_BYTES - VERTICAL_BOX_WIDTH_IN_BYTES
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">si</span>           <span class="co">;width to fill</span>
<span class="fu">HBLoop2:</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,<span class="kw">es</span>:[<span class="kw">di</span>]      <span class="co">;load latches</span>
        <span class="kw">stosb</span>                   <span class="co">;write solid pattern, through ALUs</span>
        <span class="kw">loop</span>    HBLoop2
        <span class="kw">add</span>     <span class="kw">di</span>,SCREEN_WIDTH_IN_BYTES - VERTICAL_BOX_WIDTH_IN_BYTES
        <span class="kw">inc</span>     <span class="kw">ax</span>              <span class="co">;0 fill (smaller to do word than byte DEC)</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">si</span>           <span class="co">;width to fill</span>
<span class="fu">HBLoop3:</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,<span class="kw">es</span>:[<span class="kw">di</span>]      <span class="co">;load latches</span>
        <span class="kw">stosb</span>                   <span class="co">;write empty pattern, through ALUs</span>
        <span class="kw">loop</span>    HBLoop3
        <span class="kw">add</span>     <span class="kw">di</span>,SCREEN_WIDTH_IN_BYTES - VERTICAL_BOX_WIDTH_IN_BYTES
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">si</span>           <span class="co">;width to fill</span>
<span class="fu">HBLoop4:</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,<span class="kw">es</span>:[<span class="kw">di</span>]      <span class="co">;load latches</span>
        <span class="kw">stosb</span>                   <span class="co">;write empty pattern, through ALUs</span>
        <span class="kw">loop</span>    HBLoop4
        <span class="kw">add</span>     <span class="kw">di</span>,SCREEN_WIDTH_IN_BYTES - VERTICAL_BOX_WIDTH_IN_BYTES
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">jnz</span>     HorzBarLoop
<span class="co">;</span>
        <span class="kw">ret</span>
DrawVerticalBox endp
cseg    ends
        end     start</code></pre>
<p>Logical function 0, which writes the CPU data unmodified, is the standard mode of operation of the ALUs. In this mode, the CPU data is combined with the latched data by ignoring the latched data entirely. Expressed as a logical function, this could be considered CPU data ANDed with 1 (or ORed with 0). This is the mode to use whenever you want to place CPU data into display memory, replacing the previous contents entirely. It may occur to you that there is no need to latch display memory at all when the data unmodified function is selected. In the sample program, that is true, but if the bit mask is being used, the latches must be loaded even for the data unmodified function, as I’ll discuss in the next chapter.</p>
<p>Logical functions 1 through 3 cause the CPU data to be ANDed, ORed, and XORed with the latched data, respectively. Of these, XOR is the most useful, since exclusive-ORing is a traditional way to perform animation. The uses of the AND and OR logical functions are less obvious. AND can be used to mask a blank area into display memory, or to mask off those portions of a drawing operation that don’t overlap an existing display memory image. OR could conceivably be used to force an image into display memory over an existing image. To be honest, I haven’t encountered any particularly valuable applications for AND and OR, but they’re the sort of building-block features that could come in handy in just the right context, so keep them in mind.</p>
</section>
<section id="notes-on-the-alulatch-demo-program" class="level3">
<h3><a href="#notes-on-the-alulatch-demo-program">Notes on the ALU/Latch Demo Program</a></h3>
<p>VGA settings such as the logical function select should be restored to their default condition before the BIOS is called to output text or draw pixels. The VGA BIOS does not guarantee that it will set most VGA registers except on mode sets, and there are so many compatible BIOSes around that the code of the IBM BIOS is not a reliable guide. For instance, when the BIOS is called to draw text, it’s likely that the result will be illegible if the Bit Mask register is not in its default state. Similarly, a mode set should generally be performed before exiting a program that tinkers with VGA settings.</p>
<p>Along the same lines, the sample program does not explicitly set the Map Mask register to ensure that all planes are enabled for writing. The mode set for mode 10H leaves all planes enabled, so I did not bother to program the Map Mask register, or any other register besides the Data Rotate register, for that matter. However, the profusion of compatible BIOSes means there is some small risk in relying on the BIOS to leave registers set properly. For the highly safety-conscious, the best course would be to program data control registers such as the Map Mask and Read Mask explicitly before relying on their contents.</p>
<p>On the other hand, any function the BIOS provides explicitly—as part of the interface specification—such as setting the palette RAM, should be used in preference to programming the hardware directly whenever possible, because the BIOS may mask hardware differences between VGA implementations.</p>
<p>The code that draws each vertical box in the sample program reads from display memory immediately before writing to display memory. The read operation loads the VGA latches. The value that is read is irrelevant as far as the sample program is concerned. The read operation is present only because it is necessary to perform a read to load the latches, and there is no way to read without placing a value in a register. This is a bit of a nuisance, since it means that the value of some 8-bit register must be destroyed. Under certain circumstances, a single logical instruction such as <code>XOR</code> or <code>AND</code> can be used to perform both the read to load the latches and then write to modify display memory without affecting any CPU registers, as we’ll see later on.</p>
<p>All text in the sample program is drawn by VGA BIOS function 13H, the write string function. This function is also present in the AT’s BIOS, but not in the XT’s or PC’s, and as a result is rarely used; the function is always available if a VGA is installed, however. Text drawn with this function is relatively slow. If speed is important, a program can draw text directly into display memory much faster in any given display mode. The great virtue of the BIOS write string function in the case of the VGA is that it provides an uncomplicated way to get text on the screen reliably in any mode and color, over any background.</p>
<p>The expression used to load DX in the <code>TEXT_UP</code> macro in the sample program may seem strange, but it’s a convenient way to save a byte of program code and a few cycles of execution time. DX is being loaded with a word value that’s composed of two independent immediate byte values. The obvious way to implement this would be with</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">MOV</span> <span class="kw">DL</span>,VALUE1
<span class="kw">MOV</span> <span class="kw">DH</span>,VALUE2</code></pre>
<p>which requires four instruction bytes. By shifting the value destined for the high byte into the high byte with MASM’s shift-left operator, <code>SHL</code> (*100H would work also), and then logically combining the values with MASM’s <code>OR</code> operator (or the <code>ADD</code> operator), both halves of DX can be loaded with a single instruction, as in</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">MOV</span> <span class="kw">DX</span>,(VALUE2 <span class="kw">SHL</span> <span class="dv">8</span>) <span class="kw">OR</span> VALUE1</code></pre>
<p>which takes only three bytes and is faster, being a single instruction. (Note, though, that in 32-bit protected mode, there’s a size and performance penalty for 16-bit instructions such as the <code>MOV</code> above; see the first part of this book for details.) As shown, a macro is an ideal place to use this technique; the macro invocation can refer to two separate byte values, making matters easier for the programmer, while the macro itself can combine the values into a single word-sized constant.</p>
<blockquote>
<p><img src="images/i.jpg" /> A minor optimization tip illustrated in the listing is the use of <code>INC AX</code> and <code>DEC AX</code> in the <code>DrawVerticalBox</code> subroutine when only AL actually needs to be modified. Word-sized register increment and decrement instructions (or dword-sized instructions in 32-bit protected mode) are only one byte long, while byte-size register increment and decrement instructions are two bytes long. Consequently, when size counts, it is worth using a whole 16-bit (or 32-bit) register instead of the low 8 bits of that register for <code>INC</code> and <code>DEC</code>—if you don’t need the upper portion of the register for any other purpose, or if you can be sure that the <code>INC</code> or <code>DEC</code> won’t affect the upper part of the register.</p>
</blockquote>
<p>The latches and ALUs are central to high-performance VGA code, since they allow programs to process across all four memory planes without a series of <code>OUT</code>s and read/write operations. It is not always easy to arrange a program to exploit this power, however, because the ALUs are far more limited than a CPU. In many instances, however, additional hardware in the VGA, including the bit mask, the set/reset features, and the barrel shifter, can assist the ALUs in controlling data, as we’ll see in the next few chapters.</p>
</section>
</section>
<section id="chapter-25-vga-data-machinery" class="level2">
<h2><a href="#chapter-25-vga-data-machinery">Chapter 25 – VGA Data Machinery</a></h2>
<section id="the-barrel-shifter-bit-mask-and-setreset-mechanisms" class="level3">
<h3><a href="#the-barrel-shifter-bit-mask-and-setreset-mechanisms">The Barrel Shifter, Bit Mask, and Set/Reset Mechanisms</a></h3>
<p>In the last chapter, we examined a simplified model of data flow within the GC portion of the VGA, featuring the latches and ALUs. Now we’re ready to expand that model to include the barrel shifter, bit mask, and the set/reset capabilities, leaving only the write modes to be explored over the next few chapters.</p>
</section>
<section id="vga-data-rotation" class="level3">
<h3><a href="#vga-data-rotation">VGA Data Rotation</a></h3>
<p>Figure 25.1 shows an expanded model of GC data flow, featuring the barrel shifter and bit mask circuitry. Let’s look at the barrel shifter first. A barrel shifter is circuitry capable of shifting—or rotating, in the VGA’s case—data an arbitrary number of bits in a single operation, as opposed to being able to shift only one bit position at a time. The barrel shifter in the VGA can rotate incoming CPU data up to seven bits to the right (toward the least significant bit), with bit 0 wrapping back to bit 7, after which the VGA continues processing the rotated byte just as it normally processes unrotated CPU data. Thanks to the nature of barrel shifters, this rotation requires no extra processing time over unrotated VGA operations. The number of bits by which CPU data is shifted is controlled by bits 2-0 of GC register 3, the Data Rotate register, which also contains the ALU function select bits (data unmodified, AND, OR, and XOR) that we looked at in the last chapter.</p>
<figure>
<img src="images/25-01.jpg" alt="Figure 25.1  Data flow through the Graphics Controller." /><figcaption><strong>Figure 25.1</strong>  <em>Data flow through the Graphics Controller.</em></figcaption>
</figure>
<p>The barrel shifter is powerful, but (as sometimes happens in this business) it sounds more useful than it really is. This is because the GC can only rotate CPU data, a task that the CPU itself is perfectly capable of performing. Two <code>OUT</code>s are needed to select a given rotation: one to set the GC Index register, and one to set the Data Rotate register. However, with careful programming it’s sometimes possible to leave the GC Index always pointing to the Data Rotate register, so only one <code>OUT</code> is needed. Even so, it’s often easier and/or faster to simply have the CPU rotate the data of interest CL times than to set the Data Rotate register. (Bear in mind that a single <code>OUT</code> takes from 11 to 31 cycles on a 486—and longer if the VGA is sluggish at responding to OUTs, as many VGAs are.) If only the VGA could rotate <em>latched</em> data, then there would be all sorts of useful applications for rotation, but, sadly, only CPU data can be rotated.</p>
<p>The drawing of bit-mapped text is one use for the barrel shifter, and I’ll demonstrate that application below. In general, though, don’t knock yourself out trying to figure out how to work data rotation into your programs—it just isn’t all that useful in most cases.</p>
</section>
<section id="the-bit-mask" class="level3">
<h3><a href="#the-bit-mask">The Bit Mask</a></h3>
<p>The VGA has bit mask circuitry for each of the four memory planes. The four bit masks operate in parallel and are all driven by the same mask data for each operation, so they’re generally referred to in the singular, as “the bit mask.” Figure 25.2 illustrates the operation of one bit of the bit mask for one plane. This circuitry occurs eight times in the bit mask for a given plane, once for each bit of the byte written to display memory. Briefly, the bit mask determines on a bit-by-bit basis whether the source for each byte written to display memory is the ALU for that plane or the latch for that plane.</p>
<figure>
<img src="images/25-02.jpg" alt="Figure 25.2  Bit mask operation." /><figcaption><strong>Figure 25.2</strong>  <em>Bit mask operation.</em></figcaption>
</figure>
<p>The bit mask is controlled by GC register 8, the Bit Mask register. If a given bit of the Bit Mask register is 1, then the corresponding bit of data from the ALUs is written to display memory for all four planes, while if that bit is 0, then the corresponding bit of data from the latches for the four planes is written to display memory unchanged. (In write mode 3, the actual bit mask that’s applied to data written to display memory is the logical AND of the contents of the Bit Mask register and the data written by the CPU, as we’ll see in Chapter 26.)</p>
<p>The most common use of the bit mask is to allow updating of selected bits within a display memory byte. This works as follows: The display memory byte of interest is latched; the bit mask is set to preserve all but the bit or bits to be changed; the CPU writes to display memory, with the bit mask preserving the indicated latched bits and allowing ALU data through to change the other bits. Remember, though, that it is not possible to alter selected bits in a display memory byte <em>directly;</em> the byte must first be latched by a CPU read, and then the bit mask can keep selected bits of the latched byte unchanged.</p>
<p>Listing 25.1 shows a program that uses the bit mask data rotation capabilities of the GC to draw bitmapped text at any screen location. The BIOS only draws characters on character boundaries; in 640x480 graphics mode the default font is drawn on byte boundaries horizontally and every 16 scan lines vertically. However, with direct bitmapped text drawing of the sort used in Listing 25.1, it’s possible to draw any font of any size anywhere on the screen (and a lot faster than via DOS or the BIOS, as well).</p>
<p><strong>LISTING 25.1 L25-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate operation of data rotate and bit mask</span>
<span class="co">;  features of Graphics Controller. Draws 8x8 character at</span>
<span class="co">;  specified location, using VGA&#39;s 8x8 ROM font. Designed</span>
<span class="co">;  for use with modes 0Dh, 0Eh, 0Fh, 10h, and 12h.</span>
<span class="co">; By Michael Abrash.</span>
<span class="co">;</span>
stack   <span class="kw">segment</span> para stack ‘STACK<span class="st">&#39;</span>
        <span class="dt">db</span>      <span class="dv">512</span> dup(?)
stack   ends
<span class="co">;</span>
VGA_VIDEO_SEGMENT       <span class="dt">equ</span><span class="bn">     0a000h  </span><span class="co">;VGA display memory segment</span>
SCREEN_WIDTH_IN_BYTES   <span class="dt">equ</span><span class="bn">     044ah   </span><span class="co">;offset of BIOS variable</span>
FONT_CHARACTER_SIZE     <span class="dt">equ</span>     <span class="dv">8</span>       <span class="co">;# bytes in each font char</span>
<span class="co">;</span>
<span class="co">; VGA register equates.</span>
<span class="co">;</span>
GC_INDEX        <span class="dt">equ</span><span class="bn">     3ceh    </span><span class="co">;GC index register</span>
GC_ROTATE       <span class="dt">equ</span>     <span class="dv">3</span>       <span class="co">;GC data rotate/logical function</span>
                                <span class="co">; register index</span>
GC_BIT_MASK     <span class="dt">equ</span>     <span class="dv">8</span>       <span class="co">;GC bit mask register index</span>
<span class="co">;</span>
dseg    <span class="kw">segment</span> para <span class="kw">common</span> ‘DATA<span class="st">&#39;</span>
TEST_TEXT_ROW   <span class="dt">equ</span>     <span class="dv">69</span>      <span class="co">;row to display test text at</span>
TEST_TEXT_COL   <span class="dt">equ</span>     <span class="dv">17</span>      <span class="co">;column to display test text at</span>
TEST_TEXT_WIDTH <span class="dt">equ</span>     <span class="dv">8</span>       <span class="co">;width of a character in pixels</span>

TestString      label   <span class="dt">byte</span>
        <span class="dt">db</span>      ‘Hello, world!<span class="st">&#39;,0       ;test string to print.</span>
FontPointer     <span class="dt">dd</span>      ?               <span class="co">;font offset</span>
dseg    ends
<span class="co">;</span>
<span class="co">; Macro to set indexed register INDEX of GC chip to SETTING.</span>
<span class="co">;</span>
SETGC   macro   INDEX, SETTING
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">ax</span>,(SETTING <span class="kw">SHL</span> <span class="dv">8</span>) <span class="kw">OR</span> INDEX
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>
        endm
<span class="co">;</span>
cseg    <span class="kw">segment</span> para public ‘CODE<span class="st">&#39;</span>
        assume  <span class="kw">cs</span>:cseg, <span class="kw">ds</span>:dseg
start   proc    near
        <span class="kw">mov</span>     <span class="kw">ax</span>,dseg
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Select 640x480 graphics mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,012h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
<span class="co">; Set driver to use the 8x8 font.</span>
<span class="co">;</span>
         <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,11h  </span><span class="co">;VGA BIOS character generator function,</span>
         <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,30h  </span><span class="co">; return info subfunction</span>
         <span class="kw">mov</span>     <span class="kw">bh</span>,<span class="dv">3</span><span class="co">;get 8x8 font pointer</span>
         <span class="kw">int</span><span class="bn">     10h</span>
         <span class="kw">call</span>    SelectFont
<span class="co">;</span>
<span class="co">; Print the test string.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,offset TestString
        <span class="kw">mov</span>     <span class="kw">bx</span>,TEST_TEXT_ROW
        <span class="kw">mov</span>     <span class="kw">cx</span>,TEST_TEXT_COL
<span class="fu">StringOutLoop:</span>
        <span class="kw">lodsb</span>
        <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">al</span>
        <span class="kw">jz</span>      StringOutDone
        <span class="kw">call</span>    DrawChar
        <span class="kw">add</span>     <span class="kw">cx</span>,TEST_TEXT_WIDTH
        <span class="kw">jmp</span>     StringOutLoop
<span class="fu">StringOutDone:</span>
<span class="co">;</span>
<span class="co">; Reset the data rotate and bit mask registers.</span>
<span class="co">;</span>
        SETGC   GC_ROTATE, <span class="dv">0</span>
        SETGC   GC_BIT_MASK<span class="bn">, 0ffh</span>
<span class="co">;</span>
<span class="co">; Wait for a keystroke.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
<span class="co">; Return to text mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,03h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
<span class="co">; Exit to DOS.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch</span>
        <span class="kw">int</span><span class="bn">     21h</span>
Start   endp
<span class="co">;</span>
<span class="co">; Subroutine to draw a text character in a linear graphics mode</span>
<span class="co">;  (0Dh, 0Eh, 0Fh, 010h, 012h).</span>
<span class="co">; Font used should be pointed to by FontPointer.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;  AL = character to draw</span>
<span class="co">;  BX = row to draw text character at</span>
<span class="co">;  CX = column to draw text character at</span>
<span class="co">;</span>
<span class="co">;  Forces ALU function to &quot;move&quot;.</span>
<span class="co">;</span>
DrawChar        proc    near
        <span class="kw">push</span>    <span class="kw">ax</span>
        <span class="kw">push</span>    <span class="kw">bx</span>
        <span class="kw">push</span>    <span class="kw">cx</span>
        <span class="kw">push</span>    <span class="kw">dx</span>
        <span class="kw">push</span>    <span class="kw">si</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">push</span>    <span class="kw">bp</span>
        <span class="kw">push</span>    <span class="kw">ds</span>
<span class="co">;</span>
<span class="co">; Set DS:SI to point to font and ES to point to display memory.</span>
<span class="co">;</span>
        <span class="kw">lds</span>     <span class="kw">si</span>,[FontPointer]        <span class="co">;point to font</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,VGA_VIDEO_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">dx</span>                   <span class="co">;point to display memory</span>
<span class="co">;</span>
<span class="co">; Calculate screen address of byte character starts in.</span>
<span class="co">;</span>
        <span class="kw">push</span>    <span class="kw">ds</span>      <span class="co">;point to BIOS data segment</span>
        <span class="kw">sub</span>     <span class="kw">dx</span>,<span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">dx</span>
        <span class="kw">xchg</span>    <span class="kw">ax</span>,<span class="kw">bx</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">ds</span>:[SCREEN_WIDTH_IN_BYTES]   <span class="co">;retrieve BIOS</span>
                                                <span class="co">; screen width</span>
        <span class="kw">pop</span>     <span class="kw">ds</span>
        <span class="kw">mul</span>     <span class="kw">di</span>      <span class="co">;calculate offset of start of row</span>
        <span class="kw">push</span>    <span class="kw">di</span>      <span class="co">;set aside screen width</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">cx</span>    <span class="co">;set aside the column</span>
        <span class="kw">and</span>     <span class="kw">cl</span><span class="bn">,0111b    </span><span class="co">;keep only the column in-byte address</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>       <span class="co">;divide column by 8 to make a byte address</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>    <span class="co">;and point to byte</span>
<span class="co">;</span>
<span class="co">; Calculate font address of character.</span>
<span class="co">;</span>
        <span class="kw">sub</span>     <span class="kw">bh</span>,<span class="kw">bh</span>
        <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>    <span class="co">;assumes 8 bytes per character; use</span>
        <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>    <span class="co">; a multiply otherwise</span>
        <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>    <span class="co">;offset in font of character</span>
        <span class="kw">add</span>     <span class="kw">si</span>,<span class="kw">bx</span>    <span class="co">;offset in font segment of character</span>
<span class="co">;</span>
<span class="co">; Set up the GC rotation.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_ROTATE
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">cl</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Set up BH as bit mask for left half,</span>
<span class="co">; BL as rotation for right half.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">bx</span><span class="bn">,0ffffh</span>
        <span class="kw">shr</span>     <span class="kw">bh</span>,<span class="kw">cl</span>
        <span class="kw">neg</span>     <span class="kw">cl</span>
        <span class="kw">add</span>     <span class="kw">cl</span>,<span class="dv">8</span>
        <span class="kw">shl</span>     <span class="kw">bl</span>,<span class="kw">cl</span>
<span class="co">;</span>
<span class="co">; Draw the character, left half first, then right half in the</span>
<span class="co">; succeeding byte, using the data rotation to position the character</span>
<span class="co">; across the byte boundary and then using the bit mask to get the</span>
<span class="co">; proper portion of the character into each byte.</span>
<span class="co">; Does not check for case where character is byte-aligned and</span>
<span class="co">; no rotation and only one write is required.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,FONT_CHARACTER_SIZE
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">pop</span>     <span class="kw">cx</span>      <span class="co">;get back screen width</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>      <span class="co">; -2 because do two bytes for each char</span>
<span class="fu">CharacterLoop:</span>
<span class="co">;</span>
<span class="co">; Set the bit mask for the left half of the character.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_BIT_MASK
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">bh</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Get the next character byte &amp; write it to display memory.</span>
<span class="co">; (Left half of character.)</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,[<span class="kw">si</span>]         <span class="co">;get character byte</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">es</span>:[<span class="kw">di</span>]      <span class="co">;load latches</span>
        <span class="kw">stosb</span>                   <span class="co">;write character byte</span>
<span class="co">;</span>
<span class="co">; Set the bit mask for the right half of the character.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_BIT_MASK
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">bl</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Get the character byte again &amp; write it to display memory.</span>
<span class="co">; (Right half of character.)</span>
<span class="co">;</span>
        <span class="kw">lodsb</span>                   <span class="co">;get character byte</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">es</span>:[<span class="kw">di</span>]      <span class="co">;load latches</span>
        <span class="kw">stosb</span>                   <span class="co">;write character byte</span>
<span class="co">;</span>
<span class="co">; Point to next line of character in display memory.</span>
<span class="co">;</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">cx</span>
<span class="co">;</span>
        <span class="kw">dec</span>     <span class="kw">bp</span>
        <span class="kw">jnz</span>     CharacterLoop
<span class="co">;</span>
        <span class="kw">pop</span>     <span class="kw">ds</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>
        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">dx</span>
        <span class="kw">pop</span>     <span class="kw">cx</span>
        <span class="kw">pop</span>     <span class="kw">bx</span>
        <span class="kw">pop</span>     <span class="kw">ax</span>
        <span class="kw">ret</span>
DrawChar        endp
<span class="co">;</span>
<span class="co">; Set the pointer to the font to draw from to ES:BP.</span>
<span class="co">;</span>
SelectFont      proc    near
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [FontPointer],<span class="kw">bp</span>       <span class="co">;save pointer</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [FontPointer<span class="dv">+2</span>],<span class="kw">es</span>
        <span class="kw">ret</span>
SelectFont      endp
<span class="co">;</span>
cseg    ends
        end     start</code></pre>
<p>The bit mask can be used for much more than bit-aligned fonts. For example, the bit mask is useful for fast pixel drawing, such as that performed when drawing lines, as we’ll see in Chapter 35. It’s also useful for drawing the edges of primitives, such as filled polygons, that potentially involve modifying some but not all of the pixels controlled by a single byte of display memory.</p>
<p>Basically, the bit mask is handy whenever only <em>some</em> of the eight pixels in a byte of display memory need to be changed, because it allows full use of the VGA’s four-way parallel processing capabilities for the pixels that are to be drawn, without interfering with the pixels that are to be left unchanged. The alternative would be plane-by-plane processing, which from a performance perspective would be undesirable indeed.</p>
<p>It’s worth pointing out again that the bit mask operates on the data in the latches, not on the data in display memory. This makes the bit mask a flexible resource that with a little imagination can be used for some interesting purposes. For example, you could fill the latches with a solid background color (by writing the color somewhere in display memory, then reading that location to load the latches), and then use the Bit Mask register (or write mode 3, as we’ll see later) as a mask through which to draw a foreground color stencilled into the background color <em>without</em> reading display memory first. This only works for writing whole bytes at a time (clipped bytes require the use of the bit mask; unfortunately, we’re already using it for stencilling in this case), but it completely eliminates reading display memory and does foreground-plus-background drawing in one blurry-fast pass.</p>
<blockquote>
<p><img src="images/i.jpg" /> This last-described example is a good illustration of how I’d suggest you approach the VGA: As a rich collection of hardware resources that can profitably be combined in some non-obvious ways. Don’t let yourself be limited by the obvious applications for the latches, bit mask, write modes, read modes, map mask, ALUs, and set/reset circuitry. Instead, try to imagine how they could work together to perform whatever task you happen to need done at any given time. I’ve made my code as much as four times faster by doing this, as the discussion of Mode X in Chapters 47-49 demonstrates.</p>
</blockquote>
<p>The example code in Listing 25.1 is designed to illustrate the use of the Data Rotate and Bit Mask registers, and is not as fast or as complete as it might be. The case where text <em>is</em> byte-aligned could be detected and performed much faster, without the use of the Bit Mask or Data Rotate registers and with only one display memory access per font byte (to write the font byte), rather than four (to read display memory and write the font byte to each of the two bytes the character spans). Likewise, non-aligned text drawing could be streamlined to one display memory access per byte by having the CPU rotate and combine the font data directly, rather than setting up the VGA’s hardware to do it. (Listing 25.1 was designed to illustrate VGA data rotation and bit masking rather than the fastest way to draw text. We’ll see faster text-drawing code soon.) One excellent rule of thumb is to minimize display memory accesses of all types, especially reads, which tend to be considerably slower than writes. Also, in Listing 25.1 it would be faster to use a table lookup to calculate the bit masks for the two halves of each character rather than the shifts used in the example.</p>
<p>For another (and more complex) example of drawing bit-mapped text on the VGA, see John Cockerham’s article, “Pixel Alignment of EGA Fonts,” <em>PC Tech Journal</em>, January, 1987. Parenthetically, I’d like to pass along John’s comment about the VGA: “When programming the VGA, <em>everything</em> is complex.”</p>
<p>He’s got a point there.</p>
</section>
<section id="the-vgas-setreset-circuitry" class="level3">
<h3><a href="#the-vgas-setreset-circuitry">The VGA’s Set/Reset Circuitry</a></h3>
<p>At last we come to the final aspect of data flow through the GC on write mode 0 writes: the set/reset circuitry. Figure 25.3 shows data flow on a write mode 0 write. The only difference between this figure and Figure 25.1 is that on its way to each plane potentially the rotated CPU data passes through the set/reset circuitry, which may or may not replace the CPU data with set/reset data. Briefly put, the set/reset circuitry enables the programmer to elect to independently replace the CPU data for each plane with either 00 or 0FFH.</p>
<p>What is the use of such a feature? Well, the standard way to control color is to set the Map Mask register to enable writes to only those planes that need to be set to produce the desired color. For example, the Map Mask register would be set to 09H to draw in high-intensity blue; here, bits 0 and 3 are set to 1, so only the blue plane (plane 0) and the intensity plane (plane 3) are written to.</p>
<figure>
<img src="images/25-03.jpg" alt="Figure 25.3  Data flow during a write mode 0 write operation." /><figcaption><strong>Figure 25.3</strong>  <em>Data flow during a write mode 0 write operation.</em></figcaption>
</figure>
<p>Remember, though, that planes that are disabled by the Map Mask register are not written to or modified in any way. This means that the above approach works only if the memory being written to is zeroed; if, however, the memory already contains non-zero data, that data will remain in the planes disabled by the Map Mask, and the end result will be that some planes contain the data just written and other planes contain old data. In short, color control using the Map Mask does not force all planes to contain the desired color. In particular, it is not possible to force some planes to zero and other planes to one in a single write with the Map Mask register.</p>
<p>The program in Listing 25.2 illustrates this problem. A green pattern (plane 1 set to 1, planes 0, 2, and 3 set to 0) is first written to display memory. Display memory is then filled with blue (only plane 0 set to 1), with a Map Mask setting of 01H. Where the blue crosses the green, cyan is produced, rather than blue, because the Map Mask register setting of 01H that produces blue leaves the green plane (plane 1) unchanged. In order to generate blue unconditionally, it would be necessary to set the Map Mask register to 0FH, clear memory, and then set the Map Mask register to 01H and fill with blue.</p>
<p><strong>LISTING 25.2 L25-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate operation of Map Mask register when drawing</span>
<span class="co">;  to memory that already contains data.</span>
<span class="co">; By Michael Abrash.</span>
<span class="co">;</span>
stack   <span class="kw">segment</span> para stack ‘STACK<span class="st">&#39;</span>
        <span class="dt">db</span>      <span class="dv">512</span> dup(?)
stack   ends
<span class="co">;</span>
EGA_VIDEO_SEGMENT       <span class="dt">equ</span><span class="bn">     0a000h  </span><span class="co">;EGA display memory segment</span>
<span class="co">;</span>
<span class="co">; EGA register equates.</span>
<span class="co">;</span>
SC_INDEX        <span class="dt">equ</span><span class="bn">     3c4h    </span><span class="co">;SC index register</span>
SC_MAP_MASK     <span class="dt">equ</span>     <span class="dv">2</span>       <span class="co">;SC map mask register</span>
<span class="co">;</span>
<span class="co">; Macro to set indexed register INDEX of SC chip to SETTING.</span>
<span class="co">;</span>
SETSC   macro   INDEX, SETTING
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,INDEX
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,SETTING
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        endm
<span class="co">;</span>
cseg    <span class="kw">segment</span> para public ‘CODE#<span class="dv">146</span><span class="co">;</span>
        assume  <span class="kw">cs</span>:cseg
start   proc    near
<span class="co">;</span>
<span class="co">; Select 640x480 graphics mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,012h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,EGA_VIDEO_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>                   <span class="co">;point to video memory</span>
<span class="co">;</span>
<span class="co">; Draw 24 10-scan-line high horizontal bars in green, 10 scan lines apart.</span>
<span class="co">;</span>
        SETSC   SC_MAP_MASK<span class="bn">,02h         </span><span class="co">;map mask setting enables only</span>
                                        <span class="co">; plane 1, the green plane</span>
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>           <span class="co">;start at beginning of video memory</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ffh</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="dv">24</span>           <span class="co">;# bars to draw</span>
<span class="fu">HorzBarLoop:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">80</span>*<span class="dv">10</span>        <span class="co">;# bytes per horizontal bar</span>
        rep <span class="kw">stosb</span>               <span class="co">;draw bar</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="dv">80</span>*<span class="dv">10</span>        <span class="co">;point to start of next bar</span>
        <span class="kw">dec</span>     <span class="kw">bp</span>
        <span class="kw">jnz</span>     HorzBarLoop
<span class="co">;</span>
<span class="co">; Fill screen with blue, using Map Mask register to enable writes</span>
<span class="co">; to blue plane only.</span>
<span class="co">;</span>
        SETSC   SC_MAP_MASK<span class="bn">,01h         </span><span class="co">;map mask setting enables only</span>
                                        <span class="co">; plane 0, the blue plane</span>
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">80</span>*<span class="dv">480</span>               <span class="co">;# bytes per screen</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ffh</span>
        rep <span class="kw">stosb</span>                       <span class="co">;perform fill (affects only</span>
                                        <span class="co">; plane 0, the blue plane)</span>
<span class="co">;</span>
<span class="co">; Wait for a keystroke.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
<span class="co">; Restore text mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,03h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
<span class="co">; Exit to DOS.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch</span>
        <span class="kw">int</span><span class="bn">     21h</span>
start   endp
cseg    ends
        end     start</code></pre>
<section id="setting-all-planes-to-a-single-color" class="level4">
<h4><a href="#setting-all-planes-to-a-single-color">Setting All Planes to a Single Color</a></h4>
<p>The set/reset circuitry can be used to force some planes to 0-bits and others to 1-bits during a single write, while letting CPU data go to still other planes, and so provides an efficient way to set all planes to a desired color. The set/reset circuitry works as follows:</p>
<p>For each of the bits 0-3 in the Enable Set/Reset register (Graphics Controller register 1) that is 1, the corresponding bit in the Set/Reset register (GC register 0) is extended to a byte (0 or 0FFH) and replaces the CPU data for the corresponding plane. For each of the bits in the Enable Set/Reset register that is 0, the CPU data is used unchanged for that plane (normal operation). For example, if the Enable Set/Reset register is set to 01H and the Set/Reset register is set to 05H, then the CPU data is replaced for plane 0 only (the blue plane), and the value it is replaced with is 0FFH (bit 0 of the Set/Reset register extended to a byte). Note that in this case, bits 1-3 of the Set/Reset register have no effect.</p>
<p>It is important to understand that the set/reset circuitry directly replaces CPU data in Graphics Controller data flow. Refer back to Figure 25.3 to see that the output of the set/reset circuitry passes through (and may be transformed by) the ALU and the bit mask before being written to memory, and even then the Map Mask register must enable the write. When using set/reset, it is generally desirable to set the Map Mask register to enable all planes the set/reset circuitry is controlling, since those memory planes which are disabled by the Map Mask register cannot be modified, and the purpose of enabling set/reset for a plane is to force that plane to be set by the set/reset circuitry.</p>
<p>Listing 25.3 illustrates the use of set/reset to force a specific color to be written. This program is the same as that of Listing 25.2, except that set/reset rather than the Map Mask register is used to control color. The preexisting pattern is completely overwritten this time, because the set/reset circuitry writes 0-bytes to planes that must be off as well as 0FFH-bytes to planes that must be on.</p>
<p><strong>LISTING 25.3 L25-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate operation of set/reset circuitry to force</span>
<span class="co">;  setting of memory that already contains data.</span>
<span class="co">; By Michael Abrash.</span>
<span class="co">;</span>
stack   <span class="kw">segment</span> para stack ‘STACK#<span class="dv">146</span><span class="co">;</span>
        <span class="dt">db</span>      <span class="dv">512</span> dup(?)
stack   ends
<span class="co">;</span>
EGA_VIDEO_SEGMENT       <span class="dt">equ</span><span class="bn">     0a000h  </span><span class="co">;EGA display memory segment</span>
<span class="co">;</span>
<span class="co">; EGA register equates.</span>
<span class="co">;</span>
SC_INDEX        <span class="dt">equ</span><span class="bn">     3c4h    </span><span class="co">;SC index register</span>
SC_MAP_MASK     <span class="dt">equ</span>     <span class="dv">2</span>       <span class="co">;SC map mask register</span>
GC_INDEX        <span class="dt">equ</span><span class="bn">     3ceh    </span><span class="co">;GC index register</span>
GC_SET_RESET    <span class="dt">equ</span>     <span class="dv">0</span>       <span class="co">;GC set/reset register</span>
GC_ENABLE_SET_RESET <span class="dt">equ</span> <span class="dv">1</span>       <span class="co">;GC enable set/reset register</span>
<span class="co">;</span>
<span class="co">; Macro to set indexed register INDEX of SC chip to SETTING.</span>
<span class="co">;</span>
SETSC   macro   INDEX, SETTING
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,INDEX
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,SETTING
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        endm
<span class="co">;</span>
<span class="co">; Macro to set indexed register INDEX of GC chip to SETTING.</span>
<span class="co">;</span>
SETGC   macro   INDEX, SETTING
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,INDEX
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,SETTING
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        endm
<span class="co">;</span>
cseg    <span class="kw">segment</span> para public ‘CODE#<span class="dv">146</span><span class="co">;</span>
        assume  <span class="kw">cs</span>:cseg
start   proc    near
<span class="co">;</span>
<span class="co">; Select 640x480 graphics mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,012h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,EGA_VIDEO_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>                   <span class="co">;point to video memory</span>
<span class="co">;</span>
<span class="co">; Draw 24 10-scan-line high horizontal bars in green, 10 scan lines apart.</span>
<span class="co">;</span>
        SETSC   SC_MAP_MASK<span class="bn">,02h         </span><span class="co">;map mask setting enables only</span>
                                        <span class="co">; plane 1, the green plane</span>
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>           <span class="co">;start at beginning of video memory</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ffh</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="dv">24</span>           <span class="co">;# bars to draw</span>
<span class="fu">HorzBarLoop:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">80</span>*<span class="dv">10</span>        <span class="co">;# bytes per horizontal bar</span>
        rep <span class="kw">stosb</span>               <span class="co">;draw bar</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="dv">80</span>*<span class="dv">10</span>        <span class="co">;point to start of next bar</span>
        <span class="kw">dec</span>     <span class="kw">bp</span>
        <span class="kw">jnz</span>     HorzBarLoop
<span class="co">;</span>
<span class="co">; Fill screen with blue, using set/reset to force plane 0 to 1#146;s and all</span>
<span class="co">; other plane to 0#146;s.</span>
<span class="co">;</span>
        SETSC   SC_MAP_MASK<span class="bn">,0fh         </span><span class="co">;must set map mask to enable all</span>
                                        <span class="co">; planes, so set/reset values can</span>
                                        <span class="co">; be written to memory</span>
        SETGC   GC_ENABLE_SET_RESET<span class="bn">,0fh </span><span class="co">;CPU data to all planes will be</span>
                                        <span class="co">; replaced by set/reset value</span>
        SETGC   GC_SET_RESET<span class="bn">,01h        </span><span class="co">;set/reset value is 0ffh for plane 0</span>
                                        <span class="co">; (the blue plane) and 0 for other</span>
                                        <span class="co">; planes</span>
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">80</span>*<span class="dv">480</span>               <span class="co">;# bytes per screen</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ffh                 </span><span class="co">;since set/reset is enabled for all</span>
                                        <span class="co">; planes, the CPU data is ignored-</span>
                                        <span class="co">; only the act of writing is</span>
                                        <span class="co">; important</span>
        rep <span class="kw">stosb</span>                       <span class="co">;perform fill (affects all planes)</span>
<span class="co">;</span>
<span class="co">; Turn off set/reset.</span>
<span class="co">;</span>
        SETGC   GC_ENABLE_SET_RESET,<span class="dv">0</span>
<span class="co">;</span>
<span class="co">; Wait for a keystroke.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
<span class="co">; Restore text mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,03h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
<span class="co">; Exit to DOS.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch</span>
        <span class="kw">int</span><span class="bn">     21h</span>
start   endp
cseg    ends
        end     start</code></pre>
</section>
<section id="manipulating-planes-individually" class="level4">
<h4><a href="#manipulating-planes-individually">Manipulating Planes Individually</a></h4>
<p>Listing 25.4 illustrates the use of set/reset to control only some, rather than all, planes. Here, the set/reset circuitry forces plane 2 to 1 and planes 0 and 3 to 0. Because bit 1 of the Enable Set/Reset register is 0, however, set/reset does not affect plane 1; the CPU data goes unchanged to the plane 1 ALU. Consequently, the CPU data can be used to control the value written to plane 1. Given the settings of the other three planes, this means that each bit of CPU data that is 1 generates a brown pixel, and each bit that is 0 generates a red pixel. Writing alternating bytes of 07H and 0E0H, then, creates a vertically striped pattern of brown and red.</p>
<p>In Listing 25.4, note that the vertical bars are 10 and 6 bytes wide, and do not start on byte boundaries. Although set/reset replaces an entire byte of CPU data for a plane, the combination of set/reset for some planes and CPU data for other planes, as in the example above, can be used to control individual pixels.</p>
<p><strong>LISTING 25.4 L25-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate operation of set/reset circuitry in conjunction</span>
<span class="co">;  with CPU data to modify setting of memory that already contains data.</span>
<span class="co">; By Michael Abrash.</span>
<span class="co">;</span>
stack   <span class="kw">segment</span> para stack ‘STACK#<span class="dv">146</span><span class="co">;</span>
        <span class="dt">db</span>      <span class="dv">512</span> dup(?)
stack   ends
<span class="co">;</span>
EGA_VIDEO_SEGMENT       <span class="dt">equ</span><span class="bn">     0a000h  </span><span class="co">;EGA display memory segment</span>
<span class="co">;</span>
<span class="co">; EGA register equates.</span>
<span class="co">;</span>
SC_INDEX        <span class="dt">equ</span><span class="bn">     3c4h    </span><span class="co">;SC index register</span>
SC_MAP_MASK     <span class="dt">equ</span>     <span class="dv">2</span>       <span class="co">;SC map mask register</span>
GC_INDEX        <span class="dt">equ</span><span class="bn">     3ceh    </span><span class="co">;GC index register</span>
GC_SET_RESET    <span class="dt">equ</span>     <span class="dv">0</span>       <span class="co">;GC set/reset register</span>
GC_ENABLE_SET_RESET <span class="dt">equ</span> <span class="dv">1</span>       <span class="co">;GC enable set/reset register</span>
<span class="co">;</span>
<span class="co">; Macro to set indexed register INDEX of SC chip to SETTING.</span>
<span class="co">;</span>
SETSC   macro   INDEX, SETTING
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,INDEX
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,SETTING
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        endm
<span class="co">;</span>
<span class="co">; Macro to set indexed register INDEX of GC chip to SETTING.</span>
<span class="co">;</span>
SETGC   macro   INDEX, SETTING
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,INDEX
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,SETTING
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        endm
<span class="co">;</span>
cseg    <span class="kw">segment</span> para public ‘CODE#<span class="dv">146</span><span class="co">;</span>
        assume  <span class="kw">cs</span>:cseg
start   proc    near
<span class="co">;</span>
<span class="co">; Select 640x350 graphics mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,010h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,EGA_VIDEO_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>                   <span class="co">;point to video memory</span>
<span class="co">;</span>
<span class="co">; Draw 18 10-scan-line high horizontal bars in green, 10 scan lines apart.</span>
<span class="co">;</span>
        SETSC   SC_MAP_MASK,02h<span class="co">;map mask setting enables only</span>
<span class="co">; plane 1, the green plane</span>
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span><span class="co">;start at beginning of video memory</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ffh</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="dv">18</span><span class="co">;# bars to draw</span>
<span class="fu">HorzBarLoop:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">80</span>*<span class="dv">10</span><span class="co">;# bytes per horizontal bar</span>
        rep <span class="kw">stosb</span><span class="co">;draw bar</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="dv">80</span>*<span class="dv">10</span><span class="co">;point to start of next bar</span>
        <span class="kw">dec</span>     <span class="kw">bp</span>
        <span class="kw">jnz</span>     HorzBarLoop
<span class="co">;</span>
<span class="co">; Fill screen with alternating bars of red and brown, using CPU data</span>
<span class="co">; to set plane 1 and set/reset to set planes 0, 2 &amp; 3.</span>
<span class="co">;</span>
        SETSC   SC_MAP_MASK<span class="bn">,0fh         </span><span class="co">;must set map mask to enable all</span>
                                        <span class="co">; planes, so set/reset values can</span>
                                        <span class="co">; be written to planes 0, 2 &amp; 3</span>
                                        <span class="co">; and CPU data can be written to</span>
                                        <span class="co">; plane 1 (the green plane)</span>
        SETGC   GC_ENABLE_SET_RESET<span class="bn">,0dh    </span><span class="co">;CPU data to planes 0, 2 &amp; 3 will be</span>
                                           <span class="co">; replaced by set/reset value</span>
        SETGC   GC_SET_RESET<span class="bn">,04h        </span><span class="co">;set/reset value is 0ffh for plane 2</span>
                                        <span class="co">; (the red plane) and 0 for other</span>
                                        <span class="co">; planes</span>
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">80</span>*<span class="dv">350</span>/<span class="dv">2</span>             <span class="co">;# words per screen</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,07e0h                </span><span class="co">;CPU data controls only plane 1;</span>
                                        <span class="co">; set/reset controls other planes</span>
        rep <span class="kw">stosw</span>                       <span class="co">;perform fill (affects all planes)</span>
<span class="co">;</span>
<span class="co">; Turn off set/reset.</span>
<span class="co">;</span>
        SETGC   GC_ENABLE_SET_RESET,<span class="dv">0</span>
<span class="co">;</span>
<span class="co">; Wait for a keystroke.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
<span class="co">; Restore text mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,03h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
<span class="co">; Exit to DOS.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch</span>
        <span class="kw">int</span><span class="bn">     21h</span>
start   endp
cseg    ends
        end     start</code></pre>
<p>There is no clearly defined role for the set/reset circuitry, as there is for, say, the bit mask. In many cases, set/reset is largely interchangeable with CPU data, particularly with CPU data written in write mode 2 (write mode 2 operates similarly to the set/reset circuitry, as we’ll see in Chapter 27). The most powerful use of set/reset, in my experience, is in applications such as the example of Listing 25.4, where it is used to force the value written to certain planes while the CPU data is written to other planes. In general, though, think of set/reset as one more tool you have at your disposal in getting the VGA to do what you need done, in this case a tool that lets you force all bits in each plane to either zero or one, or pass CPU data through unchanged, on each write to display memory. As tools go, set/reset is a handy one, and it’ll pop up often in this book.</p>
</section>
</section>
<section id="notes-on-setreset" class="level3">
<h3><a href="#notes-on-setreset">Notes on Set/Reset</a></h3>
<p>The set/reset circuitry is not active in write modes 1 or 2. The Enable Set/Reset register is inactive in write mode 3, but the Set/Reset register provides the primary drawing color in write mode 3, as discussed in the next chapter.</p>
<blockquote>
<p><img src="images/i.jpg" /> Be aware that because set/reset directly replaces CPU data, it does not necessarily have to force an entire display memory byte to 0 or 0FFH, even when set/reset is replacing CPU data for all planes. For example, if the Bit Mask register is set to 80H, the set/reset circuitry can only modify bit 7 of the destination byte in each plane, since the other seven bits will come from the latches for each plane. Similarly, the set/reset value for each plane can be modified by that plane’s ALU. Once again, this illustrates that set/reset merely replaces the CPU data for selected planes; the set/reset value is then processed in exactly the same way that CPU data normally is.</p>
</blockquote>
</section>
<section id="a-brief-note-on-word-outs" class="level3">
<h3><a href="#a-brief-note-on-word-outs">A Brief Note on Word OUTs</a></h3>
<p>In the early days of the EGA and VGA, there was considerable debate about whether it was safe to do word <code>OUT</code>s (<code>OUT DX,AX</code>) to set Index/Data register pairs in a single instruction. Long ago, there were a few computers with buses that weren’t quite PC-compatatible, in that the two bytes in each word <code>OUT</code> went to the VGA in the wrong order: Data register first, then Index register, with predictably disastrous results. Consequently, I generally wrote my code in those days to use two 8-bit <code>OUT</code>s to set indexed registers. Later on, I made it a habit to use macros that could do either one 16-bit <code>OUT</code> or two 8-bit <code>OUT</code>s, depending on how I chose to assemble the code, and in fact you’ll find both ways of dealing with <code>OUT</code>s sprinkled through the code in this part of the book. Using macros for word OUTs is still not a bad idea in that it does no harm, but in my opinion it’s no longer necessary. Word <code>OUT</code>s are standard now, and it’s been a long time since I’ve heard of them causing any problems.</p>
</section>
</section>
<section id="chapter-26-vga-write-mode-3" class="level2">
<h2><a href="#chapter-26-vga-write-mode-3">Chapter 26 – VGA Write Mode 3</a></h2>
<section id="the-write-mode-that-grows-on-you" class="level3">
<h3><a href="#the-write-mode-that-grows-on-you">The Write Mode That Grows on You</a></h3>
<p>Over the last three chapters, we’ve covered the VGA’s write path from stem to stern—with one exception. Thus far, we’ve only looked at how writes work in write mode 0, the straightforward, workhorse mode in which each byte that the CPU writes to display memory fans out across the four planes. (Actually, we also took a quick look at write mode 1, in which the latches are always copied unmodified, but since exactly the same result can be achieved by setting the Bit Mask register to 0 in write mode 0, write mode 1 is of little real significance.)</p>
<p>Write mode 0 is a very useful mode, but some of VGA’s most interesting capabilities involve the two write modes that we have yet to examine: write mode 1, and, especially, write mode 3. We’ll get to write mode 1 in the next chapter, but right now I want to focus on write mode 3, which can be confusing at first, but turns out to be quite a bit more powerful than one might initially think.</p>
</section>
<section id="a-mode-born-in-strangeness" class="level3">
<h3><a href="#a-mode-born-in-strangeness">A Mode Born in Strangeness</a></h3>
<p>Write mode 3 is strange indeed, and its use is not immediately obvious. The first time I encountered write mode 3, I understood immediately how it functioned, but could think of very few useful applications for it. As time passed, and as I came to understand the atrocious performance characteristics of <code>OUT</code> instructions, and the importance of text and pattern drawing as well, write mode 3 grew considerably in my estimation. In fact, my esteem for this mode ultimately reached the point where in the last major chunk of 16-color graphics code I wrote, write mode 3 was used more than write mode 0 overall, excluding simple pixel copying. So write mode 3 is well worth using, but to use it you must first understand it. Here’s how it works.</p>
<p>In write mode 3, set/reset is automatically enabled for all four planes (the Enable Set/Reset register is ignored). The CPU data byte is rotated and then ANDed with the contents of the Bit Mask register, and the result of this operation is used as the contents of the Bit Mask register alone would normally be used. (If this is Greek to you, have a look back at Chapters 23 through 25. There’s no way to understand write mode 3 without understanding the rest of the VGA’s write data path first.)</p>
<p>That’s what write mode 3 does—but what is it <em>for?</em> It turns out that write mode 3 is excellent for a surprisingly large number of purposes, because it makes it possible to avoid the bane of VGA performance, <code>OUT</code>s. Some uses for write mode 3 include lines, circles, and solid and two-color pattern fills. Most importantly, write mode 3 is ideal for transparent text; that is, it makes it possible to draw text in 16-color graphics mode quickly without wiping out the background in the process. (As we’ll see at the end of this chapter, write mode 3 is potentially terrific for opaque text—text drawn with the character box filled in with a solid color—as well.)</p>
<p>Listing 26.1 is a modification of code I presented in Chapter 25. That code used the data rotate and bit mask features of the VGA to draw bit-mapped text in write mode 0. Listing 26.1 uses write mode 3 in place of the bit mask to draw bit-mapped text, and in the process gains the useful ability to preserve the background into which the text is being drawn. Where the original text-drawing code drew the entire character box for each character, with 0 bits in the font pattern causing a black box to appear around each character, the code in Listing 26.1 affects display memory only when 1 bits in the font pattern are drawn. As a result, the characters appear to be painted into the background, rather than over it. Another advantage of the code in Listing 26.1 is that the characters can be drawn in any of the 16 available colors.</p>
<p><strong>LISTING 26.1 L26-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate operation of write mode 3 of the VGA.</span>
<span class="co">;  Draws 8x8 characters at arbitrary locations without disturbing</span>
<span class="co">;  the background, using VGA&#39;s 8x8 ROM font.  Designed</span>
<span class="co">;  for use with modes 0Dh, 0Eh, 0Fh, 10h, and 12h.</span>
<span class="co">; Runs only on VGAs (in Models 50 &amp; up and IBM Display Adapter</span>
<span class="co">;  and 100% compatibles).</span>
<span class="co">; Assembled with MASM</span>
<span class="co">; By Michael Abrash</span>
<span class="co">;</span>
stack   <span class="kw">segment</span> para stack ‘STACK<span class="st">&#39;</span>
        <span class="dt">db</span>      <span class="dv">512</span> dup(?)
stack   ends
<span class="co">;</span>
VGA_VIDEO_SEGMENT       <span class="dt">equ</span><span class="bn">     0a000h  </span><span class="co">;VGA display memory segment</span>
SCREEN_WIDTH_IN_BYTES   <span class="dt">equ</span><span class="bn">     044ah   </span><span class="co">;offset of BIOS variable</span>
FONT_CHARACTER_SIZE     <span class="dt">equ</span>     <span class="dv">8</span>       <span class="co">;# bytes in each font char</span>
<span class="co">;</span>
<span class="co">; VGA register equates.</span>
<span class="co">;</span>
SC_INDEX        <span class="dt">equ</span><span class="bn">     3c4h    </span><span class="co">;SC index register</span>
SC_MAP_MASK     <span class="dt">equ</span>     <span class="dv">2</span>       <span class="co">;SC map mask register index</span>
GC_INDEX        <span class="dt">equ</span><span class="bn">     3ceh    </span><span class="co">;GC index register</span>
GC_SET_RESET    <span class="dt">equ</span>     <span class="dv">0</span>       <span class="co">;GC set/reset register index</span>
GC_ENABLE_SET_RESET <span class="dt">equ</span> <span class="dv">1</span>       <span class="co">;GC enable set/reset register index</span>
GC_ROTATE       <span class="dt">equ</span>     <span class="dv">3</span>       <span class="co">;GC data rotate/logical function</span>
                                <span class="co">; register index</span>
GC_MODE         <span class="dt">equ</span>     <span class="dv">5</span>       <span class="co">;GC Mode register</span>
GC_BIT_MASK     <span class="dt">equ</span>     <span class="dv">8</span>       <span class="co">;GC bit mask register index</span>
<span class="co">;</span>
dseg    <span class="kw">segment</span> para <span class="kw">common</span> ‘DATA<span class="st">&#39;</span>
TEST_TEXT_ROW   <span class="dt">equ</span>     <span class="dv">69</span>      <span class="co">;row to display test text at</span>
TEST_TEXT_COL   <span class="dt">equ</span>     <span class="dv">17</span>      <span class="co">;column to display test text at</span>
TEST_TEXT_WIDTH <span class="dt">equ</span>     <span class="dv">8</span>       <span class="co">;width of a character in pixels</span>
TestString      label   <span class="dt">byte</span>
        <span class="dt">db</span>      ‘Hello, world!<span class="st">&#39;,0       ;test string to print.</span>
FontPointer     <span class="dt">dd</span>      ?               <span class="co">;font offset</span>
dseg    ends
<span class="co">;</span>
cseg    <span class="kw">segment</span> para public ‘CODE<span class="st">&#39;</span>
        assume  <span class="kw">cs</span>:cseg, <span class="kw">ds</span>:dseg
start   proc    near
        <span class="kw">mov</span>     <span class="kw">ax</span>,dseg
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Select 640x480 graphics mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,012h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
<span class="co">; Set the screen to all blue, using the readability of VGA registers</span>
<span class="co">; to preserve reserved bits.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_SET_RESET
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,0f0h</span>
        <span class="kw">or</span>      <span class="kw">al</span>,<span class="dv">1</span>                <span class="co">;blue plane only set, others reset</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_ENABLE_SET_RESET
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,0f0h</span>
        <span class="kw">or</span>      <span class="kw">al</span><span class="bn">,0fh              </span><span class="co">;enable set/reset for all planes</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,VGA_VIDEO_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">dx</span>               <span class="co">;point to display memory</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="dv">0</span>
        <span class="kw">mov</span>     <span class="kw">cx</span><span class="bn">,8000h            </span><span class="co">;fill all 32k words</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0ffffh           </span><span class="co">;because of set/reset, the value</span>
                                    <span class="co">; written actually doesn&#39;t matter</span>
        rep <span class="kw">stosw</span>                   <span class="co">;fill with blue</span>
<span class="co">;</span>
<span class="co">; Set driver to use the 8x8 font.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,11h          </span><span class="co">;VGA BIOS character generator function,</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,30h          </span><span class="co">; return info subfunction</span>
        <span class="kw">mov</span>     <span class="kw">bh</span>,<span class="dv">3</span>            <span class="co">;get 8x8 font pointer</span>
        <span class="kw">int</span><span class="bn">     10h</span>
        <span class="kw">call</span>    SelectFont
<span class="co">;</span>
<span class="co">; Print the test string, cycling through colors.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,offset TestString
        <span class="kw">mov</span>     <span class="kw">bx</span>,TEST_TEXT_ROW
        <span class="kw">mov</span>     <span class="kw">cx</span>,TEST_TEXT_COL
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">0</span>                <span class="co">;start with color 0</span>
<span class="fu">StringOutLoop:</span>
        <span class="kw">lodsb</span>
        <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">al</span>
        <span class="kw">jz</span>      StringOutDone
        <span class="kw">push</span>    <span class="kw">ax</span>                  <span class="co">;preserve color</span>
        <span class="kw">call</span>    DrawChar
        <span class="kw">pop</span>     <span class="kw">ax</span>                  <span class="co">;restore color</span>
        <span class="kw">inc</span>     <span class="kw">ah</span>                  <span class="co">;next color</span>
        <span class="kw">and</span>     <span class="kw">ah</span><span class="bn">,0fh              </span><span class="co">;colors range from 0 to 15</span>
        <span class="kw">add</span>     <span class="kw">cx</span>,TEST_TEXT_WIDTH
        <span class="kw">jmp</span>     StringOutLoop
<span class="fu">StringOutDone:</span>
<span class="co">;</span>
<span class="co">; Wait for a key, then set to text mode &amp; end.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">int</span><span class="bn">     21h             </span><span class="co">;wait for a key</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dv">3</span>
        <span class="kw">int</span><span class="bn">     10h             </span><span class="co">;restore text mode</span>
<span class="co">;</span>
<span class="co">; Exit to DOS.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch</span>
        <span class="kw">int</span><span class="bn">     21h</span>
Start   endp
<span class="co">;</span>
<span class="co">; Subroutine to draw a text character in a linear graphics mode</span>
<span class="co">;  (0Dh, 0Eh, 0Fh, 010h, 012h). Background around the pixels that</span>
<span class="co">;  make up the character is preserved.</span>
<span class="co">; Font used should be pointed to by FontPointer.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;  AL = character to draw</span>
<span class="co">;  AH = color to draw character in (0-15)</span>
<span class="co">;  BX = row to draw text character at</span>
<span class="co">;  CX = column to draw text character at</span>
<span class="co">;</span>
<span class="co">;  Forces ALU function to &quot;move&quot;.</span>
<span class="co">;  Forces write mode 3.</span>
<span class="co">;</span>
DrawChar        proc    near
        <span class="kw">push</span>    <span class="kw">ax</span>
        <span class="kw">push</span>    <span class="kw">bx</span>
        <span class="kw">push</span>    <span class="kw">cx</span>
        <span class="kw">push</span>    <span class="kw">dx</span>
        <span class="kw">push</span>    <span class="kw">si</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">push</span>    <span class="kw">bp</span>
        <span class="kw">push</span>    <span class="kw">ds</span>
        <span class="kw">push</span>    <span class="kw">ax</span>      <span class="co">;preserve character to draw in AL</span>
<span class="co">;</span>
<span class="co">; Set up set/reset to produce character color, using the readability</span>
<span class="co">; of VGA register to preserve the setting of reserved bits 7-4.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_SET_RESET
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,0f0h</span>
        <span class="kw">and</span>     <span class="kw">ah</span><span class="bn">,0fh</span>
        <span class="kw">or</span>      <span class="kw">al</span>,<span class="kw">ah</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Select write mode 3, using the readability of VGA registers</span>
<span class="co">; to leave bits other than the write mode bits unchanged.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_MODE
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">or</span>      <span class="kw">al</span>,<span class="dv">3</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Set DS:SI to point to font and ES to point to display memory.</span>
<span class="co">;</span>
        <span class="kw">lds</span>     <span class="kw">si</span>,[FontPointer]        <span class="co">;point to font</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,VGA_VIDEO_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">dx</span>                   <span class="co">;point to display memory</span>
<span class="co">;</span>
<span class="co">; Calculate screen address of byte character starts in.</span>
<span class="co">;</span>
        <span class="kw">pop</span>     <span class="kw">ax</span>              <span class="co">;get back character to draw in AL</span>

        <span class="kw">push</span>    <span class="kw">ds</span>              <span class="co">;point to BIOS data segment</span>
        <span class="kw">sub</span>     <span class="kw">dx</span>,<span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">dx</span>
        <span class="kw">xchg</span>    <span class="kw">ax</span>,<span class="kw">bx</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">ds</span>:[SCREEN_WIDTH_IN_BYTES]   <span class="co">;retrieve BIOS</span>
                                                <span class="co">; screen width</span>
        <span class="kw">pop</span>     <span class="kw">ds</span>
        <span class="kw">mul</span>     <span class="kw">di</span>              <span class="co">;calculate offset of start of row</span>
        <span class="kw">push</span>    <span class="kw">di</span>              <span class="co">;set aside screen width</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">cx</span>           <span class="co">;set aside the column</span>
        <span class="kw">and</span>     <span class="kw">cl</span><span class="bn">,0111b        </span><span class="co">;keep only the column in-byte address</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>            <span class="co">;divide column by 8 to make a byte address</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>           <span class="co">;and point to byte</span>
<span class="co">;</span>
<span class="co">; Calculate font address of character.</span>
<span class="co">;</span>
        <span class="kw">sub</span>     <span class="kw">bh</span>,<span class="kw">bh</span>
        <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>            <span class="co">;assumes 8 bytes per character; use</span>
        <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>            <span class="co">; a multiply otherwise</span>
        <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>            <span class="co">;offset in font of character</span>
        <span class="kw">add</span>     <span class="kw">si</span>,<span class="kw">bx</span>           <span class="co">;offset in font segment of character</span>
<span class="co">;</span>
<span class="co">; Set up the GC rotation. In write mode 3, this is the rotation</span>
<span class="co">; of CPU data before it is ANDed with the Bit Mask register to</span>
<span class="co">; form the bit mask. Force the ALU function to &quot;move&quot;. Uses the</span>
<span class="co">; readability of VGA registers to leave reserved bits unchanged.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_ROTATE
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,0e0h</span>
        <span class="kw">or</span>      <span class="kw">al</span>,<span class="kw">cl</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Set up BH as bit mask for left half, BL as rotation for right half.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">bx</span><span class="bn">,0ffffh</span>
        <span class="kw">shr</span>     <span class="kw">bh</span>,<span class="kw">cl</span>
        <span class="kw">neg</span>     <span class="kw">cl</span>
        <span class="kw">add</span>     <span class="kw">cl</span>,<span class="dv">8</span>
        <span class="kw">shl</span>     <span class="kw">bl</span>,<span class="kw">cl</span>
<span class="co">;</span>
<span class="co">; Draw the character, left half first, then right half in the</span>
<span class="co">; succeeding byte, using the data rotation to position the character</span>
<span class="co">; across the byte boundary and then using write mode 3 to combine the</span>
<span class="co">; character data with the bit mask to allow the set/reset value (the</span>
<span class="co">; character color) through only for the proper portion (where the</span>
<span class="co">; font bits for the character are 1) of the character for each byte.</span>
<span class="co">; Wherever the font bits for the character are 0, the background</span>
<span class="co">; color is preserved.</span>
<span class="co">; Does not check for case where character is byte-aligned and</span>
<span class="co">; no rotation and only one write is required.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,FONT_CHARACTER_SIZE
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">pop</span>     <span class="kw">cx</span>              <span class="co">;get back screen width</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>              <span class="co">; -2 because do two bytes for each char</span>
<span class="fu">CharacterLoop:</span>
<span class="co">;</span>
<span class="co">; Set the bit mask for the left half of the character.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_BIT_MASK
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">bh</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Get the next character byte &amp; write it to display memory.</span>
<span class="co">; (Left half of character.)</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,[<span class="kw">si</span>]         <span class="co">;get character byte</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">es</span>:[<span class="kw">di</span>]      <span class="co">;load latches</span>
        <span class="kw">stosb</span>                   <span class="co">;write character byte</span>
<span class="co">;</span>
<span class="co">; Set the bit mask for the right half of the character.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_BIT_MASK
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">bl</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Get the character byte again &amp; write it to display memory.</span>
<span class="co">; (Right half of character.)</span>
<span class="co">;</span>
        <span class="kw">lodsb</span>                   <span class="co">;get character byte</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">es</span>:[<span class="kw">di</span>]      <span class="co">;load latches</span>
        <span class="kw">stosb</span>                   <span class="co">;write character byte</span>
<span class="co">;</span>
<span class="co">; Point to next line of character in display memory.</span>
<span class="co">;</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">cx</span>
<span class="co">;</span>
        <span class="kw">dec</span>     <span class="kw">bp</span>
        <span class="kw">jnz</span>     CharacterLoop
<span class="co">;</span>
        <span class="kw">pop</span>     <span class="kw">ds</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>
        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">dx</span>
        <span class="kw">pop</span>     <span class="kw">cx</span>
        <span class="kw">pop</span>     <span class="kw">bx</span>
        <span class="kw">pop</span>     <span class="kw">ax</span>
        <span class="kw">ret</span>
DrawChar        endp
<span class="co">;</span>
<span class="co">; Set the pointer to the font to draw from to ES:BP.</span>
<span class="co">;</span>
SelectFont      proc    near
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [FontPointer],<span class="kw">bp</span>       <span class="co">;save pointer</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [FontPointer<span class="dv">+2</span>],<span class="kw">es</span>
        <span class="kw">ret</span>
SelectFont      endp
<span class="co">;</span>
cseg    ends
        end     start</code></pre>
<p>The key to understanding Listing 26.1 is understanding the effect of ANDing the rotated CPU data with the contents of the Bit Mask register. The CPU data is the pattern for the character to be drawn, with bits equal to 1 indicating where character pixels are to appear. The Data Rotate register is set to rotate the CPU data to pixel-align it, since without rotation characters could only be drawn on byte boundaries.</p>
<blockquote>
<p><img src="images/i.jpg" /> As I pointed out in Chapter 25, the CPU is perfectly capable of rotating the data itself, and it’s often the case that that’s more efficient. The problem with using the Data Rotate register is that the <code>OUT</code> that sets that register is time-consuming, especially for proportional text, which requires a different rotation for each character. Also, if the code performs full-byte accesses to display memory—that is, if it combines pieces of two adjacent characters into one byte—whenever possible for efficiency, the CPU generally has to do extra work to prepare the data so the VGA’s rotator can handle it.</p>
</blockquote>
<p>At the same time that the Data Rotate register is set, the Bit Mask register is set to allow the CPU to modify only that portion of the display memory byte accessed that the pixel-aligned character falls in, so that other characters and/or graphics data won’t be wiped out. The result of ANDing the rotated CPU data byte with the contents of the Bit Mask register is a bit mask that allows only the bits equal to 1 in the original character pattern (rotated and masked to provide pixel alignment) to be modified by the CPU; all other bits come straight from the latches. The latches should have previously been loaded from the target address, so the effect of the ultimate synthesized bit mask value is to allow the CPU to modify only those pixels in display memory that correspond to the 1 bits in that part of the pixel-aligned character that falls in the currently addressed byte. The color of the pixels set by the CPU is determined by the contents of the Set/Reset register.</p>
<p>Whew. It sounds complex, but given an understanding of what the data rotator, set/reset, and the bit mask do, it’s not that bad. One good way to make sense of it is to refer to the original text-drawing program in Listing 25.1 back in Chapter 25, and then see how Listing 26.1 differs from that program.</p>
<p>It’s worth noting that the results generated by Listing 26.1 could have been accomplished without write mode 3. Write mode 0 could have been used instead, but at a significant performance cost. Instead of letting write mode 3 rotate the CPU data and AND it with the contents of the Bit Mask register, the CPU could simply have rotated the CPU data directly and ANDed it with the value destined for the Bit Mask register and then set the Bit Mask register to the resulting value. Additionally, enable set/reset could have been forced on for all planes, emulating what write mode 3 does to provide pixel colors.</p>
<p>The write mode 3 approach used in Listing 26.1 can be efficiently extended to drawing large blocks of text. For example, suppose that we were to draw a line of 8-pixel-wide bit-mapped text 40 characters long. We could then set up the bit mask and data rotation as appropriate for the left portion of each bit-aligned character (the portion of each character to the left of the byte boundary) and then draw the left portions only of all 40 characters in write mode 3. Then the bit mask could be set up for the right portion of each character, and the right portions of all 40 characters could be drawn. The VGA’s fast rotator would be used to do all rotation, and the only <code>OUT</code>s required would be those required to set the bit mask and data rotation. This technique could well outperform single-character bit-mapped text drivers such as the one in Listing 26.1 by a significant margin. Listing 26.2 illustrates one implementation of such an approach. Incidentally, note the use of the 8x14 ROM font in Listing 26.2, rather than the 8x8 ROM font used in Listing 26.1. There is also an 8x16 font stored in ROM, along with the tables used to alter the 8x14 and 8x16 ROM fonts into 9x14 and 9x16 fonts.</p>
<p><strong>LISTING 26.2 L26-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate high-speed text-drawing operation of</span>
<span class="co">;  write mode 3 of the VGA.</span>
<span class="co">;  Draws a string of 8x14 characters at arbitrary locations</span>
<span class="co">;  without disturbing the background, using VGA&#39;s 8x14 ROM font.</span>
<span class="co">;  Designed for use with modes 0Dh, 0Eh, 0Fh, 10h, and 12h.</span>
<span class="co">; Runs only on VGAs (in Models 50 &amp; up and IBM Display Adapter</span>
<span class="co">;  and 100% compatibles).</span>
<span class="co">; Assembled with MASM</span>
<span class="co">; By Michael Abrash</span>
<span class="co">;</span>
stack   <span class="kw">segment</span> para stack ‘STACK<span class="st">&#39;</span>
        <span class="dt">db</span>      <span class="dv">512</span> dup(?)
stack   ends
<span class="co">;</span>
VGA_VIDEO_SEGMENT       <span class="dt">equ</span><span class="bn">     0a000h      </span><span class="co">;VGA display memory segment</span>
SCREEN_WIDTH_IN_BYTES   <span class="dt">equ</span><span class="bn">     044ah       </span><span class="co">;offset of BIOS variable</span>
FONT_CHARACTER_SIZE     <span class="dt">equ</span>     <span class="dv">14</span>          <span class="co">;# bytes in each font char</span>
<span class="co">;</span>
<span class="co">; VGA register equates.</span>
<span class="co">;</span>
SC_INDEX                <span class="dt">equ</span><span class="bn">     3c4h        </span><span class="co">;SC index register</span>
SC_MAP_MASK             <span class="dt">equ</span>     <span class="dv">2</span>           <span class="co">;SC map mask register index</span>
GC_INDEX                <span class="dt">equ</span><span class="bn">     3ceh        </span><span class="co">;GC index register</span>
GC_SET_RESET            <span class="dt">equ</span>     <span class="dv">0</span>           <span class="co">;GC set/reset register index</span>
GC_ENABLE_SET_RESET     <span class="dt">equ</span>     <span class="dv">1</span>           <span class="co">;GC enable set/reset register index</span>
GC_ROTATE               <span class="dt">equ</span>     <span class="dv">3</span>           <span class="co">;GC data rotate/logical function</span>
                                            <span class="co">; register index</span>
GC_MODE                 <span class="dt">equ</span>     <span class="dv">5</span>           <span class="co">;GC Mode register</span>
GC_BIT_MASK             <span class="dt">equ</span>     <span class="dv">8</span>           <span class="co">;GC bit mask register index</span>
<span class="co">;</span>
dseg    <span class="kw">segment</span> para <span class="kw">common</span> ‘DATA<span class="st">&#39;</span>
TEST_TEXT_ROW           <span class="dt">equ</span>     <span class="dv">69</span>          <span class="co">;row to display test text at</span>
TEST_TEXT_COL           <span class="dt">equ</span>     <span class="dv">17</span>          <span class="co">;column to display test text at</span>
TEST_TEXT_COLOR         <span class="dt">equ</span><span class="bn">     0fh         </span><span class="co">;high intensity white</span>
TestString      label   <span class="dt">byte</span>
        <span class="dt">db</span>      ‘Hello, world!<span class="st">&#39;,0           ;test string to print.</span>
FontPointer     <span class="dt">dd</span>      ?                   <span class="co">;font offset</span>
dseg    ends
<span class="co">;</span>
cseg    <span class="kw">segment</span> para public ‘CODE<span class="st">&#39;</span>
        assume  <span class="kw">cs</span>:cseg, <span class="kw">ds</span>:dseg
start   proc    near
        <span class="kw">mov</span>     <span class="kw">ax</span>,dseg
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Select 640x480 graphics mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,012h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
<span class="co">; Set the screen to all blue, using the readability of VGA registers</span>
<span class="co">; to preserve reserved bits.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_SET_RESET
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,0f0h</span>
        <span class="kw">or</span>      <span class="kw">al</span>,<span class="dv">1</span>                <span class="co">;blue plane only set, others reset</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_ENABLE_SET_RESET
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,0f0h</span>
        <span class="kw">or</span>      <span class="kw">al</span><span class="bn">,0fh              </span><span class="co">;enable set/reset for all planes</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,VGA_VIDEO_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">dx</span>               <span class="co">;point to display memory</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="dv">0</span>
        <span class="kw">mov</span>     <span class="kw">cx</span><span class="bn">,8000h            </span><span class="co">;fill all 32k words</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0ffffh           </span><span class="co">;because of set/reset, the value</span>
                                    <span class="co">; written actually doesn&#39;t matter</span>
        rep <span class="kw">stosw</span>                   <span class="co">;fill with blue</span>
<span class="co">;</span>
<span class="co">; Set driver to use the 8x14 font.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,11h          </span><span class="co">;VGA BIOS character generator function,</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,30h          </span><span class="co">; return info subfunction</span>
        <span class="kw">mov</span>     <span class="kw">bh</span>,<span class="dv">2</span>            <span class="co">;get 8x14 font pointer</span>
        <span class="kw">int</span><span class="bn">     10h</span>
        <span class="kw">call</span>    SelectFont
<span class="co">;</span>
<span class="co">; Print the test string.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,offset TestString
        <span class="kw">mov</span>     <span class="kw">bx</span>,TEST_TEXT_ROW
        <span class="kw">mov</span>     <span class="kw">cx</span>,TEST_TEXT_COL
        <span class="kw">mov</span>     <span class="kw">ah</span>,TEST_TEXT_COLOR
        <span class="kw">call</span>    DrawString
<span class="co">;</span>
<span class="co">; Wait for a key, then set to text mode &amp; end.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">int</span><span class="bn">     21h             </span><span class="co">;wait for a key</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dv">3</span>
        <span class="kw">int</span><span class="bn">     10h             </span><span class="co">;restore text mode</span>
<span class="co">;</span>
<span class="co">; Exit to DOS.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch</span>
        <span class="kw">int</span><span class="bn">     21h</span>
Start   endp
<span class="co">;</span>
<span class="co">; Subroutine to draw a text string left-to-right in a linear</span>
<span class="co">;  graphics mode (0Dh, 0Eh, 0Fh, 010h, 012h) with 8-dot-wide</span>
<span class="co">;  characters. Background around the pixels that make up the</span>
<span class="co">;  characters is preserved.</span>
<span class="co">; Font used should be pointed to by FontPointer.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;  AH = color to draw string in</span>
<span class="co">;  BX = row to draw string on</span>
<span class="co">;  CX = column to start string at</span>
<span class="co">;  DS:SI = string to draw</span>
<span class="co">;</span>
<span class="co">;  Forces ALU function to &quot;move&quot;.</span>
<span class="co">;  Forces write mode 3.</span>
<span class="co">;</span>
DrawString      proc    near
        <span class="kw">push</span>    <span class="kw">ax</span>
        <span class="kw">push</span>    <span class="kw">bx</span>
        <span class="kw">push</span>    <span class="kw">cx</span>
        <span class="kw">push</span>    <span class="kw">dx</span>
        <span class="kw">push</span>    <span class="kw">si</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">push</span>    <span class="kw">bp</span>
        <span class="kw">push</span>    <span class="kw">ds</span>
<span class="co">;</span>
<span class="co">; Set up set/reset to produce character color, using the readability</span>
<span class="co">; of VGA register to preserve the setting of reserved bits 7-4.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_SET_RESET
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,0f0h</span>
        <span class="kw">and</span>     <span class="kw">ah</span><span class="bn">,0fh</span>
        <span class="kw">or</span>      <span class="kw">al</span>,<span class="kw">ah</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Select write mode 3, using the readability of VGA registers</span>
<span class="co">; to leave bits other than the write mode bits unchanged.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_MODE
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">or</span>      <span class="kw">al</span>,<span class="dv">3</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,VGA_VIDEO_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">dx</span>                   <span class="co">;point to display memory</span>
<span class="co">;</span>
<span class="co">; Calculate screen address of byte character starts in.</span>
<span class="co">;</span>
        <span class="kw">push</span>    <span class="kw">ds</span>              <span class="co">;point to BIOS data segment</span>
        <span class="kw">sub</span>     <span class="kw">dx</span>,<span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">ds</span>:[SCREEN_WIDTH_IN_BYTES]   <span class="co">;retrieve BIOS</span>
                                                <span class="co">; screen width</span>
        <span class="kw">pop</span>     <span class="kw">ds</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">bx</span>           <span class="co">;row</span>
        <span class="kw">mul</span>     <span class="kw">di</span>              <span class="co">;calculate offset of start of row</span>
        <span class="kw">push</span>    <span class="kw">di</span>              <span class="co">;set aside screen width</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">cx</span>           <span class="co">;set aside the column</span>
        <span class="kw">and</span>     <span class="kw">cl</span><span class="bn">,0111b        </span><span class="co">;keep only the column in-byte address</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>            <span class="co">;divide column by 8 to make a byte address</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>           <span class="co">;and point to byte</span>
<span class="co">;</span>
<span class="co">; Set up the GC rotation. In write mode 3, this is the rotation</span>
<span class="co">; of CPU data before it is ANDed with the Bit Mask register to</span>
<span class="co">; form the bit mask. Force the ALU function to &quot;move&quot;. Uses the</span>
<span class="co">; readability of VGA registers to leave reserved bits unchanged.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_ROTATE
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,0e0h</span>
        <span class="kw">or</span>      <span class="kw">al</span>,<span class="kw">cl</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Set up BH as bit mask for left half, BL as rotation for right half.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">bx</span><span class="bn">,0ffffh</span>
        <span class="kw">shr</span>     <span class="kw">bh</span>,<span class="kw">cl</span>
        <span class="kw">neg</span>     <span class="kw">cl</span>
        <span class="kw">add</span>     <span class="kw">cl</span>,<span class="dv">8</span>
        <span class="kw">shl</span>     <span class="kw">bl</span>,<span class="kw">cl</span>
<span class="co">;</span>
<span class="co">; Draw all characters, left portion first, then right portion in the</span>
<span class="co">; succeeding byte, using the data rotation to position the character</span>
<span class="co">; across the byte boundary and then using write mode 3 to combine the</span>
<span class="co">; character data with the bit mask to allow the set/reset value (the</span>
<span class="co">; character color) through only for the proper portion (where the</span>
<span class="co">; font bits for the character are 1) of the character for each byte.</span>
<span class="co">; Wherever the font bits for the character are 0, the background</span>
<span class="co">; color is preserved.</span>
<span class="co">; Does not check for case where character is byte-aligned and</span>
<span class="co">; no rotation and only one write is required.</span>
<span class="co">;</span>
<span class="co">; Draw the left portion of each character in the string.</span>
<span class="co">;</span>
        <span class="kw">pop</span>     <span class="kw">cx</span>              <span class="co">;get back screen width</span>
        <span class="kw">push</span>    <span class="kw">si</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">push</span>    <span class="kw">bx</span>
<span class="co">;</span>
<span class="co">; Set the bit mask for the left half of the character.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_BIT_MASK
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">bh</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>
<span class="fu">LeftHalfLoop:</span>
        <span class="kw">lodsb</span>
        <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">al</span>
        <span class="kw">jz</span>      LeftHalfLoopDone
        <span class="kw">call</span>    CharacterUp
        <span class="kw">inc</span>     <span class="kw">di</span>              <span class="co">;point to next character location</span>
        <span class="kw">jmp</span>     LeftHalfLoop
<span class="fu">LeftHalfLoopDone:</span>
        <span class="kw">pop</span>     <span class="kw">bx</span>
        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
<span class="co">;</span>
<span class="co">; Draw the right portion of each character in the string.</span>
<span class="co">;</span>
        <span class="kw">inc</span>     <span class="kw">di</span>              <span class="co">;right portion of each character is across</span>
                                <span class="co">; byte boundary</span>
<span class="co">;</span>
<span class="co">; Set the bit mask for the right half of the character.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GC_BIT_MASK
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">bl</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>
<span class="fu">RightHalfLoop:</span>
        <span class="kw">lodsb</span>
        <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">al</span>
        <span class="kw">jz</span>      RightHalfLoopDone
        <span class="kw">call</span>    CharacterUp
        <span class="kw">inc</span>     <span class="kw">di</span>              <span class="co">;point to next character location</span>
        <span class="kw">jmp</span>     RightHalfLoop
<span class="fu">RightHalfLoopDone:</span>
<span class="co">;</span>
        <span class="kw">pop</span>     <span class="kw">ds</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>
        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">dx</span>
        <span class="kw">pop</span>     <span class="kw">cx</span>
        <span class="kw">pop</span>     <span class="kw">bx</span>
        <span class="kw">pop</span>     <span class="kw">ax</span>
        <span class="kw">ret</span>
DrawString      endp
<span class="co">;</span>
<span class="co">; Draw a character.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;  AL = character</span>
<span class="co">;  CX = screen width</span>
<span class="co">;  ES:DI = address to draw character at</span>
<span class="co">;</span>
CharacterUp     proc    near
        <span class="kw">push</span>    <span class="kw">cx</span>
        <span class="kw">push</span>    <span class="kw">si</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">push</span>    <span class="kw">ds</span>
<span class="co">;</span>
<span class="co">; Set DS:SI to point to font and ES to point to display memory.</span>
<span class="co">;</span>
        <span class="kw">lds</span>     <span class="kw">si</span>,[FontPointer]        <span class="co">;point to font</span>
<span class="co">;</span>
<span class="co">; Calculate font address of character.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,<span class="dv">14</span>           <span class="co">;14 bytes per character</span>
        <span class="kw">mul</span>     <span class="kw">bl</span>
        <span class="kw">add</span>     <span class="kw">si</span>,<span class="kw">ax</span>           <span class="co">;offset in font segment of character</span>

        <span class="kw">mov</span>     <span class="kw">bp</span>,FONT_CHARACTER_SIZE
        <span class="kw">dec</span>     <span class="kw">cx</span>              <span class="co">; -1 because one byte per char</span>
<span class="fu">CharacterLoop:</span>
        <span class="kw">lodsb</span>                   <span class="co">;get character byte</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">es</span>:[<span class="kw">di</span>]      <span class="co">;load latches</span>
        <span class="kw">stosb</span>                   <span class="co">;write character byte</span>
<span class="co">;</span>
<span class="co">; Point to next line of character in display memory.</span>
<span class="co">;</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">cx</span>
<span class="co">;</span>
        <span class="kw">dec</span>     <span class="kw">bp</span>
        <span class="kw">jnz</span>     CharacterLoop
<span class="co">;</span>
        <span class="kw">pop</span>     <span class="kw">ds</span>
        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">cx</span>
        <span class="kw">ret</span>
CharacterUp     endp
<span class="co">;</span>
<span class="co">; Set the pointer to the font to draw from to ES:BP.</span>
<span class="co">;</span>
SelectFont      proc    near
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [FontPointer],<span class="kw">bp</span>       <span class="co">;save pointer</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [FontPointer<span class="dv">+2</span>],<span class="kw">es</span>
        <span class="kw">ret</span>
SelectFont      endp
<span class="co">;</span>
cseg    ends
        end     start</code></pre>
<p>In this chapter, I’ve tried to give you a feel for how write mode 3 works and what it might be used for, rather than providing polished, optimized, plug-it-in-and-go code. Like the rest of the VGA’s write path, write mode 3 is a resource that can be used in a remarkable variety of ways, and I don’t want to lock you into thinking of it as useful in just one context. Instead, you should take the time to thoroughly understand what write mode 3 does, and then, when you do VGA programming, think about how write mode 3 can best be applied to the task at hand. Because I focused on illustrating the operation of write mode 3, neither listing in this chapter is the fastest way to accomplish the desired result. For example, Listing 26.2 could be made nearly twice as fast by simply having the CPU rotate, mask, and join the bytes from adjacent characters, then draw the combined bytes to display memory in a single operation.</p>
<p>Similarly, Listing 26.1 is designed to illustrate write mode 3 and its interaction with the rest of the VGA as a contrast to Listing 25.1 in Chapter 25, rather than for maximum speed, and it could be made considerably more efficient. If we were going for performance, we’d have the CPU not only rotate the bytes into position, but also do the masking by ANDing in software. Even more significantly, we would have the CPU combine adjacent characters into complete, rotated bytes whenever possible, so that only one drawing operation would be required per byte of display memory modified. By doing this, we would eliminate all per-character <code>OUT</code>s, and would minimize display memory accesses, approximately doubling text-drawing speed.</p>
<p>As a final note, consider that non-transparent text could also be accelerated with write mode 3. The latches could be filled with the background (text box) color, set/reset could be set to the foreground (text) color, and write mode 3 could then be used to turn monochrome text bytes written by the CPU into characters on the screen with just one write per byte. There are complications, such as drawing partial bytes, and rotating the bytes to align the characters, which we’ll revisit later on in Chapter 55, while we’re working through the details of the X-Sharp library. Nonetheless, the performance benefit of this approach can be a speedup of as much as four times—all thanks to the decidedly quirky but surprisingly powerful and flexible write mode 3.</p>
</section>
<section id="a-note-on-preserving-register-bits" class="level3">
<h3><a href="#a-note-on-preserving-register-bits">A Note on Preserving Register Bits</a></h3>
<p>If you take a quick look, you’ll see that the code in Listing 26.1 uses the readable register feature of the VGA to preserve reserved bits and bits other than those being modified. Older adapters such as the CGA and EGA had few readable registers, so it was necessary to set all bits in a register whenever that register was modified. Happily, all VGA registers are readable, which makes it possible to change only those bits of immediate interest, and, in general, I highly recommend doing exactly that, since IBM (or clone manufacturers) may well someday use some of those reserved bits or change the meanings of some of the bits that are currently in use.</p>
</section>
</section>
<section id="chapter-27-yet-another-vga-write-mode" class="level2">
<h2><a href="#chapter-27-yet-another-vga-write-mode">Chapter 27 – Yet Another VGA Write Mode</a></h2>
<section id="write-mode-2-chunky-bitmapsand-text-graphics-coexistence" class="level3">
<h3><a href="#write-mode-2-chunky-bitmapsand-text-graphics-coexistence">Write Mode 2, Chunky Bitmaps,and Text-Graphics Coexistence</a></h3>
<p>In the last chapter, we learned about the markedly peculiar write mode 3 of the VGA, after having spent three chapters learning the ins and outs of the VGA’s data path in write mode 0, touching on write mode 1 as well in Chapter 23. In all, the VGA supports four write modes—write modes 0, 1, 2, and 3—and read modes 0 and 1 as well. Which leaves two burning questions: What is write mode 2, and how the heck do you <em>read</em> VGA memory?</p>
<p>Write mode 2 is a bit unusual but not really hard to understand, particularly if you followed the description of set/reset in Chapter 25. Reading VGA memory, on the other hand, can be stranger than you could ever imagine.</p>
<p>Let’s start with the easy stuff, write mode 2, and save the read modes for the next chapter.</p>
</section>
<section id="write-mode-2-and-setreset" class="level3">
<h3><a href="#write-mode-2-and-setreset">Write Mode 2 and Set/Reset</a></h3>
<p>Remember how set/reset works? Good, because that’s pretty much how write mode 2 works. (You <em>don’t</em> remember? Well, I’ll provide a brief refresher, but I suggest that you go back through Chapters 23 through 25 and come up to speed on the VGA.)</p>
<p>Recall that the set/reset circuitry for each of the four planes affects the byte written by the CPU in one of three ways: By replacing the CPU byte with 0, by replacing it with 0FFH, or by leaving it unchanged. The nature of the transformation for each plane is controlled by two bits. The enable set/reset bit for a given plane selects whether the CPU byte is replaced or not, and the set/reset bit for that plane selects the value with which the CPU byte is replaced if the enable set/reset bit is 1. The net effect of set/reset is to independently force any, none, or all planes to either of all ones or all zeros on CPU writes. As we discussed in Chapter 25, this is a convenient way to force a specific color to appear no matter what color the pixels being overwritten are. Set/reset also allows the CPU to control the contents of some planes while the set/reset circuitry controls the contents of other planes.</p>
<p>Write mode 2 is basically a set/reset-type mode with enable set/reset always on for all planes and the set/reset data coming directly from the byte written by the CPU. Put another way, the lower four bits written by the CPU are written across the four planes, thereby becoming a color value. Put yet another way, bit 0 of the CPU byte is expanded to a byte and sent to the plane 0 ALU (if bit 0 is 0, a 0 byte is the CPU-side input to the plane 0 ALU, while if bit 0 is 1, a 0FFH byte is the CPU-side input); likewise, bit 1 of the CPU byte is expanded to a byte for plane 1, bit 2 is expanded for plane 2, and bit 3 is expanded for plane 3.</p>
<p>It’s possible that you understand write mode 2 thoroughly at this point; nonetheless, I suspect that some additional explanation of an admittedly non-obvious mode wouldn’t hurt. Let’s follow the CPU byte through the VGA in write mode 2, step by step.</p>
<section id="a-bytes-progress-in-write-mode-2" class="level4">
<h4><a href="#a-bytes-progress-in-write-mode-2">A Byte’s Progress in Write Mode 2</a></h4>
<p>Figure 27.1 shows the write mode 2 data path. The CPU byte comes into the VGA and is split into four separate bits, one for each plane. Bits 7-4 of the CPU byte vanish into the bit bucket, never to be heard from again. Speculation long held that those 4 unused bits indicated that IBM would someday come out with an 8-plane adapter that supported 256 colors. When IBM did finally come out with a 256-color mode (mode 13H of the VGA), it turned out not to be planar at all, and the upper nibble of the CPU byte remains unused in write mode 2 to this day.</p>
<p>The bit of the CPU byte sent to each plane is expanded to a 0 or 0FFH byte, depending on whether the bit is 0 or 1, respectively. The byte for each plane then becomes the CPU-side input to the respective plane’s ALU. From this point on, the write mode 2 data path is identical to the write mode 0 data path. As discussed in earlier articles, the latch byte for each plane is the other ALU input, and the ALU either ANDs, ORs, or XORs the two bytes together or simply passes the CPU-side byte through. The byte generated by each plane’s ALU then goes through the bit mask circuitry, which selects on a bit-by-bit basis between the ALU byte and the latch byte. Finally, the byte from the bit mask circuitry for each plane is written to that plane if the corresponding bit in the Map Mask register is set to 1.</p>
<figure>
<img src="images/27-01.jpg" alt="Figure 27.1  VGA data flow in write mode 2." /><figcaption><strong>Figure 27.1</strong>  <em>VGA data flow in write mode 2.</em></figcaption>
</figure>
<blockquote>
<p><img src="images/i.jpg" /> It’s worth noting two differences between write mode 2 and write mode 0, the standard write mode of the VGA. First, rotation of the CPU data byte does not take place in write mode 2. Second, the Set/Reset and Enable Set/Reset registers have no effect in write mode 2.</p>
</blockquote>
<p>Now that we understand the mechanics of write mode 2, we can step back and get a feel for what it might be useful for. View bits 3-0 of the CPU byte as a single pixel in one of 16 colors. Next imagine that nibble turned sideways and written across the four planes, one bit to a plane. Finally, expand each of the bits to a byte, as shown in Figure 27.2, so that 8 pixels are drawn in the color selected by bits 3-0 of the CPU byte. Within the constraints of the VGA’s data paths, that’s exactly what write mode 2 does.</p>
<p>By “the constraints of the VGA’s data paths,” I mean the ALUs, the bit mask, and the map mask. As Figure 27.1 indicates, the ALUs can modify the color written by the CPU, the map mask can prevent the CPU from altering selected planes, and the bit mask can prevent the CPU from altering selected bits of the byte written to. (Actually, the bit mask simply substitutes latch bits for ALU bits, but since the latches are normally loaded from the destination display memory byte, the net effect of the bit mask is usually to preserve bits of the destination byte.) These are not really constraints at all, of course, but rather features of the VGA; I simply want to make it clear that the use of write mode 2 to set 8 pixels to a given color is a rather simple special case among the many possible ways in which write mode 2 can be used to feed data into the VGA’s data path.</p>
<p>Write mode 2 is selected by setting bits 1 and 0 of the Graphics Mode register (Graphics Controller register 5) to 1 and 0, respectively. Since VGA registers are readable, the correct way to select write mode 2 on the VGA is to read the Graphics Mode register, mask off bits 1 and 0, OR in 00000010b (02H), and write the result back to the Graphics Mode register, thereby leaving the other bits in the register undisturbed.</p>
</section>
<section id="copying-chunky-bitmaps-to-vga-memory-using-write-mode-2" class="level4">
<h4><a href="#copying-chunky-bitmaps-to-vga-memory-using-write-mode-2">Copying Chunky Bitmaps to VGA Memory Using Write Mode 2</a></h4>
<p>Let’s take a look at two examples of write mode 2 in action. Listing 27.1 presents a program that uses write mode 2 to copy a graphics image in chunky format to the VGA. In chunky format adjacent bits in a single byte make up each pixel: mode 4 of the CGA, EGA, and VGA is a 2-bit-per-pixel chunky mode, and mode 13H of the VGA is an 8-bit-per-pixel chunky mode. Chunky format is convenient, since all the information about each pixel is contained in a single byte; consequently chunky format is often used to store bitmaps in system memory.</p>
<p>Unfortunately, VGA memory is organized as a planar rather than chunky bitmap in modes 0DH through 12H, with the bits that make up each pixel spread across four planes. The conversion from chunky to planar format in write mode 0 is quite a nuisance, requiring a good deal of bit manipulation. In write mode 2, however, the conversion becomes a snap, as shown in Listing 27.1. Once the VGA is placed in write mode 2, the lower four bits (the lower nibble) of the CPU byte (a single 4-bit chunky pixel) become eight planar pixels, all the same color. As discussed in Chapter 25, the bit mask makes it possible to narrow the effect of the CPU write down to a single pixel.</p>
<p>Given the above, conversion of a chunky 4-bit-per-pixel bitmap to the VGA’s planar format in write mode 2 is trivial. First, the Bit Mask register is set to allow only the VGA display memory bits corresponding to the leftmost chunky pixel of the two stored in the first chunky bitmap byte to be modified. Next, the destination byte in display memory is read in order to load the latches. Then a byte containing two chunky pixels is read from the chunky bitmap in system memory, and the byte is rotated four bits to the right to get the leftmost chunky pixel in position. This rotated byte is written to the destination byte; since write mode 2 is active, each bit of the chunky pixel goes to its respective plane, and since the Bit Mask register is set up to allow only one bit in each plane to be modified, a single pixel in the color of the chunky pixel is written to VGA memory.</p>
<p>This process is then repeated for the rightmost chunky pixel, if necessary, and repeated again for as many pixels as there are in the image.</p>
<p><strong>LISTING 27.1 L27-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate one use of write mode 2 of the VGA and EGA by</span>
<span class="co">; animating the image of an &quot;A&quot; drawn by copying it from a chunky</span>
<span class="co">; bit-map in system memory to a planar bit-map in VGA or EGA memory.</span>
<span class="co">;</span>
<span class="co">; Assemble with MASM or TASM</span>
<span class="co">;</span>
<span class="co">; By Michael Abrash</span>
<span class="co">;</span>
Stack   <span class="kw">segment</span> para stack ‘STACK<span class="st">&#39;</span>
        <span class="dt">db</span>      <span class="dv">512</span> dup(<span class="dv">0</span>)
Stack   ends

SCREEN_WIDTH_IN_BYTES   <span class="dt">equ</span>     <span class="dv">80</span>
DISPLAY_MEMORY_SEGMENT  <span class="dt">equ</span><span class="bn">     0a000h</span>
SC_INDEX                                  <span class="dt">equ</span><span class="bn">     3c4h    </span><span class="co">;Sequence Controller Index register</span>
MAP_MASK                                  <span class="dt">equ</span>     <span class="dv">2</span>       <span class="co">;index of Map Mask register</span>
GC_INDEX                                  <span class="dt">equ</span><span class="bn">     03ceh   </span><span class="co">;Graphics Controller Index reg</span>
GRAPHICS_MODE                             <span class="dt">equ</span>     <span class="dv">5</span>       <span class="co">;index of Graphics Mode reg</span>
BIT_MASKequ     <span class="dv">8</span>       <span class="co">;index of Bit Mask reg</span>

Data    <span class="kw">segment</span> para <span class="kw">common</span> ‘DATA<span class="st">&#39;</span>
<span class="co">;</span>
<span class="co">; Current location of &quot;A&quot; as it is animated across the screen.</span>
<span class="co">;</span>
CurrentX        <span class="dt">dw</span>      ?
CurrentY        <span class="dt">dw</span>      ?
RemainingLength <span class="dt">dw</span>      ?
<span class="co">;</span>
<span class="co">; Chunky bit-map image of a yellow &quot;A&quot; on a bright blue background</span>
<span class="co">;</span>
AImage          label   <span class="dt">byte</span>
                <span class="dt">dw</span>      <span class="dv">13</span>, <span class="dv">13</span>          <span class="co">;width, height in pixels</span>
                <span class="dt">db</span><span class="bn">      000h, </span>000h<span class="bn">, 000h, </span>000h<span class="bn">, 000h, </span>000h<span class="bn">, 000h</span>
                <span class="dt">db</span><span class="bn">      009h, </span>099h<span class="bn">, 099h, </span>099h<span class="bn">, 099h, </span>099h<span class="bn">, 000h</span>
                <span class="dt">db</span><span class="bn">      009h, </span>099h<span class="bn">, 099h, </span>099h<span class="bn">, 099h, </span>099h<span class="bn">, 000h</span>
                <span class="dt">db</span><span class="bn">      009h, </span>099h<span class="bn">, 099h, </span>0e9h<span class="bn">, 099h, </span>099h<span class="bn">, 000h</span>
                <span class="dt">db</span><span class="bn">      009h, </span>099h<span class="bn">, 09eh, </span>0eeh<span class="bn">, 099h, </span>099h<span class="bn">, 000h</span>
                <span class="dt">db</span><span class="bn">      009h, </span>099h<span class="bn">, 0eeh, </span>09eh<span class="bn">, 0e9h, </span>099h<span class="bn">, 000h</span>
                <span class="dt">db</span><span class="bn">      009h, </span>09eh<span class="bn">, 0e9h, </span>099h<span class="bn">, 0eeh, </span>099h<span class="bn">, 000h</span>
                <span class="dt">db</span><span class="bn">      009h, </span>09eh<span class="bn">, 0eeh, </span>0eeh<span class="bn">, 0eeh, </span>099h<span class="bn">, 000h</span>
                <span class="dt">db</span><span class="bn">      009h, </span>09eh<span class="bn">, 0e9h, </span>099h<span class="bn">, 0eeh, </span>099h<span class="bn">, 000h</span>
                <span class="dt">db</span><span class="bn">      009h, </span>09eh<span class="bn">, 0e9h, </span>099h<span class="bn">, 0eeh, </span>099h<span class="bn">, 000h</span>
                <span class="dt">db</span><span class="bn">      009h, </span>099h<span class="bn">, 099h, </span>099h<span class="bn">, 099h, </span>099h<span class="bn">, 000h</span>
                <span class="dt">db</span><span class="bn">      009h, </span>099h<span class="bn">, 099h, </span>099h<span class="bn">, 099h, </span>099h<span class="bn">, 000h</span>
                <span class="dt">db</span><span class="bn">      000h, </span>000h<span class="bn">, 000h, </span>000h<span class="bn">, 000h, </span>000h<span class="bn">, 000h</span>
Data    ends

Code    <span class="kw">segment</span> para public ‘CODE<span class="st">&#39;</span>
        assume  <span class="kw">cs</span>:Code, <span class="kw">ds</span>:Data
Start   proc    near
        <span class="kw">mov</span>     <span class="kw">ax</span>,Data
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,10h</span>
        <span class="kw">int</span><span class="bn">     10h             </span><span class="co">;select video mode 10h (640x350)</span>
<span class="co">;</span>
<span class="co">; Prepare for animation.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     [CurrentX],<span class="dv">0</span>
        <span class="kw">mov</span>     [CurrentY],<span class="dv">200</span>
        <span class="kw">mov</span>     [RemainingLength],<span class="dv">600</span>   <span class="co">;move 600 times</span>
<span class="co">;</span>
<span class="co">; Animate, repeating RemainingLength times. It&#39;s unnecessary to erase</span>
<span class="co">; the old image, since the one pixel of blank fringe around the image</span>
<span class="co">; erases the part of the old image not overlapped by the new image.</span>
<span class="co">;</span>
<span class="fu">AnimationLoop:</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[CurrentX]
        <span class="kw">mov</span>     <span class="kw">cx</span>,[CurrentY]
        <span class="kw">mov</span>     <span class="kw">si</span>,offset AImage
        <span class="kw">call</span>    DrawFromChunkyBitmap    <span class="co">;draw the &quot;A&quot; image</span>
        <span class="kw">inc</span>     [CurrentX]              <span class="co">;move one pixel to the right</span>

        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">0</span>                    <span class="co">;delay so we don&#39;t move the</span>
<span class="fu">DelayLoop:</span>                              <span class="co">; image too fast; adjust as</span>
                                        <span class="co">; needed</span>
        <span class="kw">loop</span>    DelayLoop

        <span class="kw">dec</span>     [RemainingLength]
        <span class="kw">jnz</span>     AnimationLoop
<span class="co">;</span>
<span class="co">; Wait for a key before returning to text mode and ending.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,01h</span>
        <span class="kw">int</span><span class="bn">     21h</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,03h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch</span>
        <span class="kw">int</span><span class="bn">     21h</span>
Start   endp
<span class="co">;</span>
<span class="co">; Draw an image stored in a chunky-bit map into planar VGA/EGA memory</span>
<span class="co">; at the specified location.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;       BX = X screen location at which to draw the upper-left corner</span>
<span class="co">;               of the image</span>
<span class="co">;       CX = Y screen location at which to draw the upper-left corner</span>
<span class="co">;               of the image</span>
<span class="co">;       DS:SI = pointer to chunky image to draw, as follows:</span>
<span class="co">;               word at 0: width of image, in pixels</span>
<span class="co">;               word at 2: height of image, in pixels</span>
<span class="co">;               byte at 4: msb/lsb = first &amp; second chunky pixels,</span>
<span class="co">;                       repeating for the remainder of the scan line</span>
<span class="co">;                       of the image, then for all scan lines. Images</span>
<span class="co">;                       with odd widths have an unused null nibble</span>
<span class="co">;                       padding each scan line out to a byte width</span>
<span class="co">;</span>
<span class="co">; AX, BX, CX, DX, SI, DI, ES destroyed.</span>
<span class="co">;</span>
DrawFromChunkyBitmap    proc    near
        <span class="kw">cld</span>
<span class="co">;</span>
<span class="co">; Select write mode 2.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GRAPHICS_MODE
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,02h</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Enable writes to all 4 planes.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0fh</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Point ES:DI to the display memory byte in which the first pixel</span>
<span class="co">; of the image goes, with AH set up as the bit mask to access that</span>
<span class="co">; pixel within the addressed byte.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_WIDTH_IN_BYTES
        <span class="kw">mul</span>     <span class="kw">cx</span>              <span class="co">;offset of start of top scan line</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">cl</span>,<span class="kw">bl</span>
        <span class="kw">and</span>     <span class="kw">cl</span><span class="bn">,111b</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,80h          </span><span class="co">;set AH to the bit mask for the</span>
        <span class="kw">shr</span>     <span class="kw">ah</span>,<span class="kw">cl</span>           <span class="co">; initial pixel</span>
        <span class="kw">shr</span>     <span class="kw">bx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">bx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">bx</span>,<span class="dv">1</span>            <span class="co">;X in bytes</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">bx</span>           <span class="co">;offset of upper-left byte of image</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,DISPLAY_MEMORY_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">bx</span>           <span class="co">;ES:DI points to the byte at which the</span>
                                <span class="co">; upper left of the image goes</span>
<span class="co">;</span>
<span class="co">; Get the width and height of the image.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">si</span>]         <span class="co">;get the width</span>
        <span class="kw">inc</span>     <span class="kw">si</span>
        <span class="kw">inc</span>     <span class="kw">si</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">si</span>]      <span class="co">;get the height</span>
        <span class="kw">inc</span>     <span class="kw">si</span>
        <span class="kw">inc</span>     <span class="kw">si</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,BIT_MASK
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">;leave the GC Index register pointing</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>              <span class="co">; to the Bit Mask register</span>
<span class="fu">RowLoop:</span>

        <span class="kw">push</span>    <span class="kw">ax</span>              <span class="co">;preserve the left column&#39;s bit mask</span>
        <span class="kw">push</span>    <span class="kw">cx</span>              <span class="co">;preserve the width</span>
        <span class="kw">push</span>    <span class="kw">di</span>              <span class="co">;preserve the destination offset</span>

<span class="fu">ColumnLoop:</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">ah</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">;set the bit mask to draw this pixel</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">es</span>:[<span class="kw">di</span>]      <span class="co">;load the latches</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,[<span class="kw">si</span>]         <span class="co">;get the next two chunky pixels</span>
        <span class="kw">shr</span>     <span class="kw">al</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">al</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">al</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">al</span>,<span class="dv">1</span>            <span class="co">;move the first pixel into the lsb</span>
        <span class="kw">stosb</span>                   <span class="co">;draw the first pixel</span>
        <span class="kw">ror</span>     <span class="kw">ah</span>,<span class="dv">1</span>           <span class="co">;move mask to next pixel position</span>
        <span class="kw">jc</span>      CheckMorePixels <span class="co">;is next pixel in the adjacent byte?</span>
        <span class="kw">dec</span>     <span class="kw">di</span>              <span class="co">;no</span>

<span class="fu">CheckMorePixels:</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>              <span class="co">;see if there are any more pixels</span>
        <span class="kw">jz</span>      AdvanceToNextScanLine <span class="co">; across in image</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">ah</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">;set the bit mask to draw this pixel</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">es</span>:[<span class="kw">di</span>]      <span class="co">;load the latches</span>
        <span class="kw">lodsb</span>                   <span class="co">;get the same two chunky pixels again</span>
                          <span class="co">; and advance pointer to the next</span>
                               <span class="co">; two pixels</span>
        <span class="kw">stosb</span>                   <span class="co">;draw the second of the two pixels</span>
        <span class="kw">ror</span>     <span class="kw">ah</span>,<span class="dv">1</span>            <span class="co">;move mask to next pixel position</span>
        <span class="kw">jc</span>      CheckMorePixels2 <span class="co">;is next pixel in the adjacent byte?</span>
        <span class="kw">dec</span>     <span class="kw">di</span>              <span class="co">;no</span>

<span class="fu">CheckMorePixels2:</span>
        <span class="kw">loop</span>    ColumnLoop      <span class="co">;see if there are any more pixels</span>
                                <span class="co">; across in the image</span>
        <span class="kw">jmp</span>     <span class="dt">short</span> CheckMoreScanLines

<span class="fu">AdvanceToNextScanLine:</span>
        <span class="kw">inc</span>     <span class="kw">si</span>              <span class="co">;advance to the start of the next</span>
                                <span class="co">; scan line in the image</span>

<span class="fu">CheckMoreScanLines:</span>
        <span class="kw">pop</span>     <span class="kw">di</span>              <span class="co">;get back the destination offset</span>
        <span class="kw">pop</span>     <span class="kw">cx</span>              <span class="co">;get back the width</span>
        <span class="kw">pop</span>     <span class="kw">ax</span>              <span class="co">;get back the left column&#39;s bit mask</span>
        <span class="kw">add</span>     <span class="kw">di</span>,SCREEN_WIDTH_IN_BYTES
                                <span class="co">;point to the start of the next scan</span>
                                <span class="co">; line of the image</span>
        <span class="kw">dec</span>     <span class="kw">bx</span>              <span class="co">;see if there are any more scan lines</span>
        <span class="kw">jnz</span>     RowLoop         <span class="co">; in the image</span>
        <span class="kw">ret</span>
DrawFromChunkyBitmap    endp
Code    ends
        end     Start</code></pre>
<p>“That’s an interesting application of write mode 2,” you may well say, “but is it really useful?” While the ability to convert chunky bitmaps into VGA bitmaps does have its uses, Listing 27.1 is primarily intended to illustrate the mechanics of write mode 2.</p>
<blockquote>
<p><img src="images/i.jpg" /> For performance, it’s best to store 16-color bitmaps in pre-separated four-plane format in system memory, and copy one plane at a time to the screen. Ideally, such bitmaps should be copied one scan line at a time, with all four planes completed for one scan line before moving on to the next. I say this because when entire images are copied one plane at a time, nasty transient color effects can occur as one plane becomes visibly changed before other planes have been modified.</p>
</blockquote>
</section>
<section id="drawing-color-patterned-lines-using-write-mode-2" class="level4">
<h4><a href="#drawing-color-patterned-lines-using-write-mode-2">Drawing Color-Patterned Lines Using Write Mode 2</a></h4>
<p>A more serviceable use of write mode 2 is shown in the program presented in Listing 27.2. The program draws multicolored horizontal, vertical, and diagonal lines, basing the color patterns on passed color tables. Write mode 2 is ideal because in this application color can vary from one pixel to the next, and in write mode 2 all that’s required to set pixel color is a change of the lower nibble of the byte written by the CPU. Set/reset could be used to achieve the same result, but an index/data pair of <code>OUT</code>s would be required to set the Set/Reset register to each new color. Similarly, the Map Mask register could be used in write mode 0 to set pixel color, but in this case not only would an index/data pair of <code>OUT</code>s be required but there would also be no guarantee that data already in display memory wouldn’t interfere with the color of the pixel being drawn, since the Map Mask register allows only selected planes to be drawn to.</p>
<p>Listing 27.2 is hardly a comprehensive line drawing program. It draws only a few special line cases, and although it is reasonably fast, it is far from the fastest possible code to handle those cases, because it goes through a dot-plot routine and because it draws horizontal lines a pixel rather than a byte at a time. Write mode 2 would, however, serve just as well in a full-blown line drawing routine. For any type of patterned line drawing on the VGA, the basic approach remains the same: Use the bit mask to select the pixel (or pixels) to be altered and use the CPU byte in write mode 2 to select the color in which to draw.</p>
<p><strong>LISTING 27.2 L27-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate one use of write mode 2 of the VGA and EGA by</span>
<span class="co">; drawing lines in color patterns.</span>
<span class="co">;</span>
<span class="co">; Assemble with MASM or TASM</span>
<span class="co">;</span>
<span class="co">; By Michael Abrash</span>
<span class="co">;</span>
Stack   <span class="kw">segment</span> para stack ‘STACK<span class="st">&#39;</span>
        <span class="dt">db</span>      <span class="dv">512</span> dup(<span class="dv">0</span>)
Stack   ends

SCREEN_WIDTH_IN_BYTES <span class="dt">equ</span>     <span class="dv">80</span>
GRAPHICS_SEGMENT      <span class="dt">equ</span><span class="bn">    0a000h   </span><span class="co">;mode 10 bit-map segment</span>
SC_INDEX              <span class="dt">equ</span><span class="bn">     3c4h    </span><span class="co">;Sequence Controller Index register</span>
MAP_MASK              <span class="dt">equ</span>     <span class="dv">2</span>       <span class="co">;index of Map Mask register</span>
GC_INDEX              <span class="dt">equ</span><span class="bn">     03ceh   </span><span class="co">;Graphics Controller Index reg</span>
GRAPHICS_MODE         <span class="dt">equ</span>     <span class="dv">5</span>       <span class="co">;index of Graphics Mode reg</span>
BIT_MASK              <span class="dt">equ</span>     <span class="dv">8</span>       <span class="co">;index of Bit Mask reg</span>

Data    <span class="kw">segment</span> para <span class="kw">common</span> ‘DATA<span class="st">&#39;</span>
Pattern0        <span class="dt">db</span>      <span class="dv">16</span>
                <span class="dt">db</span>      <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>
                <span class="dt">db</span>      <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>, <span class="dv">15</span>
Pattern1        <span class="dt">db</span>      <span class="dv">6</span>
                <span class="dt">db</span>      <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">10</span>
Pattern2        <span class="dt">db</span>      <span class="dv">8</span>
                <span class="dt">db</span>      <span class="dv">15</span>, <span class="dv">15</span>, <span class="dv">15</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">15</span>, <span class="dv">0</span>, <span class="dv">0</span>
Pattern3        <span class="dt">db</span>      <span class="dv">9</span>
                <span class="dt">db</span>      <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">4</span>
Data    ends

Code    <span class="kw">segment</span> para public ‘CODE<span class="st">&#39;</span>
        assume  <span class="kw">cs</span>:Code, <span class="kw">ds</span>:Data
Start   proc    near
        <span class="kw">mov</span>     <span class="kw">ax</span>,Data
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,10h</span>
        <span class="kw">int</span><span class="bn">     10h             </span><span class="co">;select video mode 10h (640x350)</span>
<span class="co">;</span>
<span class="co">; Draw 8 radial lines in upper-left quadrant in pattern 0.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="dv">0</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">0</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,offset Pattern0
        <span class="kw">call</span>    QuadrantUp
<span class="co">;</span>
<span class="co">; Draw 8 radial lines in upper-right quadrant in pattern 1.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="dv">320</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">0</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,offset Pattern1
        <span class="kw">call</span>    QuadrantUp
<span class="co">;</span>
<span class="co">; Draw 8 radial lines in lower-left quadrant in pattern 2.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="dv">0</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">175</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,offset Pattern2
        <span class="kw">call</span>    QuadrantUp
<span class="co">;</span>
<span class="co">; Draw 8 radial lines in lower-right quadrant in pattern 3.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="dv">320</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">175</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,offset Pattern3
        <span class="kw">call</span>    QuadrantUp
<span class="co">;</span>
<span class="co">; Wait for a key before returning to text mode and ending.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,01h</span>
        <span class="kw">int</span><span class="bn">     21h</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,03h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch</span>
        <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
<span class="co">; Draws 8 radial lines with specified pattern in specified mode 10h</span>
<span class="co">; quadrant.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;       BX = X coordinate of upper left corner of quadrant</span>
<span class="co">;       CX = Y coordinate of upper left corner of quadrant</span>
<span class="co">;       SI = pointer to pattern, in following form:</span>
<span class="co">;               Byte 0: Length of pattern</span>
<span class="co">;               Byte 1: Start of pattern, one color per byte</span>
<span class="co">;</span>
<span class="co">; AX, BX, CX, DX destroyed</span>
<span class="co">;</span>
QuadrantUp      proc    near
        <span class="kw">add</span>     <span class="kw">bx</span>,<span class="dv">160</span>
        <span class="kw">add</span>     <span class="kw">cx</span>,<span class="dv">87</span>           <span class="co">;point to the center of the quadrant</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dv">0</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dv">160</span>
        <span class="kw">call</span>    LineUp          <span class="co">;draw horizontal line to right edge</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dv">88</span>
        <span class="kw">call</span>    LineUp          <span class="co">;draw diagonal line to upper right</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dv">2</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dv">88</span>
        <span class="kw">call</span>    LineUp          <span class="co">;draw vertical line to top edge</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dv">3</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dv">88</span>
        <span class="kw">call</span>    LineUp          <span class="co">;draw diagonal line to upper left</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dv">4</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dv">161</span>
        <span class="kw">call</span>    LineUp          <span class="co">;draw horizontal line to left edge</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dv">5</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dv">88</span>
        <span class="kw">call</span>    LineUp          <span class="co">;draw diagonal line to lower left</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dv">6</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dv">88</span>
        <span class="kw">call</span>    LineUp          <span class="co">;draw vertical line to bottom edge</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dv">7</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dv">88</span>
        <span class="kw">call</span>    LineUp          <span class="co">;draw diagonal line to bottom right</span>
        <span class="kw">ret</span>
QuadrantUp      endp
<span class="co">;</span>
<span class="co">; Draws a horizontal, vertical, or diagonal line (one of the eight</span>
<span class="co">; possible radial lines) of the specified length from the specified</span>
<span class="co">; starting point.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;       AX = line direction, as follows:</span>
<span class="co">;               3  2  1</span>
<span class="co">;               4  *  0</span>
<span class="co">;               5  6  7</span>
<span class="co">;       BX = X coordinate of starting point</span>
<span class="co">;       CX = Y coordinate of starting point</span>
<span class="co">;       DX = length of line (number of pixels drawn)</span>
<span class="co">;</span>
<span class="co">; All registers preserved.</span>
<span class="co">;</span>
<span class="co">; Table of vectors to routines for each of the 8 possible lines.</span>
<span class="co">;</span>
LineUpVectors   label   <span class="dt">word</span>
        <span class="dt">dw</span>      LineUp0, LineUp1, LineUp2, LineUp3
        <span class="dt">dw</span>      LineUp4, LineUp5, LineUp6, LineUp7

<span class="co">;</span>
<span class="co">; Macro to draw horizontal, vertical, or diagonal line.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;       XParm = 1 to draw right, -1 to draw left, 0 to not move horz.</span>
<span class="co">;       YParm = 1 to draw up, -1 to draw down, 0 to not move vert.</span>
<span class="co">;       BX = X start location</span>
<span class="co">;       CX = Y start location</span>
<span class="co">;       DX = number of pixels to draw</span>
<span class="co">;       DS:SI = line pattern</span>
<span class="co">;</span>
MLineUp macro   XParm, YParm
        local   LineUpLoop, CheckMoreLine
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">si</span>           <span class="co">;set aside start offset of pattern</span>
        <span class="kw">lodsb</span>                   <span class="co">;get length of pattern</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">al</span>

<span class="fu">LineUpLoop:</span>
        <span class="kw">lodsb</span>                   <span class="co">;get color of this pixel...</span>
        <span class="kw">call</span>    DotUpInColor    <span class="co">;...and draw it</span>
if XParm EQ <span class="dv">1</span>
        <span class="kw">inc</span>     <span class="kw">bx</span>
endif
if XParm EQ -<span class="dv">1</span>
        <span class="kw">dec</span>     <span class="kw">bx</span>
endif
if YParm EQ <span class="dv">1</span>
        <span class="kw">inc</span>     <span class="kw">cx</span>
endif
if YParm EQ -<span class="dv">1</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>
endif
        <span class="kw">dec</span>     <span class="kw">ah</span>              <span class="co">;at end of pattern?</span>
        <span class="kw">jnz</span>     CheckMoreLine
        <span class="kw">mov</span>     <span class="kw">si</span>,<span class="kw">di</span>           <span class="co">;get back start of pattern</span>
        <span class="kw">lodsb</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">al</span>           <span class="co">;reset pattern count</span>

<span class="fu">CheckMoreLine:</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">jnz</span>     LineUpLoop
        <span class="kw">jmp</span>     LineUpEnd
        endm

LineUp  proc    near
        <span class="kw">push</span>    <span class="kw">ax</span>
        <span class="kw">push</span>    <span class="kw">bx</span>
        <span class="kw">push</span>    <span class="kw">cx</span>
        <span class="kw">push</span>    <span class="kw">dx</span>
        <span class="kw">push</span>    <span class="kw">si</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">push</span>    <span class="kw">es</span>

        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">ax</span>

        <span class="kw">mov</span>     <span class="kw">ax</span>,GRAPHICS_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>

        <span class="kw">push</span>    <span class="kw">dx</span>              <span class="co">;save line length</span>
<span class="co">;</span>
<span class="co">; Enable writes to all planes.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0fh</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Select write mode 2.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,GRAPHICS_MODE
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,02h</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Vector to proper routine.</span>
<span class="co">;</span>
        <span class="kw">pop</span>     <span class="kw">dx</span>              <span class="co">;get back line length</span>

        <span class="kw">shl</span>     <span class="kw">di</span>,<span class="dv">1</span>
        <span class="kw">jmp</span>     <span class="kw">cs</span>:[LineUpVectors+<span class="kw">di</span>]
<span class="co">;</span>
<span class="co">; Horizontal line to right.</span>
<span class="co">;</span>
<span class="fu">LineUp0:</span>
        MLineUp <span class="dv">1</span>, <span class="dv">0</span>
<span class="co">;</span>
<span class="co">; Diagonal line to upper right.</span>
<span class="co">;</span>
<span class="fu">LineUp1:</span>
        MLineUp <span class="dv">1</span>, -<span class="dv">1</span>
<span class="co">;</span>
<span class="co">; Vertical line to top.</span>
<span class="co">;</span>
<span class="fu">LineUp2:</span>
        MLineUp <span class="dv">0</span>, -<span class="dv">1</span>
<span class="co">;</span>
<span class="co">; Diagonal line to upper left.</span>
<span class="co">;</span>
<span class="fu">LineUp3:</span>
        MLineUp -<span class="dv">1</span>, -<span class="dv">1</span>
<span class="co">;</span>
<span class="co">; Horizontal line to left.</span>
<span class="co">;</span>
<span class="fu">LineUp4:</span>
        MLineUp -<span class="dv">1</span>, <span class="dv">0</span>
<span class="co">;</span>
<span class="co">; Diagonal line to bottom left.</span>
<span class="co">;</span>
<span class="fu">LineUp5:</span>
        MLineUp -<span class="dv">1</span>, <span class="dv">1</span>
<span class="co">;</span>
<span class="co">; Vertical line to bottom.</span>
<span class="co">;</span>
<span class="fu">LineUp6:</span>
        MLineUp <span class="dv">0</span>, <span class="dv">1</span>
<span class="co">;</span>
<span class="co">; Diagonal line to bottom right.</span>
<span class="co">;</span>
<span class="fu">LineUp7:</span>
        MLineUp <span class="dv">1</span>, <span class="dv">1</span>

<span class="fu">LineUpEnd:</span>
        <span class="kw">pop</span>     <span class="kw">es</span>
        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">dx</span>
        <span class="kw">pop</span>     <span class="kw">cx</span>
        <span class="kw">pop</span>     <span class="kw">bx</span>
        <span class="kw">pop</span>     <span class="kw">ax</span>
        <span class="kw">ret</span>
LineUp  endp
<span class="co">;</span>
<span class="co">; Draws a dot in the specified color at the specified location.</span>
<span class="co">; Assumes that the VGA is in write mode 2 with writes to all planes</span>
<span class="co">; enabled and that ES points to display memory.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;       AL = dot color</span>
<span class="co">;       BX = X coordinate of dot</span>
<span class="co">;       CX = Y coordinate of dot</span>
<span class="co">;       ES = display memory segment</span>
<span class="co">;</span>
<span class="co">; All registers preserved.</span>
<span class="co">;</span>
DotUpInColor    proc    near
        <span class="kw">push</span>    <span class="kw">bx</span>
        <span class="kw">push</span>    <span class="kw">cx</span>
        <span class="kw">push</span>    <span class="kw">dx</span>
        <span class="kw">push</span>    <span class="kw">di</span>
<span class="co">;</span>
<span class="co">; Point ES:DI to the display memory byte in which the pixel goes, with</span>
<span class="co">; the bit mask set up to access that pixel within the addressed byte.</span>
<span class="co">;</span>
        <span class="kw">push</span>    <span class="kw">ax</span>              <span class="co">;preserve dot color</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_WIDTH_IN_BYTES
        <span class="kw">mul</span>     <span class="kw">cx</span>              <span class="co">;offset of start of top scan line</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">cl</span>,<span class="kw">bl</span>
        <span class="kw">and</span>     <span class="kw">cl</span><span class="bn">,111b</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,BIT_MASK
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,80h</span>
        <span class="kw">shr</span>     <span class="kw">al</span>,<span class="kw">cl</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">;set the bit mask for the pixel</span>
        <span class="kw">shr</span>     <span class="kw">bx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">bx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">bx</span>,<span class="dv">1</span>            <span class="co">;X in bytes</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">bx</span>           <span class="co">;offset of byte pixel is in</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">es</span>:[<span class="kw">di</span>]      <span class="co">;load latches</span>
        <span class="kw">pop</span>     <span class="kw">ax</span>              <span class="co">;get back dot color</span>
        <span class="kw">stosb</span>                   <span class="co">;write dot in desired color</span>

        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">pop</span>     <span class="kw">dx</span>
        <span class="kw">pop</span>     <span class="kw">cx</span>
        <span class="kw">pop</span>     <span class="kw">bx</span>
        <span class="kw">ret</span>
DotUpInColor    endp
Start   endp
Code    ends
        end     Start</code></pre>
</section>
</section>
<section id="when-to-use-write-mode-2-and-when-to-use-setreset" class="level3">
<h3><a href="#when-to-use-write-mode-2-and-when-to-use-setreset">When to Use Write Mode 2 and When to Use Set/Reset</a></h3>
<p>As indicated earlier, write mode 2 and set/reset are functionally interchangeable. Write mode 2 lends itself to more efficient implementations when the drawing color changes frequently, as in Listing 27.2.</p>
<p>Set/reset tends to be superior when many pixels in succession are drawn in the same color, since with set/reset enabled for all planes the Set/Reset register provides the color data and as a result the CPU is free to draw whatever byte value it wishes. For example, the CPU can execute an <code>OR</code> instruction to display memory when set/reset is enabled for all planes, thus both loading the latches and writing the color value with a single instruction, secure in the knowledge that the value it writes is ignored in favor of the set/reset color.</p>
<p>Set/reset is also the mode of choice whenever it is necessary to force the value written to some planes to a fixed value while allowing the CPU byte to modify other planes. This is the mode of operation when set/reset is enabled for some but not all planes.</p>
</section>
<section id="mode-13h320x200-with-256-colors" class="level3">
<h3><a href="#mode-13h320x200-with-256-colors">Mode 13H—320x200 with 256 Colors</a></h3>
<p>I’m going to take a minute—and I do mean a minute—to discuss the programming model for mode 13H, the VGA’s 320x200 256-color mode. Frankly, there’s just not much to it, especially compared to the convoluted 16-color model that we’ve explored over the last five chapters. Mode 13H offers the simplest programming model in the history of PC graphics: A linear bitmap starting at A000:0000, consisting of 64,000 bytes, each controlling one pixel. The byte at offset 0 controls the upper left pixel on the screen, the byte at offset 319 controls the upper right pixel on the screen, the byte at offset 320 controls the second pixel down at the left of the screen, and the byte at offset 63,999 controls the lower right pixel on the screen. That’s all there is to it; it’s so simple that I’m not going to spend any time on a demo program, especially given that some of the listings later in this book, such as the antialiasing code in Chapter F on the companion CD-ROM, use mode 13H.</p>
</section>
<section id="flipping-pages-from-text-to-graphics-and-back" class="level3">
<h3><a href="#flipping-pages-from-text-to-graphics-and-back">Flipping Pages from Text to Graphics and Back</a></h3>
<p>A while back, I got an interesting letter from Phil Coleman, of La Jolla, who wrote:</p>
<p>“Suppose I have the EGA in mode 10H (640x350 16-color graphics). I would like to preserve some or all of the image while I temporarily switch to text mode 3 to give my user a ‘Help’ screen. Naturally memory is scarce so I’d rather not make a copy of the video buffer at A000H to ‘remember’ the image while I digress to the Help text. The EGA BIOS says that the screen memory will not be cleared on a mode set if bit 7 of AL is set. Yet if I try that, it is clear that writing text into the B800H buffer trashes much more than the 4K bytes of a text page; when I switch back to mode 10H,”ghosts&quot; appear in the form of bands of colored dots. (When in text mode, I do make a copy of the 4K buffer at B800H before showing the help; and I restore the 4K before switching back to mode 10H.) Is there a way to preserve the graphics image while I switch to text mode?’’</p>
<p>“A corollary to this question is: Where does the 64/128/256K of EGA memory ‘hide’ when the EGA is in text mode? Some I guess is used to store character sets, but what happens to the rest? Or rather, how can I protect it?”</p>
<p>Those are good questions. Alas, answering them in full would require extensive explanation that would have little general application, so I’m not going to do that. However, the issue of how to go to text mode and back without losing the graphics image certainly rates a short discussion, complete with some working code. That’s especially true given that both the discussion and the code apply just as well to the VGA as to the EGA (with a few differences in mode 12H, the VGA’s highmode, as noted below).</p>
<p>Phil is indeed correct in his observation that setting bit 7 of AL instructs the BIOS not to clear display memory on mode sets, and he is also correct in surmising that a font is loaded when going to text mode. The normal mode 10H bitmap occupies the first 28,000 bytes of each of the VGA’s four planes. (The mode 12H bitmap takes up the first 38,400 bytes of each plane.) The normal mode 3 character/attribute memory map resides in the first 4000 bytes of planes 0 and 1 (the blue and green planes in mode 10H). The standard font in mode 3 is stored in the first 8K of plane 2 (the red plane in mode 10H). Neither mode 3 nor any other text mode makes use of plane 3 (the intensity plane in mode 10H); if necessary, plane 3 could be used as scratch memory in text mode.</p>
<p>Consequently, you can get away with saving a total of just under 16K bytes—the first 4000 bytes of planes 0 and 1 and the first 8K bytes of plane 2—when going from mode 10H or mode 12H to mode 3, to be restored on returning to graphics mode.</p>
<p>That’s hardly all there is to the matter of going from text to graphics and back without bitmap corruption, though. One interesting point is that the mode 10H bitmap can be relocated to A000:8000 simply by doing a mode set to mode 10H and setting the start address (programmed at CRT Controller registers 0CH and 0DH) to 8000H. You can then access display memory starting at A800:8000 instead of the normal A000:0000, with the resultant display exactly like that of normal mode 10H. There are BIOS issues, since the BIOS doesn’t automatically access display memory at the new start address, but if your program does all its drawing directly without the help of the BIOS, that’s no problem.</p>
<p>The mode 12H bitmap can’t start at A000:8000, because it’s so long that it would run off the end of display memory. However, the mode 12H bitmap can be relocated to, say, A000:6000, where it would fit without conflicting with the default font or the normal text mode memory map, although it would overlap two of the upper pages available for use (but rarely used) by text-mode programs.</p>
<p>At any rate, once the graphics mode bitmap is relocated, flipping to text mode and back becomes painless. The memory used by mode 3 doesn’t overlap the relocated mode 10H bitmap at all (unless additional portions of font memory are loaded), so all you need do is set bit 7 of AL on mode sets in order to flip back and forth between the two modes.</p>
<p>Another interesting point about flipping from graphics to text and back is that the standard mode 3 character/attribute map doesn’t actually take up every byte of the first 4000 bytes of planes 0 and 1. The standard mode 3 character/attribute map actually only takes up every even byte of the first 4000 in each plane; the odd bytes are left untouched. This means that only about 12K bytes actually have to be saved when going to text mode. The code in Listing 27.3 flips from graphics mode to text mode and back, saving only those 12K bytes that actually have to be saved. This code saves and restores the first 8K of plane 2 (the font area) while in graphics mode, but performs the save and restore of the 4000 bytes used for the character/attribute map while in text mode, because the characters and attributes, which are actually stored in the even bytes of planes 0 and 1, respectively, appear to be contiguous bytes in memory in text mode and so are easily saved as a single block.</p>
<p>Explaining why only every other byte of planes 0 and 1 is used in text mode and why characters and attributes appear to be contiguous bytes when they are actually in different planes is a large part of the explanation I’m not going to go into now. One bit of fallout from this, however, is that if you flip to text mode and preserve the graphics bitmap using the mechanism illustrated in Listing 27.3, you shouldn’t write to any text page other than page 0 (that is, don’t write to any offset in display memory above 3999 in text mode) or alter the Page Select bit in the Miscellaneous Output register (3C2H) while in text mode. In order to allow completely unfettered access to text pages, it would be necessary to save every byte in the first 32K of each of planes 0 and 1. (On the other hand, this <em>would</em> allow up to 16 text screens to be stored simultaneously, with any one displayable instantly.) Moreover, if any fonts other than the default font are loaded, the portions of plane 2 that those particular fonts are loaded into would have to be saved, up to a maximum of all 64K of plane 2. In the worst case, a full 128K would have to be saved in order to preserve all the memory potentially used by text mode.</p>
<p>As I said, Phil Coleman’s question is an interesting one, and I’ve only touched on the intriguing possibilities arising from the various configurations of display memory in VGA graphics and text modes. Right now, though, we’ve still got the basics of the remarkably complex (but rewarding!) VGA to cover.</p>
<p><strong>LISTING 27.3 L27-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate flipping from bit-mapped graphics mode to</span>
<span class="co">; text mode and back without losing any of the graphics bit-map.</span>
<span class="co">;</span>
<span class="co">; Assemble with MASM or TASM</span>
<span class="co">;</span>
<span class="co">; By Michael Abrash</span>
<span class="co">;</span>
Stack   <span class="kw">segment</span> para stack ‘STACK<span class="st">&#39;</span>
        <span class="dt">db</span>      <span class="dv">512</span> dup(<span class="dv">0</span>)
Stack   ends

GRAPHICS_SEGMENT <span class="dt">equ</span><span class="bn">     0a000h  </span><span class="co">;mode 10 bit-map segment</span>
TEXT_SEGMENT    <span class="dt">equ</span><span class="bn">     0b800h  </span><span class="co">;mode 3 bit-map segment</span>
SC_INDEX        <span class="dt">equ</span><span class="bn">     3c4h    </span><span class="co">;Sequence Controller Index register</span>
MAP_MASK        <span class="dt">equ</span>     <span class="dv">2</span>       <span class="co">;index of Map Mask register</span>
GC_INDEX        <span class="dt">equ</span><span class="bn">     3ceh    </span><span class="co">;Graphics Controller Index register</span>
READ_MAP        <span class="dt">equ</span>     <span class="dv">4</span>       <span class="co">;index of Read Map register</span>

Data    <span class="kw">segment</span> para <span class="kw">common</span> ‘DATA<span class="st">&#39;</span>

GStrikeAnyKeyMsg0       label   <span class="dt">byte</span>
        <span class="dt">db</span><span class="bn">      0dh, </span>0ah, ‘Graphics mode<span class="st">&#39;, 0dh, 0ah</span>
        <span class="dt">db</span>      ‘Strike any key to continue...<span class="st">&#39;, 0dh, 0ah, ‘$&#39;</span>

GStrikeAnyKeyMsg1       label   <span class="dt">byte</span>
        <span class="dt">db</span><span class="bn">      0dh, </span>0ah, ‘Graphics mode again<span class="st">&#39;, 0dh, 0ah</span>
        <span class="dt">db</span>      ‘Strike any key to continue...<span class="st">&#39;, 0dh, 0ah, ‘$&#39;</span>

TStrikeAnyKeyMsg        label   <span class="dt">byte</span>
        <span class="dt">db</span><span class="bn">      0dh, </span>0ah, ‘Text mode<span class="st">&#39;, 0dh, 0ah</span>
        <span class="dt">db</span>      ‘Strike any key to continue...<span class="st">&#39;, 0dh, 0ah, ‘$&#39;</span>

Plane2Save      <span class="dt">db</span><span class="bn">      2000h </span>dup (?)   <span class="co">;save area for plane 2 data</span>
                                        <span class="co">; where font gets loaded</span>
CharAttSave     <span class="dt">db</span>      <span class="dv">4000</span> dup (?)    <span class="co">;save area for memory wiped</span>
                                        <span class="co">; out by character/attribute</span>
                                        <span class="co">; data in text mode</span>
Data    ends

Code    <span class="kw">segment</span> para public ‘CODE<span class="st">&#39;</span>
        assume  <span class="kw">cs</span>:Code, <span class="kw">ds</span>:Data
Start   proc    near
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,10h</span>
        <span class="kw">int</span><span class="bn">     10h             </span><span class="co">;select video mode 10h (640x350)</span>
<span class="co">;</span>
<span class="co">; Fill the graphics bit-map with a colored pattern.</span>
<span class="co">;</span>
        <span class="kw">cld</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,GRAPHICS_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">3</span>            <span class="co">;initial fill pattern</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">4</span>            <span class="co">;four planes to fill</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">;leave the SC Index pointing to the</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>              <span class="co">; Map Mask register</span>

<span class="fu">FillBitMap:</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,10h</span>
        <span class="kw">shr</span>     <span class="kw">al</span>,<span class="kw">cl</span>           <span class="co">;generate map mask for this plane</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">;set map mask for this plane</span>
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>           <span class="co">;start at offset 0</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">ah</span>           <span class="co">;get the fill pattern</span>
        <span class="kw">push</span>    <span class="kw">cx</span>              <span class="co">;preserve plane count</span>
        <span class="kw">mov</span>     <span class="kw">cx</span><span class="bn">,8000h        </span><span class="co">;fill 32K words</span>
        rep <span class="kw">stosw</span>               <span class="co">;do fill for this plane</span>
        <span class="kw">pop</span>     <span class="kw">cx</span>              <span class="co">;get back plane count</span>
        <span class="kw">shl</span>     <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">shl</span>     <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">loop</span>    FillBitMap
<span class="co">;</span>
<span class="co">; Put up &quot;strike any key&quot; message.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,Data
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,offset GStrikeAnyKeyMsg0
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">9</span>
        <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
<span class="co">; Wait for a key.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,01h</span>
        <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
<span class="co">; Save the 8K of plane 2 that will be used by the font.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,READ_MAP
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dv">2</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">;set up to read from plane 2</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,Data
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,GRAPHICS_SEGMENT
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">si</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,offset Plane2Save
        <span class="kw">mov</span>     <span class="kw">cx</span>,2000h/<span class="dv">2</span>      <span class="co">;save 8K (length of default font)</span>
        rep <span class="kw">movsw</span>
<span class="co">;</span>
<span class="co">; Go to text mode without clearing display memory.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,083h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
<span class="co">; Save the text mode bit-map.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,Data
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,TEXT_SEGMENT
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">si</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,offset CharAttSave
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">4000</span>/<span class="dv">2</span>       <span class="co">;length of one text screen in words</span>
        rep <span class="kw">movsw</span>
<span class="co">;</span>
<span class="co">; Fill the text mode screen with dots and put up &quot;strike any key&quot;</span>
<span class="co">; message.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,TEXT_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,‘.<span class="st">&#39;          ;fill character</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">7</span>            <span class="co">;fill attribute</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">4000</span>/<span class="dv">2</span>       <span class="co">;length of one text screen in words</span>
        rep <span class="kw">stosw</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,Data
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,offset TStrikeAnyKeyMsg
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">9</span>
        <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
<span class="co">; Wait for a key.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,01h</span>
        <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
<span class="co">; Restore the text mode screen to the state it was in on entering</span>
<span class="co">; text mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,Data
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,TEXT_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,offset CharAttSave
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">4000</span>/<span class="dv">2</span>       <span class="co">;length of one text screen in words</span>
        rep <span class="kw">movsw</span>
<span class="co">;</span>
<span class="co">; Return to mode 10h without clearing display memory.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,90h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
<span class="co">; Restore the portion of plane 2 that was wiped out by the font.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dv">4</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">;set up to write to plane 2</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,Data
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,GRAPHICS_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,offset Plane2Save
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,2000h/<span class="dv">2</span>      <span class="co">;restore 8K (length of default font)</span>
        rep <span class="kw">movsw</span>
<span class="co">;</span>
<span class="co">; Put up &quot;strike any key&quot; message.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,Data
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,offset GStrikeAnyKeyMsg1
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">9</span>
        <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
<span class="co">; Wait for a key before returning to text mode and ending.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,01h</span>
        <span class="kw">int</span><span class="bn">     21h</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,03h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch</span>
        <span class="kw">int</span><span class="bn">     21h</span>
Start   endp
Code    ends
        end     Start</code></pre>
</section>
</section>
<section id="chapter-28-reading-vga-memory" class="level2">
<h2><a href="#chapter-28-reading-vga-memory">Chapter 28 – Reading VGA Memory</a></h2>
<section id="read-modes-0-and-1-and-the-color-dont-care-register" class="level3">
<h3><a href="#read-modes-0-and-1-and-the-color-dont-care-register">Read Modes 0 and 1, and the Color Don’t Care Register</a></h3>
<p>Well, it’s taken five chapters, but we’ve finally covered the data write path and all four write modes of the VGA. Now it’s time to tackle the VGA’s two read modes. While the read modes aren’t as complex as the write modes, they’re nothing to sneeze at. In particular, read mode 1 (also known as color compare mode) is rather unusual and not at all intuitive.</p>
<p>You may well ask, isn’t <em>anything</em> about programming the VGA straightforward? Well…no. But then, clearing up the mysteries of VGA programming is what this part of the book is all about, so let’s get started.</p>
</section>
<section id="read-mode-0" class="level3">
<h3><a href="#read-mode-0">Read Mode 0</a></h3>
<p>Read mode 0 is actually relatively uncomplicated, given that you understand the four-plane nature of the VGA. (If you don’t understand the four-plane nature of the VGA, I strongly urge you to read Chapters 23-27 before continuing with this chapter.) Read mode 0, the read mode counterpart of write mode 0, lets you read from one (and only one) plane of VGA memory at any one time.</p>
<p>Read mode 0 is selected by setting bit 3 of the Graphics Mode register (Graphics Controller register 5) to 0. When read mode 0 is active, the plane that supplies the data when the CPU reads VGA memory is the plane selected by bits 1 and 0 of the Read Map register (Graphics Controller register 4). When the Read Map register is set to 0, CPU reads come from plane 0 (the plane that normally contains blue pixel data). When the Read Map register is set to 1, CPU reads come from plane 1; when the Read Map register is 2, CPU reads come from plane 2; and when the Read Map register is 3, CPU reads come from plane 3.</p>
<p>That all seems simple enough; in read mode 0, the Read Map register acts as a selector among the four planes, determining which one of the planes will supply the value returned to the CPU. There is a slight complication, however, in that the value written to the Read Map register in order to read from a given plane is not the same as the value written to the Map Mask register (Sequence Controller register 2) in order to write to that plane.</p>
<p>Why is that? Well, in read mode 0, one and only one plane can be read at a time, so there are only four possible settings of the Read Map register: 0, 1, 2, or 3, to select reads from plane 0, 1, 2, or 3. In write mode 0, by contrast (in fact, in any write mode), any or all planes may be written to at once, since the byte written by the CPU can “fan out” to multiple planes. Consequently, there are not four but sixteen possible settings of the Map Mask register. The setting of the Map Mask register to write only to plane 0 is 1; to write only to plane 1 is 2; to write only to plane 2 is 4; and to write only to plane 3 is 8.</p>
<p>As you can see, the settings of the Read Map and Map Mask registers for accessing a given plane don’t match. The code in Listing 28.1 illustrates this. Listing 28.1 simply copies a sixteen-color image from system memory to VGA memory, one plane at a time, then animates by repeatedly copying the image back to system memory, again one plane at a time, clearing the old image, and copying the image to a new location in VGA memory. Note the differing settings of the Read Map and Map Mask registers.</p>
<p><strong>LISTING 28.1 L28-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate the use of the Read Map register in read mode 0.</span>
<span class="co">; Animates by copying a 16-color image from VGA memory to system memory,</span>
<span class="co">; one plane at a time, then copying the image back to a new location</span>
<span class="co">; in VGA memory.</span>
<span class="co">;</span>
<span class="co">; By Michael Abrash</span>
<span class="co">;</span>
stacksegmentword stack <span class="st">&#39;STACK&#39;</span>
db512 dup (?)
stackends
<span class="co">;</span>
datasegment    <span class="dt">word</span> <span class="st">&#39;DATA&#39;</span>
IMAGE_WIDTHEQU <span class="dv">4</span>                 <span class="co">;in bytes</span>
IMAGE_HEIGHT   <span class="dt">EQU</span>   <span class="dv">32</span>          <span class="co">;in pixels</span>
LEFT_BOUND     <span class="dt">EQU</span>   <span class="dv">10</span>          <span class="co">;in bytes</span>
RIGHT_BOUND    <span class="dt">EQU</span>   <span class="dv">66</span>          <span class="co">;in bytes</span>
VGA_SEGMENT    <span class="dt">EQU</span><span class="bn">   0a000h</span>
SCREEN_WIDTH   <span class="dt">EQU</span>   <span class="dv">80</span>          <span class="co">;in bytes</span>
SC_INDEX       <span class="dt">EQU</span><span class="bn">   3c4h        </span><span class="co">;Sequence Controller Index register</span>
GC_INDEX       <span class="dt">EQU</span><span class="bn">   3ceh        </span><span class="co">;Graphics Controller Index register</span>
MAP_MASK       <span class="dt">EQU</span>   <span class="dv">2</span>           <span class="co">;Map Mask register index in SC</span>
READ_MAP       <span class="dt">EQU</span>   <span class="dv">4</span>           <span class="co">;Read Map register index in GC</span>
<span class="co">;</span>
                                 <span class="co">; Base pattern for 16-color image.</span>
<span class="co">;</span>
PatternPlane0    label <span class="dt">byte</span>
     <span class="dt">db</span>    <span class="dv">32</span> dup (0ffh<span class="bn">,0ffh,</span><span class="dv">0</span>,<span class="dv">0</span>)
PatternPlane1    labelbyte
     <span class="dt">db</span>    <span class="dv">32</span> dup (0ffh,<span class="dv">0</span><span class="bn">,0ffh,</span><span class="dv">0</span>)
PatternPlane2    labelbyte
     <span class="dt">db</span>    <span class="dv">32</span> dup (0f0h<span class="bn">,0f0h,</span>0f0h,0f0h)
PatternPlane3    labelbyte
     <span class="dt">db</span>    <span class="dv">32</span> dup (0cch<span class="bn">,0cch,</span>0cch,0cch)
<span class="co">;</span>
<span class="co">; Temporary storage for 16-color image during animation.</span>
<span class="co">;</span>
ImagePlane0 <span class="dt">db</span>   <span class="dv">32</span>*<span class="dv">4</span> dup (?)
ImagePlane1 <span class="dt">db</span>   <span class="dv">32</span>*<span class="dv">4</span> dup (?)
ImagePlane2 <span class="dt">db</span>   <span class="dv">32</span>*<span class="dv">4</span> dup (?)
ImagePlane3 <span class="dt">db</span>   <span class="dv">32</span>*<span class="dv">4</span> dup (?)
<span class="co">;</span>
<span class="co">; Current image location &amp; direction.</span>
<span class="co">;</span>
ImageX          <span class="dt">dw</span>  <span class="dv">40</span>           <span class="co">;in bytes</span>
ImageY          <span class="dt">dw</span>  <span class="dv">100</span>          <span class="co">;in pixels</span>
ImageXDirection <span class="dt">dw</span>  <span class="dv">1</span>            <span class="co">;in bytes</span>
dataends
<span class="co">;</span>
code <span class="kw">segment</span>    <span class="dt">word</span> <span class="st">&#39;CODE&#39;</span>
     assume     <span class="kw">cs</span>:code,<span class="kw">ds</span>:data
Start proc  near
     <span class="kw">cld</span>
     <span class="kw">mov</span>  <span class="kw">ax</span>,data
     <span class="kw">mov</span>  <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Select graphics mode 10h.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">ax</span><span class="bn">,10h</span>
     <span class="kw">int</span><span class="bn">  10h</span>
<span class="co">;</span>
<span class="co">; Draw the initial image.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">si</span>,offset PatternPlane0
     <span class="kw">call</span> DrawImage
<span class="co">;</span>
<span class="co">; Loop to animate by copying the image from VGA memory to system memory,</span>
<span class="co">; erasing the image, and copying the image from system memory to a new</span>
<span class="co">; location in VGA memory. Ends when a key is hit.</span>
<span class="co">;</span>
<span class="fu">AnimateLoop:</span>
<span class="co">;</span>
<span class="co">; Copy the image from VGA memory to system memory.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">di</span>,offset ImagePlane0
     <span class="kw">call</span> GetImage
<span class="co">;</span>
<span class="co">; Clear the image from VGA memory.</span>
<span class="co">;</span>
     <span class="kw">call</span> EraseImage
<span class="co">;</span>
<span class="co">; Advance the image X coordinate, reversing direction if either edge</span>
<span class="co">; of the screen has been reached.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">ax</span>,[ImageX]
     <span class="kw">cmp</span>  <span class="kw">ax</span>,LEFT_BOUND
     <span class="kw">jz</span>   ReverseDirection
     <span class="kw">cmp</span>  <span class="kw">ax</span>,RIGHT_BOUND
     <span class="kw">jnz</span>  SetNewX
<span class="fu">ReverseDirection:</span>
     <span class="kw">neg</span>  [ImageXDirection]
<span class="fu">SetNewX:</span>
     <span class="kw">add</span>  <span class="kw">ax</span>,[ImageXDirection]
     <span class="kw">mov</span>  [ImageX],<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Draw the image by copying it from system memory to VGA memory.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">si</span>,offset ImagePlane0
     <span class="kw">call</span> DrawImage
<span class="co">;</span>
<span class="co">; Slow things down a bit for visibility (adjust as needed).</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">cx</span>,<span class="dv">0</span>
<span class="fu">DelayLoop:</span>
     <span class="kw">loop</span> DelayLoop
<span class="co">;</span>
<span class="co">; See if a key has been hit, ending the program.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">ah</span>,<span class="dv">1</span>
     <span class="kw">int</span><span class="bn">  16h</span>
     <span class="kw">jz</span>   AnimateLoop
<span class="co">;</span>
<span class="co">; Clear the key, return to text mode, and return to DOS.</span>
<span class="co">;</span>
     <span class="kw">sub</span>  <span class="kw">ah</span>,<span class="kw">ah</span>
     <span class="kw">int</span><span class="bn">  16h</span>
     <span class="kw">mov</span>  <span class="kw">ax</span>,<span class="dv">3</span>
     <span class="kw">int</span><span class="bn">  10h</span>
     <span class="kw">mov</span>  <span class="kw">ah</span><span class="bn">,4ch</span>
     <span class="kw">int</span><span class="bn">  21h</span>
Startendp
<span class="co">;</span>
<span class="co">; Draws the image at offset DS:SI to the current image location in</span>
<span class="co">; VGA memory.</span>
<span class="co">;</span>
DrawImageprocnear
     <span class="kw">mov</span>  <span class="kw">ax</span>,VGA_SEGMENT
     <span class="kw">mov</span>  <span class="kw">es</span>,<span class="kw">ax</span>
     <span class="kw">call</span> GetImageOffset   <span class="co">;ES:DI is the destination address for the</span>
                      <span class="co">; image in VGA memory</span>
     <span class="kw">mov</span>  <span class="kw">dx</span>,SC_INDEX
     <span class="kw">mov</span>  <span class="kw">al</span>,<span class="dv">1</span>        <span class="co">;do plane 0 first</span>
<span class="fu">DrawImagePlaneLoop:</span>
     <span class="kw">push</span> <span class="kw">di</span>          <span class="co">;image is drawn at the same offset in</span>
                      <span class="co">; each plane</span>
     <span class="kw">push</span> <span class="kw">ax</span>          <span class="co">;preserve plane select</span>
     <span class="kw">mov</span>  <span class="kw">al</span>,MAP_MASK <span class="co">;Map Mask index</span>
     <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>       <span class="co">;point SC Index to the Map Mask register</span>
     <span class="kw">pop</span>  <span class="kw">ax</span>          <span class="co">;get back plane select</span>
     <span class="kw">inc</span>  <span class="kw">dx</span>          <span class="co">;point to SC index register</span>
     <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>       <span class="co">;set up the Map Mask to allow writes to</span>
                      <span class="co">; the plane of interest</span>
     <span class="kw">dec</span>  <span class="kw">dx</span>          <span class="co">;point back to SC Data register</span>
     <span class="kw">mov</span>  <span class="kw">bx</span>,IMAGE_HEIGHT  <span class="co">;# of scan lines in image</span>
<span class="fu">DrawImageLoop:</span>
     <span class="kw">mov</span>  <span class="kw">cx</span>,IMAGE_WIDTH   <span class="co">;# of bytes across image</span>
     rep  <span class="kw">movsb</span>
     <span class="kw">add</span>  <span class="kw">di</span>,SCREEN_WIDTH-IMAGE_WIDTH
                           <span class="co">;point to next scan line of image</span>
     <span class="kw">dec</span>  <span class="kw">bx</span>               <span class="co">;any more scan lines?</span>
     <span class="kw">jnz</span>  DrawImageLoop
     <span class="kw">pop</span>  <span class="kw">di</span>               <span class="co">;get back image start offset in VGA memory</span>
     <span class="kw">shl</span>  <span class="kw">al</span>,<span class="dv">1</span>             <span class="co">;Map Mask setting for next plane</span>
     <span class="kw">cmp</span>  <span class="kw">al</span><span class="bn">,10h           </span><span class="co">;have we done all four planes?</span>
     <span class="kw">jnz</span>  DrawImagePlaneLoop
     <span class="kw">ret</span>
DrawImageendp
<span class="co">;</span>
<span class="co">; Copies the image from its current location in VGA memory into the</span>
<span class="co">; buffer at DS:DI.</span>
<span class="co">;</span>
GetImage  proc near
     <span class="kw">mov</span>  <span class="kw">si</span>,<span class="kw">di</span>             <span class="co">;move destination offset into SI</span>
     <span class="kw">call</span> GetImageOffset    <span class="co">;DI is offset of image in VGA memory</span>
     <span class="kw">xchg</span> <span class="kw">si</span>,<span class="kw">di</span>             <span class="co">;SI is offset of image, DI is destination offset</span>
     <span class="kw">push</span> <span class="kw">ds</span>
     <span class="kw">pop</span>  <span class="kw">es</span>                <span class="co">;ES:DI is destination</span>
     <span class="kw">mov</span>  <span class="kw">ax</span>,VGA_SEGMENT
     <span class="kw">mov</span>  <span class="kw">ds</span>,<span class="kw">ax</span>             <span class="co">;DS:SI is source</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">dx</span>,GC_INDEX
     <span class="kw">sub</span>  <span class="kw">al</span>,<span class="kw">al</span><span class="co">;do plane 0 first</span>
<span class="fu">GetImagePlaneLoop:</span>
     <span class="kw">push</span> <span class="kw">si</span>                <span class="co">;image comes from same offset in each plane</span>
     <span class="kw">push</span> <span class="kw">ax</span>                <span class="co">;preserve plane select</span>
     <span class="kw">mov</span>  <span class="kw">al</span>,READ_MAP       <span class="co">;Read Map index</span>
     <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>             <span class="co">;point GC Index to Read Map register</span>
     <span class="kw">pop</span>  <span class="kw">ax</span>                <span class="co">;get back plane select</span>
     <span class="kw">inc</span>  <span class="kw">dx</span>                <span class="co">;point to GC Index register</span>
     <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>             <span class="co">;set up the Read Map to select reads from</span>
                            <span class="co">; the plane of interest</span>
     <span class="kw">dec</span>  <span class="kw">dx</span>                <span class="co">;point back to GC data register</span>
     <span class="kw">mov</span>  <span class="kw">bx</span>,IMAGE_HEIGHT   <span class="co">;# of scan lines in image</span>
<span class="fu">GetImageLoop:</span>
     <span class="kw">mov</span>  <span class="kw">cx</span>,IMAGE_WIDTH    <span class="co">;# of bytes across image</span>
     rep  <span class="kw">movsb</span>
     <span class="kw">add</span>  <span class="kw">si</span>,SCREEN_WIDTH-IMAGE_WIDTH
                            <span class="co">;point to next scan line of image</span>
     <span class="kw">dec</span>  <span class="kw">bx</span>                <span class="co">;any more scan lines?</span>
     <span class="kw">jnz</span>  GetImageLoop
     <span class="kw">pop</span>  <span class="kw">si</span>                <span class="co">;get back image start offset</span>
     <span class="kw">inc</span>  <span class="kw">al</span>                <span class="co">;Read Map setting for next plane</span>
     <span class="kw">cmp</span>  <span class="kw">al</span>,<span class="dv">4</span>              <span class="co">;have we done all four planes?</span>
     <span class="kw">jnz</span>  GetImagePlaneLoop
     <span class="kw">push</span> <span class="kw">es</span>
     <span class="kw">pop</span>  <span class="kw">ds</span>                <span class="co">;restore original DS</span>
     <span class="kw">ret</span>
GetImageendp
<span class="co">;</span>
<span class="co">; Erases the image at its current location.</span>
<span class="co">;</span>
EraseImage proc near
     <span class="kw">mov</span>  <span class="kw">dx</span>,SC_INDEX
     <span class="kw">mov</span>  <span class="kw">al</span>,MAP_MASK
     <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>             <span class="co">;point SC Index to the Map Mask register</span>
     <span class="kw">inc</span>  <span class="kw">dx</span>                <span class="co">;point to SC Data register</span>
     <span class="kw">mov</span>  <span class="kw">al</span><span class="bn">,0fh</span>
     <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>             <span class="co">;set up the Map Mask to allow writes to go to</span>
                            <span class="co">; all 4 planes</span>
     <span class="kw">mov</span>  <span class="kw">ax</span>,VGA_SEGMENT
     <span class="kw">mov</span>  <span class="kw">es</span>,<span class="kw">ax</span>
     <span class="kw">call</span> GetImageOffset    <span class="co">;ES:DI points to the start address</span>
                            <span class="co">; of the image</span>
     <span class="kw">sub</span>  <span class="kw">al</span>,<span class="kw">al</span>             <span class="co">;erase with zeros</span>
     <span class="kw">mov</span>  <span class="kw">bx</span>,IMAGE_HEIGHT   <span class="co">;# of scan lines in image</span>
<span class="fu">EraseImageLoop:</span>
     <span class="kw">mov</span>  <span class="kw">cx</span>,IMAGE_WIDTH    <span class="co">;# of bytes across image</span>
     rep  <span class="kw">stosb</span>
     <span class="kw">add</span>  <span class="kw">di</span>,SCREEN_WIDTH-IMAGE_WIDTH
                            <span class="co">;point to next scan line of image</span>
     <span class="kw">dec</span>  <span class="kw">bx</span>                <span class="co">;any more scan lines?</span>
     <span class="kw">jnz</span>  EraseImageLoop
     <span class="kw">ret</span>
EraseImage endp
<span class="co">;</span>
<span class="co">; Returns the current offset of the image in the VGA segment in DI.</span>
<span class="co">;</span>
GetImageOffset proc near
     <span class="kw">mov</span>  <span class="kw">ax</span>,SCREEN_WIDTH
     <span class="kw">mul</span>  [ImageY]
     <span class="kw">add</span>  <span class="kw">ax</span>,[ImageX]
     <span class="kw">mov</span>  <span class="kw">di</span>,<span class="kw">ax</span>
     <span class="kw">ret</span>
GetImageOffset endp
code  ends
     end  Start</code></pre>
<p>By the way, the code in Listing 28.1 is intended only to illustrate read mode 0, and is, in general, a poor way to perform animation, since it’s slow and tends to flicker. Later in this book, we’ll take a look at some far better VGA animation techniques.</p>
<p>As you’d expect, neither the read mode nor the setting of the Read Map register affects CPU <em>writes</em> to VGA memory in any way.</p>
<blockquote>
<p><img src="images/i.jpg" /> An important point regarding reading VGA memory involves the VGA’s latches. (Remember that each of the four latches stores a byte for one plane; on CPU writes, the latches can provide some or all of the data written to display memory, allowing fast copying and efficient pixel masking.) Whenever the CPU reads a given address in VGA memory, each of the four latches is loaded with the contents of the byte at that address in its respective plane. Even though the CPU only receives data from one plane in read mode 0, all four planes are always read, and the values read are stored in the latches. This is true in read mode 1 as well. In short, whenever the CPU reads VGA memory in any read mode, all four planes are read and all four latches are always loaded.</p>
</blockquote>
</section>
<section id="read-mode-1" class="level3">
<h3><a href="#read-mode-1">Read Mode 1</a></h3>
<p>Read mode 0 is the workhorse read mode, but it’s got an annoying limitation: Whenever you want to determine the color of a given pixel in read mode 0, you have to perform four VGA memory reads, one for each plane, and then interpret the four bytes you’ve read as eight 16-color pixels. That’s a lot of programming. The code is also likely to run slowly, all the more so because a standard IBM VGA takes an average of 1.1 microseconds to complete each memory read, and read mode 0 requires four reads in order to read the four planes, not to mention the even greater amount of time taken by the <code>OUT</code>s required to switch between the planes. (1.1 microseconds may not sound like much, but on a 66-MHz 486, it’s 73 clock cycles! Local-bus VGAs can be a good deal faster, but a read from the fastest local-bus adapter I’ve yet seen would still cost in the neighborhood of 10 486/66 cycles.)</p>
<p>Read mode 1, also known as <em>color compare mode</em>, provides special hardware assistance for determining whether a pixel is a given color. With a single read mode 1 read, you can determine whether each of up to eight pixels is a specific color, and you can even specify any or all planes as “don’t care” planes in the pixel color comparison.</p>
<p>Read mode 1 is selected by setting bit 3 of the Graphics Mode register (Graphics Controller register 5) to 1. In its simplest form, read mode 1 compares the cross-plane value of each of the eight pixels at a given address to the color value in bits 3-0 of the Color Compare register (Graphics Controller register 2), and returns a 1 to the CPU in the bit position of each pixel that matches the color in the Color Compare register and a 0 for each pixel that does not match.</p>
<p>That’s certainly interesting, but what’s read mode 1 good for? One obvious application is in implementing flood-fill algorithms, since read mode 1 makes it easy to tell when a given byte contains a pixel of a boundary color. Another application is in detecting on-screen object collisions, as illustrated by the code in Listing 28.2.</p>
<p><strong>LISTING 28.2 L28-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate use of read mode 1 (color compare mode)</span>
<span class="co">; to detect collisions in display memory. Draws a yellow line on a</span>
<span class="co">; blue background, then draws a perpendicular green line until the</span>
<span class="co">; yellow line is reached.</span>
<span class="co">;</span>
<span class="co">; By Michael Abrash</span>
<span class="co">;</span>
stack <span class="kw">segment</span>     <span class="dt">word</span> stack `STACK<span class="st">&#39;</span>
      <span class="dt">db</span>    <span class="dv">512</span> dup (?)
stack ends
<span class="co">;</span>
VGA_SEGMENT       <span class="dt">EQU</span><span class="bn">    0a000h</span>
SCREEN_WIDTH             <span class="dt">EQU</span>   <span class="dv">80</span>    <span class="co">;in bytes</span>
GC_INDEX          <span class="dt">EQU</span><span class="bn">    3ceh        </span><span class="co">;Graphics Controller Index register</span>
SET_RESET         <span class="dt">EQU</span>    <span class="dv">0</span>           <span class="co">;Set/Reset register index in GC</span>
ENABLE_SET_RESET  <span class="dt">EQU</span>    <span class="dv">1</span>           <span class="co">;Enable Set/Reset register index in GC</span>
COLOR_COMPARE     <span class="dt">EQU</span>    <span class="dv">2</span>           <span class="co">;Color Compare register index in GC</span>
GRAPHICS_MODE     <span class="dt">EQU</span>    <span class="dv">5</span>           <span class="co">;Graphics Mode register index in GC</span>
BIT_MASK          <span class="dt">EQU</span>    <span class="dv">8</span>           <span class="co">;Bit Mask register index in GC</span>
<span class="co">;</span>
code              <span class="kw">segment</span>   <span class="dt">word</span> `CODE<span class="st">&#39;</span>
                  assume    <span class="kw">cs</span>:code
Start             proc      near
                  <span class="kw">cld</span>
<span class="co">;</span>
<span class="co">; Select graphics mode 10h.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">ax</span><span class="bn">,10h</span>
     <span class="kw">int</span><span class="bn">    10h</span>
<span class="co">;</span>
<span class="co">; Fill the screen with blue.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">al</span>,<span class="dv">1</span>                  <span class="co">;blue is color 1</span>
     <span class="kw">call</span>   SelectSetResetColor   <span class="co">;set to draw in blue</span>
     <span class="kw">mov</span>    <span class="kw">ax</span>,VGA_SEGMENT
     move   s,<span class="kw">ax</span>
     <span class="kw">sub</span>    <span class="kw">di</span>,<span class="kw">di</span>
     <span class="kw">mov</span>    <span class="kw">cx</span><span class="bn">,7000h</span>
     rep    <span class="kw">stosb</span>                 <span class="co">;the value written actually doesn&#39;t</span>
<span class="co">; matter, since set/reset is providing</span>
<span class="co">; the data written to display memory</span>
<span class="co">;</span>
<span class="co">; Draw a vertical yellow line.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">al</span>,<span class="dv">14</span>                 <span class="co">;yellow is color 14</span>
     <span class="kw">call</span>   SelectSetResetColor   <span class="co">;set to draw in yellow</span>
     <span class="kw">mov</span>    <span class="kw">dx</span>,GC_INDEX
     <span class="kw">mov</span>    <span class="kw">al</span>,BIT_MASK
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                 <span class="co">;point GC Index to Bit Mask</span>
     <span class="kw">inc</span>    <span class="kw">dx</span>                    <span class="co">;point to GC Data</span>
     <span class="kw">mov</span>    <span class="kw">al</span><span class="bn">,10h</span>
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                 <span class="co">;set Bit Mask to 10h</span>
     <span class="kw">mov</span>    <span class="kw">di</span>,<span class="dv">40</span>                 <span class="co">;start in the middle of the top line</span>
     <span class="kw">mov</span>    <span class="kw">cx</span>,<span class="dv">350</span>                <span class="co">;do full height of screen</span>
<span class="fu">VLineLoop:</span>
     <span class="kw">mov</span>    <span class="kw">al</span>,<span class="kw">es</span>:[<span class="kw">di</span>]            <span class="co">;load the latches</span>
     <span class="kw">stosb</span>                        <span class="co">;write next pixel of yellow line (set/reset</span>
<span class="co">; provides the data written to display</span>
<span class="co">; memory, and AL is actually ignored)</span>
     <span class="kw">add</span>    <span class="kw">di</span>,SCREEN_WIDTH<span class="dv">-1</span>     <span class="co">;point to the next scan line</span>
loopVLineLoop
<span class="co">;</span>
<span class="co">; Select write mode 0 and read mode 1.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">dx</span>,GC_INDEX
     <span class="kw">mov</span>    <span class="kw">al</span>,GRAPHICS_MODE
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                 <span class="co">;point GC Index to Graphics Mode register</span>
     <span class="kw">inc</span>    <span class="kw">dx</span>                    <span class="co">;point to GC Data</span>
     <span class="kw">mov</span>    <span class="kw">al</span><span class="bn">,00001000b          </span><span class="co">;bit 3=1 is read mode 1, bits 1 &amp; 0=00</span>
                                  <span class="co">; is write mode 0</span>
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                 <span class="co">;set Graphics Mode to read mode 1,</span>
                                  <span class="co">; write mode 0</span>
<span class="co">;</span>
<span class="co">; Draw a horizontal green line, one pixel at a time, from left</span>
<span class="co">; to right until color compare reports a yellow pixel is encountered.</span>
<span class="co">;</span>
<span class="co">; Draw in green.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">al</span>,<span class="dv">2</span>                  <span class="co">;green is color 2</span>
     <span class="kw">call</span>    SelectSetResetColor  <span class="co">;set to draw in green</span>
<span class="co">;</span>
<span class="co">; Set color compare to look for yellow.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">dx</span>,GC_INDEX
     <span class="kw">mov</span>    <span class="kw">al</span>,COLOR_COMPARE
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                 <span class="co">;point GC Index to Color Compare register</span>
     <span class="kw">inc</span>    <span class="kw">dx</span>                    <span class="co">;point to GC Data</span>
     <span class="kw">mov</span>    <span class="kw">al</span>,<span class="dv">14</span>                 <span class="co">;we&#39;re looking for yellow, color 14</span>
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                 <span class="co">;set color compare to look for yellow</span>
     <span class="kw">dec</span>    <span class="kw">dx</span>                    <span class="co">;point to GC Index</span>
<span class="co">;</span>
<span class="co">; Set up for quick access to Bit Mask register.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">al</span>,BIT_MASK
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                 <span class="co">;point GC Index to Bit Mask register</span>
     <span class="kw">inc</span>    <span class="kw">dx</span>                    <span class="co">;point to GC Data</span>
<span class="co">;</span>
<span class="co">; Set initial pixel mask and display memory offset.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">al</span><span class="bn">,80h                </span><span class="co">;initial pixel mask</span>
     <span class="kw">mov</span>    <span class="kw">di</span>,<span class="dv">100</span>*SCREEN_WIDTH
                                  <span class="co">;start at left edge of scan line 100</span>
<span class="fu">HLineLoop:</span>
     <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="kw">es</span>:[<span class="kw">di</span>]            <span class="co">;do a read mode 1 (color compare) read.</span>
                                  <span class="co">; This also loads the latches.</span>
     <span class="kw">and</span>    <span class="kw">ah</span>,<span class="kw">al</span>                 <span class="co">;is the pixel of current interest yellow?</span>
     <span class="kw">jnz</span>    WaitKeyAndDone        <span class="co">;yes-we&#39;ve reached the yellow line, so we&#39;re</span>
                                  <span class="co">; done</span>
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                 <span class="co">;set the Bit Mask register so that we</span>
                                  <span class="co">; modify only the pixel of interest</span>
     <span class="kw">mov</span>    <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">al</span>            <span class="co">;draw the pixel. The value written is</span>
                                  <span class="co">; irrelevant, since set/reset is providing</span>
                                  <span class="co">; the data written to display memory</span>
     <span class="kw">ror</span>    <span class="kw">al</span>,<span class="dv">1</span>                  <span class="co">;shift pixel mask to the next pixel</span>
     <span class="kw">adc</span>    <span class="kw">di</span>,<span class="dv">0</span>                  <span class="co">;advance the display memory offset if</span>
                                  <span class="co">; the pixel mask wrapped</span>
<span class="co">;</span>
<span class="co">; Slow things down a bit for visibility (adjust as needed).</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">cx</span>,<span class="dv">0</span>
<span class="fu">DelayLoop:</span>
     <span class="kw">loop</span>   DelayLoop
     <span class="kw">jmp</span>    HLineLoop
<span class="co">;</span>
<span class="co">; Wait for a key to be pressed to end, then return to text mode and</span>
<span class="co">; return to DOS.</span>
<span class="co">;</span>
<span class="fu">WaitKeyAndDone:</span>
<span class="fu">WaitKeyLoop:</span>
     <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="dv">1</span>
     <span class="kw">int</span><span class="bn">    16h</span>
     <span class="kw">jz</span>    WaitKeyLoop
     <span class="kw">sub</span>    <span class="kw">ah</span>,<span class="kw">ah</span>
     <span class="kw">int</span><span class="bn">    16h                   </span><span class="co">;clear the key</span>
     <span class="kw">mov</span>    <span class="kw">ax</span>,<span class="dv">3</span>
     <span class="kw">int</span><span class="bn">    10h                   </span><span class="co">;return to text mode</span>
     <span class="kw">mov</span>    <span class="kw">ah</span><span class="bn">,4ch</span>
     <span class="kw">int</span><span class="bn">    21h                   </span><span class="co">;done</span>
Startendp
<span class="co">;</span>
<span class="co">; Enables set/reset for all planes, and sets the set/reset color</span>
<span class="co">; to AL.</span>
<span class="co">;</span>
SelectSetResetColorprocnear
     <span class="kw">mov</span>    <span class="kw">dx</span>,GC_INDEX
     <span class="kw">push</span>   <span class="kw">ax</span>                    <span class="co">;preserve color</span>
     <span class="kw">mov</span>    <span class="kw">al</span>,SET_RESET
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                 <span class="co">;point GC Index to Set/Reset register</span>
     <span class="kw">inc</span>    <span class="kw">dx</span>                    <span class="co">;point to GC Data</span>
     <span class="kw">pop</span>    <span class="kw">ax</span>                    <span class="co">;get back color</span>
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                 <span class="co">;set Set/Reset register to selected color</span>
     <span class="kw">dec</span>    <span class="kw">dx</span>                    <span class="co">;point to GC Index</span>
     <span class="kw">mov</span>    <span class="kw">al</span>,ENABLE_SET_RESET
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                 <span class="co">;point GC Index to Enable Set/Reset register</span>
     <span class="kw">inc</span>    <span class="kw">dx</span>                    <span class="co">;point to GC Data</span>
     <span class="kw">mov</span>    <span class="kw">al</span><span class="bn">,0fh</span>
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                 <span class="co">;enable set/reset for all planes</span>
     <span class="kw">ret</span>
SelectSetResetColorendp
code ends
end  Start</code></pre>
</section>
<section id="when-all-planes-dont-care" class="level3">
<h3><a href="#when-all-planes-dont-care">When all Planes “Don’t Care”</a></h3>
<p>Still and all, there aren’t all that many uses for basic color compare operations. There is, however, a genuinely odd application of read mode 1 that’s worth knowing about; but in order to understand that, we must first look at the “don’t care” aspect of color compare operation.</p>
<p>As described earlier, during read mode 1 reads the color stored in the Color Compare register is compared to each of the 8 pixels at a given address in VGA memory. But—and it’s a big but—any plane for which the corresponding bit in the Color Don’t Care register is a 0 is always considered a color compare match, regardless of the values of that plane’s bits in the pixels and in the Color Compare register.</p>
<p>Let’s look at this another way. A given pixel is controlled by four bits, one in each plane. Normally (when the Color Don’t Care register is 0FH), the color in the Color Compare register is compared to the four bits of each pixel; bit 0 of the Color Compare register is compared to the plane 0 bit of each pixel, bit 1 of the Color Compare register is compared to the plane 1 bit of each pixel, and so on. That is, when the lower four bits of the Color Don’t Care register are all set to 1, then all four bits of a given pixel must match the Color Compare register in order for a read mode 1 read to return a 1 for that pixel to the CPU.</p>
<p>However, if any bit of the Color Don’t Care register is 0, then the corresponding bit of each pixel is unconditionally considered to match the corresponding bit of the Color Compare register. You might think of the Color Don’t Care register as selecting exactly which planes should matter in a given read mode 1 read. At the extreme, if all bits of the Color Don’t Care register are 0, then read mode 1 reads will always return 0FFH, since all planes are considered to match all bits of all pixels.</p>
<p>Now, we’re all prone to using tools the “right” way—that is, in the way in which they were intended to be used. By that token, the Color Don’t Care register is clearly intended to mask one or more planes out of a color comparison, and as such, has limited use. However, the Color Don’t Care register becomes far more interesting in exactly the “extreme” case described above, where all planes become “don’t care” planes.</p>
<p>Why? Well, as I’ve said, when all planes are “don’t care” planes, read mode 1 reads always return 0FFH. Now, when you AND any value with 0FFH, the value remains unchanged, and that can be awfully handy when you’re using the bit mask to modify selected pixels in VGA memory. Recall that you must always read VGA memory to load the latches before writing to VGA memory when you’re using the bit mask. Traditionally, two separate instructions—a read followed by a write—are used to perform this task. The code in Listing 28.2 uses this approach. Suppose, however, that you’ve set the VGA to read mode 1, with the Color Don’t Care register set to 0 (meaning all reads of VGA memory will return 0FFH). Under these circumstances, you can use a single <code>AND</code> instruction to both read and write VGA memory, since ANDing any value with 0FFH leaves that value unchanged.</p>
<p>Listing 28.3 illustrates an efficient use of write mode 3 in conjunction with read mode 1 and a Color Don’t Care register setting of 0. The mask in AL is passed directly to the VGA’s bit mask (that’s how write mode 3 works—see Chapter 4 for details). Because the VGA always returns 0FFH, the single <code>AND</code> instruction loads the latches, and writes the value in AL, unmodified, to the VGA, where it is used to generate the bit mask. This is more compact and register-efficient than using separate instructions to read and write, although it is not necessarily faster by cycle count, because on a 486 or a Pentium <code>MOV</code> is a 1-cycle instruction, but <code>AND</code> with memory is a 3-cycle instruction. However, given display memory wait states, it is often the case that the two approaches run at the same speed, and the register that the above approach frees up can frequently be used to save one or more cycles in any case.</p>
<p>By the way, Listing 28.3 illustrates how write mode 3 can make for excellent pixel- and line-drawing code.</p>
<p><strong>LISTING 28.3 L28-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program that draws a diagonal line to illustrate the use of a</span>
<span class="co">; Color Don&#39;t Care register setting of 0FFH to support fast</span>
<span class="co">; read-modify-write operations to VGA memory in write mode 3 by</span>
<span class="co">; drawing a diagonal line.</span>
<span class="co">;</span>
<span class="co">; Note: Works on VGAs only.</span>
<span class="co">;</span>
<span class="co">; By Michael Abrash</span>
<span class="co">;</span>
stack <span class="kw">segment</span>  <span class="dt">word</span> stack <span class="st">&#39;STACK&#39;</span>
     <span class="dt">db</span>  <span class="dv">512</span> dup (?)
stackends
<span class="co">;</span>
VGA_SEGMENT      <span class="dt">EQU</span><span class="bn">  0a000h</span>
SCREEN_WIDTH     <span class="dt">EQU</span>  <span class="dv">80</span>           <span class="co">;in bytes</span>
GC_INDEX         <span class="dt">EQU</span><span class="bn">  3ceh         </span><span class="co">;Graphics Controller Index register</span>
SET_RESET        <span class="dt">EQU</span>  <span class="dv">0</span>            <span class="co">;Set/Reset register index in GC</span>
ENABLE_SET_RESET <span class="dt">EQU</span>  <span class="dv">1</span>            <span class="co">;Enable Set/Reset register index in GC</span>
GRAPHICS_MODE    <span class="dt">EQU</span>  <span class="dv">5</span>            <span class="co">;Graphics Mode register index in GC</span>
COLOR_DONT_CARE  <span class="dt">EQU</span>  <span class="dv">7</span>            <span class="co">;Color Don&#39;t Care register index in GC</span>
<span class="co">;</span>
code  <span class="kw">segment</span>  <span class="dt">word</span> <span class="st">&#39;CODE&#39;</span>
     assume    <span class="kw">cs</span>:code
Startprocnear
<span class="co">;</span>
<span class="co">; Select graphics mode 12h.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">ax</span><span class="bn">,12h</span>
     <span class="kw">int</span><span class="bn">  10h</span>
<span class="co">;</span>
<span class="co">; Select write mode 3 and read mode 1.</span>
<span class="co">;</span>
     <span class="kw">mov</span>  <span class="kw">dx</span>,GC_INDEX
     <span class="kw">mov</span>  <span class="kw">al</span>,GRAPHICS_MODE
     <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>
     <span class="kw">inc</span>  <span class="kw">dx</span>
     <span class="kw">in</span>   <span class="kw">al</span>,<span class="kw">dx</span>               <span class="co">;VGA registers are readable, bless them!</span>
     <span class="kw">or</span>   <span class="kw">al</span><span class="bn">,00001011b        </span><span class="co">;bit 3=1 selects read mode 1, and</span>
                              <span class="co">; bits 1 &amp; 0=11 selects write mode 3</span>
    <span class="kw">jmp</span>   <span class="dv">$</span>+<span class="dv">2</span>                 <span class="co">;delay between IN and OUT to same port</span>
    <span class="kw">out</span>   <span class="kw">dx</span>,<span class="kw">al</span>
    <span class="kw">dec</span>   <span class="kw">dx</span>
<span class="co">;</span>
<span class="co">; Set up set/reset to always draw in white.</span>
<span class="co">;</span>
    <span class="kw">mov</span>  <span class="kw">al</span>,SET_RESET
    <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>
    <span class="kw">inc</span>  <span class="kw">dx</span>
    <span class="kw">mov</span>  <span class="kw">al</span><span class="bn">,0fh</span>
    <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>
    <span class="kw">dec</span>  <span class="kw">dx</span>
    <span class="kw">mov</span>  <span class="kw">al</span>,ENABLE_SET_RESET
    <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>
    <span class="kw">inc</span>  <span class="kw">dx</span>
    <span class="kw">mov</span>  <span class="kw">al</span><span class="bn">,0fh</span>
    <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>
    <span class="kw">dec</span>  <span class="kw">dx</span>
<span class="co">;</span>
<span class="co">; Set Color Don&#39;t Care to 0, so reads of VGA memory always return 0FFH.</span>
<span class="co">;</span>
    <span class="kw">mov</span>  <span class="kw">al</span>,COLOR_DONT_CARE
    <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>
    <span class="kw">inc</span>  <span class="kw">dx</span>
    <span class="kw">sub</span>  <span class="kw">al</span>,<span class="kw">al</span>
    <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Set up the initial memory pointer and pixel mask.</span>
<span class="co">;</span>
    <span class="kw">mov</span>  <span class="kw">ax</span>,VGA_SEGMENT
    <span class="kw">mov</span>  <span class="kw">ds</span>,<span class="kw">ax</span>
    <span class="kw">sub</span>  <span class="kw">bx</span>,<span class="kw">bx</span>
    <span class="kw">mov</span>  <span class="kw">al</span><span class="bn">,80h</span>
<span class="co">;</span>
<span class="co">; Draw 400 points on a diagonal line sloping down and to the right.</span>
<span class="co">;</span>
    <span class="kw">mov</span>  <span class="kw">cx</span>,<span class="dv">400</span>
<span class="fu">DrawDiagonalLoop:</span>
    <span class="kw">and</span>  [<span class="kw">bx</span>],<span class="kw">al</span>            <span class="co">;reads display memory, loading the latches,</span>
                            <span class="co">; then writes AL to the VGA. AL becomes the</span>
                            <span class="co">; bit mask, and set/reset provides the</span>
                            <span class="co">; actual data written</span>
    <span class="kw">add</span>  <span class="kw">bx</span>,SCREEN_WIDTH
                            <span class="co">; point to the next scan line</span>
    <span class="kw">ror</span>  <span class="kw">al</span>,<span class="dv">1</span>               <span class="co">;move the pixel mask one pixel to the right</span>
    <span class="kw">adc</span>  <span class="kw">bx</span>,<span class="dv">0</span>               <span class="co">;advance to the next byte if the pixel mask wrapped</span>
loopDrawDiagonalLoop
<span class="co">;</span>
<span class="co">; Wait for a key to be pressed to end, then return to text mode and</span>
<span class="co">; return to DOS.</span>
<span class="co">;</span>
<span class="fu">WaitKeyLoop:</span>
    <span class="kw">mov</span>  <span class="kw">ah</span>,<span class="dv">1</span>
    <span class="kw">int</span><span class="bn">  16h</span>
    <span class="kw">jz</span>   WaitKeyLoop
    <span class="kw">sub</span>  <span class="kw">ah</span>,<span class="kw">ah</span>
    <span class="kw">int</span><span class="bn">  16h                </span><span class="co">;clear the key</span>
    <span class="kw">mov</span>  <span class="kw">ax</span>,<span class="dv">3</span>
    <span class="kw">int</span><span class="bn">  10h                </span><span class="co">;return to text mode</span>
    <span class="kw">mov</span>  <span class="kw">ah</span><span class="bn">,4ch</span>
    <span class="kw">int</span><span class="bn">  21h                </span><span class="co">;done</span>
Startendp
code ends
    end  Start</code></pre>
<p>I hope I’ve given you a good feel for what color compare mode is and what it might be used for. Color compare mode isn’t particularly easy to understand, but it’s not that complicated in actual operation, and it’s certainly useful at times; take some time to study the sample code and perform a few experiments of your own, and you may well find useful applications for color compare mode in your graphics code.</p>
<p>A final note: The Read Map register has no effect in read mode 1, and the Color Compare and Color Don’t Care registers have no effect either in read mode 0 or when writing to VGA memory. And with that, by gosh, we’re actually done with the basics of accessing VGA memory!</p>
<p>Not to worry—that still leaves us a slew of interesting VGA topics, including smooth panning and scrolling, the split screen, color selection, page flipping, and Mode X. And that’s not to mention actual uses to which the VGA’s hardware can be put, including lines, circles, polygons, and my personal favorite, animation. We’ve covered a lot of challenging and rewarding ground—and we’ve only just begun.</p>
</section>
</section>
<section id="chapter-29-saving-screens-and-other-vga-mysteries" class="level2">
<h2><a href="#chapter-29-saving-screens-and-other-vga-mysteries">Chapter 29 – Saving Screens and Other VGA Mysteries</a></h2>
<section id="useful-nuggets-from-the-vga-zen-file" class="level3">
<h3><a href="#useful-nuggets-from-the-vga-zen-file">Useful Nuggets from the VGA Zen File</a></h3>
<p>There are a number of VGA graphics topics that aren’t quite involved enough to warrant their own chapters, yet still cause a fair amount of programmer headscratching—and thus deserve treatment somewhere in this book. This is the place, and during the course of this chapter we’ll touch on saving and restoring 16-color EGA and VGA screens, the 16-out-of-64 colors issue, and techniques involved in reading and writing VGA control registers.</p>
<p>That’s a lot of ground to cover, so let’s get started!</p>
</section>
<section id="saving-and-restoring-ega-and-vga-screens" class="level3">
<h3><a href="#saving-and-restoring-ega-and-vga-screens">Saving and Restoring EGA and VGA Screens</a></h3>
<p>The memory architectures of EGAs and VGAs are similar enough to treat both together in this regard. The basic principle for saving EGA and VGA 16-color graphics screens is astonishingly simple: Write each plane to disk separately. Let’s take a look at how this works in the EGA’s hi-res mode 10H, which provides 16 colors at 640x350.</p>
<p>All we need do is enable reads from plane 0 and write the 28,000 bytes of plane 0 that are displayed in mode 10H to disk, then enable reads from plane 1 and write the displayed portion of that plane to disk, and so on for planes 2 and 3. The result is a file that’s 112,000 (28,000 * 4) bytes long, with the planes stored as four distinct 28,000-byte blocks, as shown in Figure 29.1.</p>
<p>The program shown later on in Listing 29.1 does just what I’ve described here, putting the screen into mode 10H, putting up some bittext so there is something to save, and creating the 112K file SNAPSHOT.SCR, which contains the visible portion of the mode 10H frame buffer.</p>
<figure>
<img src="images/29-01.jpg" alt="Figure 29.1  Saving EGA/VGA display memory." /><figcaption><strong>Figure 29.1</strong>  <em>Saving EGA/VGA display memory.</em></figcaption>
</figure>
<p>The only part of Listing 29.1 that’s even remotely tricky is the use of the Read Map register (Graphics Controller register 4) to make each of the four planes of display memory readable in turn. The same code is used to write 28,000 bytes of display memory to disk four times, and 28,000 bytes of memory starting at A000:0000 are written to disk each time; however, a different plane is read each time, thanks to the changing setting of the Read Map register. (If this is unclear, refer back to Figure 29.1; you may also want to reread Chapter 28 to brush up on the operation of the Read Map register in particular and reading EGA and VGA memory in general.)</p>
<p>Of course, we’ll want the ability to restore what we’ve saved, and Listing 29.2 does this. Listing 29.2 reverses the action of Listing 29.1, selecting mode 10H and then loading 28,000 bytes from SNAPSHOT.SCR into each plane of display memory. The Map Mask register (Sequence Controller register 2) is used to select the plane to be written to. If your computer is slow enough, you can see the colors of the text change as each plane is loaded when Listing 29.2 runs. Note that Listing 29.2 does not itself draw any text, but rather simply loads the bit map saved by Listing 29.1 back into the mode 10H frame buffer.</p>
<p><strong>LISTING 29.1 L29-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to put up a mode 10h EGA graphics screen, then save it</span>
<span class="co">; to the file SNAPSHOT.SCR.</span>
<span class="co">;</span>
VGA_SEGMENT                 <span class="dt">equ</span><span class="bn">   0a000h</span>
GC_INDEX                    <span class="dt">equ</span><span class="bn">   3ceh             </span><span class="co">;Graphics Controller Index register</span>
READ_MAP                    <span class="dt">equ</span>   <span class="dv">4</span>                <span class="co">;Read Map register index in GC</span>
DISPLAYED_SCREEN_SIZE       <span class="dt">equ</span>  (<span class="dv">640</span>/<span class="dv">8</span>)*<span class="dv">350</span>       <span class="co">;# of displayed bytes per plane in a</span>
                                                   <span class="co">; hi-res graphics screen</span>
<span class="co">;</span>
stack      <span class="kw">segment</span> para stack ‘STACK<span class="st">&#39;</span>
                 <span class="dt">db</span>                  <span class="dv">512</span> dup (?)
stack      ends
<span class="co">;</span>
Data       <span class="kw">segment</span>     <span class="dt">word</span> ‘DATA<span class="st">&#39;</span>
SampleText       <span class="dt">db</span>    ‘This is bit-mapped text, drawn <span class="kw">in</span> hi-res <span class="st">&#39;</span>
                 <span class="dt">db</span>    ‘EGA graphics mode 10h.<span class="st">&#39;, 0dh, 0ah, 0ah</span>
                 <span class="dt">db</span>    ‘Saving the screen (including this text)...<span class="st">&#39;</span>
                 <span class="dt">db</span><span class="bn">    0dh, </span>0ah, ‘<span class="dv">$</span><span class="st">&#39;</span>
Filename         <span class="dt">db</span>    ‘SNAPSHOT.SCR<span class="st">&#39;,0   ;name of file we&#39;</span>re saving to
ErrMsg1          <span class="dt">db</span>    ‘*** Couldn<span class="st">&#39;t open SNAPSHOT.SCR ***&#39;</span><span class="bn">,0dh,</span>0ah,‘<span class="dv">$</span><span class="st">&#39;</span>
ErrMsg2          <span class="dt">db</span>    ‘*** Error writing to SNAPSHOT.SCR ***<span class="st">&#39;,0dh,0ah,‘$&#39;</span>
WaitKeyMsg       <span class="dt">db</span><span class="bn">    0dh, </span>0ah, ‘Done. Press any key to end...<span class="st">&#39;,0dh,0ah,‘$&#39;</span>
Handle           <span class="dt">dw</span>    ?                           <span class="co">;handle of file we&#39;re saving to</span>
Plane            <span class="dt">db</span>    ?                           <span class="co">;plane being read</span>
Data  ends
<span class="co">;</span>
Code           <span class="kw">segment</span>
               assume   <span class="kw">cs</span>:Code, <span class="kw">ds</span>:Data
Start          proc     near
               <span class="kw">mov</span>      <span class="kw">ax</span>,Data
               <span class="kw">mov</span>      <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Go to hi-res graphics mode.</span>
<span class="co">;</span>
               <span class="kw">mov</span>      <span class="kw">ax</span><span class="bn">,10h     </span><span class="co">;AH = 0 means mode set, AL = 10h selects</span>
                                   <span class="co">; hi-res graphics mode</span>
               <span class="kw">int</span><span class="bn">      10h        </span><span class="co">;BIOS video interrupt</span>
<span class="co">;</span>
<span class="co">; Put up some text, so the screen isn&#39;t empty.</span>
<span class="co">;</span>
               <span class="kw">mov</span>      <span class="kw">ah</span>,<span class="dv">9</span>       <span class="co">;DOS print string function</span>
               <span class="kw">mov</span>      <span class="kw">dx</span>,offset SampleText
               <span class="kw">int</span><span class="bn">      21h</span>
<span class="co">;</span>
<span class="co">; Delete SNAPSHOT.SCR if it exists.</span>
<span class="co">;</span>
               <span class="kw">mov</span>      <span class="kw">ah</span><span class="bn">,41h     </span><span class="co">;DOS unlink file function</span>
               <span class="kw">mov</span>      <span class="kw">dx</span>,offset Filename
               <span class="kw">int</span><span class="bn">      21h</span>
<span class="co">;</span>
<span class="co">; Create the file SNAPSHOT.SCR.</span>
<span class="co">;</span>
               <span class="kw">mov</span>      <span class="kw">ah</span><span class="bn">,3ch        </span><span class="co">;DOS create file function</span>
               <span class="kw">mov</span>      <span class="kw">dx</span>,offset Filename
               <span class="kw">sub</span>      <span class="kw">cx</span>,<span class="kw">cx</span>         <span class="co">;make it a normal file</span>
               <span class="kw">int</span><span class="bn">      21h</span>
               <span class="kw">mov</span>      [Handle],<span class="kw">ax</span>   <span class="co">;save the handle</span>
               <span class="kw">jnc</span>      SaveTheScreen <span class="co">;we&#39;re ready to save if no error</span>
               <span class="kw">mov</span>      <span class="kw">ah</span>,<span class="dv">9</span>          <span class="co">;DOS print string function</span>
               <span class="kw">mov</span>      <span class="kw">dx</span>,offset ErrMsg1
               <span class="kw">int</span><span class="bn">      21h           </span><span class="co">;notify of the error</span>
               <span class="kw">jmp</span>      <span class="dt">short</span> Done    <span class="co">;and done</span>
<span class="co">;</span>
<span class="co">; Loop through the 4 planes, making each readable in turn and</span>
<span class="co">; writing it to disk. Note that all 4 planes are readable at</span>
<span class="co">; A000:0000; the Read Map register selects which plane is readable</span>
<span class="co">; at any one time.</span>
<span class="co">;</span>
<span class="fu">SaveTheScreen:</span>
               <span class="kw">mov</span>      [Plane],<span class="dv">0</span><span class="co">;start with plane 0</span>
<span class="fu">SaveLoop:</span>
               <span class="kw">mov</span>      <span class="kw">dx</span>,GC_INDEX
               <span class="kw">mov</span>      <span class="kw">al</span>,READ_MAP<span class="co">;set GC Index to Read Map register</span>
               <span class="kw">out</span>      <span class="kw">dx</span>,<span class="kw">al</span>
               <span class="kw">inc</span>      <span class="kw">dx</span>
               <span class="kw">mov</span>      <span class="kw">al</span>,[Plane]          <span class="co">;get the # of the plane we want</span>
                                            <span class="co">; to save</span>
               <span class="kw">out</span>      <span class="kw">dx</span>,<span class="kw">al</span>               <span class="co">;set to read from the desired plane</span>
               <span class="kw">mov</span>      <span class="kw">ah</span><span class="bn">,40h              </span><span class="co">;DOS write to file function</span>
               <span class="kw">mov</span>      <span class="kw">bx</span>,[Handle]
               <span class="kw">mov</span>      <span class="kw">cx</span>,DISPLAYED_SCREEN_SIZE <span class="co">;# of bytes to save</span>
               <span class="kw">sub</span>      <span class="kw">dx</span>,<span class="kw">dx</span>               <span class="co">;write all displayed bytes at A000:0000</span>
               <span class="kw">push</span>     <span class="kw">ds</span>
               <span class="kw">mov</span>      <span class="kw">si</span>,VGA_SEGMENT
               <span class="kw">mov</span>      <span class="kw">ds</span>,<span class="kw">si</span>
               <span class="kw">int</span><span class="bn">      21h                 </span><span class="co">;write the displayed portion of this plane</span>
               <span class="kw">pop</span>      <span class="kw">ds</span>
               <span class="kw">cmp</span>      <span class="kw">ax</span>,DISPLAYED_SCREEN_SIZE <span class="co">;did all bytes get written?</span>
               <span class="kw">jz</span>       SaveLoopBottom
               <span class="kw">mov</span>      <span class="kw">ah</span>,<span class="dv">9</span>                <span class="co">;DOS print string function</span>
               <span class="kw">mov</span>      <span class="kw">dx</span>,offset ErrMsg2
               <span class="kw">int</span><span class="bn">      21h                 </span><span class="co">;notify about the error</span>
               <span class="kw">jmp</span>      <span class="dt">short</span> DoClose       <span class="co">;and done</span>
<span class="fu">SaveLoopBottom:</span>
               <span class="kw">mov</span>      <span class="kw">al</span>,[Plane]
               <span class="kw">inc</span>      <span class="kw">ax</span>                  <span class="co">;point to the next plane</span>
               <span class="kw">mov</span>      [Plane],<span class="kw">al</span>
               <span class="kw">cmp</span>      <span class="kw">al</span>,<span class="dv">3</span>                <span class="co">;have we done all planes?</span>
               <span class="kw">jbe</span>      SaveLoop            <span class="co">;no, so do the next plane</span>
<span class="co">;</span>
<span class="co">; Close SNAPSHOT.SCR.</span>
<span class="co">;</span>
<span class="fu">DoClose:</span>
               <span class="kw">mov</span>      <span class="kw">ah</span><span class="bn">,3eh              </span><span class="co">;DOS close file function</span>
               <span class="kw">mov</span>      <span class="kw">bx</span>,[Handle]
               <span class="kw">int</span><span class="bn">      21h</span>
<span class="co">;</span>
<span class="co">; Wait for a keypress.</span>
<span class="co">;</span>
               <span class="kw">mov</span>      <span class="kw">ah</span>,<span class="dv">9</span>                <span class="co">;DOS print string function</span>
               <span class="kw">mov</span>      <span class="kw">dx</span>,offset WaitKeyMsg
               <span class="kw">int</span><span class="bn">      21h                 </span><span class="co">;prompt</span>
               <span class="kw">mov</span>      <span class="kw">ah</span>,<span class="dv">8</span>                <span class="co">;DOS input without echo function</span>
               <span class="kw">int</span><span class="bn">      21h</span>
<span class="co">;</span>
<span class="co">; Restore text mode.</span>
<span class="co">;</span>
               <span class="kw">mov</span>      <span class="kw">ax</span>,<span class="dv">3</span>
               <span class="kw">int</span><span class="bn">      10h</span>
<span class="co">;</span>
<span class="co">; Done.</span>
<span class="co">;</span>
<span class="fu">Done:</span>
               <span class="kw">mov</span>      <span class="kw">ah</span>,4ch<span class="co">;DOS terminate function</span>
               <span class="kw">int</span><span class="bn">      21h</span>
Start          endp
Code           ends
               end      Start</code></pre>
<p><strong>LISTING 29.2 L29-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to restore a mode 10h EGA graphics screen from</span>
<span class="co">; the file SNAPSHOT.SCR.</span>
<span class="co">;</span>
VGA_SEGMENT                 <span class="dt">equ</span><span class="bn">   0a000h</span>
SC_INDEX                    <span class="dt">equ</span><span class="bn">   3c4h            </span><span class="co">;Sequence Controller Index register</span>
MAP_MASK                    <span class="dt">equ</span>   <span class="dv">2</span>               <span class="co">;Map Mask register index in SC</span>
DISPLAYED_SCREEN_SIZE       <span class="dt">equ</span>  (<span class="dv">640</span>/<span class="dv">8</span>)*<span class="dv">350</span>      <span class="co">;# of displayed bytes per plane in a</span>
                                                  <span class="co">; hi-res graphics screen</span>
<span class="co">;</span>
stack      <span class="kw">segment</span> para stack ‘STACK<span class="st">&#39;</span>
                 <span class="dt">db</span>              <span class="dv">512</span> dup (?)
stack      ends
<span class="co">;</span>
Data       <span class="kw">segment</span>     <span class="dt">word</span> ‘DATA<span class="st">&#39;</span>
Filename         <span class="dt">db</span>          ‘SNAPSHOT.SCR<span class="st">&#39;,0   ;name of file we&#39;</span>re restoring from
ErrMsg1          <span class="dt">db</span>          ‘*** Couldn<span class="st">&#39;‘t open SNAPSHOT.SCR ***&#39;</span><span class="bn">,0dh,</span>0ah,‘<span class="dv">$</span><span class="st">&#39;</span>
ErrMsg2          <span class="dt">db</span>          ‘*** Error reading from SNAPSHOT.SCR ***<span class="st">&#39;,0dh,0ah,‘$&#39;</span>
WaitKeyMsg       <span class="dt">db</span><span class="bn">          0dh, </span>0ah, ‘Done. Press any key to end...<span class="st">&#39;,0dh,0ah,‘$&#39;</span>
Handle           <span class="dt">dw</span>          ?                  <span class="co">;handle of file we&#39;re restoring from</span>
Plane            <span class="dt">db</span>          ?                  <span class="co">;plane being written</span>
Data       ends
<span class="co">;</span>
Code          <span class="kw">segment</span>
              assume   <span class="kw">cs</span>:Code, <span class="kw">ds</span>:Data
Start         proc     near
              <span class="kw">mov</span>      <span class="kw">ax</span>,Data
              <span class="kw">mov</span>      <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Go to hi-res graphics mode.</span>
<span class="co">;</span>
              <span class="kw">mov</span>      <span class="kw">ax</span><span class="bn">,10h          </span><span class="co">;AH = 0 means mode set, AL = 10h selects</span>
                                       <span class="co">; hi-res graphics mode</span>
              <span class="kw">int</span><span class="bn">      10h             </span><span class="co">;BIOS video interrupt</span>
<span class="co">;</span>
<span class="co">; Open SNAPSHOT.SCR.</span>
<span class="co">;</span>
              <span class="kw">mov</span>      <span class="kw">ah</span><span class="bn">,3dh           </span><span class="co">;DOS open file function</span>
              <span class="kw">mov</span>      <span class="kw">dx</span>,offset Filename
              <span class="kw">sub</span>      <span class="kw">al</span>,<span class="kw">al</span>            <span class="co">;open for reading</span>
              <span class="kw">int</span><span class="bn">      21h</span>
              <span class="kw">mov</span>      [Handle],<span class="kw">ax</span>      <span class="co">;save the handle</span>
              <span class="kw">jnc</span>      RestoreTheScreen <span class="co">;we&#39;re ready to restore if no error</span>
              <span class="kw">mov</span>      <span class="kw">ah</span>,<span class="dv">9</span>             <span class="co">;DOS print string function</span>
              <span class="kw">mov</span>      <span class="kw">dx</span>,offset ErrMsg1
              <span class="kw">int</span><span class="bn">      21h              </span><span class="co">;notify of the error</span>
              <span class="kw">jmp</span>      <span class="dt">short</span> Done<span class="co">;and done</span>
<span class="co">;</span>
<span class="co">; Loop through the 4 planes, making each writable in turn and</span>
<span class="co">; reading it from disk. Note that all 4 planes are writable at</span>
<span class="co">; A000:0000; the Map Mask register selects which planes are readable</span>
<span class="co">; at any one time. We only make one plane readable at a time.</span>
<span class="co">;</span>
<span class="fu">RestoreTheScreen:</span>
              <span class="kw">mov</span>      [Plane],<span class="dv">0</span>                <span class="co">;start with plane 0</span>
<span class="fu">RestoreLoop:</span>
              <span class="kw">mov</span>      <span class="kw">dx</span>,SC_INDEX
              <span class="kw">mov</span>      <span class="kw">al</span>,MAP_MASK              <span class="co">;set SC Index to Map Mask register</span>
outdx,<span class="kw">al</span>
              <span class="kw">inc</span>      <span class="kw">dx</span>
              <span class="kw">mov</span>      <span class="kw">cl</span>,[Plane]               <span class="co">;get the # of the plane we want</span>
<span class="co">; to restore</span>
              <span class="kw">mov</span>      <span class="kw">al</span>,<span class="dv">1</span>
              <span class="kw">shl</span>      <span class="kw">al</span>,<span class="kw">cl</span>                    <span class="co">;set the bit enabling writes to</span>
                                                <span class="co">; only the one desired plane</span>
              <span class="kw">out</span>      <span class="kw">dx</span>,<span class="kw">al</span>                    <span class="co">;set to read from desired plane</span>
              <span class="kw">mov</span>      <span class="kw">ah</span><span class="bn">,3fh                   </span><span class="co">;DOS read from file function</span>
              <span class="kw">mov</span>      <span class="kw">bx</span>,[Handle]
              <span class="kw">mov</span>      <span class="kw">cx</span>,DISPLAYED_SCREEN_SIZE <span class="co">;# of bytes to read</span>
              <span class="kw">sub</span>      <span class="kw">dx</span>,<span class="kw">dx</span>                    <span class="co">;start loading bytes at A000:0000</span>
              <span class="kw">push</span>     <span class="kw">ds</span>
              <span class="kw">mov</span>      <span class="kw">si</span>,VGA_SEGMENT
              <span class="kw">mov</span>      <span class="kw">ds</span>,<span class="kw">si</span>
              <span class="kw">int</span><span class="bn">      21h                      </span><span class="co">;read the displayed portion of this plane</span>
              <span class="kw">pop</span>      <span class="kw">ds</span>
              <span class="kw">jc</span>       ReadError
              <span class="kw">cmp</span>      <span class="kw">ax</span>,DISPLAYED_SCREEN_SIZE <span class="co">;did all bytes get read?</span>
              <span class="kw">jz</span>       RestoreLoopBottom
<span class="fu">ReadError:</span>
              <span class="kw">mov</span>      <span class="kw">ah</span>,<span class="dv">9</span>                     <span class="co">;DOS print string function</span>
              <span class="kw">mov</span>      <span class="kw">dx</span>,offset ErrMsg2
              <span class="kw">int</span><span class="bn">      21h                      </span><span class="co">;notify about the error</span>
              <span class="kw">jmp</span>      <span class="dt">short</span> DoClose            <span class="co">;and done</span>
<span class="fu">RestoreLoopBottom:</span>
              <span class="kw">mov</span>      <span class="kw">al</span>,[Plane]
              <span class="kw">inc</span>      <span class="kw">ax</span>                       <span class="co">;point to the next plane</span>
              <span class="kw">mov</span>      [Plane],<span class="kw">al</span>
              <span class="kw">cmp</span>      <span class="kw">al</span>,<span class="dv">3</span>                     <span class="co">;have we done all planes?</span>
              <span class="kw">jbe</span>      RestoreLoop              <span class="co">;no, so do the next plane</span>
<span class="co">;</span>
<span class="co">; Close SNAPSHOT.SCR.</span>
<span class="co">;</span>
<span class="fu">DoClose:</span>
              <span class="kw">mov</span>      <span class="kw">ah</span><span class="bn">,3eh                   </span><span class="co">;DOS close file function</span>
              <span class="kw">mov</span>      <span class="kw">bx</span>,[Handle]
              <span class="kw">int</span><span class="bn">      21h</span>
<span class="co">;</span>
<span class="co">; Wait for a keypress.</span>
<span class="co">;</span>
              <span class="kw">mov</span>      <span class="kw">ah</span>,<span class="dv">8</span>                     <span class="co">;DOS input without echo function</span>
              <span class="kw">int</span><span class="bn">      21h</span>
<span class="co">;</span>
<span class="co">; Restore text mode.</span>
<span class="co">;</span>
              <span class="kw">mov</span>      <span class="kw">ax</span>,<span class="dv">3</span>
              <span class="kw">int</span><span class="bn">      10h</span>
<span class="co">;</span>
<span class="co">; Done.</span>
<span class="co">;</span>
<span class="fu">Done:</span>
              <span class="kw">mov</span>      <span class="kw">ah</span><span class="bn">,4ch                   </span><span class="co">;DOS terminate function</span>
              <span class="kw">int</span><span class="bn">      21h</span>
Start         endp
Code          ends
              end      Start</code></pre>
<p>If you compare Listings 29.1 and 29.2, you will see that the Map Mask register setting used to load a given plane does not match the Read Map register setting used to read that plane. This is so because while only one plane can ever be read at a time, anywhere from zero to four planes can be written to at once; consequently, Read Map register settings are plane selections from 0 to 3, while Map Mask register settings are plane <em>masks</em> from 0 to 15, where a bit 0 setting of 1 enables writes to plane 0, a bit 1 setting of 1 enables writes to plane 1, and so on. Again, Chapter 28 provides a detailed explanation of the differences between the Read Map and Map Mask registers.</p>
<p>Screen saving and restoring is pretty simple, eh? There are a few caveats, of course, but nothing serious. First, the adapter’s registers must be programmed properly in order for screen saving and restoring to work. For screen saving, you must be in read mode 0; if you’re in color compare mode, there’s no telling what bit pattern you’ll save, but it certainly won’t be the desired screen image. For screen restoring, you must be in write mode 0, with the Bit Mask register set to 0FFH and Data Rotate register set to 0 (no data rotation and the logical function set to pass the data through unchanged).</p>
<blockquote>
<p><img src="images/i.jpg" /> While these requirements are no problem if you’re simply calling a subroutine in order to save an image from your program, they pose a considerable problem if you’re designing a hot-key operated TSR that can capture a screen image at any time. With the EGA specifically, there’s never any way to tell what state the registers are currently in, since the registers aren’t readable. (More on this issue later in this chapter.) As a result, any TSR that sets the Bit Mask to 0FFH, the Data Rotate register to 0, and so on runs the risk of interfering with the drawing code of the program that’s already running.</p>
</blockquote>
<p>What’s the solution? Frankly, the solution is to get VGA-specific. A TSR designed for the VGA can simply read out and save the state of the registers of interest, program those registers as needed, save the screen image, and restore the original settings. From a programmer’s perspective, readable registers are certainly near the top of the list of things to like about the VGA! The remaining installed base of EGAs is steadily dwindling, and you may be able to ignore it as a market today, as you couldn’t even a year or two ago.</p>
<p>If you are going to write a hi-res VGA version of the screen capture program, be sure to account for the increased size of the VGA’s mode 12H bit map. The mode 12H (640x480) screen uses 37.5K per plane of display memory, so for mode 12H the displayed screen size equate in Listings 29.1 and 29.2 should be changed to:</p>
<pre><code>DISPLAYED_SCREEN_SIZEequ(640/8)*480</code></pre>
<p>Similarly, if you’re capturing a graphics screen that starts at an offset other than 0 in the segment at A000H, you must change the memory offset used by the disk functions to match. You can, if you so desire, read the start offset of the display memory providing the information shown on the screen from the Start Address registers (CRT Controller registers 0CH and 0DH); these registers are readable even on an EGA.</p>
<p>Finally, be aware that the screen capture and restore programs in Listings 29.1 and 29.2 are only appropriate for EGA/VGA modes 0DH, 0EH, 0FH, 010H, and 012H, since they assume a fourconfiguration of EGA/VGA memory. In all text modes and in CGA graphics modes, and in VGA modes 11H and 13H as well, display memory can simply be written to disk and read back as a linear block of memory, just like a normal array.</p>
<p>While Listings 29.1 and 29.2 are written in assembly, the principles they illustrate apply equally well to high-level languages. In fact, there’s no need for any assembly at all when saving an EGA/VGA screen, as long as the high-level language you’re using can perform direct port I/O to set up the adapter and can read and write display memory directly.</p>
<blockquote>
<p><img src="images/i.jpg" /> One tip if you’re saving and restoring the screen from a high-level language on an EGA, though: After you’ve completed the save or restore operation, be sure to put any registers that you’ve changed back to their default settings. Some high-level languages (and the BIOS as well) assume that various registers are left in a certain state, so on the EGA it’s safest to leave the registers in their most likely state. On the VGA, of course, you can just read the registers out before you change them, then put them back the way you found them when you’re done.</p>
</blockquote>
</section>
<section id="colors-out-of-64" class="level3">
<h3><a href="#colors-out-of-64">16 Colors out of 64</a></h3>
<p>How does one produce the 64 colors from which the 16 colors displayed by the EGA can be chosen? The answer is simple enough: There’s a BIOS function that lets you select the mapping of the 16 possible pixel values to the 64 possible colors. Let’s lay out a bit of background before proceeding, however.</p>
<p>The EGA sends pixel information to the monitor on 6 pins. This means that there are 2 to the 6th, or 64 possible colors that an EGA can generate. However, for compatibility with premonitors, in 200-scan-line modes Enhanced Color Displaymonitors ignore two of the signals. As a result, in CGA-compatible modes (modes 4, 5, 6, and the 200-scan-line versions of modes 0, 1, 2, and 3) you can select from only 16 colors (although the colors can still be remapped, as described below). If you’re not hooked up to a monitor capable of displaying 350 scan lines (such as the old IBM Color Display), you can never select from more than 16 colors, since those monitors only accept four input signals. For now, we’ll assume we’re in one of the 350-scan line color modes, a group which includes mode 10H and the 350-scan-line versions of modes 0, 1, 2, and 3.</p>
<p>Each pixel comes out of memory (or, in text mode, out of the attribute-handling portion of the EGA) as a 4-bit value, denoting 1 of 16 possible colors. In graphics modes, the 4-bit pixel value is made up of one bit from each plane, with 8 pixels’ worth of data stored at any given byte address in display memory. Normally, we think of the 4-bit value of a pixel as being that pixel’s color, so a pixel value of 0 is black, a pixel value of 1 is blue, and so on, as if that’s a built-in feature of the EGA.</p>
<p>Actually, though, the correspondence of pixel values to color is absolutely arbitrary, depending solely on how the colorportion of the EGA containing the palette registers is programmed. If you cared to have color 0 be bright red and color 1 be black, that could easily be arranged, as could a mapping in which all 16 colors were yellow. What’s more, these mappings affect text-mode characters as readily as they do graphics-mode pixels, so you could map text attribute 0 to white and text attribute 15 to black to produce a black on white display, if you wished.</p>
<p>Each of the 16 palette registers stores the mapping of one of the 16 possible 4-bit pixel values from memory to one of 64 possible 6-bit pixel values to be sent to the monitor as video data, as shown in Figure 29.2. A 4-bit pixel value of 0 causes the 6-bit value stored in palette register 0 to be sent to the display as the color of that pixel, a pixel value of 1 causes the contents of palette register 1 to be sent to the display, and so on. Since there are only four input bits, it stands to reason that only 16 colors are available at any one time; since there are six output bits, however, those 16 colors can be mapped to any of 64 colors. The mapping for each of the 16 pixel values is controlled by the lower six bits of the corresponding palette register, as shown in Figure 29.3. Secondary red, green, and blue are less-intense versions of red, green, and blue, although their exact effects vary from monitor to monitor. The best way to figure out what the 64 colors look like on your monitor is to see them, and that’s just what the program in Listing 29.3, which we’ll discuss shortly, lets you do.</p>
<figure>
<img src="images/29-02.jpg" alt="Figure 29.2  Color translation via the palette registers." /><figcaption><strong>Figure 29.2</strong>  <em>Color translation via the palette registers.</em></figcaption>
</figure>
<p>How does one go about setting the palette registers? Well, it’s certainly possible to set the palette registers directly by addressing them at registers 0 through 0FH of the Attribute Controller. However, setting the palette registers is a bit tricky—bit 5 of the Attribute Controller Index register must be 0 while the palette registers are written to, and glitches can occur if the updating doesn’t take place during the blanking interval—and besides, it turns out that there’s no need at all to go straight to the hardware on this one. Conveniently, the EGA BIOS provides us with video function 10H, which supports setting either any one palette register or all 16 palette registers (and the overscan register as well) with a single video interrupt.</p>
<p>Video function 10H is invoked by performing an <code>INT</code> 10H with AH set to 10H. If AL is 0 (subfunction 0), then BL contains the number of the palette register to set, and BH contains the value to set that register to. If AL is 1 (subfunction 1), then BH contains the value to set the overscan (border) color to. Finally, if AL is 2 (subfunction 2), then ES:DX points to a 17-byte array containing the values to set palette registers 0-15 and the overscan register to. (For completeness, although it’s unrelated to the palette registers, there is one more subfunction of video function 10H. If AL = 3 (subfunction 3), bit 0 of BL is set to 1 to cause bit 7 of text attributes to select blinking, or set to 0 to cause bit 7 of text attributes to select highreverse video.)</p>
<figure>
<img src="images/29-03.jpg" alt="Figure 29.3  Bit organization within a palette register." /><figcaption><strong>Figure 29.3</strong>  <em>Bit organization within a palette register.</em></figcaption>
</figure>
<p>Listing 29.3 uses video function 10H, subfunction 2 to step through all 64 possible colors. This is accomplished by putting up 16 color bars, one for each of the 16 possible 4-bit pixel values, then changing the mapping provided by the palette registers to select a different group of 16 colors from the set of 64 each time a key is pressed. Initially, colors 0-15 are displayed, then 1-16, then 2-17, and so on up to color 3FH wrapping around to colors 0-14, and finally back to colors 0-15. (By the way, at mode set time the 16 palette registers are not set to colors 0-15, but rather to 0H, 1H, 2H, H, 4H, 5H, 14H, 7H, 38H, 39H, 3AH, 3BH, 3CH, 3DH, 3EH, and 3FH, respectively. Bits 6, 5, and 4—secondary red, green, and blue—are all set to 1 in palette registers 8-15 in order to produce high-intensity colors. Palette register 6 is set to 14H to produce brown, rather than the yellow that the expected value of 6H would produce.)</p>
<p>When you run Listing 29.3, you’ll see that the whole screen changes color as each new color set is selected. This occurs because most of the pixels on the screen have a value of 0, selecting the background color stored in palette register 0, and we’re reprogramming palette register 0 right along with the other 15 palette registers.</p>
<p>It’s important to understand that in Listing 29.3 the contents of display memory are never changed after initialization. The only change is the mapping from the 4-bit pixel data coming out of display memory to the 6-bit data going to the monitor. For this reason, it’s technically inaccurate to speak of bits in display memory as representing colors; more accurately, they represent attributes in the range 0-15, which are mapped to colors 0-3FH by the palette registers.</p>
<p><strong>LISTING 29.3 L29-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to illustrate the color mapping capabilities of the</span>
<span class="co">; EGA&#39;s palette registers.</span>
<span class="co">;</span>
VGA_SEGMENT            <span class="dt">equ</span><span class="bn">  0a000h</span>
SC_INDEX               <span class="dt">equ</span><span class="bn">  3c4h         </span><span class="co">;Sequence Controller Index register</span>
MAP_MASK               <span class="dt">equ</span>  <span class="dv">2</span>            <span class="co">;Map Mask register index in SC</span>
BAR_HEIGHT             <span class="dt">equ</span>  <span class="dv">14</span>           <span class="co">;height of each bar</span>
TOP_BAR                <span class="dt">equ</span>  BAR_HEIGHT*<span class="dv">6</span> <span class="co">;start the bars down a bit to</span>
                                         <span class="co">; leave room for text</span>
<span class="co">;</span>
stack    <span class="kw">segment</span> para stack ‘STACK<span class="st">&#39;</span>
              <span class="dt">db</span>                  <span class="dv">512</span> dup (?)
stack    ends
<span class="co">;</span>
Data     <span class="kw">segment</span>    <span class="dt">word</span> ‘DATA<span class="st">&#39;</span>
KeyMsg   <span class="dt">db</span>         ‘Press any key to see the next color set. <span class="st">&#39;</span>
         <span class="dt">db</span>         ‘There are <span class="dv">64</span> color <span class="kw">sets</span> <span class="kw">in</span> all.<span class="st">&#39;</span>
         <span class="dt">db</span><span class="bn">         0dh, </span>0ah<span class="bn">, 0ah, </span>0ah<span class="bn">, 0ah</span>
         <span class="dt">db</span>         <span class="dv">13</span> dup (‘ <span class="st">&#39;), ‘Attribute&#39;</span>
         <span class="dt">db</span>         <span class="dv">38</span> dup (‘ <span class="st">&#39;), ‘Color$&#39;</span>
<span class="co">;</span>
<span class="co">; Used to label the attributes of the color bars.</span>
<span class="co">;</span>
AttributeNumbers    label <span class="dt">byte</span>
x=         <span class="dv">0</span>
           rept     <span class="dv">16</span>
if x lt <span class="dv">10</span>
           <span class="dt">db</span>       ‘0<span class="st">&#39;, x+‘0&#39;</span>, ‘h<span class="st">&#39;, 0ah, 8, 8, 8</span>
else
           <span class="dt">db</span>       ‘0<span class="st">&#39;, x+‘A&#39;</span>-<span class="dv">10</span>, ‘h<span class="st">&#39;, 0ah, 8, 8, 8</span>
endif
x=         x<span class="dv">+1</span>
           endm
           <span class="dt">db</span>       ‘<span class="dv">$</span><span class="st">&#39;</span>
<span class="co">;</span>
<span class="co">; Used to label the colors of the color bars. (Color values are</span>
<span class="co">; filled in on the fly.)</span>
<span class="co">;</span>
ColorNumberslabelbyte
           rept    <span class="dv">16</span>
           <span class="dt">db</span>      ‘000h<span class="st">&#39;, 0ah, 8, 8, 8, 8</span>
           endm
COLOR_ENTRY_LENGTHequ(<span class="dv">$</span>-ColorNumbers)/<span class="dv">16</span>
           <span class="dt">db</span>      ‘<span class="dv">$</span><span class="st">&#39;</span>
<span class="co">;</span>
CurrentColordb?
<span class="co">;</span>
<span class="co">; Space for the array of 16 colors we&#39;ll pass to the BIOS, plus</span>
<span class="co">; an overscan setting of black.</span>
<span class="co">;</span>
ColorTable    <span class="dt">db</span>         <span class="dv">16</span> dup (?), <span class="dv">0</span>
Data          ends
<span class="co">;</span>
Code          <span class="kw">segment</span>
              assume     <span class="kw">cs</span>:Code, <span class="kw">ds</span>:Data
Start         procnear
              <span class="kw">cld</span>
              <span class="kw">mov</span>        <span class="kw">ax</span>,Data
              <span class="kw">mov</span>        <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Go to hi-res graphics mode.</span>
<span class="co">;</span>
              <span class="kw">mov</span>        <span class="kw">ax</span><span class="bn">,10h           </span><span class="co">;AH = 0 means mode set, AL = 10h selects</span>
                                          <span class="co">; hi-res graphics mode</span>
              <span class="kw">int</span><span class="bn">        10h              </span><span class="co">;BIOS video interrupt</span>
<span class="co">;</span>
<span class="co">; Put up relevant text.</span>
<span class="co">;</span>
              <span class="kw">mov</span>        <span class="kw">ah</span>,<span class="dv">9</span>             <span class="co">;DOS print string function</span>
              <span class="kw">mov</span>        <span class="kw">dx</span>,offset KeyMsg
              <span class="kw">int</span><span class="bn">        21h</span>
<span class="co">;</span>
<span class="co">; Put up the color bars, one in each of the 16 possible pixel values</span>
<span class="co">; (which we&#39;ll call attributes).</span>
<span class="co">;</span>
              <span class="kw">mov</span>        <span class="kw">cx</span>,<span class="dv">16</span>            <span class="co">;we&#39;ll put up 16 color bars</span>
              <span class="kw">sub</span>        <span class="kw">al</span>,<span class="kw">al</span>            <span class="co">;start with attribute 0</span>
<span class="fu">BarLoop:</span>
              <span class="kw">push</span>       <span class="kw">ax</span>
              <span class="kw">push</span>       <span class="kw">cx</span>
              <span class="kw">call</span>       BarUp
              <span class="kw">pop</span>        <span class="kw">cx</span>
              <span class="kw">pop</span>        <span class="kw">ax</span>
              <span class="kw">inc</span>        <span class="kw">ax</span>               <span class="co">;select the next attribute</span>
              <span class="kw">loop</span>       BarLoop
<span class="co">;</span>
<span class="co">; Put up the attribute labels.</span>
<span class="co">;</span>
              <span class="kw">mov</span>        <span class="kw">ah</span>,<span class="dv">2</span>             <span class="co">;video interrupt set cursor position function</span>
              <span class="kw">sub</span>        <span class="kw">bh</span>,<span class="kw">bh</span>            <span class="co">;page 0</span>
              <span class="kw">mov</span>        <span class="kw">dh</span>,TOP_BAR/<span class="dv">14</span>    <span class="co">;counting in character rows, match to</span>
                                          <span class="co">; top of first bar, counting in</span>
                                          <span class="co">; scan lines</span>
              <span class="kw">mov</span>        <span class="kw">dl</span>,<span class="dv">16</span>            <span class="co">;just to left of bars</span>
              <span class="kw">int</span><span class="bn">        10h</span>
              <span class="kw">mov</span>        <span class="kw">ah</span>,<span class="dv">9</span>             <span class="co">;DOS print string function</span>
              <span class="kw">mov</span>        <span class="kw">dx</span>,offset AttributeNumbers
              <span class="kw">int</span><span class="bn">        21h</span>
<span class="co">;</span>
<span class="co">; Loop through the color set, one new setting per keypress.</span>
<span class="co">;</span>
              <span class="kw">mov</span>        [CurrentColor],<span class="dv">0</span> <span class="co">;start with color zero</span>
<span class="fu">ColorLoop:</span>
<span class="co">;</span>
<span class="co">; Set the palette registers to the current color set, consisting</span>
<span class="co">; of the current color mapped to attribute 0, current color + 1</span>
<span class="co">; mapped to attribute 1, and so on.</span>
<span class="co">;</span>
              <span class="kw">mov</span>        <span class="kw">al</span>,[CurrentColor]
              <span class="kw">mov</span>        <span class="kw">bx</span>,offset ColorTable
              <span class="kw">mov</span>        <span class="kw">cx</span>,<span class="dv">16</span>            <span class="co">;we have 16 colors to set</span>
<span class="fu">PaletteSetLoop:</span>
              <span class="kw">and</span>        <span class="kw">al</span><span class="bn">,3fh          </span><span class="co">;limit to 6-bit color values</span>
              <span class="kw">mov</span>        [<span class="kw">bx</span>],<span class="kw">al</span>         <span class="co">;build the 16-color table used for setting</span>
              <span class="kw">inc</span>        <span class="kw">bx</span>              <span class="co">; the palette registers</span>
              <span class="kw">inc</span>        <span class="kw">ax</span>
              <span class="kw">loop</span>       PaletteSetLoop
              <span class="kw">mov</span>        <span class="kw">ah</span><span class="bn">,10h          </span><span class="co">;video interrupt palette function</span>
              <span class="kw">mov</span>        <span class="kw">al</span>,<span class="dv">2</span>            <span class="co">;subfunction to set all 16 palette registers</span>
                                         <span class="co">; and overscan at once</span>
              <span class="kw">mov</span>        <span class="kw">dx</span>,offset ColorTable
              <span class="kw">push</span>       <span class="kw">ds</span>
              <span class="kw">pop</span>        <span class="kw">es</span>              <span class="co">;ES:DX points to the color table</span>
              <span class="kw">int</span><span class="bn">        10h             </span><span class="co">;invoke the video interrupt to set the palette</span>
<span class="co">;</span>
<span class="co">; Put up the color numbers, so we can see how attributes map</span>
<span class="co">; to color values, and so we can see how each color # looks</span>
<span class="co">; (at least on this particular screen).</span>
<span class="co">;</span>
              <span class="kw">call</span>       ColorNumbersUp
<span class="co">;</span>
<span class="co">; Wait for a keypress, so they can see this color set.</span>
<span class="co">;</span>
<span class="fu">WaitKey:</span>
              <span class="kw">mov</span>        <span class="kw">ah</span>,<span class="dv">8</span>            <span class="co">;DOS input without echo function</span>
              <span class="kw">int</span><span class="bn">        21h</span>
<span class="co">;</span>
<span class="co">; Advance to the next color set.</span>
<span class="co">;</span>
              <span class="kw">mov</span>        <span class="kw">al</span>,[CurrentColor]
              <span class="kw">inc</span>        <span class="kw">ax</span>
              <span class="kw">mov</span>        [CurrentColor],<span class="kw">al</span>
              <span class="kw">cmp</span>        <span class="kw">al</span>,<span class="dv">64</span>
              <span class="kw">jbe</span>        ColorLoop
<span class="co">;</span>
<span class="co">; Restore text mode.</span>
<span class="co">;</span>
              <span class="kw">mov</span>        <span class="kw">ax</span>,<span class="dv">3</span>
              <span class="kw">int</span><span class="bn">        10h</span>
<span class="co">;</span>
<span class="co">; Done.</span>
<span class="co">;</span>
<span class="fu">Done:</span>
              <span class="kw">mov</span>        <span class="kw">ah</span><span class="bn">,4ch          </span><span class="co">;DOS terminate function</span>
              <span class="kw">int</span><span class="bn">        21h</span>
<span class="co">;</span>
<span class="co">; Puts up a bar consisting of the specified attribute (pixel value),</span>
<span class="co">; at a vertical position corresponding to the attribute.</span>
<span class="co">;</span>
<span class="co">; Input: AL = attribute</span>
<span class="co">;</span>
BarUp         proc       near
              <span class="kw">mov</span>        <span class="kw">dx</span>,SC_INDEX
              <span class="kw">mov</span>        <span class="kw">ah</span>,<span class="kw">al</span>
              <span class="kw">mov</span>        <span class="kw">al</span>,MAP_MASK
              <span class="kw">out</span>        <span class="kw">dx</span>,<span class="kw">al</span>
              <span class="kw">inc</span>        <span class="kw">dx</span>
              <span class="kw">mov</span>        <span class="kw">al</span>,<span class="kw">ah</span>
              <span class="kw">out</span>        <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">;set the Map Mask register to produce</span>
                                         <span class="co">; the desired color</span>
              <span class="kw">mov</span>        <span class="kw">ah</span>,BAR_HEIGHT
              <span class="kw">mul</span>        <span class="kw">ah</span>              <span class="co">;row of top of bar</span>
              <span class="kw">add</span>        <span class="kw">ax</span>,TOP_BAR      <span class="co">;start a few lines down to leave room for</span>
                                         <span class="co">; text</span>
              <span class="kw">mov</span>        <span class="kw">dx</span>,<span class="dv">80</span>           <span class="co">;rows are 80 bytes long</span>
              <span class="kw">mul</span>        <span class="kw">dx</span>              <span class="co">;offset in bytes of start of scan line bar</span>
                                         <span class="co">; starts on</span>
              <span class="kw">add</span>         <span class="kw">ax</span>,<span class="dv">20</span>          <span class="co">;offset in bytes of upper left corner of bar</span>
              <span class="kw">mov</span>         <span class="kw">di</span>,<span class="kw">ax</span>
              <span class="kw">mov</span>         <span class="kw">ax</span>,VGA_SEGMENT
              <span class="kw">mov</span>         <span class="kw">es</span>,<span class="kw">ax</span>          <span class="co">;ES:DI points to offset of upper left</span>
                                         <span class="co">; corner of bar</span>
              <span class="kw">mov</span>         <span class="kw">dx</span>,BAR_HEIGHT
              <span class="kw">mov</span>         <span class="kw">al</span><span class="bn">,0ffh</span>
<span class="fu">BarLineLoop:</span>
              <span class="kw">mov</span>         <span class="kw">cx</span>,<span class="dv">40</span>          <span class="co">;make the bars 40 wide</span>
              rep         <span class="kw">stosb</span>          <span class="co">;do one scan line of the bar</span>
              <span class="kw">add</span>         <span class="kw">di</span>,<span class="dv">40</span>          <span class="co">;point to the start of the next scan line</span>
                                         <span class="co">; of the bar</span>
              <span class="kw">dec</span>         <span class="kw">dx</span>
              <span class="kw">jnz</span>         BarLineLoop
              <span class="kw">ret</span>
BarUp         endp
<span class="co">;</span>
<span class="co">; Converts AL to a hex digit in the range 0-F.</span>
<span class="co">;</span>
BinToHexDigit proc        near
              <span class="kw">cmp</span>         <span class="kw">al</span>,<span class="dv">9</span>
              <span class="kw">ja</span>                IsHex
              <span class="kw">add</span>         <span class="kw">al</span>,‘0<span class="st">&#39;</span>
              <span class="kw">ret</span>
<span class="fu">IsHex:</span>
              <span class="kw">add</span>         <span class="kw">al</span>,‘A<span class="st">&#39;-10</span>
              <span class="kw">ret</span>
BinToHexDigit endp
<span class="co">;</span>
<span class="co">; Displays the color values generated by the color bars given the</span>
<span class="co">; current palette register settings off to the right of the color</span>
<span class="co">; bars.</span>
<span class="co">;</span>
ColorNumbersUp proc       near
               <span class="kw">mov</span>        <span class="kw">ah</span>,<span class="dv">2</span>             <span class="co">;video interrupt set cursor position function</span>
               <span class="kw">sub</span>        <span class="kw">bh</span>,<span class="kw">bh</span>            <span class="co">;page 0</span>
               <span class="kw">mov</span>        <span class="kw">dh</span>,TOP_BAR/<span class="dv">14</span>    <span class="co">;counting in character rows, match to</span>
                                           <span class="co">; top of first bar, counting in</span>
                                           <span class="co">; scan lines</span>
               <span class="kw">mov</span>        <span class="kw">dl</span>,<span class="dv">20+40+1</span>       <span class="co">;just to right of bars</span>
               <span class="kw">int</span><span class="bn">        10h</span>
               <span class="kw">mov</span>        <span class="kw">al</span>,[CurrentColor] <span class="co">;start with the current color</span>
               <span class="kw">mov</span>        <span class="kw">bx</span>,offset ColorNumbers<span class="dv">+1</span>
                                            <span class="co">;build color number text string on the fly</span>
               <span class="kw">mov</span>        <span class="kw">cx</span>,<span class="dv">16</span>             <span class="co">;we&#39;ve got 16 colors to do</span>
<span class="fu">ColorNumberLoop:</span>
               pus        hax<span class="co">;save the color #</span>
               <span class="kw">and</span>        <span class="kw">al</span>,3fh<span class="co">;limit to 6-bit color values</span>
               <span class="kw">shr</span>        <span class="kw">al</span>,<span class="dv">1</span>
               <span class="kw">shr</span>        <span class="kw">al</span>,<span class="dv">1</span>
               <span class="kw">shr</span>        <span class="kw">al</span>,<span class="dv">1</span>
               <span class="kw">shr</span>        <span class="kw">al</span>,<span class="dv">1</span>              <span class="co">;isolate the high nibble of the color #</span>
               <span class="kw">call</span>       BinToHexDigit     <span class="co">;convert the high color # nibble</span>
               <span class="kw">mov</span>        [<span class="kw">bx</span>],<span class="kw">al</span>           <span class="co">; and put it into the text</span>
               <span class="kw">pop</span>        <span class="kw">ax</span>                <span class="co">;get back the color #</span>
               <span class="kw">push</span>       <span class="kw">ax</span>                <span class="co">;save the color #</span>
               <span class="kw">and</span>        <span class="kw">al</span><span class="bn">,0fh            </span><span class="co">;isolate the low color # nibble</span>
               <span class="kw">call</span>       BinToHexDigit     <span class="co">;convert the low nibble of the</span>
                                            <span class="co">; color # to ASCII</span>
               <span class="kw">mov</span>        [<span class="kw">bx</span><span class="dv">+1</span>],<span class="kw">al</span>         <span class="co">; and put it into the text</span>
               <span class="kw">add</span>        <span class="kw">bx</span>,COLOR_ENTRY_LENGTH     <span class="co">;point to the next entry</span>
               <span class="kw">pop</span>        <span class="kw">ax</span>                <span class="co">;get back the color #</span>
               <span class="kw">inc</span>        <span class="kw">ax</span>                <span class="co">;next color #</span>
               <span class="kw">loop</span>       ColorNumberLoop
               <span class="kw">mov</span>        <span class="kw">ah</span>,<span class="dv">9</span>              <span class="co">;DOS print string function</span>
               <span class="kw">mov</span>        <span class="kw">dx</span>,offset ColorNumbers
               <span class="kw">int</span><span class="bn">        21h               </span><span class="co">;put up the attribute numbers</span>
               <span class="kw">ret</span>
ColorNumbersUpendp
<span class="co">;</span>
Start          endp
Code           ends
               end       Start</code></pre>
</section>
<section id="overscan" class="level3">
<h3><a href="#overscan">Overscan</a></h3>
<p>While we’re at it, I’m going to touch on overscan. Overscan is the color of the border of the display, the rectangular area around the edge of the monitor that’s outside the region displaying active video data but inside the blanking area. The overscan (or border) color can be programmed to any of the 64 possible colors by either setting Attribute Controller register 11H directly or calling video function 10H, subfunction 1.</p>
<blockquote>
<p><img src="images/i.jpg" /> On ECD-compatible monitors, however, there’s too little scan time to display a proper border when the EGA is in 350-scan-line mode, so overscan should always be 0 (black) unless you’re in 200-scanmode. Note, though, that a VGA can easily display a border on a VGA-compatible monitor, and VGAs are in fact programmed at mode set for an 8-pixel-wide border in all modes; all you need do is set the overscan color on any VGA to see the border.</p>
</blockquote>
</section>
<section id="a-bonus-blanker" class="level3">
<h3><a href="#a-bonus-blanker">A Bonus Blanker</a></h3>
<p>An interesting bonus: The Attribute Controller provides a very convenient way to blank the screen, in the form of the aforementioned bit 5 of the Attribute Controller Index register (at address 3C0H after the Input Status 1 register—3DAH in color, 3BAH in monochrome—has been read and on every other write to 3C0H thereafter). Whenever bit 5 of the AC Index register is 0, video data is cut off, effectively blanking the screen. Setting bit 5 of the AC Index back to 1 restores video data immediately. Listing 29.4 illustrates this simple but effective form of screen blanking.</p>
<p><strong>LISTING 29.4 L29-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to demonstrate screen blanking via bit 5 of the</span>
<span class="co">; Attribute Controller Index register.</span>
<span class="co">;</span>
AC_INDEX               <span class="dt">equ</span><span class="bn">   3c0h            </span><span class="co">;Attribute Controller Index register</span>
INPUT_STATUS_1         <span class="dt">equ</span><span class="bn">   3dah            </span><span class="co">;color-mode address of the Input</span>
                                             <span class="co">; Status 1 register</span>
<span class="co">;</span>
<span class="co">; Macro to wait for and clear the next keypress.</span>
<span class="co">;</span>
WAIT_KEY macro
              <span class="kw">mov</span>      <span class="kw">ah</span>,<span class="dv">8</span>                  <span class="co">;DOS input without echo function</span>
              <span class="kw">int</span><span class="bn">      21h</span>
              endm
<span class="co">;</span>
stack         <span class="kw">segment</span> para stack ‘STACK<span class="st">&#39;</span>
              db512 dup (?)
stack         ends
<span class="co">;</span>
Data  <span class="kw">segment</span>   <span class="dt">word</span>   ‘DATA<span class="st">&#39;</span>
SampleText      <span class="dt">db</span>     ‘This is bit-mapped text, drawn <span class="kw">in</span> hi-res <span class="st">&#39;</span>
                <span class="dt">db</span>     ‘EGA graphics mode 10h.<span class="st">&#39;, 0dh, 0ah, 0ah</span>
                <span class="dt">db</span>     ‘Press any key to blank the screen, then <span class="st">&#39;</span>
                <span class="dt">db</span>     ‘any key to unblank it,<span class="st">&#39;, 0dh, 0ah</span>
                <span class="dt">db</span>     ‘then any key to end.<span class="dv">$</span><span class="st">&#39;</span>
Data        ends
<span class="co">;</span>
Code        <span class="kw">segment</span>
            assume  <span class="kw">cs</span>:Code, <span class="kw">ds</span>:Data
Start       proc    near
            <span class="kw">mov</span>     <span class="kw">ax</span>,Data
            <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Go to hi-res graphics mode.</span>
<span class="co">;</span>
            <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,10h          </span><span class="co">;AH = 0 means mode set, AL = 10h selects</span>
                                    <span class="co">; hi-res graphics mode</span>
            <span class="kw">int</span><span class="bn">     10h             </span><span class="co">;BIOS video interrupt</span>
<span class="co">;</span>
<span class="co">; Put up some text, so the screen isn&#39;t empty.</span>
<span class="co">;</span>
            <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">9</span>            <span class="co">;DOS print string function</span>
            <span class="kw">mov</span>     <span class="kw">dx</span>,offset SampleText
            <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
            WAIT_KEY
<span class="co">;</span>
<span class="co">; Blank the screen.</span>
<span class="co">;</span>
            <span class="kw">mov</span>     <span class="kw">dx</span>,INPUT_STATUS_1
            <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>           <span class="co">;reset port 3c0h to index (rather than data)</span>
                                    <span class="co">; mode</span>
            <span class="kw">mov</span>     <span class="kw">dx</span>,AC_INDEX
            <span class="kw">sub</span>     <span class="kw">al</span>,<span class="kw">al</span>           <span class="co">;make bit 5 zero...</span>
            <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">;...which blanks the screen</span>
<span class="co">;</span>
            WAIT_KEY
<span class="co">;</span>
<span class="co">; Unblank the screen.</span>
<span class="co">;</span>
            <span class="kw">mov</span>    <span class="kw">dx</span>,INPUT_STATUS_1
            <span class="kw">in</span>     <span class="kw">al</span>,<span class="kw">dx</span>            <span class="co">;reset port 3c0h to Index (rather than data)</span>
                                    <span class="co">; mode</span>
            <span class="kw">mov</span>    <span class="kw">dx</span>,AC_INDEX
            <span class="kw">mov</span>    <span class="kw">al</span><span class="bn">,20h           </span><span class="co">;make bit 5 one...</span>
            <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>            <span class="co">;...which unblanks the screen</span>
<span class="co">;</span>
            WAIT_KEY
<span class="co">;</span>
<span class="co">; Restore text mode.</span>
<span class="co">;</span>
            <span class="kw">mov</span>    <span class="kw">ax</span>,<span class="dv">2</span>
            <span class="kw">int</span><span class="bn">    10h</span>
<span class="co">;</span>
<span class="co">; Done.</span>
<span class="co">;</span>
<span class="fu">Done:</span>
            <span class="kw">mov</span>    <span class="kw">ah</span><span class="bn">,4ch           </span><span class="co">;DOS terminate function</span>
            <span class="kw">int</span><span class="bn">    21h</span>
Start              endp
Code               ends
            end    Start</code></pre>
<p>Does that do it for color selection? Yes and no. For the EGA, we’ve covered the whole of color selection—but not so for the VGA. The VGA can emulate everything we’ve discussed, but actually performs one 4-bit to 8-bit translation (except in 256-color modes, where all 256 colors are simultaneously available), followed by yet another translation, this one 8-bit to 18-bit. What’s more, the VGA has the ability to flip instantly through as many as 16 16-color sets. The VGA’s color selection capabilities, which are supported by another set of BIOS functions, can be used to produce stunning color effects, as we’ll see when we cover them starting in Chapter 33.</p>
</section>
<section id="modifying-vga-registers" class="level3">
<h3><a href="#modifying-vga-registers">Modifying VGA Registers</a></h3>
<p>EGA registers are not readable. VGA registers are readable. This revelation will not come as news to most of you, but many programmers still insist on setting entire VGA registers even when they’re modifying only selected bits, as if they were programming the EGA. This comes to mind because I recently received a query inquiring why write mode 1 (in which the contents of the latches are copied directly to display memory) didn’t work in Mode X. (I’ll go into Mode X in detail later in this book.) Actually, write mode 1 does work in Mode X; it didn’t work when this particular correspondent enabled it because he did so by writing the value 01H to the Graphics Mode register. As it happens, the write mode field is only one of several fields in that register, as shown in Figure 29.4. In 256-color modes, one of the other fields—bit 6, which enables 256-color pixel formatting—is not 0, and setting it to 0 messes up the screen quite thoroughly.</p>
<p>The correct way to set a field within a VGA register is, of course, to read the register, mask off the desired field, insert the desired setting, and write the result back to the register. In the case of setting the VGA to write mode 1, do this:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>   <span class="kw">dx</span><span class="bn">,3ceh          </span><span class="co">;Graphics controller index</span>
<span class="kw">mov</span>   <span class="kw">al</span>,<span class="dv">5</span>             <span class="co">;Graphics mode reg index</span>
<span class="kw">out</span>   <span class="kw">dx</span>,<span class="kw">al</span>            <span class="co">;point GC index to G_MODE</span>
<span class="kw">inc</span>   <span class="kw">dx</span>               <span class="co">;Graphics controller data</span>
<span class="kw">in</span>    <span class="kw">al</span>,<span class="kw">dx</span>            <span class="co">;get current mode setting</span>
<span class="kw">and</span>   <span class="kw">al</span>,<span class="kw">not</span> <span class="dv">3</span>         <span class="co">;mask off write mode field</span>
<span class="kw">or</span>    <span class="kw">al</span>,<span class="dv">1</span>             <span class="co">;set write mode field to 1</span>
<span class="kw">out</span>   <span class="kw">dx</span>,<span class="kw">al</span>            <span class="co">;set write mode 1</span></code></pre>
<p>This approach is more of a nuisance than simply setting the whole register, but it’s safer. It’s also slower; for cases where you must set a field repeatedly, it might be worthwhile to read and mask the register once at the start, and save it in a variable, so that the value is readily available in memory and need not be repeatedly read from the port. This approach is especially attractive because <code>IN</code>s are much slower than memory accesses on 386 and 486 machines.</p>
<p>Astute readers may wonder why I didn’t put a delay sequence, such as <code>JMP \$+2</code>, between the <code>IN</code> and <code>OUT</code> involving the same register. There are, after all, guidelines from IBM, specifying that a certain period should be allowed to elapse before a second access to an I/O port is attempted, because not all devices can respond as rapidly as a 286 or faster CPU can access a port. My answer is that while I can’t guarantee that a delay isn’t needed, I’ve never found a VGA that required one; I suspect that the delay specification has more to do with motherboard chips such as the timer, the interrupt controller, and the like, and I sure hate to waste the delay time if it’s not necessary. However, I’ve never been able to find anyone with the definitive word on whether delays might ever be needed when accessing VGAs, so if you know the gospel truth, or if you know of a VGA/processor combo that does require delays, please let me know by contacting me through the publisher. You’d be doing a favor for a whole generation of graphics programmers who aren’t sure whether they’re skating on thin ice without those legendary delays.</p>
<figure>
<img src="images/29-04.jpg" alt="Figure 29.4  Graphics mode register fields." /><figcaption><strong>Figure 29.4</strong>  <em>Graphics mode register fields.</em></figcaption>
</figure>
</section>
</section>
<section id="chapter-30-video-est-omnis-divisa" class="level2">
<h2><a href="#chapter-30-video-est-omnis-divisa">Chapter 30 – Video Est Omnis Divisa</a></h2>
<section id="the-joys-and-galling-problems-of-using-split-screens-on-the-ega-and-vga" class="level3">
<h3><a href="#the-joys-and-galling-problems-of-using-split-screens-on-the-ega-and-vga">The Joys and Galling Problems of Using Split Screens on the EGA and VGA</a></h3>
<p>The ability to split the screen into two largely independent portions one—displayed above the other on the screen—is one of the more intriguing capabilities of the VGA and EGA. The split screen feature can be used for popups (including popups that slide smoothly onto the screen), or simply to display two separate portions of display memory on a single screen. While it’s possible to accomplish the same effects purely in software without using the split screen, software solutions tend to be slow and hard to implement.</p>
<p>By contrast, the basic operation of the split screen is fairly simple, once you grasp the various coding tricks required to pull it off, and understand the limitations and pitfalls—like the fact that the EGA’s split screen implementation is a little buggy. Furthermore, panning with the split screen enabled is not as simple as it might seem. All in all, we do have some ground to cover.</p>
<p>Let’s start with the basic operation of the split screen.</p>
</section>
<section id="how-the-split-screen-works" class="level3">
<h3><a href="#how-the-split-screen-works">How the Split Screen Works</a></h3>
<p>The <em>operation</em> of the split screen is simplicity itself. A split screen start scan line value is programmed into two EGA registers or three VGA registers. (More on exactly which registers in a moment.) At the beginning of each frame, the video circuitry begins to scan display memory for video data starting at the address specified by the start address registers, just as it normally would. When the video circuitry encounters the specified split screen start scan line in the course of scanning video data onto the screen, it completes that scan line normally, then resets the internal pointer which addresses the next byte of display memory to be read for video data to zero. Display memory from address zero onward is then scanned for video data in the usual way, progressing toward the high end of memory. At the end of the frame, the pointer to the next byte of display memory to scan is reloaded from the start address registers, and the whole process starts over.</p>
<p>The net effect: The contents of display memory starting at offset zero are displayed starting at the scan line following the specified split screen start scan line, as shown in Figure 30.1. It’s important to understand that the scan line that matches the split screen scan line is <em>not</em> part of the split screen; the split screen starts on the <em>following</em> scan line. So, for example, if the split screen scan line is set to zero, the split screen actually starts at scan line 1, the second scan line from the top of the screen.</p>
<p>If both the start address and the split screen start scan line are set to 0, the data at offset zero in display memory is displayed as both the first scan line on the screen <em>and</em> the second scan line. There is no way to make the split screen cover the entire screen—it always comes up at least one scan line short.</p>
<figure>
<img src="images/30-01.jpg" alt="Figure 30.1  Display memory and the split screen." /><figcaption><strong>Figure 30.1</strong>  <em>Display memory and the split screen.</em></figcaption>
</figure>
<p>So, where is the split screen start scan line stored? The answer varies a bit, depending on whether you’re talking about the EGA or the VGA. On the EGA, the split screen start scan line is a 9-bit value, with bits 7-0 stored in the Line Compare register (CRTC register 18H) and bit 8 stored in bit 4 of the Overflow register (CRTC register 7). Other bits in the Overflow register serve as the high bits of other values, such as the vertical total and the vertical blanking start. Since EGA registers are—alas!—not readable, you must know the correct settings for the other bits in the Overflow registers to use the split screen on an EGA. Fortunately, there are only two standard Overflow register settings on the EGA: 11H for 200-scan-line modes and 1FH for 350-scan-line modes.</p>
<p>The VGA, of course, presents no such problem in setting the split screen start scan line, for it has readable registers. However, the VGA supports a 10-bit split screen start scan line value, with bits 8-0 stored just as with the EGA, and bit 9 stored in bit 6 of the Maximum Scan Line register (CRTC register 9).</p>
<p>Turning the split screen on involves nothing more than setting all bits of the split screen start scan line to the scan line after which you want the split screen to start appearing. (Of course, you’ll probably want to change the start address before using the split screen; otherwise, you’ll just end up displaying the memory at offset zero <em>twice:</em> once in the normal screen and once in the split screen.) Turning off the split screen is a simple matter of setting the split screen start scan line to a value equal to or greater than the last scan line displayed; the safest such approach is to set all bits of the split screen start scan line to 1. (That is, in fact, the split screen start scan line value programmed by the BIOS during a mode set.)</p>
<section id="the-split-screen-in-action" class="level4">
<h4><a href="#the-split-screen-in-action">The Split Screen in Action</a></h4>
<p>All of these points are illustrated by Listing 30.1. Listing 30.1 fills display memory starting at offset zero (the split screen area of memory) with text identifying the split screen, fills display memory starting at offset 8000H with a graphics pattern, and sets the start address to 8000H. At this point, the normal screen is being displayed (the split screen start scan line is still set to the BIOS default setting, with all bits equal to 1, so the split screen is off), with the pixels based on the contents of display memory at offset 8000H. The contents of display memory between offset 0 and offset 7FFFH are not visible at all.</p>
<p>Listing 30.1 then slides the split screen up from the bottom of the screen, one scan line at a time. The split screen slides halfway up the screen, bounces down a quarter of the screen, advances another half-screen, drops another quarter-screen, and finally slides all the way up to the top. If you’ve never seen the split screen in action, you should run Listing 30.1; the smooth overlapping of the split screen on top of the normal display is a striking effect.</p>
<p>Listing 30.1 isn’t done just yet, however. After a keypress, Listing 30.1 demonstrates how to turn the split screen off (by setting all bits of the split screen start scan line to 1). After another keypress, Listing 30.1 shows that the split screen can never cover the whole screen, by setting the start address to 0 and then flipping back and forth between the normal screen and the split screen with a split screen start scan line setting of zero. Both the normal screen and the split screen display the same text, but the split screen displays it one scan line lower, because the split screen doesn’t start until <em>after</em> the first scan line, and that produces a jittering effect as the program switches the split screen on and off. (On the EGA, the split screen may display <em>two</em> scan lines lower, for reasons I’ll discuss shortly.)</p>
<p>Finally, after another keypress, Listing 30.1 halts.</p>
<p><strong>LISTING 30.1 L30-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Demonstrates the VGA/EGA split screen in action.</span>
<span class="co">;</span>
<span class="co">;*********************************************************************</span>
IS_VGA               <span class="dt">equ</span>  <span class="dv">1</span>        <span class="co">;set to 0 to assemble for EGA</span>
<span class="co">;</span>
VGA_SEGMENT          <span class="dt">equ</span><span class="bn">  0a000h</span>
SCREEN_WIDTH         <span class="dt">equ</span>  <span class="dv">640</span>
SCREEN_HEIGHT        <span class="dt">equ</span>  <span class="dv">350</span>
CRTC_INDEX           <span class="dt">equ</span><span class="bn">  3d4h     </span><span class="co">;CRT Controller Index register</span>
OVERFLOW             <span class="dt">equ</span>  <span class="dv">7</span>        <span class="co">;index of Overflow reg in CRTC</span>
MAXIMUM_SCAN_LINEequ <span class="dv">9</span>             <span class="co">;index of Maximum Scan Line register</span>
                                   <span class="co">; in CRTC</span>
START_ADDRESS_HIGH   <span class="dt">equ</span><span class="bn">  0ch      </span><span class="co">;index of Start Address High register</span>
                                   <span class="co">; in CRTC</span>
START_ADDRESS_LOW    <span class="dt">equ</span><span class="bn">  0dh      </span><span class="co">;index of Start Address Low register</span>
                                   <span class="co">; in CRTC</span>
LINE_COMPARE         <span class="dt">equ</span><span class="bn">  18h      </span><span class="co">;index of Line Compare reg (bits 7-0</span>
                                   <span class="co">; of split screen start scan line)</span>
                                   <span class="co">; in CRTC</span>
INPUT_STATUS_0       <span class="dt">equ</span><span class="bn">  3dah     </span><span class="co">;Input Status 0 register</span>
WORD_OUTS_OK         <span class="dt">equ</span>  <span class="dv">1</span>        <span class="co">;set to 0 to assemble for</span>
                                   <span class="co">; computers that can&#39;t handle</span>
                                   <span class="co">; word outs to indexed VGA registers</span>
<span class="co">;*********************************************************************</span>
<span class="co">; Macro to output a word value to a port.</span>
<span class="co">;</span>
OUT_WORD     macro
if WORD_OUTS_OK
      <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">ax</span>
else
      <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
      <span class="kw">inc</span>    <span class="kw">dx</span>
      <span class="kw">xchg</span>   <span class="kw">ah</span>,<span class="kw">al</span>
      <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
      <span class="kw">dec</span>    <span class="kw">dx</span>
      <span class="kw">xchg</span>   <span class="kw">ah</span>,<span class="kw">al</span>
endif
      endm
<span class="co">;*********************************************************************</span>
MyStack      <span class="kw">segment</span> para stack <span class="st">&#39;STACK&#39;</span>
     <span class="dt">db</span>      <span class="dv">512</span> dup (<span class="dv">0</span>)
MyStack      ends
<span class="co">;*********************************************************************</span>
Data  <span class="kw">segment</span>
SplitScreenLine   <span class="dt">dw</span>   ?   <span class="co">;line the split screen currently</span>
                           <span class="co">; starts after</span>
StartAddress      <span class="dt">dw</span>   ?   <span class="co">;display memory offset at which</span>
                           <span class="co">; scanning for video data starts</span>
<span class="co">; Message displayed in split screen.</span>
SplitScreenMsg    <span class="dt">db</span>   <span class="st">&#39;Split screen text row #&#39;</span>
DigitInsert       <span class="dt">dw</span>   ?
                  <span class="dt">db</span>   <span class="st">&#39;...$&#39;</span>
Data  ends
<span class="co">;*********************************************************************</span>
Code  <span class="kw">segment</span>
      assume      <span class="kw">cs</span>:Code, <span class="kw">ds</span>:Data
<span class="co">;*********************************************************************</span>
Start proc  near
      <span class="kw">mov</span>   <span class="kw">ax</span>,Data
      <span class="kw">mov</span>   <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Select mode 10h, 640x350 16-color graphics mode.</span>
<span class="co">;</span>
      <span class="kw">mov</span>   <span class="kw">ax</span><span class="bn">,0010h              </span><span class="co">;AH=0 is select mode function</span>
                                  <span class="co">;AL=10h is mode to select,</span>
                                  <span class="co">; 640x350 16-color graphics mode</span>
      <span class="kw">int</span><span class="bn">   10h</span>
<span class="co">;</span>
<span class="co">; Put text into display memory starting at offset 0, with each row</span>
<span class="co">; labelled as to number. This is the part of memory that will be</span>
<span class="co">; displayed in the split screen portion of the display.</span>
<span class="co">;</span>
       <span class="kw">mov</span>   <span class="kw">cx</span>,<span class="dv">25</span>                <span class="co">;# of lines of text we&#39;ll draw into</span>
                                  <span class="co">; the split screen part of memory</span>
<span class="fu">FillSplitScreenLoop:</span>
       <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="dv">2</span>                <span class="co">;set cursor location function #</span>
       <span class="kw">sub</span>    <span class="kw">bh</span>,<span class="kw">bh</span>               <span class="co">;set cursor in page 0</span>
       <span class="kw">mov</span>    <span class="kw">dh</span>,<span class="dv">25</span>
       <span class="kw">sub</span>    <span class="kw">dh</span>,<span class="kw">cl</span>               <span class="co">;calculate row to draw in</span>
       <span class="kw">sub</span>    <span class="kw">dl</span>,<span class="kw">dl</span>               <span class="co">;start in column 0</span>
       <span class="kw">int</span><span class="bn">    10h                 </span><span class="co">;set the cursor location</span>
       <span class="kw">mov</span>    <span class="kw">al</span>,<span class="dv">25</span>
       <span class="kw">sub</span>    <span class="kw">al</span>,<span class="kw">cl</span>               <span class="co">;calculate row to draw in again</span>
       <span class="kw">sub</span>    <span class="kw">ah</span>,<span class="kw">ah</span>               <span class="co">;make the value a word for division</span>
       <span class="kw">mov</span>    <span class="kw">dh</span>,<span class="dv">10</span>
       <span class="kw">div</span>    <span class="kw">dh</span>                  <span class="co">;split the row # into two digits</span>
       <span class="kw">add</span>    <span class="kw">ax</span>,<span class="st">&#39;00&#39;</span>             <span class="co">;convert the digits to ASCII</span>
       <span class="kw">mov</span>    [DigitInsert],<span class="kw">ax</span>    <span class="co">;put the digits into the text</span>
                                  <span class="co">; to be displayed</span>
       <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="dv">9</span>
       <span class="kw">mov</span>    <span class="kw">dx</span>,offset SplitScreenMsg
       <span class="kw">int</span><span class="bn">    21h                 </span><span class="co">;print the text</span>
       <span class="kw">loop</span>   FillSplitScreenLoop
<span class="co">;</span>
<span class="co">; Fill display memory starting at 8000h with a diagonally striped</span>
<span class="co">; pattern.</span>
<span class="co">;</span>
       <span class="kw">mov</span>    <span class="kw">ax</span>,VGA_SEGMENT
       <span class="kw">mov</span>    <span class="kw">es</span>,<span class="kw">ax</span>
       <span class="kw">mov</span>    <span class="kw">di</span><span class="bn">,8000h</span>
       <span class="kw">mov</span>    <span class="kw">dx</span>,SCREEN_HEIGHT     <span class="co">;fill all lines</span>
       <span class="kw">mov</span>    <span class="kw">ax</span><span class="bn">,8888h             </span><span class="co">;starting fill pattern</span>
       <span class="kw">cld</span>
<span class="fu">RowLoop:</span>
       <span class="kw">mov</span>    <span class="kw">cx</span>,SCREEN_WIDTH/<span class="dv">8</span>/<span class="dv">2</span>  <span class="co">;fill 1 scan line a word at a time</span>
       rep    <span class="kw">stosw</span>                <span class="co">;fill the scan line</span>
       <span class="kw">ror</span>    <span class="kw">ax</span>,<span class="dv">1</span>                 <span class="co">;shift pattern word</span>
       <span class="kw">dec</span>    <span class="kw">dx</span>
       <span class="kw">jnz</span>    RowLoop
<span class="co">;</span>
<span class="co">; Set the start address to 8000h and display that part of memory.</span>
<span class="co">;</span>
       <span class="kw">mov</span>    [StartAddress]<span class="bn">,8000h</span>
       <span class="kw">call</span>   SetStartAddress
<span class="co">;</span>
<span class="co">; Slide the split screen half way up the screen and then back down</span>
<span class="co">; a quarter of the screen.</span>
<span class="co">;</span>
       <span class="kw">mov</span>    [SplitScreenLine],SCREEN_HEIGHT<span class="dv">-1</span>
                                    <span class="co">;set the initial line just off</span>
                                    <span class="co">; the bottom of the screen</span>
       <span class="kw">mov</span>    <span class="kw">cx</span>,SCREEN_HEIGHT/<span class="dv">2</span>
       <span class="kw">call</span>   SplitScreenUp
       <span class="kw">mov</span>    <span class="kw">cx</span>,SCREEN_HEIGHT/<span class="dv">4</span>
       <span class="kw">call</span>   SplitScreenDown
<span class="co">;</span>
<span class="co">; Now move up another half a screen and then back down a quarter.</span>
<span class="co">;</span>
       <span class="kw">mov</span>    <span class="kw">cx</span>,SCREEN_HEIGHT/<span class="dv">2</span>
       <span class="kw">call</span>   SplitScreenUp
       <span class="kw">mov</span>    <span class="kw">cx</span>,SCREEN_HEIGHT/<span class="dv">4</span>
       <span class="kw">call</span>   SplitScreenDown
<span class="co">;</span>
<span class="co">; Finally move up to the top of the screen.</span>
<span class="co">;</span>
       <span class="kw">mov</span>    <span class="kw">cx</span>,SCREEN_HEIGHT/<span class="dv">2-2</span>
       <span class="kw">call</span>   SplitScreenUp
<span class="co">;</span>
<span class="co">; Wait for a key press (don&#39;t echo character).</span>
<span class="co">;</span>
       <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="dv">8</span>                   <span class="co">;DOS console input without echo function</span>
       <span class="kw">int</span><span class="bn">    21h</span>
<span class="co">;</span>
<span class="co">; Turn the split screen off.</span>
<span class="co">;</span>
       <span class="kw">mov</span>    [SplitScreenLine]<span class="bn">,0ffffh</span>
       <span class="kw">call</span>   SetSplitScreenScanLine
<span class="co">;</span>
<span class="co">; Wait for a key press (don&#39;t echo character).</span>
<span class="co">;</span>
       <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="dv">8</span>                    <span class="co">;DOS console input without echo function</span>
       <span class="kw">int</span><span class="bn">    21h</span>
<span class="co">;</span>
<span class="co">; Display the memory at 0 (the same memory the split screen displays).</span>
<span class="co">;</span>
       <span class="kw">mov</span>    [StartAddress],<span class="dv">0</span>
       <span class="kw">call</span>   SetStartAddress
<span class="co">;</span>
<span class="co">; Flip between the split screen and the normal screen every 10th</span>
<span class="co">; frame until a key is pressed.</span>
<span class="co">;</span>
<span class="fu">FlipLoop:</span>
       <span class="kw">xor</span>    [SplitScreenLine]<span class="bn">,0ffffh</span>
       <span class="kw">call</span>   SetSplitScreenScanLine
       <span class="kw">mov</span>    <span class="kw">cx</span>,<span class="dv">10</span>
<span class="fu">CountVerticalSyncsLoop:</span>
       <span class="kw">call</span>   WaitForVerticalSyncEnd
       <span class="kw">loop</span>   CountVerticalSyncsLoop
       <span class="kw">mov</span>    <span class="kw">ah</span><span class="bn">,0bh                  </span><span class="co">;DOS character available status</span>
       <span class="kw">int</span><span class="bn">    21h</span>
       <span class="kw">and</span>    <span class="kw">al</span>,<span class="kw">al</span> <span class="co">;character available?</span>
       <span class="kw">jz</span>     FlipLoop                 <span class="co">;no, toggle split screen on/off status</span>
       <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="dv">1</span>
       <span class="kw">int</span><span class="bn">    21h                      </span><span class="co">;clear the character</span>
<span class="co">;</span>
<span class="co">; Return to text mode and DOS.</span>
<span class="co">;</span>
       <span class="kw">mov</span>    <span class="kw">ax</span><span class="bn">,0003h                 </span><span class="co">;AH=0 is select mode function</span>
<span class="co">;AL=3 is mode to select, text mode</span>
       <span class="kw">int</span><span class="bn">    10h                      </span><span class="co">;return to text mode</span>
       <span class="kw">mov</span>    <span class="kw">ah</span><span class="bn">,4ch</span>
       <span class="kw">int</span><span class="bn">    21h                      </span><span class="co">;return to DOS</span>
Startendp
<span class="co">;*********************************************************************</span>
<span class="co">; Waits for the leading edge of the vertical sync pulse.</span>
<span class="co">;</span>
<span class="co">; Input: none</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; Registers altered: AL, DX</span>
<span class="co">;</span>
WaitForVerticalSyncStartprocnear
       <span class="kw">mov</span>    <span class="kw">dx</span>,INPUT_STATUS_0
<span class="fu">WaitNotVerticalSync:</span>
       <span class="kw">in</span>     <span class="kw">al</span>,<span class="kw">dx</span>
       <span class="kw">test</span>   <span class="kw">al</span><span class="bn">,08h</span>
       <span class="kw">jnz</span>    WaitNotVerticalSync
<span class="fu">WaitVerticalSync:</span>
       <span class="kw">in</span>     <span class="kw">al</span>,<span class="kw">dx</span>
       <span class="kw">test</span>   <span class="kw">al</span><span class="bn">,08h</span>
       <span class="kw">jz</span>     WaitVerticalSync
       <span class="kw">ret</span>
WaitForVerticalSyncStart       endp
<span class="co">;*********************************************************************</span>
<span class="co">; Waits for the trailing edge of the vertical sync pulse.</span>
<span class="co">;</span>
<span class="co">; Input: none</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; Registers altered: AL, DX</span>
<span class="co">;</span>
WaitForVerticalSyncEndprocnear
       <span class="kw">mov</span>    <span class="kw">dx</span>,INPUT_STATUS_0
<span class="fu">WaitVerticalSync2:</span>
       <span class="kw">in</span>     <span class="kw">al</span>,<span class="kw">dx</span>
       <span class="kw">test</span>   <span class="kw">al</span><span class="bn">,08h</span>
       <span class="kw">jz</span>     WaitVerticalSync2
<span class="fu">WaitNotVerticalSync2:</span>
       <span class="kw">in</span>     <span class="kw">al</span>,<span class="kw">dx</span>
       <span class="kw">test</span>   <span class="kw">al</span><span class="bn">,08h</span>
       <span class="kw">jnz</span>    WaitNotVerticalSync2
       <span class="kw">ret</span>
WaitForVerticalSyncEndendp
<span class="co">;*********************************************************************</span>
<span class="co">; Sets the start address to the value specifed by StartAddress.</span>
<span class="co">; Wait for the trailing edge of vertical sync before setting so that</span>
<span class="co">; one half of the address isn&#39;t loaded before the start of the frame</span>
<span class="co">; and the other half after, resulting in flicker as one frame is</span>
<span class="co">; displayed with mismatched halves. The new start address won&#39;t be</span>
<span class="co">; loaded until the start of the next frame; that is, one full frame</span>
<span class="co">; will be displayed before the new start address takes effect.</span>
<span class="co">;</span>
<span class="co">; Input: none</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; Registers altered: AX, DX</span>
<span class="co">;</span>
SetStartAddress       proc    near
       <span class="kw">call</span>    WaitForVerticalSyncEnd
       <span class="kw">mov</span>     <span class="kw">dx</span>,CRTC_INDEX
       <span class="kw">mov</span>     <span class="kw">al</span>,START_ADDRESS_HIGH
       <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [StartAddress<span class="dv">+1</span>]
       <span class="kw">cli</span>                       <span class="co">;make sure both registers get set at once</span>
       OUT_WORD
       <span class="kw">mov</span>     <span class="kw">al</span>,START_ADDRESS_LOW
       <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [StartAddress]
       OUT_WORD
       <span class="kw">sti</span>
       <span class="kw">ret</span>
SetStartAddress     endp
<span class="co">;*********************************************************************</span>
<span class="co">; Sets the scan line the split screen starts after to the scan line</span>
<span class="co">; specified by SplitScreenLine.</span>
<span class="co">;</span>
<span class="co">; Input: none</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; All registers preserved</span>
<span class="co">;</span>
SetSplitScreenScanLine    proc  near
       <span class="kw">push</span>    <span class="kw">ax</span>
       <span class="kw">push</span>    <span class="kw">cx</span>
       <span class="kw">push</span>    <span class="kw">dx</span>
<span class="co">;</span>
<span class="co">; Wait for the leading edge of the vertical sync pulse. This ensures</span>
<span class="co">; that we don&#39;t get mismatched portions of the split screen setting</span>
<span class="co">; while setting the two or three split screen registers (register 18h</span>
<span class="co">; set but register 7 not yet set when a match occurs, for example),</span>
<span class="co">; which could produce brief flickering.</span>
<span class="co">;</span>
       <span class="kw">call</span> WaitForVerticalSyncStart
<span class="co">;</span>
<span class="co">; Set the split screen scan line.</span>
<span class="co">;</span>
       <span class="kw">mov</span>    <span class="kw">dx</span>,CRTC_INDEX
       <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [SplitScreenLine]
       <span class="kw">mov</span>    <span class="kw">al</span>,LINE_COMPARE
       <span class="kw">cli</span>                               <span class="co">;make sure all the registers get set at once</span>
       OUT_WORD                          <span class="co">;set bits 7-0 of the split screen scan line</span>
       <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [SplitScreenLine<span class="dv">+1</span>]
       <span class="kw">and</span>    <span class="kw">ah</span>,<span class="dv">1</span>
       <span class="kw">mov</span>    <span class="kw">cl</span>,<span class="dv">4</span>
       <span class="kw">shl</span>    <span class="kw">ah</span>,<span class="kw">cl</span>                      <span class="co">;move bit 8 of the split split screen scan</span>
                                         <span class="co">; line into position for the Overflow reg</span>
       <span class="kw">mov</span>    <span class="kw">al</span>,OVERFLOW
if IS_VGA
<span class="co">;</span>
<span class="co">; The Split Screen, Overflow, and Line Compare registers all contain</span>
<span class="co">; part of the split screen start scan line on the VGA. We&#39;ll take</span>
<span class="co">; advantage of the readable registers of the VGA to leave other bits</span>
<span class="co">; in the registers we access undisturbed.</span>
<span class="co">;</span>
       <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                      <span class="co">;set CRTC Index reg to point to Overflow</span>
       <span class="kw">inc</span>    <span class="kw">dx</span>                         <span class="co">;point to CRTC Data reg</span>
       <span class="kw">in</span>     <span class="kw">al</span>,<span class="kw">dx</span>                      <span class="co">;get the current Overflow reg setting</span>
       <span class="kw">and</span>    <span class="kw">al</span>,<span class="kw">not</span><span class="bn"> 10h                 </span><span class="co">;turn off split screen bit 8</span>
       <span class="kw">or</span>     <span class="kw">al</span>,<span class="kw">ah</span>                      <span class="co">;insert the new split screen bit 8</span>
                                         <span class="co">; (works in any mode)</span>
       <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                      <span class="co">;set the new split screen bit 8</span>
       <span class="kw">dec</span>    <span class="kw">dx</span>                         <span class="co">;point to CRTC Index reg</span>
       <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [SplitScreenLine<span class="dv">+1</span>]
       <span class="kw">and</span>    <span class="kw">ah</span>,<span class="dv">2</span>
       <span class="kw">mov</span>    <span class="kw">cl</span>,<span class="dv">3</span>
       <span class="kw">ror</span>    <span class="kw">ah</span>,<span class="kw">cl</span>                      <span class="co">;move bit 9 of the split split screen scan</span>
                                         <span class="co">; line into position for the Maximum Scan</span>
                                         <span class="co">; Line register</span>
       <span class="kw">mov</span>    <span class="kw">al</span>,MAXIMUM_SCAN_LINE
       <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                      <span class="co">;set CRTC Index reg to point to Maximum</span>
                                         <span class="co">; Scan Line</span>
       <span class="kw">inc</span>    <span class="kw">dx</span>                         <span class="co">;point to CRTC Data reg</span>
       <span class="kw">in</span>     <span class="kw">al</span>,<span class="kw">dx</span>                      <span class="co">;get the current Maximum Scan Line setting</span>
       <span class="kw">and</span>    <span class="kw">al</span>,<span class="kw">not</span><span class="bn"> 40h                 </span><span class="co">;turn off split screen bit 9</span>
       <span class="kw">or</span>     <span class="kw">al</span>,<span class="kw">ah</span>                      <span class="co">;insert the new split screen bit 9</span>
                                         <span class="co">; (works in any mode)</span>
       <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>                      <span class="co">;set the new split screen bit 9</span>
else
<span class="co">;</span>
<span class="co">; Only the Split Screen and Overflow registers contain part of the</span>
<span class="co">; Split Screen start scan line and need to be set on the EGA.</span>
<span class="co">; EGA registers are not readable, so we have to set the non-split</span>
<span class="co">; screen bits of the Overflow register to a preset value, in this</span>
<span class="co">; case the value for 350-scan-line modes.</span>
<span class="co">;</span>
       <span class="kw">or</span>    <span class="kw">ah</span><span class="bn">,0fh                       </span><span class="co">;insert the new split screen bit 8</span>
                                          <span class="co">; (only works in 350-scan-line EGA modes)</span>
       OUT_WORD                           <span class="co">;set the new split screen bit 8</span>
endif
       <span class="kw">sti</span>
       <span class="kw">pop</span>    <span class="kw">dx</span>
       <span class="kw">pop</span>    <span class="kw">cx</span>
       <span class="kw">pop</span>    <span class="kw">ax</span>
       <span class="kw">ret</span>
SetSplitScreenScanLine endp
<span class="co">;*********************************************************************</span>
<span class="co">; Moves the split screen up the specified number of scan lines.</span>
<span class="co">;</span>
<span class="co">; Input: CX = # of scan lines to move the split screen up by</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; Registers altered: CX</span>
<span class="co">;</span>
SplitScreenUp    proc    near
<span class="fu">SplitScreenUpLoop:</span>
       <span class="kw">dec</span>    [SplitScreenLine]
       <span class="kw">call</span>   SetSplitScreenScanLine
       <span class="kw">loop</span>   SplitScreenUpLoop
       <span class="kw">ret</span>
SplitScreenUp    endp
<span class="co">;*********************************************************************</span>
<span class="co">; Moves the split screen down the specified number of scan lines.</span>
<span class="co">;</span>
<span class="co">; Input: CX = # of scan lines to move the split screen down by</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; Registers altered: CX</span>
<span class="co">;</span>
SplitScreenDown    proc    near
<span class="fu">SplitScreenDownLoop:</span>
       <span class="kw">inc</span>    [SplitScreenLine]
       <span class="kw">call</span>   SetSplitScreenScanLine
       <span class="kw">loop</span>   SplitScreenDownLoop
       <span class="kw">ret</span>
SplitScreenDown    endp
<span class="co">;*********************************************************************</span>
Code    ends
        end    Start</code></pre>
</section>
<section id="vga-and-ega-split-screen-operation-dont-mix" class="level4">
<h4><a href="#vga-and-ega-split-screen-operation-dont-mix">VGA and EGA Split-Screen Operation Don’t Mix</a></h4>
<p>You must set the <code>IS_VGA</code> equate at the start of Listing 30.1 correctly for the adapter the code will run on in order for the program to perform properly. This equate determines how the upper bits of the split screen start scan line are set by <code>SetSplitScreenRow</code>. If <code>IS_VGA</code> is 0 (specifying an EGA target), then bit 8 of the split screen start scan line is set by programming the entire Overflow register to 1FH; this is hard-wired for the 350-scan-line modes of the EGA. If <code>IS_VGA</code> is 1 (specifying a VGA target), then bits 8 and 9 of the split screen start scan line are set by reading the registers they reside in, changing only the split-screen-related bits, and writing the modified settings back to their respective registers.</p>
<p>The VGA version of Listing 30.1 won’t work on an EGA, because EGA registers aren’t readable. The EGA version of Listing 30.1 won’t work on a VGA, both because VGA monitors require different vertical settings than EGA monitors and because the EGA version doesn’t set bit 9 of the split screen start scan line. In short, there is no way that I know of to support both VGA and EGA split screens with common code; separate drivers are required. This is one of the reasons that split screens are so rarely used in PC programming.</p>
<p>By the way, Listing 30.1 operates in mode 10H because that’s the highest-resolution mode the VGA and EGA share. That’s not the only mode the split screen works in, however. In fact, it works in <em>all</em> modes, as we’ll see later.</p>
</section>
</section>
<section id="setting-the-split-screen-related-registers" class="level3">
<h3><a href="#setting-the-split-screen-related-registers">Setting the Split-Screen-Related Registers</a></h3>
<p>Setting the split-screen-related registers is not as simple a matter as merely outputting the right values to the right registers; timing is also important. The split screen start scan line value is checked against the number of each scan line as that scan line is displayed, which means that the split screen start scan line potentially takes effect the moment it is set. In other words, if the screen is displaying scan line 15 and you set the split screen start to 16, that change will be picked up immediately and the split screen will start after the next scan line. This is markedly different from changes to the start address, which take effect only at the start of the next frame.</p>
<p>The instantly-effective nature of the split screen is a bit of a problem, not because the changed screen appears as soon as the new split screen start scan line is set—that seems to me to be an advantage—but because the changed screen can appear <em>before</em> the new split screen start scan line is set.</p>
<blockquote>
<p><img src="images/i.jpg" /> Remember, the split screen start scan line is spread out over two or three registers. What if the incompletely-changed value matches the current scan line after you’ve set one register but before you’ve set the rest? For one frame, you’ll see the split screen in a wrong place—possibly a very wrong place—resulting in jumping and flicker.</p>
</blockquote>
<p>The solution is simple: Set the split screen start scan line at a time when it can’t possibly match the currently displayed scan line. The easy way to do that is to set it when there isn’t any currently displayed scan line—during vertical non-display time. One safe time that’s easy to find is the start of the vertical sync pulse, which is typically pretty near the middle of vertical non-display time, and that’s the approach I’ve followed in Listing 30.1. I’ve also disabled interrupts during the period when the split screen registers are being set. This isn’t absolutely necessary, but if it’s not done, there’s the possibility that an interrupt will occur between register sets and delay the later register sets until display time, again causing flicker.</p>
<p>One interesting effect of setting the split screen registers at the start of vertical sync is that it has the effect of synchronizing the program to the display adapter’s frame rate. No matter how fast the computer running Listing 30.1 may be, the split screen will move at a maximum rate of once per frame. This is handy for regulating execution speed over a wide variety of hardware performance ranges; however, be aware that the VGA supports 70 Hz frame rates in all non-480-scan-line modes, while the VGA in 480-scan-line-modes and the EGA in all color modes support 60 Hz frame rates.</p>
</section>
<section id="the-problem-with-the-ega-split-screen" class="level3">
<h3><a href="#the-problem-with-the-ega-split-screen">The Problem with the EGA Split Screen</a></h3>
<p>I mentioned earlier that the EGA’s split screen is a little buggy. How? you may well ask, particularly given that Listing 30.1 illustrates that the EGA split screen seems pretty functional.</p>
<p>The bug is this: The first scan line of the EGA split screen—the scan line starting at offset zero in display memory—is displayed not once but twice. In other words, the first line of split screen display memory, and only the first line, is replicated one unnecessary time, pushing all the other lines down by one.</p>
<p>That’s not a fatal bug, of course. In fact, if the first few scan lines are identical, it’s not even noticeable. The EGA’s split-screen bug can produce visible distortion given certain patterns, however, so you should try to make the top few lines identical (if possible) when designing split-screen images that might be displayed on EGAs, and you should in any case check how your split-screens look on both VGAs and EGAs.</p>
<blockquote>
<p><img src="images/i.jpg" /> I have an important caution here: Don’t count on the EGA’s split-screen bug; that is, don’t rely on the first scan line being doubled when you design your split screens. IBM designed and made the original EGA, but a lot of companies cloned it, and there’s no guarantee that all EGA clones copy the bug. It is a certainty, at least, that the VGA didn’t copy it.</p>
</blockquote>
<p>There’s another respect in which the EGA is inferior to the VGA when it comes to the split screen, and that’s in the area of panning when the split screen is on. This isn’t a bug—it’s just one of the many areas in which the VGA’s designers learned from the shortcomings of the EGA and went the EGA one better.</p>
</section>
<section id="split-screen-and-panning" class="level3">
<h3><a href="#split-screen-and-panning">Split Screen and Panning</a></h3>
<p>Back in Chapter 23, I presented a program that performed smooth horizontal panning. Smooth horizontal panning consists of two parts: byte-by-byte (8-pixel) panning by changing the start address and pixel-by-pixel intrabyte panning by setting the Pel Panning register (AC register 13H) to adjust alignment by 0 to 7 pixels. (IBM prefers its own jargon and uses the word “pel” instead of “pixel” in much of their documentation, hence “pel panning.” Then there’s DASD, a.k.a. Direct Access Storage Device—IBM-speak for hard disk.)</p>
<p>Horizontal smooth panning works just fine, although I’ve always harbored some doubts that any one horizontal-smooth-panning approach works properly on all display board clones. (More on this later.) There’s a catch when using horizontal smooth panning with the split screen up, though, and it’s a serious catch: You can’t byte-pan the split screen (which always starts at offset zero, no matter what the setting of the start address registers)—but you <em>can</em> pel-pan the split screen.</p>
<p>Put another way, when the normal portion of the screen is horizontally smooth-panned, the split screen portion moves a pixel at a time until it’s time to move to the next byte, then jumps back to the start of the current byte. As the top part of the screen moves smoothly about, the split screen will move and jump, move and jump, over and over. Believe me, it’s not a pretty sight.</p>
<blockquote>
<p><img src="images/i.jpg" /> What’s to be done? On the EGA, nothing. Unless you’re willing to have your users’ eyes doing the jitterbug, don’t use horizontal smooth scrolling while the split screen is up. Byte panning is fine—just don’t change the Pel Panning register from its default setting.</p>
</blockquote>
<p>On the VGA, there is recourse. A VGA-only bit, bit 5 of the AC Mode Control register (AC register 10H), turns off pel panning in the split screen. In other words, when this bit is set to 1, pel panning is reset to zero before the first line of the split screen, and remains zero until the end of the frame. This doesn’t allow you to pan the split screen horizontally, mind you—there’s no way to do that—but it does let you pan the normal screen while the split screen stays rock-solid. This can be used to produce an attractive “streaming tape” effect in the normal screen while the split screen is used to display non-moving information.</p>
<section id="the-split-screen-and-horizontal-panning-an-example" class="level4">
<h4><a href="#the-split-screen-and-horizontal-panning-an-example">The Split Screen and Horizontal Panning: An Example</a></h4>
<p>Listing 30.2 illustrates the interaction of horizontal smooth panning with the split screen, as well as the suppression of pel panning in the split screen. Listing 30.2 creates a virtual screen 1024 pixels across by setting the Offset register (CRTC register 13H) to 64, sets the normal screen to scan video data beginning far enough up in display memory to leave room for the split screen starting at offset zero, turns on the split screen, and fills in the normal screen and split screen with distinctive patterns. Next, Listing 30.2 pans the normal screen horizontally without setting bit 5 of the AC Mode Control register to 1. As you’d expect, the split screen jerks about quite horribly. After a key press, Listing 30.2 sets bit 5 of the Mode Control register and pans the normal screen again. This time, the split screen doesn’t budge an inch—<em>if</em> the code is running on a VGA.</p>
<p>By the way, if <code>IS_VGA</code> is set to 0 in Listing 30.2, the program will assemble in a form that will run on the EGA and <em>only</em> the EGA. Pel panning suppression in the split screen won’t work in this version, however, because the EGA lacks the capability to support that feature. When the EGA version runs, the split screen simply jerks back and forth during both panning sessions.</p>
<p><strong>LISTING 30.2 L30-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Demonstrates the interaction of the split screen and</span>
<span class="co">; horizontal pel panning. On a VGA, first pans right in the top</span>
<span class="co">; half while the split screen jerks around, because split screen</span>
<span class="co">; pel panning suppression is disabled, then enables split screen</span>
<span class="co">; pel panning suppression and pans right in the top half while the</span>
<span class="co">; split screen remains stable. On an EGA, the split screen jerks</span>
<span class="co">; around in both cases, because the EGA doesn&#39;t support split</span>
<span class="co">; screen pel panning suppression.</span>
<span class="co">;</span>
<span class="co">; The jerking in the split screen occurs because the split screen</span>
<span class="co">; is being pel panned (panned by single pixels--intrabyte panning),</span>
<span class="co">; but is not and cannot be byte panned (panned by single bytes--</span>
<span class="co">; &quot;extrabyte&quot; panning) because the start address of the split screen</span>
<span class="co">; is forever fixed at 0.</span>
<span class="co">;*********************************************************************</span>
IS_VGA                  <span class="dt">equ</span>    <span class="dv">1</span>            <span class="co">;set to 0 to assemble for EGA</span>
<span class="co">;</span>
VGA_SEGMENT             <span class="dt">equ</span><span class="bn">    0a000h</span>
LOGICAL_SCREEN_WIDTH    <span class="dt">equ</span>    <span class="dv">1024</span>         <span class="co">;# of pixels across virtual</span>
                                            <span class="co">; screen that we&#39;ll pan across</span>
SCREEN_HEIGHT           <span class="dt">equ</span>    <span class="dv">350</span>
SPLIT_SCREEN_START      <span class="dt">equ</span>    <span class="dv">200</span>          <span class="co">;start scan line for split screen</span>
SPLIT_SCREEN_HEIGHT     <span class="dt">equ</span>    SCREEN_HEIGHT-SPLIT_SCREEN_START<span class="dv">-1</span>
CRTC_INDEX              <span class="dt">equ</span><span class="bn">    3d4h         </span><span class="co">;CRT Controller Index register</span>
AC_INDEX                <span class="dt">equ</span><span class="bn">    3c0h         </span><span class="co">;Attribute Controller Index reg</span>
OVERFLOW                <span class="dt">equ</span>    <span class="dv">7</span>            <span class="co">;index of Overflow reg in CRTC</span>
MAXIMUM_SCAN_LINE       <span class="dt">equ</span>    <span class="dv">9</span>            <span class="co">;index of Maximum Scan Line register</span>
                                            <span class="co">; in CRTC</span>
START_ADDRESS_HIGH      <span class="dt">equ</span><span class="bn">    0ch          </span><span class="co">;index of Start Address High register</span>
                                            <span class="co">; in CRTC</span>
START_ADDRESS_LOW       <span class="dt">equ</span><span class="bn">    0dh          </span><span class="co">;index of Start Address Low register</span>
                                            <span class="co">; in CRTC</span>
HOFFSET                 <span class="dt">equ</span><span class="bn">    13h          </span><span class="co">;index of Horizontal Offset register</span>
                                            <span class="co">; in CRTC</span>
LINE_COMPARE            <span class="dt">equ</span><span class="bn">    18h          </span><span class="co">;index of Line Compare reg (bits 7-0</span>
                                            <span class="co">; of split screen start scan line)</span>
                                            <span class="co">; in CRTC</span>
AC_MODE_CONTROL         <span class="dt">equ</span><span class="bn">    10h          </span><span class="co">;index of Mode Control reg in AC</span>
PEL_PANNING             <span class="dt">equ</span><span class="bn">    13h          </span><span class="co">;index of Pel Panning reg in AC</span>
INPUT_STATUS_0          <span class="dt">equ</span><span class="bn">    3dah         </span><span class="co">;Input Status 0 register</span>
WORD_OUTS_OK            <span class="dt">equ</span>    <span class="dv">1</span>            <span class="co">;set to 0 to assemble for</span>
                                            <span class="co">; computers that can&#39;t handle</span>
                                            <span class="co">; word outs to indexed VGA registers</span>
<span class="co">;*********************************************************************</span>
<span class="co">; Macro to output a word value to a port.</span>
<span class="co">;</span>
OUT_WORD    macro
if WORD_OUTS_OK
       <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">ax</span>
else
       <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
       <span class="kw">inc</span>    <span class="kw">dx</span>
       <span class="kw">xchg</span>   <span class="kw">ah</span>,<span class="kw">al</span>
       <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
       <span class="kw">dec</span>    <span class="kw">dx</span>
       <span class="kw">xchg</span>   <span class="kw">ah</span>,<span class="kw">al</span>
endif
       endm
<span class="co">;*********************************************************************</span>
MyStack       <span class="kw">segment</span> para stack <span class="st">&#39;STACK&#39;</span>
       <span class="dt">db</span>     <span class="dv">512</span> dup (<span class="dv">0</span>)
MyStack       ends
<span class="co">;*********************************************************************</span>
Datasegment
SplitScreenLine       <span class="dt">dw</span>    ?            <span class="co">;line the split screen currently</span>
                                         <span class="co">; starts after</span>
StartAddress          <span class="dt">dw</span>    ?            <span class="co">;display memory offset at which</span>
                                         <span class="co">; scanning for video data starts</span>
PelPan                <span class="dt">db</span>    ?            <span class="co">;current intrabyte horizontal pel</span>
                                         <span class="co">; panning setting</span>
Data    ends
<span class="co">;*********************************************************************</span>
Code    <span class="kw">segment</span>
        assume    <span class="kw">cs</span>:Code, <span class="kw">ds</span>:Data
<span class="co">;*********************************************************************</span>
Startproc    near
     <span class="kw">mov</span>     <span class="kw">ax</span>,Data
     <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Select mode 10h, 640x350 16-color graphics mode.</span>
<span class="co">;</span>
     <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0010h                    </span><span class="co">;AH=0 is select mode function</span>
                                         <span class="co">;AL=10h is mode to select,</span>
                                         <span class="co">; 640x350 16-color graphics mode</span>
     <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
<span class="co">; Set the Offset register to make the offset from the start of one</span>
<span class="co">; scan line to the start of the next the desired number of pixels.</span>
<span class="co">; This gives us a virtual screen wider than the actual screen to</span>
<span class="co">; pan across.</span>
<span class="co">; Note that the Offset register is programmed with the logical</span>
<span class="co">; screen width in words, not bytes, hence the final division by 2.</span>
<span class="co">;</span>
     <span class="kw">mov</span>     <span class="kw">dx</span>,CRTC_INDEX
     <span class="kw">mov</span>     <span class="kw">ax</span>,(LOGICAL_SCREEN_WIDTH/<span class="dv">8</span>/<span class="dv">2</span> <span class="kw">shl</span> <span class="dv">8</span>) <span class="kw">or</span> HOFFSET
     OUT_WORD
<span class="co">;</span>
<span class="co">; Set the start address to display the memory just past the split</span>
<span class="co">; screen memory.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    [StartAddress],SPLIT_SCREEN_HEIGHT*(LOGICAL_SCREEN_WIDTH/<span class="dv">8</span>)
     <span class="kw">call</span>    SetStartAddress
<span class="co">;</span>
<span class="co">; Set the split screen start scan line.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    [SplitScreenLine],SPLIT_SCREEN_START
     <span class="kw">call</span>   SetSplitScreenScanLine
<span class="co">;</span>
<span class="co">; Fill the split screen portion of display memory (starting at</span>
<span class="co">; offset 0) with a choppy diagonal pattern sloping left.</span>
<span class="co">;</span>
     <span class="kw">mov</span>     <span class="kw">ax</span>,VGA_SEGMENT
     <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
     <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>
     <span class="kw">mov</span>     <span class="kw">dx</span>,SPLIT_SCREEN_HEIGHT
                                              <span class="co">;fill all lines in the split screen</span>
     <span class="kw">mov</span>     <span class="kw">ax</span>,0FF0h                         <span class="co">;starting fill pattern</span>
    <span class="kw">cld</span>
<span class="fu">RowLoop:</span>
     <span class="kw">mov</span>     <span class="kw">cx</span>,LOGICAL_SCREEN_WIDTH/<span class="dv">8</span>/<span class="dv">4</span>
                                              <span class="co">;fill 1 scan line</span>
<span class="fu">ColumnLoop:</span>
     sto     sw                               <span class="co">;draw part of a diagonal line</span>
     <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> <span class="kw">es</span>:[<span class="kw">di</span>],<span class="dv">0</span>               <span class="co">;make vertical blank spaces so</span>
                                              <span class="co">; panning effects can be seen easily</span>
     <span class="kw">inc</span>     <span class="kw">di</span>
     <span class="kw">inc</span>     <span class="kw">di</span>
     <span class="kw">loop</span>    ColumnLoop
     <span class="kw">rol</span>     <span class="kw">ax</span>,<span class="dv">1</span>                             <span class="co">;shift pattern word</span>
     <span class="kw">dec</span>     <span class="kw">dx</span>
     <span class="kw">jnz</span>     RowLoop
<span class="co">;</span>
<span class="co">; Fill the portion of display memory that will be displayed in the</span>
<span class="co">; normal screen (the non-split screen part of the display) with a</span>
<span class="co">; choppy diagonal pattern sloping right.</span>
<span class="co">;</span>
     <span class="kw">mov</span>     <span class="kw">di</span>,SPLIT_SCREEN_HEIGHT*(LOGICAL_SCREEN_WIDTH/<span class="dv">8</span>)
     <span class="kw">mov</span>     <span class="kw">dx</span>,SCREEN_HEIGHT                 <span class="co">;fill all lines</span>
     <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0c510h                        </span><span class="co">;starting fill pattern</span>
     <span class="kw">cld</span>
<span class="fu">RowLoop2:</span>
     <span class="kw">mov</span>     <span class="kw">cx</span>,LOGICAL_SCREEN_WIDTH/<span class="dv">8</span>/<span class="dv">4</span>
                                              <span class="co">;fill 1 scan line</span>
<span class="fu">ColumnLoop2:</span>
     sto     sw                               <span class="co">;draw part of a diagonal line</span>
     <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> <span class="kw">es</span>:[<span class="kw">di</span>],<span class="dv">0</span>               <span class="co">;make vertical blank spaces so</span>
                                              <span class="co">; panning effects can be seen easily</span>
     <span class="kw">inc</span>     <span class="kw">di</span>
     <span class="kw">inc</span>     <span class="kw">di</span>
loopColumnLoop2
     <span class="kw">ror</span>     <span class="kw">ax</span>,<span class="dv">1</span>                             <span class="co">;shift pattern word</span>
     <span class="kw">dec</span>     <span class="kw">dx</span>
     <span class="kw">jnz</span>     RowLoop2
<span class="co">;</span>
<span class="co">; Pel pan the non-split screen portion of the display; because</span>
<span class="co">; split screen pel panning suppression is not turned on, the split</span>
<span class="co">; screen jerks back and forth as the pel panning setting cycles.</span>
<span class="co">;</span>
     <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">200</span>                   <span class="co">;pan 200 pixels to the left</span>
callPanRight
<span class="co">;</span>
<span class="co">; Wait for a key press (don&#39;t echo character).</span>
<span class="co">;</span>
     <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">8</span>                     <span class="co">;DOS console input without echo function</span>
     <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
<span class="co">; Return to the original screen location, with pel panning turned off.</span>
<span class="co">;</span>
     <span class="kw">mov</span>     [StartAddress],SPLIT_SCREEN_HEIGHT*(LOGICAL_SCREEN_WIDTH/<span class="dv">8</span>)
     <span class="kw">call</span>    SetStartAddress
     <span class="kw">mov</span>     [PelPan],<span class="dv">0</span>
     <span class="kw">call</span>    SetPelPan
<span class="co">;</span>
<span class="co">; Turn on split screen pel panning suppression, so the split screen</span>
<span class="co">; won&#39;t be affected by pel panning. Not done on EGA because both</span>
<span class="co">; readable registers and the split screen pel panning suppression bit</span>
<span class="co">; aren&#39;t supported by EGAs.</span>
<span class="co">;</span>
if IS_VGA
     <span class="kw">mov</span>     <span class="kw">dx</span>,INPUT_STATUS_0
     <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>                      <span class="co">;reset the AC Index/Data toggle to</span>
                                        <span class="co">; Index state</span>
     <span class="kw">mov</span>     <span class="kw">al</span>,20h+AC_MODE_CONTROL
                                        <span class="co">;bit 5 set to 1 to keep video on</span>
     <span class="kw">mov</span>     <span class="kw">dx</span>,AC_INDEX                <span class="co">;point to AC Index/Data register</span>
     <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
     <span class="kw">inc</span>     <span class="kw">dx</span>                         <span class="co">;point to AC Data reg (for reads only)</span>
     <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>                      <span class="co">;get the current AC Mode Control reg</span>
     <span class="kw">or</span>      <span class="kw">al</span><span class="bn">,20h                     </span><span class="co">;enable split screen pel panning</span>
                                        <span class="co">; suppression</span>
     <span class="kw">dec</span>     <span class="kw">dx</span>                         <span class="co">;point to AC Index/Data reg (Data for</span>
                                        <span class="co">; writes only)</span>
     <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                      <span class="co">;write the new AC Mode Control setting</span>
                                        <span class="co">; with split screen pel panning</span>
                                        <span class="co">; suppression turned on</span>
endif
<span class="co">;</span>
<span class="co">; Pel pan the non-split screen portion of the display; because</span>
<span class="co">; split screen pel panning suppression is turned on, the split</span>
<span class="co">; screen will not move as the pel panning setting cycles.</span>
<span class="co">;</span>
     <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">200</span>                     <span class="co">;pan 200 pixels to the left</span>
     <span class="kw">call</span>    PanRight
<span class="co">;</span>
<span class="co">; Wait for a key press (don&#39;t echo character).</span>
<span class="co">;</span>
     <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">8</span>                       <span class="co">;DOS console input without echo function</span>
     <span class="kw">int</span><span class="bn">     21h</span>
<span class="co">;</span>
<span class="co">; Return to text mode and DOS.</span>
<span class="co">;</span>
     <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0003h                    </span><span class="co">;AH=0 is select mode function</span>
                                         <span class="co">;AL=3 is mode to select, text mode</span>
     <span class="kw">int</span><span class="bn">     10h                         </span><span class="co">;return to text mode</span>
     <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch</span>
     <span class="kw">int</span><span class="bn">     21h                         </span><span class="co">;return to DOS</span>
Startendp
<span class="co">;*********************************************************************</span>
<span class="co">; Waits for the leading edge of the vertical sync pulse.</span>
<span class="co">;</span>
<span class="co">; Input: none</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; Registers altered: AL, DX</span>
<span class="co">;</span>
WaitForVerticalSyncStart     proc     near
     <span class="kw">mov</span>     <span class="kw">dx</span>,INPUT_STATUS_0
<span class="fu">WaitNotVerticalSync:</span>
     <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
     <span class="kw">test</span>    <span class="kw">al</span><span class="bn">,08h</span>
     <span class="kw">jnz</span>     WaitNotVerticalSync
<span class="fu">WaitVerticalSync:</span>
     <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
     <span class="kw">test</span>    <span class="kw">al</span><span class="bn">,08h</span>
     <span class="kw">jz</span>      WaitVerticalSync
     <span class="kw">ret</span>
WaitForVerticalSyncStart     endp
<span class="co">;*********************************************************************</span>
<span class="co">; Waits for the trailing edge of the vertical sync pulse.</span>
<span class="co">;</span>
<span class="co">; Input: none</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; Registers altered: AL, DX</span>
<span class="co">;</span>
WaitForVerticalSyncEnd     proc     near
     <span class="kw">mov</span>     <span class="kw">dx</span>,INPUT_STATUS_0
<span class="fu">WaitVerticalSync2:</span>
     <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
     <span class="kw">test</span>    <span class="kw">al</span><span class="bn">,08h</span>
     <span class="kw">jz</span>      WaitVerticalSync2
<span class="fu">WaitNotVerticalSync2:</span>
     <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
     <span class="kw">test</span>    <span class="kw">al</span><span class="bn">,08h</span>
     <span class="kw">jnz</span>     WaitNotVerticalSync2
     <span class="kw">ret</span>
WaitForVerticalSyncEnd     endp
<span class="co">;*********************************************************************</span>
<span class="co">; Sets the start address to the value specifed by StartAddress.</span>
<span class="co">; Wait for the trailing edge of vertical sync before setting so that</span>
<span class="co">; one half of the address isn&#39;t loaded before the start of the frame</span>
<span class="co">; and the other half after, resulting in flicker as one frame is</span>
<span class="co">; displayed with mismatched halves. The new start address won&#39;t be</span>
<span class="co">; loaded until the start of the next frame; that is, one full frame</span>
<span class="co">; will be displayed before the new start address takes effect.</span>
<span class="co">;</span>
<span class="co">; Input: none</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; Registers altered: AX, DX</span>
<span class="co">;</span>
SetStartAddress     proc     near
     <span class="kw">call</span>     WaitForVerticalSyncEnd
     <span class="kw">mov</span>      <span class="kw">dx</span>,CRTC_INDEX
     <span class="kw">mov</span>      <span class="kw">al</span>,START_ADDRESS_HIGH
     <span class="kw">mov</span>      <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [StartAddress<span class="dv">+1</span>]
     <span class="kw">cli</span>                               <span class="co">;make sure both registers get set at once</span>
     OUT_WORD
     <span class="kw">mov</span>      <span class="kw">al</span>,START_ADDRESS_LOW
     <span class="kw">mov</span>      <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [StartAddress]
     OUT_WORD
     <span class="kw">sti</span>
     <span class="kw">ret</span>
SetStartAddress     endp
<span class="co">;*********************************************************************</span>
<span class="co">; Sets the horizontal pel panning setting to the value specified</span>
<span class="co">; by PelPan. Waits until the start of vertical sync to do so, so</span>
<span class="co">; the new pel pan setting can be loaded during non-display time</span>
<span class="co">; and can be ready by the start of the next frame.</span>
<span class="co">;</span>
<span class="co">; Input: none</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; Registers altered: AL, DX</span>
<span class="co">;</span>
SetPelPan     proc     near
     <span class="kw">call</span>     WaitForVerticalSyncStart    <span class="co">;also resets the AC</span>
                                          <span class="co">; Index/Data toggle</span>
                                          <span class="co">; to Index state</span>
     <span class="kw">mov</span>      <span class="kw">dx</span>,AC_INDEX
     <span class="kw">mov</span>      <span class="kw">al</span>,PEL_PANNING+20h          <span class="co">;bit 5 set to 1 to keep video on</span>
     <span class="kw">out</span>      <span class="kw">dx</span>,<span class="kw">al</span>                       <span class="co">;point the AC Index to Pel Pan reg</span>
     <span class="kw">mov</span>      <span class="kw">al</span>,[PelPan]
     <span class="kw">out</span>      <span class="kw">dx</span>,<span class="kw">al</span>                       <span class="co">;load the new Pel Pan setting</span>
     <span class="kw">ret</span>
SetPelPanendp
<span class="co">;*********************************************************************</span>
<span class="co">; Sets the scan line the split screen starts after to the scan line</span>
<span class="co">; specified by SplitScreenLine.</span>
<span class="co">;</span>
<span class="co">; Input: none</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; All registers preserved</span>
<span class="co">;</span>
SetSplitScreenScanLine     proc     near
     <span class="kw">push</span>     <span class="kw">ax</span>
     <span class="kw">push</span>     <span class="kw">cx</span>
     <span class="kw">push</span>     <span class="kw">dx</span>
<span class="co">;</span>
<span class="co">; Wait for the leading edge of the vertical sync pulse. This ensures</span>
<span class="co">; that we don&#39;t get mismatched portions of the split screen setting</span>
<span class="co">; while setting the two or three split screen registers (register 18h</span>
<span class="co">; set but register 7 not yet set when a match occurs, for example),</span>
<span class="co">; which could produce brief flickering.</span>
<span class="co">;</span>
     <span class="kw">call</span>     WaitForVerticalSyncStart
<span class="co">;</span>
<span class="co">; Set the split screen scan line.</span>
<span class="co">;</span>
     <span class="kw">mov</span>     <span class="kw">dx</span>,CRTC_INDEX
     <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [SplitScreenLine]
     <span class="kw">mov</span>     <span class="kw">al</span>,LINE_COMPARE
     <span class="kw">cli</span>                              <span class="co">;make sure all the registers get set at once</span>
     OUT_WORD                         <span class="co">;set bits 7-0 of the split screen scan line</span>
     <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [SplitScreenLine<span class="dv">+1</span>]
     <span class="kw">and</span>     <span class="kw">ah</span>,<span class="dv">1</span>
     <span class="kw">mov</span>     <span class="kw">cl</span>,<span class="dv">4</span>
     <span class="kw">shl</span>     <span class="kw">ah</span>,<span class="kw">cl</span>                    <span class="co">;move bit 8 of the split split screen scan</span>
<span class="co">; line into position for the Overflow reg</span>
     <span class="kw">mov</span>     <span class="kw">al</span>,OVERFLOW
if IS_VGA
<span class="co">;</span>
<span class="co">; The Split Screen, Overflow, and Line Compare registers all contain</span>
<span class="co">; part of the split screen start scan line on the VGA. We&#39;ll take</span>
<span class="co">; advantage of the readable registers of the VGA to leave other bits</span>
<span class="co">; in the registers we access undisturbed.</span>
<span class="co">;</span>
     <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                    <span class="co">;set CRTC Index reg to point to Overflow</span>
     <span class="kw">inc</span>     <span class="kw">dx</span>                       <span class="co">;point to CRTC Data reg</span>
     <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>                    <span class="co">;get the current Overflow reg setting</span>
     <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">not</span><span class="bn"> 10h               </span><span class="co">;turn off split screen bit 8</span>
     <span class="kw">or</span>      <span class="kw">al</span>,<span class="kw">ah</span>                    <span class="co">;insert the new split screen bit 8</span>
                                      <span class="co">; (works in any mode)</span>
     <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                    <span class="co">;set the new split screen bit 8</span>
     <span class="kw">dec</span>     <span class="kw">dx</span>                       <span class="co">;point to CRTC Index reg</span>
     <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [SplitScreenLine<span class="dv">+1</span>]
     <span class="kw">and</span>     <span class="kw">ah</span>,<span class="dv">2</span>
     <span class="kw">mov</span>     <span class="kw">cl</span>,<span class="dv">3</span>
     <span class="kw">ror</span>     <span class="kw">ah</span>,<span class="kw">cl</span>                    <span class="co">;move bit 9 of the split split screen scan</span>
                                      <span class="co">; line into position for the Maximum Scan</span>
                                      <span class="co">; Line register</span>
     <span class="kw">mov</span>     <span class="kw">al</span>,MAXIMUM_SCAN_LINE
     <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                    <span class="co">;set CRTC Index reg to point to Maximum</span>
                                      <span class="co">; Scan Line</span>
     <span class="kw">inc</span>     <span class="kw">dx</span>                       <span class="co">;point to CRTC Data reg</span>
     <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>                    <span class="co">;get the current Maximum Scan Line setting</span>
     <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">not</span><span class="bn"> 40h               </span><span class="co">;turn off split screen bit 9</span>
     <span class="kw">or</span>      <span class="kw">al</span>,<span class="kw">ah</span>                    <span class="co">;insert the new split screen bit 9</span>
                                      <span class="co">; (works in any mode)</span>
     <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                    <span class="co">;set the new split screen bit 9</span>
else
<span class="co">;</span>
<span class="co">; Only the Split Screen and Overflow registers contain part of the</span>
<span class="co">; Split Screen start scan line and need to be set on the EGA.</span>
<span class="co">; EGA registers are not readable, so we have to set the non-split</span>
<span class="co">; screen bits of the Overflow register to a preset value, in this</span>
<span class="co">; case the value for 350-scan-line modes.</span>
<span class="co">;</span>
     <span class="kw">or</span>     <span class="kw">ah</span><span class="bn">,0fh                     </span><span class="co">;insert the new split screen bit 8</span>
                                       <span class="co">; (only works in 350-scan-line EGA modes)</span>
     OUT_WORD                          <span class="co">;set the new split screen bit 8</span>
endif
     <span class="kw">sti</span>
     <span class="kw">pop</span>     <span class="kw">dx</span>
     <span class="kw">pop</span>     <span class="kw">cx</span>
     <span class="kw">pop</span>     <span class="kw">ax</span>
     <span class="kw">ret</span>
SetSplitScreenScanLine     endp
<span class="co">;*********************************************************************</span>
<span class="co">; Pan horizontally to the right the number of pixels specified by CX.</span>
<span class="co">;</span>
<span class="co">; Input: CX = # of pixels by which to pan horizontally</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; Registers altered: AX, CX, DX</span>
<span class="co">;</span>
PanRight     proc     near
<span class="fu">PanLoop:</span>
     <span class="kw">inc</span>     [PelPan]
     <span class="kw">and</span>     [PelPan]<span class="bn">,07h</span>
     <span class="kw">jnz</span>     DoSetStartAddress
     <span class="kw">inc</span>     [StartAddress]
<span class="fu">DoSetStartAddress:</span>
     <span class="kw">call</span>    SetStartAddress
     <span class="kw">call</span>    SetPelPan
     <span class="kw">loop</span>    PanLoop
     <span class="kw">ret</span>
PanRight     endp
<span class="co">;*********************************************************************</span>
Codeends
endStart</code></pre>
</section>
</section>
<section id="notes-on-setting-and-reading-registers" class="level3">
<h3><a href="#notes-on-setting-and-reading-registers">Notes on Setting and Reading Registers</a></h3>
<p>There are a few interesting points regarding setting and reading registers to be made about Listing 30.2. First, bit 5 of the AC Index register should be set to 1 whenever palette RAM is not being set (which is to say, all the time in your code, because palette RAM should normally be set via the BIOS). When bit 5 is 0, video data from display memory is no longer sent to palette RAM, and the screen becomes a solid color—not normally a desirable state of affairs.</p>
<p>Recall also that the AC Index and Data registers are both written to at I/O address 3C0H, with the toggle that determines which one is written to at any time switching state on every write to 3C0H; this toggle is reset to index mode by each read from the Input Status 0 register (3DAH in color modes, 3BAH in monochrome modes). The AC Index and Data registers can also be written to at 3C1H on the EGA, but not on the VGA, so steer clear of that practice.</p>
<p>On the VGA, reading AC registers is a bit different from writing to them. The AC Data register can be read from 3C0H, and the AC register currently addressed by the AC Index register can be read from 3C1H; reading does not affect the state of the AC index/data toggle. Listing 30.2 illustrates reading from and writing to the AC registers. Finally, setting the start address registers (CRTC registers 0CH and 0DH) has its complications. As with the split screen registers, the start address registers must be set together and without interruption at a time when there’s no chance of a partial setting being used for a frame. However, it’s a little more difficult to know when that might be the case with the start address registers than it was with the split screen registers, because it’s not clear when the start address is used.</p>
<p>You see, the start address is loaded into the EGA’s or VGA’s internal display memory pointer once per frame. The internal pointer is then advanced, byte-by-byte and line-by-line, until the end of the frame (with a possible resetting to zero if the split screen line is reached), and is then reloaded for the next frame. That’s straightforward enough; the real question is, <em>Exactly when is the start address loaded?</em></p>
<p>In his excellent book <em>Programmer’s Guide to PC Video Systems</em> (Microsoft Press) Richard Wilton says that the start address is loaded at the start of the vertical sync pulse. (Wilton calls it vertical retrace, which can also be taken to mean vertical non-display time, but given that he’s testing the vertical sync status bit in the Input Status 0 register, I assume he means that the start address is loaded at the start of vertical sync.) Consequently, he waits until the <em>end</em> of the vertical sync pulse to set the start address registers, confident that the start address won’t take effect until the next frame.</p>
<p>I’m sure Richard is right when it comes to the real McCoy IBM VGA and EGA, but I’m less confident that every clone out there loads the start address at the start of vertical sync.</p>
<blockquote>
<p><img src="images/i.jpg" /> For that very reason, I generally advise people not to use horizontal smooth panning unless they can test their software on all the makes of display adapter it might run on. I’ve used Richard’s approach in Listings 30.1 and 30.2, and so far as I’ve seen it works fine, but be aware that there are potential, albeit unproven, hazards to relying on the setting of the start address registers to occur at a specific time in the frame.</p>
</blockquote>
<p>The interaction of the start address registers and the Pel Panning register is worthy of note. After waiting for the end of vertical sync to set the start address in Listing 30.2, I wait for the start of the <em>next</em> vertical sync to set the Pel Panning register. That’s because the start address doesn’t take effect until the start of the next frame, but the pel panning setting takes effect at the start of the next line; if we set the pel panning at the same time we set the start address, we’d get a whole frame with the old start address and the new pel panning settings mixed together, causing the screen to jump. As with the split screen registers, it’s safest to set the Pel Panning register during non-display time. For maximum reliability, we’d have interrupts off from the time we set the start address registers to the time we change the pel planning setting, to make sure an interrupt doesn’t come in and cause us to miss the start of a vertical sync and thus get a mismatched pel panning/start address pair for a frame, although for modularity I haven’t done this in Listing 30.2. (Also, doing so would require disabling interrupts for much too long a time.)</p>
<p>What if you wanted to pan faster? Well, you could of course just move two pixels at a time rather than one; I assure you no one will ever notice when you’re panning at a rate of 10 or more times per second.</p>
</section>
<section id="split-screens-in-other-modes" class="level3">
<h3><a href="#split-screens-in-other-modes">Split Screens in Other Modes</a></h3>
<p>So far we’ve only discussed the split screen in mode 10H. What about other modes? Generally, the split screen works in any mode; the basic rule is that when a scan line on the screen matches the split screen scan line, the internal display memory pointer is reset to zero. I’ve found this to be true even in oddball modes, such as line-doubled CGA modes and the 320x200 256-color mode (which is really a 320x400 mode with each line repeated. For split-screen purposes, the VGA and EGA seem to count purely in scan lines, not in rows or doubled scan lines or the like. However, I have run into small anomalies in those modes on clones, and I haven’t tested all modes (nor, lord knows, all clones!) so be careful when using the split screen in modes other than modes 0DH-12H, and test your code on a variety of hardware.</p>
<p>Come to think of it, I warn you about the hazards of running fancy VGA code on clones pretty often, don’t I? Ah, well—just one of the hazards of the diversity and competition of the PC market! It is a fact of life, though—if you’re a commercial developer and don’t test your video code on at least half a dozen VGAs, you’re living dangerously.</p>
<p>What of the split screen in text mode? It works fine; in fact, it not only resets the internal memory pointer to zero, but also resets the text scan line counter—which marks which line within the font you’re on—to zero, so the split screen starts out with a full row of text. There’s only one trick with text mode: When split screen pel panning suppression is on, the pel panning setting is forced to 0 for the rest of the frame. Unfortunately, 0 is <em>not</em> the “no-panning” setting for 9-dot-wide text; 8 is. The result is that when you turn on split screen pel panning suppression, the text in the split screen won’t pan with the normal screen, as intended, but will also display the undesirable characteristic of moving one pixel to the left. Whether this causes any noticeable on-screen effects depends on the text displayed by a particular application; for example, there should be no problem if the split screen has a border of blanks on the left side.</p>
</section>
<section id="how-safe" class="level3">
<h3><a href="#how-safe">How Safe?</a></h3>
<p>So, how safe <em>is</em> it to use the split screen? My opinion is that it’s perfectly safe, although I’d welcome input from people with extensive split screen experience—and the effects are striking enough that the split screen is well worth using in certain applications.</p>
<p>I’m a little more leery of horizontal smooth scrolling, with or without the split screen. Still, the Wilton book doesn’t advise any particular caution, and I haven’t heard any horror stories from the field lately, so the clone manufacturers must finally have gotten it right. (I vividly remember some early clones years back that <em>didn’t</em> quite get it right.) So, on balance, I’d say to use horizontal smooth scrolling if you really need it; on the other hand, in fast animation you can often get away with byte scrolling, which is easier, faster, and safer. (I recently saw a game that scrolled as smoothly as you could ever want. It was only by stopping it with Ctrl-NumLock that I was able to be sure that it was, in fact, byte panning, not pel panning.)</p>
<p>In short, use the fancy stuff—but only when you have</p>
</section>
</section>
<section id="chapter-31-higher-256-color-resolution-on-the-vga" class="level2">
<h2><a href="#chapter-31-higher-256-color-resolution-on-the-vga">Chapter 31 – Higher 256-Color Resolution on the VGA</a></h2>
<section id="when-is-320x200-really-320x400" class="level3">
<h3><a href="#when-is-320x200-really-320x400">When Is 320x200 Really 320x400?</a></h3>
<p>One of the more appealing features of the VGA is its ability to display 256 simultaneous colors. Unfortunately, one of the <em>less</em> appealing features of the VGA is the limited resolution (320x200) of the one 256-color mode the IBM-standard BIOS supports. (There are, of course, higher resolution 256-color modes in the legion of SuperVGAs, but they are by no means a standard, and differences between seemingly identical modes from different manufacturers can be vexing.) More colors can often compensate for less resolution, but the resolution difference between the 640x480 16-color mode and the 320x200 256-color mode is so great that many programmers must regretfully decide that they simply can’t afford to use the 256-color mode.</p>
<p>If there’s one thing we’ve learned about the VGA, however, it’s that there’s <em>never</em> just one way to do things. With the VGA, alternatives always exist for the clever programmer, and that’s more true than you might imagine with 256-color mode. Not only is there a high 256-color resolution, there are <em>lots</em> of higher 256-color resolutions, going all the way up to 360x480—and that’s with the vanilla IBM VGA!</p>
<p>In this chapter, I’m going to focus on one of my favorite 256-color modes, which provides 320x400 resolution and two graphics pages and can be set up with very little reof the VGA. In the next chapter, I’ll discuss higher-resolution 256-color modes, and starting in Chapter 47, I’ll cover the high-performance “Mode X” 256-color programming that many games use.</p>
<p>So. Let’s get started.</p>
</section>
<section id="why-320x200-only-ibm-knows-for-sure" class="level3">
<h3><a href="#why-320x200-only-ibm-knows-for-sure">Why 320x200? Only IBM Knows for Sure</a></h3>
<p>The first question, of course, is, “How can it be possible to get higher 256-color resolutions out of the VGA?” After all, there were no unused higher resolutions to be found in the CGA, Hercules card, or EGA.</p>
<p>The answer is another question: “Why did IBM <em>not</em> use the higher-resolution 256-color modes of the VGA?” The VGA is easily capable of twice the 200-scan-line vertical resolution of mode 13H, the 256-color mode, and IBM clearly made a decision not to support a higher-resolution 256-color mode. In fact, mode 13H <em>does</em> display 400 scan lines, but each row of pixels is displayed on two successive scan lines, resulting in an effective resolution of 320x200. This is the same scan-doubling approach used by the VGA to convert the CGA’s 200-scan-line modes to 400 scan lines; however, the resolution of the CGA has long been fixed at 200 scan lines, so IBM had no choice with the CGA modes but to scan-double the lines. Mode 13H has no such historical limitation—it’s the first 256-color mode ever offered by IBM, if you don’t count the late and unlamented Professional Graphics Controller (PGC). Why, then, would IBM choose to limit the resolution of mode 13H?</p>
<p>There’s no way to know, but one good guess is that IBM wanted a standard 256-color mode across all PS/2 computers (for which the VGA was originally created), and mode 13H is the highest-resolution 256-color mode that could fill the bill. You see, each 256-color pixel requires one byte of display memory, so a 320x200 256-color mode requires 64,000 bytes of display memory. That’s no problem for the VGA, which has 256K of display memory, but it’s a stretch for the MCGA of the Model 30, since the MCGA comes with only 64K.</p>
<p>On the other hand, the smaller display memory size of the MCGA also limits the number of colors supported in 640x480 mode to 2, rather than the 16 supported by the VGA. In this case, though, IBM simply created two modes and made both available on the VGA: mode 11H for 640x480 2-color graphics and mode 12H for 640x480 16-color graphics. The same could have been done for 256-color graphics—but wasn’t. Why? I don’t know. Maybe IBM just didn’t like the odd aspect ratio of a 320x400 graphics mode. Maybe they didn’t want to have to worry about how to map in more than 64K of display memory. Heck, maybe they made a mistake in designing the chip. Whatever the reason, mode 13H is really a 400-scan-line mode masquerading as a 200-scan-line mode, and we can readily end that masquerade.</p>
</section>
<section id="x400-256-color-mode" class="level3">
<h3><a href="#x400-256-color-mode">320x400 256-Color Mode</a></h3>
<p>Okay, what’s so great about 320x400 256-color mode? Two things: easy, safe mode sets and page flipping.</p>
<p>As I said above, mode 13H is really a 320x400 mode, albeit with each line doubled to produce an effective resolution of 320x200. That means that we don’t need to change any display timings, widths, or heights in order to tweak mode 13H into 320x400 mode—and that makes 320x400 a safe choice. Basically, 320x400 mode differs from mode 13H only in the settings of <em>mode</em> bits, which are sure to be consistent from one VGA clone to the next and which work equally well with all monitors. The other hi-res 256-color modes differ from mode 13H not only in the settings of the mode bits but also in the settings of timing and dimension registers, which may not be exactly the same on all VGA clones and particularly not on all multisync monitors. (Because multisyncs sometimes shrink the active area of the screen when used with standard VGA modes, some VGAs use alternate register settings for multisync monitors that adjust the CRT Controller timings to use as much of the screen area as possible for displaying pixels.)</p>
<p>The other good thing about 320x400 256-color mode is that two pages are supported. Each 320x400 256-color mode requires 128,000 bytes of display memory, so we can just barely manage two pages in 320x400 mode, one starting at offset 0 in display memory and the other starting at offset 8000H. Those two pages are the largest pair of pages that can fit in the VGA’s 256K, though, and the higher-resolution 256-color modes, which use still larger bitmaps (areas of display memory that control pixels on the screen), can’t support two pages at all. As we’ve seen in earlier chapters and will see again in this book, paging is very useful for off-screen construction of images and fast, smooth animation.</p>
<p>That’s why I like 320x400 256-color mode. The next step is to understand how display memory is organized in 320x400 mode, and that’s not so simple.</p>
<section id="display-memory-organization-in-320x400-mode" class="level4">
<h4><a href="#display-memory-organization-in-320x400-mode">Display Memory Organization in 320x400 Mode</a></h4>
<p>First, let’s look at why display memory must be organized differently in 320x400 256-color mode than in mode 13H. The designers of the VGA intentionally limited the maximum size of the bitmap in mode 13H to 64K, thereby limiting resolution to 320x200. This was accomplished <em>in hardware</em>, so there is no way to extend the bitmap organization of mode 13H to 320x400 mode.</p>
<p>That’s a shame, because mode 13H has the simplest bitmap organization of any mode—one long, linear bitmap, with each byte controlling one pixel. We can’t have that organization, though, so we’ll have to find an acceptable substitute if we want to use a higher 256-color resolution.</p>
<p>We’re talking about the VGA, so of course there are actually <em>several</em> bitmap organizations that let us use higher 256-color resolutions than mode 13H. The one I like best is shown in Figure 31.1. Each byte controls one 256-color pixel. Pixel 0 is at address 0 in plane 0, pixel 1 is at address 0 in plane 1, pixel 2 is at address 0 in plane 2, pixel 3 is at address 0 in plane 3, pixel 4 is at address 1 in plane 0, and so on.</p>
<p>Let’s look at this another way. Ideally, we’d like one long bitmap, with each pixel at the address that’s just after the address of the pixel to the left. Well, that’s true in this case too, <em>if</em> you consider the number of the plane that the pixel is in to be part of the pixel’s address. View the pixel numbers on the screen as increasing from left to right and from the end of one scan line to the start of the next. Then the pixel number, n, of the pixel at display memory address <em>address</em> in plane <em>plane</em> is:</p>
<figure>
<img src="images/31-01.jpg" alt="Figure 31.1  Bitmap organization in 320x400 256-color mode in 320x400 256-color mode." /><figcaption><strong>Figure 31.1</strong>  <em>Bitmap organization in 320x400 256-color mode in 320x400 256-color mode.</em></figcaption>
</figure>
<p><em>n</em> = (<em>address</em> * 4) + <em>plane</em></p>
<p>To turn that around, the display memory address of pixel number n is given by</p>
<p>address = <em>n</em> / 4</p>
<p>and the plane of pixel <em>n</em> is given by:</p>
<p>plane = <em>n</em> modulo 4</p>
<p>Basically, the full address of the pixel, its pixel number, is broken into two components: the display memory address and the plane.</p>
<p>By the way, because 320x400 mode has a significantly different memory organization from mode 13H, the BIOS text routines won’t work in 320x400 mode. If you want to draw text in 320x400 mode, you’ll have to look up a font in the BIOS ROM and draw the text yourself. Likewise, the BIOS read pixel and write pixel routines won’t work in 320x400 mode, but that’s no problem because I’ll provide equivalent routines in the next section.</p>
<p>Our next task is to convert standard mode 13H into 320x400 mode. That’s accomplished by undoing some of the mode bits that are set up especially for mode 13H, so that from a programming perspective the VGA reverts to a straightforward planar model of memory. That means taking the VGA out of chain 4 mode and doubleword mode, turning off the double display of each scan line, making sure chain mode, odd/even mode, and word mode are turned off, and selecting byte mode for video data display. All that’s done in the <code>Set320x400Mode</code> subroutine in Listing 31.1, which we’ll discuss next.</p>
</section>
<section id="reading-and-writing-pixels" class="level4">
<h4><a href="#reading-and-writing-pixels">Reading and Writing Pixels</a></h4>
<p>The basic graphics functions in any mode are functions to read and write single pixels. Any more complex function can be built on these primitives, although that’s rarely the speediest solution. What’s more, once you understand the operation of the read and write pixel functions, you’ve got all the knowledge you need to create functions that perform more complex graphics functions. Consequently, we’ll start our exploration of 320x400 mode with pixel-at-a-time line drawing.</p>
<p>Listing 31.1 draws 8 multicolored octagons in turn, drawing a new one on top of the old one each time a key is pressed. The main-loop code of Listing 31.1 should be easily understood; a series of diagonal, horizontal, and vertical lines are drawn one pixel at a time based on a list of line descriptors, with the draw colors incremented for each successive time through the line list.</p>
<p><strong>LISTING 31.1 L31-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to demonstrate pixel drawing in 320x400 256-color</span>
<span class="co">; mode on the VGA. Draws 8 lines to form an octagon, a pixel</span>
<span class="co">; at a time. Draws 8 octagons in all, one on top of the other,</span>
<span class="co">; each in a different color set. Although it&#39;s not used, a</span>
<span class="co">; pixel read function is also provided.</span>
<span class="co">;</span>
VGA_SEGMENT              <span class="dt">equ</span><span class="bn">        0a000h</span>
SC_INDEX                 <span class="dt">equ</span><span class="bn">        3c4h        </span><span class="co">;Sequence Controller Index register</span>
GC_INDEX                 <span class="dt">equ</span><span class="bn">        3ceh        </span><span class="co">;Graphics Controller Index register</span>
CRTC_INDEX               <span class="dt">equ</span><span class="bn">        3d4h        </span><span class="co">;CRT Controller Index register</span>
MAP_MASK                 <span class="dt">equ</span>        <span class="dv">2</span>           <span class="co">;Map Mask register index in SC</span>
MEMORY_MODE              <span class="dt">equ</span>        <span class="dv">4</span>           <span class="co">;Memory Mode register index in SC</span>
MAX_SCAN_LINE            <span class="dt">equ</span>        <span class="dv">9</span>           <span class="co">;Maximum Scan Line reg index in CRTC</span>
START_ADDRESS_HIGH       <span class="dt">equ</span><span class="bn">        0ch         </span><span class="co">;Start Address High reg index in CRTC</span>
UNDERLINE                <span class="dt">equ</span><span class="bn">        14h         </span><span class="co">;Underline Location reg index in CRTC</span>
MODE_CONTROL             <span class="dt">equ</span><span class="bn">        17h         </span><span class="co">;Mode Control register index in CRTC</span>
READ_MAP                 <span class="dt">equ</span>        <span class="dv">4</span>           <span class="co">;Read Map register index in GC</span>
GRAPHICS_MODE            <span class="dt">equ</span>        <span class="dv">5</span>           <span class="co">;Graphics Mode register index in GC</span>
MISCELLANEOUS            <span class="dt">equ</span>        <span class="dv">6</span>           <span class="co">;Miscellaneous register index in GC</span>
SCREEN_WIDTH             <span class="dt">equ</span>        <span class="dv">320</span>         <span class="co">;# of pixels across screen</span>
SCREEN_HEIGHT            <span class="dt">equ</span>        <span class="dv">400</span>         <span class="co">;# of scan lines on screen</span>
WORD_OUTS_OK             <span class="dt">equ</span>        <span class="dv">1</span>           <span class="co">;set to 0 to assemble for</span>
                                                <span class="co">; computers that can&#39;t handle</span>
                                                <span class="co">; word outs to indexed VGA registers</span>
<span class="co">;</span>
stack        <span class="kw">segment</span>     para stack <span class="st">&#39;STACK&#39;</span>
                  <span class="dt">db</span>     <span class="dv">512</span> dup (?)
stack        ends
<span class="co">;</span>
Data         <span class="kw">segment</span>     <span class="dt">word</span> <span class="st">&#39;DATA&#39;</span>
<span class="co">;</span>
BaseColor         <span class="dt">db</span>     <span class="dv">0</span>
<span class="co">;</span>
<span class="co">; Structure used to control drawing of a line.</span>
<span class="co">;</span>
LineControl <span class="kw">struc</span>
StartX           <span class="dt">dw</span>   ?
StartY           <span class="dt">dw</span>   ?
LineXInc         <span class="dt">dw</span>   ?
LineYInc         <span class="dt">dw</span>   ?
BaseLength       <span class="dt">dw</span>   ?
LineColor        <span class="dt">db</span>   ?
LineControl      ends
<span class="co">;</span>
<span class="co">; List of descriptors for lines to draw.</span>
<span class="co">;</span>
LineList      label    LineControl
      LineControl &lt;<span class="dv">130</span>,<span class="dv">110</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">60</span>,<span class="dv">0</span>&gt;
      LineControl &lt;<span class="dv">190</span>,<span class="dv">110</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">60</span>,<span class="dv">1</span>&gt;
      LineControl &lt;<span class="dv">250</span>,<span class="dv">170</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">60</span>,<span class="dv">2</span>&gt;
      LineControl &lt;<span class="dv">250</span>,<span class="dv">230</span>,-<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">60</span>,<span class="dv">3</span>&gt;
      LineControl &lt;<span class="dv">190</span>,<span class="dv">290</span>,-<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">60</span>,<span class="dv">4</span>&gt;
      LineControl &lt;<span class="dv">130</span>,<span class="dv">290</span>,-<span class="dv">1</span>,-<span class="dv">1</span>,<span class="dv">60</span>,<span class="dv">5</span>&gt;
      LineControl &lt;<span class="dv">70</span>,<span class="dv">230</span>,<span class="dv">0</span>,-<span class="dv">1</span>,<span class="dv">60</span>,<span class="dv">6</span>&gt;
      LineControl &lt;<span class="dv">70</span>,<span class="dv">170</span>,<span class="dv">1</span>,-<span class="dv">1</span>,<span class="dv">60</span>,<span class="dv">7</span>&gt;
      LineControl &lt;-<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>&gt;
Data ends
<span class="co">;</span>
<span class="co">; Macro to output a word value to a port.</span>
<span class="co">;</span>
OUT_WORD macro
if WORD_OUTS_OK
     <span class="kw">out</span>   <span class="kw">dx</span>,<span class="kw">ax</span>
else
     <span class="kw">out</span>   <span class="kw">dx</span>,<span class="kw">al</span>
     <span class="kw">inc</span>   <span class="kw">dx</span>
     <span class="kw">xchg</span>  <span class="kw">ah</span>,<span class="kw">al</span>
     <span class="kw">out</span>   <span class="kw">dx</span>,<span class="kw">al</span>
     <span class="kw">dec</span>   <span class="kw">dx</span>
     <span class="kw">xchg</span>  <span class="kw">ah</span>,<span class="kw">al</span>
endif
     endm
<span class="co">;</span>
<span class="co">; Macro to output a constant value to an indexed VGA register.</span>
<span class="co">;</span>
CONSTANT_TO_INDEXED_REGISTERmacroADDRESS, INDEX, VALUE
      <span class="kw">mov</span>  <span class="kw">dx</span>,ADDRESS
      <span class="kw">mov</span>  <span class="kw">ax</span>,(VALUE <span class="kw">shl</span> <span class="dv">8</span>) + INDEX
      OUT_WORD
      endm
<span class="co">;</span>
Code    <span class="kw">segment</span>
        assume        <span class="kw">cs</span>:Code, <span class="kw">ds</span>:Data
Start   proc  near
        <span class="kw">mov</span>   <span class="kw">ax</span>,Data
        <span class="kw">mov</span>   <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>



<span class="co">; Set 320x400 256-color mode.</span>
<span class="co">;</span>
     <span class="kw">call</span>  Set320By400Mode
<span class="co">;</span>
<span class="co">; We&#39;re in 320x400 256-color mode. Draw each line in turn.</span>
<span class="co">;</span>
<span class="fu">ColorLoop:</span>
     <span class="kw">mov</span>   <span class="kw">si</span>,offset LineList     <span class="co">;point to the start of the</span>
                                  <span class="co">; line descriptor list</span>
<span class="fu">LineLoop:</span>
     <span class="kw">mov</span>   <span class="kw">cx</span>,[<span class="kw">si</span>+StartX]         <span class="co">;set the initial X coordinate</span>
     cmpcx,-<span class="dv">1</span>
     <span class="kw">jz</span>    LinesDone              <span class="co">;a descriptor with a -1 X</span>
                                  <span class="co">; coordinate marks the end</span>
                                  <span class="co">; of the list</span>
     <span class="kw">mov</span>   <span class="kw">dx</span>,[<span class="kw">si</span>+StartY]         <span class="co">;set the initial Y coordinate,</span>
     <span class="kw">mov</span>   <span class="kw">bl</span>,[<span class="kw">si</span>+LineColor]      <span class="co">; line color,</span>
     <span class="kw">mov</span>   <span class="kw">bp</span>,[<span class="kw">si</span>+BaseLength]     <span class="co">; and pixel count</span>
     <span class="kw">add</span>   <span class="kw">bl</span>,[BaseColor]         <span class="co">;adjust the line color according</span>
                                  <span class="co">; to BaseColor</span>
<span class="fu">PixelLoop:</span>
     <span class="kw">push</span>  <span class="kw">cx</span>                     <span class="co">;save the coordinates</span>
     <span class="kw">push</span>  <span class="kw">dx</span>
     <span class="kw">call</span>  WritePixel             <span class="co">;draw this pixel</span>
     <span class="kw">pop</span>   <span class="kw">dx</span>                     <span class="co">;retrieve the coordinates</span>
     <span class="kw">pop</span>   <span class="kw">cx</span>
     <span class="kw">add</span>   <span class="kw">cx</span>,[<span class="kw">si</span>+LineXInc]       <span class="co">;set the coordinates of the</span>
     <span class="kw">add</span>   <span class="kw">dx</span>,[<span class="kw">si</span>+LineYInc]       <span class="co">; next point of the line</span>
     <span class="kw">dec</span>   <span class="kw">bp</span>                     <span class="co">;any more points?</span>
     <span class="kw">jnz</span>   PixelLoop              <span class="co">;yes, draw the next</span>
     <span class="kw">add</span>   <span class="kw">si</span>,size LineControl    <span class="co">;point to the next line descriptor</span>
     <span class="kw">jmp</span>   LineLoop               <span class="co">; and draw the next line</span>
<span class="fu">LinesDone:</span>
     <span class="kw">call</span>  GetNextKey             <span class="co">;wait for a key, then</span>
     <span class="kw">inc</span>   [BaseColor]            <span class="co">; bump the color selection and</span>
     <span class="kw">cmp</span>   [BaseColor],<span class="dv">8</span>          <span class="co">; see if we&#39;re done</span>
     <span class="kw">jb</span>    ColorLoop              <span class="co">;not done yet</span>
<span class="co">;</span>
<span class="co">; Wait for a key and return to text mode and end when</span>
<span class="co">; one is pressed.</span>
<span class="co">;</span>
     <span class="kw">call</span>   GetNextKey
     <span class="kw">mov</span>    <span class="kw">ax</span><span class="bn">,0003h</span>
     <span class="kw">int</span><span class="bn">    10h                    </span>text mode
     <span class="kw">mov</span>    <span class="kw">ah</span><span class="bn">,4ch</span>
     <span class="kw">int</span><span class="bn">    21h   </span><span class="co">;done</span>
<span class="co">;</span>
Start endp
<span class="co">;</span>
<span class="co">; Sets up 320x400 256-color modes.</span>
<span class="co">;</span>
<span class="co">; Input: none</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
Set320By400Mode   proc   near
<span class="co">;</span>
<span class="co">; First, go to normal 320x200 256-color mode, which is really a</span>
<span class="co">; 320x400 256-color mode with each line scanned twice.</span>
<span class="co">;</span>
        <span class="kw">mov</span>        <span class="kw">ax</span><span class="bn">,0013h        </span><span class="co">;AH = 0 means mode set, AL = 13h selects</span>
                                   <span class="co">; 256-color graphics mode</span>
        <span class="kw">int</span><span class="bn">        10h             </span><span class="co">;BIOS video interrupt</span>
<span class="co">;</span>
<span class="co">; Change CPU addressing of video memory to linear (not odd/even,</span>
<span class="co">; chain, or chain 4), to allow us to access all 256K of display</span>
<span class="co">; memory. When this is done, VGA memory will look just like memory</span>
<span class="co">; in modes 10h and 12h, except that each byte of display memory will</span>
<span class="co">; control one 256-color pixel, with 4 adjacent pixels at any given</span>
<span class="co">; address, one pixel per plane.</span>
<span class="co">;</span>
     <span class="kw">mov</span>    <span class="kw">dx</span>,SC_INDEX
     <span class="kw">mov</span>    <span class="kw">al</span>,MEMORY_MODE
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
     <span class="kw">inc</span>    <span class="kw">dx</span>
     ina    l,<span class="kw">dx</span>
     <span class="kw">and</span>    <span class="kw">al</span>,<span class="kw">not</span><span class="bn"> 08h                   </span><span class="co">;turn off chain 4</span>
     ora    l<span class="bn">,04h                        </span><span class="co">;turn off odd/even</span>
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
     <span class="kw">mov</span>    <span class="kw">dx</span>,GC_INDEX
     <span class="kw">mov</span>    <span class="kw">al</span>,GRAPHICS_MODE
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
     <span class="kw">inc</span>    <span class="kw">dx</span>
     ina    l,<span class="kw">dx</span>
     <span class="kw">and</span>    <span class="kw">al</span>,<span class="kw">not</span><span class="bn"> 10h                   </span><span class="co">;turn off odd/even</span>
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
     <span class="kw">dec</span>    <span class="kw">dx</span>
     <span class="kw">mov</span>    <span class="kw">al</span>,MISCELLANEOUS
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
     <span class="kw">inc</span>    <span class="kw">dx</span>
     ina    l,<span class="kw">dx</span>
     <span class="kw">and</span>    <span class="kw">al</span>,<span class="kw">not</span><span class="bn"> 02h                   </span><span class="co">;turn off chain</span>
     <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Now clear the whole screen, since the mode 13h mode set only</span>
<span class="co">; cleared 64K out of the 256K of display memory. Do this before</span>
<span class="co">; we switch the CRTC out of mode 13h, so we don&#39;t see garbage</span>
<span class="co">; on the screen when we make the switch.</span>
<span class="co">;</span>
CONSTANT_TO_INDEXED_REGISTER SC_INDEX,MAP_MASK<span class="bn">,0fh</span>
                                     <span class="co">;enable writes to all planes, so</span>
                                     <span class="co">; we can clear 4 pixels at a time</span>
        <span class="kw">mov</span>    <span class="kw">ax</span>,VGA_SEGMENT
        <span class="kw">mov</span>    <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">sub</span>    <span class="kw">di</span>,<span class="kw">di</span>
        <span class="kw">mov</span>    <span class="kw">ax</span>,<span class="kw">di</span>
        <span class="kw">mov</span>    <span class="kw">cx</span><span class="bn">,8000h   </span><span class="co">;# of words in 64K</span>
        <span class="kw">cld</span>    
        rep    <span class="kw">stosw</span>      <span class="co">;clear all of display memory</span>
<span class="co">;</span>
<span class="co">; Tweak the mode to 320x400 256-color mode by not scanning each</span>
<span class="co">; line twice.</span>
<span class="co">;</span>
        <span class="kw">mov</span>   <span class="kw">dx</span>,CRTC_INDEX
        <span class="kw">mov</span>   <span class="kw">al</span>,MAX_SCAN_LINE
        <span class="kw">out</span>   <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>   <span class="kw">dx</span>
        <span class="kw">in</span>    <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>   <span class="kw">al</span>,<span class="kw">not</span><span class="bn"> 1fh         </span><span class="co">;set maximum scan line = 0</span>
        <span class="kw">out</span>   <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>   <span class="kw">dx</span>
<span class="co">;</span>
<span class="co">; Change CRTC scanning from doubleword mode to byte mode, allowing</span>
<span class="co">; the CRTC to scan more than 64K of video data.</span>
<span class="co">;</span>
        <span class="kw">mov</span>    <span class="kw">al</span>,UNDERLINE
        <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>    <span class="kw">dx</span>
        <span class="kw">in</span>     <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>    <span class="kw">al</span>,<span class="kw">not</span><span class="bn"> 40h        </span><span class="co">;turn off doubleword</span>
        <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>    <span class="kw">dx</span>
        <span class="kw">mov</span>    <span class="kw">al</span>,MODE_CONTROL
        <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>    <span class="kw">dx</span>
        <span class="kw">in</span>    <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">or</span>    <span class="kw">al</span><span class="bn">,40h             </span><span class="co">;turn on the byte mode bit, so memory is</span>
                                 <span class="co">; scanned for video data in a purely</span>
                                 <span class="co">; linear way, just as in modes 10h and 12h</span>
        <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">ret</span> 
Set320By400Mode        endp
<span class="co">;</span>
<span class="co">; Draws a pixel in the specified color at the specified</span>
<span class="co">; location in 320x400 256-color mode.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;    CX = X coordinate of pixel</span>
<span class="co">;    DX = Y coordinate of pixel</span>
<span class="co">;    BL = pixel color</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; Registers altered: AX, CX, DX, DI, ES</span>
<span class="co">;</span>
WritePixel proc near
        <span class="kw">mov</span>    <span class="kw">ax</span>,VGA_SEGMENT
        <span class="kw">mov</span>    <span class="kw">es</span>,<span class="kw">ax</span>                    <span class="co">;point to display memory</span>
        <span class="kw">mov</span>    <span class="kw">ax</span>,SCREEN_WIDTH/<span class="dv">4</span>
                                        <span class="co">;there are 4 pixels at each address, so</span>
                                        <span class="co">; each 320-pixel row is 80 bytes wide</span>
                                        <span class="co">; in each plane</span>
        <span class="kw">mul</span>   <span class="kw">dx</span>                        <span class="co">;point to start of desired row</span>
        <span class="kw">push</span>  <span class="kw">cx</span>                        <span class="co">;set aside the X coordinate</span>
        <span class="kw">shr</span>   <span class="kw">cx</span>,<span class="dv">1</span>                      <span class="co">;there are 4 pixels at each address</span>
        <span class="kw">shr</span>   <span class="kw">cx</span>,<span class="dv">1</span>                      <span class="co">; so divide the X coordinate by 4</span>
        <span class="kw">add</span>   <span class="kw">ax</span>,<span class="kw">cx</span>                     <span class="co">;point to the pixel&#39;s address</span>
        <span class="kw">mov</span>   <span class="kw">di</span>,<span class="kw">ax</span>
        <span class="kw">pop</span>   <span class="kw">cx</span>                        <span class="co">;get back the X coordinate</span>
        <span class="kw">and</span>   <span class="kw">cl</span>,<span class="dv">3</span>                      <span class="co">;get the plane # of the pixel</span>
        <span class="kw">mov</span>   <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">shl</span>   <span class="kw">ah</span>,<span class="kw">cl</span>                     <span class="co">;set the bit corresponding to the plane</span>
                                        <span class="co">; the pixel is in</span>
        <span class="kw">mov</span>   <span class="kw">al</span>,MAP_MASK
        <span class="kw">mov</span>   <span class="kw">dx</span>,SC_INDEX
        OUT_WORD                        <span class="co">;set to write to the proper plane for</span>
                                        <span class="co">; the pixel</span>
        <span class="kw">mov</span>  <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">bl</span>                 <span class="co">;draw the pixel</span>
        <span class="kw">ret</span>
WritePixelendp
<span class="co">;</span>
<span class="co">; Reads the color of the pixel at the specified location in 320x400</span>
<span class="co">; 256-color mode.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;     CX = X coordinate of pixel to read</span>
<span class="co">;     DX = Y coordinate of pixel to read</span>
<span class="co">;</span>
<span class="co">; Output:</span>
<span class="co">;     AL = pixel color</span>
<span class="co">;</span>
<span class="co">; Registers altered: AX, CX, DX, SI, ES</span>
<span class="co">;</span>
ReadPixelprocnear
        <span class="kw">mov</span>   <span class="kw">ax</span>,VGA_SEGMENT
        <span class="kw">mov</span>   <span class="kw">es</span>,<span class="kw">ax</span>                        <span class="co">;point to display memory</span>
        <span class="kw">mov</span>   <span class="kw">ax</span>,SCREEN_WIDTH/<span class="dv">4</span>
                                           <span class="co">;there are 4 pixels at each address, so</span>
                                           <span class="co">; each 320-pixel row is 80 bytes wide</span>
                                           <span class="co">; in each plane</span>
        <span class="kw">mul</span>    <span class="kw">dx</span>                          <span class="co">;point to start of desired row</span>
        <span class="kw">push</span>   <span class="kw">cx</span>                          <span class="co">;set aside the X coordinate</span>
        <span class="kw">shr</span>    <span class="kw">cx</span>,<span class="dv">1</span>                        <span class="co">;there are 4 pixels at each address</span>
        <span class="kw">shr</span>    <span class="kw">cx</span>,<span class="dv">1</span>                        <span class="co">; so divide the X coordinate by 4</span>
        <span class="kw">add</span>    <span class="kw">ax</span>,<span class="kw">cx</span>                       <span class="co">;point to the pixel&#39;s address</span>
        <span class="kw">mov</span>    <span class="kw">si</span>,<span class="kw">ax</span>
        <span class="kw">pop</span>    <span class="kw">ax</span>                          <span class="co">;get back the X coordinate</span>
        <span class="kw">and</span>    <span class="kw">al</span>,<span class="dv">3</span>                        <span class="co">;get the plane # of the pixel</span>
        <span class="kw">mov</span>    <span class="kw">ah</span>,<span class="kw">al</span>
        <span class="kw">mov</span>    <span class="kw">al</span>,READ_MAP
        <span class="kw">mov</span>    <span class="kw">dx</span>,GC_INDEX
        OUT_WORD                           <span class="co">;set to read from the proper plane for</span>
                                           <span class="co">; the pixel</span>
        lodsbyte <span class="dt">ptr</span> <span class="kw">es</span>:[<span class="kw">si</span>]               <span class="co">;read the pixel</span>
        <span class="kw">ret</span>
ReadPixelendp
<span class="co">;</span>
<span class="co">; Waits for the next key and returns it in AX.</span>
<span class="co">;</span>
<span class="co">; Input: none</span>
<span class="co">;</span>
<span class="co">; Output:</span>
<span class="co">;     AX = full 16-bit code for key pressed</span>
<span class="co">;</span>
GetNextKey   proc   near
<span class="fu">WaitKey:</span>
        <span class="kw">mov</span>   <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">int</span><span class="bn">   16h</span>
        <span class="kw">jz</span>    WaitKey                        <span class="co">;wait for a key to become available</span>
        <span class="kw">sub</span>   <span class="kw">ah</span>,<span class="kw">ah</span>
        <span class="kw">int</span><span class="bn">   16h                            </span><span class="co">;read the key</span>
        <span class="kw">ret</span>
GetNextKey   endp
<span class="co">;</span>
Code   ends
<span class="co">;</span>
end    Start</code></pre>
<p>The interesting aspects of Listing 31.1 are three. First, the <code>Set320x400Mode</code> subroutine selects 320x400 256-color mode. This is accomplished by performing a mode 13H mode set followed by then putting the VGA into standard planar byte mode. <code>Set320x400Mode</code> zeros display memory as well. It’s necessary to clear display memory even after a mode 13H mode set because the mode 13H mode set clears only the 64K of display memory that can be accessed in that mode, leaving 192K of display memory untouched.</p>
<p>The second interesting aspect of Listing 31.1 is the <code>WritePixel</code> subroutine, which draws a colored pixel at any <em>x,y</em> addressable location on the screen. Although it may not be obvious because I’ve optimized the code a little, the process of drawing a pixel is remarkably simple. First, the pixel’s display memory address is calculated as</p>
<p><em>address</em>=(<em>y</em> * (SCREEN_WIDTH / 4)) + (<em>x</em> / 4)</p>
<p>which might be more recognizable as:</p>
<p><em>address</em>=((<em>y</em> * SCREEN_WIDTH) + <em>x</em>) / 4</p>
<p>(There are 4 pixels at each display memory address in 320x400 mode, hence the division by 4.) Then the pixel’s plane is calculated as</p>
<p><em>plane</em>=<em>x</em> and 3</p>
<p>which is equivalent to:</p>
<p><em>plane</em>=<em>x</em> modulo 4</p>
<p>The pixel’s color is then written to the addressed byte in the addressed plane. That’s all there is to it!</p>
<p>The third item of interest in Listing 31.1 is the <code>ReadPixel</code> subroutine. <code>ReadPixel</code> is virtually identical to <code>WritePixel</code>, save that in <code>ReadPixel</code> the Read Map register is programmed with a plane number, while <code>WritePixel</code> uses a plane <em>mask</em> to set the Map Mask register. Of course, that difference merely reflects a fundamental difference in the operation of the two registers. (If that’s Greek to you, refer back to Chapters 23-30 for a refresher on VGA programming.) <code>ReadPixel</code> isn’t used in Listing 31.1, but I’ve included it because, as I said above, the read and write pixel functions together can support a whole host of more complex graphics functions.</p>
<p>How does 320x400 256-color mode stack up as regards performance? As it turns out, the programming model of 320x400 mode is actually pretty good for pixel drawing, pretty much on a par with the model of mode 13H. When you run Listing 31.1, you’ll no doubt notice that the lines are drawn quite rapidly. (In fact, the drawing could be considerably faster still with a dedicated line-drawing subroutine, which would avoid the multiplication associated with each pixel in Listing 31.1.)</p>
<p>In 320x400 mode, the calculation of the memory address is not significantly slower than in mode 13H, and the calculation and selection of the target plane is quickly accomplished. As with mode 13H, 320x400 mode benefits tremendously from the byte-per-pixel organization of 256-color mode, which eliminates the need for the time-consuming pixel-masking of the 16-color modes. Most important, byte-per-pixel modes never require read-modify-write operations (which can be extremely slow due to display memory wait states) in order to clip and draw pixels. To draw a pixel, you just store its color in display memory—what could be simpler?</p>
<p>More sophisticated operations than pixel drawing are less easy to accomplish in 320x400 mode, but with a little ingenuity it is possible to implement a reasonably efficient version of just about any useful graphics function. A fast line draw for 320x400 256-color mode would be simple (although not as fast as would be possible in mode 13H). Fast image copies could be implemented by copying one-quarter of the image to one plane, one-quarter to the next plane, and so on for all four planes, thereby eliminating the <code>OUT</code> per pixel that sequential processing requires. If you’re really into performance, you could store your images with all the bytes for plane 0 grouped together, followed by all the bytes for plane 1, and so on. That would allow a single <code>REP MOVS</code> instruction to copy all the bytes for a given plane, with just four <code>REP MOVS</code> instructions copying the whole image. In a number of cases, in fact, 320x400 256-color mode can actually be much faster than mode 13H, because the VGA’s hardware can be used to draw four or even eight pixels with a single access; I’ll return to the topic of high-performance programming in 256-color modes other than mode 13H (“non-chain 4” modes) in Chapter 47.</p>
<p>It’s all a bit complicated, but as I say, you should be able to design an adequately fast—and often <em>very</em> fast—version for 320x400 mode of whatever graphics function you need. If you’re not all that concerned with speed, <code>WritePixel</code> and <code>ReadPixel</code> should meet your needs.</p>
</section>
</section>
<section id="two-256-color-pages" class="level3">
<h3><a href="#two-256-color-pages">Two 256-Color Pages</a></h3>
<p>Listing 31.2 demonstrates the two pages of 320x400 256-color mode by drawing slanting color bars in page 0, then drawing color bars slanting the other way in page 1 and flipping to page 1 on the next key press. (Note that page 1 is accessed starting at offset 8000H in display memory, and is—unsurprisingly—displayed by setting the start address to 8000H.) Finally, Listing 31.2 draws vertical color bars in page 0 and flips back to page 0 when another key is pressed.</p>
<p>The color bar routines don’t use the <code>WritePixel</code> subroutine from Listing 31.1; they go straight to display memory instead for improved speed. As I mentioned above, better speed yet could be achieved by a color-bar algorithm that draws all the pixels in plane 0, then all the pixels in plane 1, and so on, thereby avoiding the overhead of constantly reprogramming the Map Mask register.</p>
<p><strong>LISTING 31.2 L31-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to demonstrate the two pages available in 320x400</span>
<span class="co">; 256-color modes on a VGA.  Draws diagonal color bars in all</span>
<span class="co">; 256 colors in page 0, then does the same in page 1 (but with</span>
<span class="co">; the bars tilted the other way), and finally draws vertical</span>
<span class="co">; color bars in page 0.</span>
<span class="co">;</span>
VGA_SEGMENT        <span class="dt">equ</span><span class="bn">    0a000h</span>
SC_INDEX           <span class="dt">equ</span><span class="bn">    3c4h        </span><span class="co">;Sequence Controller Index register</span>
GC_INDEX           <span class="dt">equ</span><span class="bn">    3ceh        </span><span class="co">;Graphics Controller Index register</span>
CRTC_INDEX         <span class="dt">equ</span><span class="bn">    3d4h        </span><span class="co">;CRT Controller Index register</span>
MAP_MASK           <span class="dt">equ</span>    <span class="dv">2</span>           <span class="co">;Map Mask register index in SC</span>
MEMORY_MODE        <span class="dt">equ</span>    <span class="dv">4</span>           <span class="co">;Memory Mode register index in SC</span>
MAX_SCAN_LINE      <span class="dt">equ</span>    <span class="dv">9</span>           <span class="co">;Maximum Scan Line reg index in CRTC</span>
START_ADDRESS_HIGH <span class="dt">equ</span><span class="bn">    0ch         </span><span class="co">;Start Address High reg index in CRTC</span>
UNDERLINE          <span class="dt">equ</span><span class="bn">    14h         </span><span class="co">;Underline Location reg index in CRTC</span>
MODE_CONTROL       <span class="dt">equ</span><span class="bn">    17h         </span><span class="co">;Mode Control register index in CRTC</span>
GRAPHICS_MODE      <span class="dt">equ</span>    <span class="dv">5</span>           <span class="co">;Graphics Mode register index in GC</span>
MISCELLANEOUS      <span class="dt">equ</span>    <span class="dv">6</span>           <span class="co">;Miscellaneous register index in GC</span>
SCREEN_WIDTH       <span class="dt">equ</span>    <span class="dv">320</span>         <span class="co">;# of pixels across screen</span>
SCREEN_HEIGHT      <span class="dt">equ</span>    <span class="dv">400</span>         <span class="co">;# of scan lines on screen</span>
WORD_OUTS_OK       <span class="dt">equ</span>    <span class="dv">1</span>           <span class="co">;set to 0 to assemble for</span>
                                      <span class="co">; computers that can&#39;t handle</span>
                                      <span class="co">; word outs to indexed VGA registers</span>
<span class="co">;</span>
stack        <span class="kw">segment</span>        para stack <span class="st">&#39;STACK&#39;</span>
             <span class="dt">db</span>             <span class="dv">512</span> dup (?)
stack        ends
<span class="co">;</span>
<span class="co">; Macro to output a word value to a port.</span>
<span class="co">;</span>
OUT_WORDmacro
if WORD_OUTS_OK
      outdx,<span class="kw">ax</span>
else
        <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>  <span class="kw">dx</span>
        xch  gah,<span class="kw">al</span>
        <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>  <span class="kw">dx</span>
        xch  gah,<span class="kw">al</span>
endif
        endm
<span class="co">;</span>
<span class="co">; Macro to output a constant value to an indexed VGA register.</span>
<span class="co">;</span>
CONSTANT_TO_INDEXED_REGISTERmacroADDRESS, INDEX, VALUE
        <span class="kw">mov</span>  <span class="kw">dx</span>,ADDRESS
        <span class="kw">mov</span>  <span class="kw">ax</span>,(VALUE <span class="kw">shl</span> <span class="dv">8</span>) + INDEX
        OUT_WORD
        endm
<span class="co">;</span>
Code    <span class="kw">segment</span>
        assume        <span class="kw">cs</span>:Code
Start   proc   near
<span class="co">;</span>
<span class="co">; Set 320x400 256-color mode.</span>
<span class="co">;</span>
callSet320By400Mode
<span class="co">;</span>
<span class="co">; We&#39;re in 320x400 256-color mode, with page 0 displayed.</span>
<span class="co">; Let&#39;s fill page 0 with color bars slanting down and to the right.</span>
<span class="co">;</span>
        <span class="kw">sub</span>   <span class="kw">di</span>,<span class="kw">di</span>        <span class="co">;page 0 starts at address 0</span>
        <span class="kw">mov</span>   <span class="kw">bl</span>,<span class="dv">1</span>         <span class="co">;make color bars slant down and</span>
                           <span class="co">; to the right</span>
        <span class="kw">call</span>   ColorBarsUp <span class="co">;draw the color bars</span>
<span class="co">;</span>
<span class="co">; Now do the same for page 1, but with the color bars</span>
<span class="co">; tilting the other way.</span>
<span class="co">;</span>
        <span class="kw">mov</span>   <span class="kw">di</span><span class="bn">,8000h        </span><span class="co">;page 1 starts at address 8000h</span>
        <span class="kw">mov</span>   <span class="kw">bl</span>,-<span class="dv">1</span>           <span class="co">;make color bars slant down and</span>
                              <span class="co">; to the left</span>
        <span class="kw">call</span>  ColorBarsUp     <span class="co">;draw the color bars</span>
<span class="co">;</span>
<span class="co">; Wait for a key and flip to page 1 when one is pressed.</span>
<span class="co">;</span>
      callGetNextKey
      CONSTANT_TO_INDEXED_REGISTER CRTC_INDEX,START_ADDRESS_HIGH<span class="bn">,80h</span>
                               <span class="co">;set the Start Address High register</span>
                               <span class="co">; to 80h, for a start address of 8000h</span>
<span class="co">;</span>
<span class="co">; Draw vertical bars in page 0 while page 1 is displayed.</span>
<span class="co">;</span>
        <span class="kw">sub</span>  <span class="kw">di</span>,<span class="kw">di</span>              <span class="co">;page 0 starts at address 0</span>
        <span class="kw">sub</span>  <span class="kw">bl</span>,<span class="kw">bl</span>              <span class="co">;make color bars vertical</span>
        <span class="kw">call</span> ColorBarsUp        <span class="co">;draw the color bars</span>
<span class="co">;</span>
<span class="co">; Wait for another key and flip back to page 0 when one is pressed.</span>
<span class="co">;</span>
        callGetNextKey
        CONSTANT_TO_INDEXED_REGISTER CRTC_INDEX,START_ADDRESS_HIGH<span class="bn">,00h</span>
                                <span class="co">;set the Start Address High register</span>
                                <span class="co">; to 00h, for a start address of 0000h</span>
<span class="co">;</span>
<span class="co">; Wait for yet another key and return to text mode and end when</span>
<span class="co">; one is pressed.</span>
<span class="co">;</span>
        <span class="kw">call</span>   GetNextKey
        <span class="kw">mov</span>    <span class="kw">ax</span><span class="bn">,0003h</span>
        <span class="kw">int</span><span class="bn">    10h                </span><span class="co">;text mode</span>
        <span class="kw">mov</span>    <span class="kw">ah</span><span class="bn">,4ch</span>
        <span class="kw">int</span><span class="bn">    21h                </span><span class="co">;done</span>
<span class="co">;</span>
Start endp
<span class="co">;</span>
<span class="co">; Sets up 320x400 256-color modes.</span>
<span class="co">;</span>
<span class="co">; Input: none</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
Set320By400Modeprocnear
<span class="co">;</span>
<span class="co">; First, go to normal 320x200 256-color mode, which is really a</span>
<span class="co">; 320x400 256-color mode with each line scanned twice.</span>
<span class="co">;</span>
        <span class="kw">mov</span>   <span class="kw">ax</span><span class="bn">,0013h           </span><span class="co">;AH = 0 means mode set, AL = 13h selects</span>
                                 <span class="co">; 256-color graphics mode</span>
        <span class="kw">int</span><span class="bn">   10h                </span><span class="co">;BIOS video interrupt</span>
<span class="co">;</span>
<span class="co">; Change CPU addressing of video memory to linear (not odd/even,</span>
<span class="co">; chain, or chain 4), to allow us to access all 256K of display</span>
<span class="co">; memory. When this is done, VGA memory will look just like memory</span>
<span class="co">; in modes 10h and 12h, except that each byte of display memory will</span>
<span class="co">; control one 256-color pixel, with 4 adjacent pixels at any given</span>
<span class="co">; address, one pixel per plane.</span>
<span class="co">;</span>
      <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
      <span class="kw">mov</span>     <span class="kw">al</span>,MEMORY_MODE
      <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
      <span class="kw">inc</span>     <span class="kw">dx</span>
      ina     l,<span class="kw">dx</span>
      <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">not</span><span class="bn"> 08h                   </span><span class="co">;turn off chain 4</span>
      ora     l<span class="bn">,04h                        </span><span class="co">;turn off odd/even</span>
      <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
      <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
      <span class="kw">mov</span>     <span class="kw">al</span>,GRAPHICS_MODE
      <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
      <span class="kw">inc</span>     <span class="kw">dx</span>
      ina     l,<span class="kw">dx</span>
      <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">not</span><span class="bn"> 10h                   </span><span class="co">;turn off odd/even</span>
      <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
      <span class="kw">dec</span>     <span class="kw">dx</span>
      <span class="kw">mov</span>     <span class="kw">al</span>,MISCELLANEOUS
      <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
      <span class="kw">inc</span>     <span class="kw">dx</span>
      ina     l,<span class="kw">dx</span>
      <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">not</span><span class="bn"> 02h                   </span><span class="co">;turn off chain</span>
      <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Now clear the whole screen, since the mode 13h mode set only</span>
<span class="co">; cleared 64K out of the 256K of display memory. Do this before</span>
<span class="co">; we switch the CRTC out of mode 13h, so we don&#39;t see garbage</span>
<span class="co">; on the screen when we make the switch.</span>
<span class="co">;</span>
CONSTANT_TO_INDEXED_REGISTER SC_INDEX,MAP_MASK<span class="bn">,0fh</span>
                                        <span class="co">;  enable writes to all planes, so</span>
                                        <span class="co">; we can clear 4 pixels at a time</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,VGA_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">cx</span><span class="bn">,8000h                </span><span class="co">;# of words in 64K</span>
        <span class="kw">cld</span>
        rep     <span class="kw">stosw</span>                   <span class="co">;clear all of display memory</span>
<span class="co">;</span>
<span class="co">; Tweak the mode to 320x400 256-color mode by not scanning each</span>
<span class="co">; line twice.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,CRTC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,MAX_SCAN_LINE
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">not</span><span class="bn"> 1fh                </span><span class="co">;set maximum scan line = 0</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
<span class="co">;</span>
<span class="co">; Change CRTC scanning from doubleword mode to byte mode, allowing</span>
<span class="co">; the CRTC to scan more than 64K of video data.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,UNDERLINE
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        ina     l,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span>,not40h                <span class="co">;turn off doubleword</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,MODE_CONTROL
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">or</span>      <span class="kw">al</span><span class="bn">,40h                   </span><span class="co">;turn on the byte mode bit, so memory is</span>
                                         <span class="co">; scanned for video data in a purely</span>
                                         <span class="co">; linear way, just as in modes 10h and 12h</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">ret</span>
Set320By400Mode  endp
<span class="co">;</span>
<span class="co">; Draws a full screen of slanting color bars in the specified page.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;        DI = page start address</span>
<span class="co">;        BL = 1 to make the bars slant down and to the right, -1 to</span>
<span class="co">;        make them slant down and to the left, 0 to make</span>
<span class="co">;        them vertical.</span>
<span class="co">;</span>
ColorBarsUpprocnear
        <span class="kw">mov</span>     <span class="kw">ax</span>,VGA_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>                <span class="co">;point to display memory</span>
        <span class="kw">sub</span>     <span class="kw">bh</span>,<span class="kw">bh</span>                <span class="co">;start with color 0</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,SCREEN_HEIGHT     <span class="co">;# of rows to do</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                <span class="co">;point the SC Index reg to the Map Mask reg</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>                   <span class="co">;point DX to the SC Data register</span>
<span class="fu">RowLoop:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,SCREEN_WIDTH/<span class="dv">4</span>
                                     <span class="co">;4 pixels at each address, so</span>
                                     <span class="co">; each 320-pixel row is 80 bytes wide</span>
                                     <span class="co">; in each plane</span>
        pus h   <span class="kw">bx</span>                   <span class="co">;save the row-start color</span>
<span class="fu">ColumnLoop:</span>
MAP_SELECT = <span class="dv">1</span>
        rept  <span class="dv">4</span>                      <span class="co">;do all 4 pixels at this address with</span>
                                     <span class="co">; in-line code</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_SELECT
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                <span class="co">;select planes 0, 1, 2, and 3 in turn</span>
        <span class="kw">mov</span>     <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">bh</span>           <span class="co">;write this plane&#39;s pixel</span>
        <span class="kw">inc</span>     <span class="kw">bh</span>                   <span class="co">;set the color for the next pixel</span>
MAP_SELECT = MAP_SELECT <span class="kw">shl</span> <span class="dv">1</span>
        endm
        <span class="kw">inc</span>     <span class="kw">di</span>                    <span class="co">;point to the address containing the next</span>
                                      <span class="co">; 4 pixels</span>
        <span class="kw">loop</span>    ColumnLoop            <span class="co">;do any remaining pixels on this line</span>
        <span class="kw">pop</span>     <span class="kw">bx</span>                    <span class="co">;get back the row-start color</span>
        <span class="kw">add</span>     <span class="kw">bh</span>,<span class="kw">bl</span>                 <span class="co">;select next row-start color (controls</span>
                                       <span class="co">; slanting of color bars)</span>
        <span class="kw">dec</span>     <span class="kw">si</span>                     <span class="co">;count down lines on the screen</span>
        <span class="kw">jnz</span>     RowLoop
        <span class="kw">ret</span>
ColorBarsUpendp
<span class="co">;</span>
<span class="co">; Waits for the next key and returns it in AX.</span>
<span class="co">;</span>
GetNextKeyprocnear
<span class="fu">WaitKey:</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">int</span><span class="bn">     16h</span>
        <span class="kw">jz</span>      WaitKey                <span class="co">;wait for a key to become available</span>
        <span class="kw">sub</span>     <span class="kw">ah</span>,<span class="kw">ah</span>
        <span class="kw">int</span><span class="bn">     16h                    </span><span class="co">;read the key</span>
        <span class="kw">ret</span>
GetNextKey      endp
<span class="co">;</span>
Codeends
<span class="co">;</span>
endStart</code></pre>
<p>When you run Listing 31.2, note the extremely smooth edges and fine gradations of color, especially in the screens with slanting color bars. The displays produced by Listing 31.2 make it clear that 320x400 256-color mode can produce effects that are simply not possible in any 16-color mode.</p>
</section>
<section id="something-to-think-about" class="level3">
<h3><a href="#something-to-think-about">Something to Think About</a></h3>
<p>You can, if you wish, use the display memory organization of 320x400 mode in 320x200 mode by modifying <code>Set320x400Mode</code> to leave the maximum scan line setting at 1 in the mode set. (The version of <code>Set320x400Mode</code> in Listings 31.1 and 31.2 forces the maximum scan line to 0, doubling the effective resolution of the screen.) Why would you want to do that? For one thing, you could then choose from not two but <em>four</em> 320x200 256-color display pages, starting at offsets 0, 4000H, 8000H, and 0C000H in display memory. For another, having only half as many pixels per screen can as much as double drawing speeds; that’s one reason that many games run at 320x200, and even then often limit the active display drawing area to only a portion of the screen.</p>
</section>
</section>
<section id="chapter-32-be-it-resolved-360x480" class="level2">
<h2><a href="#chapter-32-be-it-resolved-360x480">Chapter 32 – Be It Resolved: 360x480</a></h2>
<section id="taking-256-color-modes-about-as-far-as-the-standard-vga-can-take-them" class="level3">
<h3><a href="#taking-256-color-modes-about-as-far-as-the-standard-vga-can-take-them">Taking 256-Color Modes About as Far as the Standard VGA Can Take Them</a></h3>
<p>In the last chapter, we learned how to coax 320x400 256-color resolution out of a standard VGA. At the time, I noted that the VGA was actually capable of supporting 256-color resolutions as high as 360x480, but didn’t pursue the topic further, preferring to concentrate on the versatile and easy-to-set 320x400 256-color mode instead.</p>
<p>Some time back I was sent a particularly useful item from John Bridges, a longtime correspondent and an excellent programmer. It was a complete mode set routine for 360x480 256-color mode that he has placed into the public domain. In addition, John wrote, “I also have a couple of freeware (free, but not public domain) utilities out there, including PICEM, which displays PIC, PCX, and GIF images not only in 360x480x256 but also in 640x350x256, 640x400x256, 640x480x256, and 800x600x256 on SuperVGAs.”</p>
<p>In this chapter, I’m going to combine John’s mode set code with appropriately modified versions of the dot-plot code from Chapter 31 and the line-drawing code that we’ll develop in Chapter 35. Together, those routines will make a pretty nifty demo of the capabilities of 360x480 256-color mode.</p>
</section>
<section id="extended-256-color-modes-whats-not-to-like" class="level3">
<h3><a href="#extended-256-color-modes-whats-not-to-like">Extended 256-Color Modes: What’s Not to Like?</a></h3>
<p>When last we left 256-color programming, we had found that the standard 256-color mode, mode 13H, which officially offers 320x200 resolution, actually displays 400, not 200, scan lines, with line-doubling used to reduce the effective resolution to 320x200. By tweaking a few of the VGA’s mode registers, we converted mode 13H to a true 320x400 256-color mode. As an added bonus, that 320x400 mode supports two graphics pages, a distinct improvement over the single graphics page supported by mode 13H. (We also learned how to get <em>four</em> graphics pages at 320x200 resolution, should that be needed.)</p>
<p>I particularly like 320x400 256-color mode for two reasons: It supports two-page graphics, which is very important for animation applications; and it doesn’t require changing any of the monitor timing characteristics of the VGA. The mode bits that we changed to produce 320x400 256-color mode are pretty much guaranteed to be the same from one VGA to another, but the monitor-oriented registers are less certain to be constant, especially for VGAs that provide special support for the extended capabilities of various multiscanning monitors.</p>
<p>All in all, those are good arguments for 320x400 256-color mode. However, the counter-argument seems compelling as well—nothing beats higher resolution for producing striking graphics. Given that, and given that John Bridges was kind enough to make his mode set code available, I’m going to look at 360x480 256mode next. However, bear in mind that the drawbacks of this mode are the flip side of the strengths of 320x400 256-color mode: Only one graphics page, and direct setting of the monitorregisters. Also, this mode has a peculiar and unique aspect ratio, with 480 pixels (as many as high-resolution mode 12H) vertically and only 360 horizontally. That makes for fairly poor horizontal resolution and sometimes-jagged drawing; on the other hand, the resolution is better in both directions than in mode 13H, and mode 13H itself has an odd aspect ratio, so it seems a bit petty to complain.</p>
<p>The single graphics page isn’t a drawback if you don’t need page flipping, of course, so there’s not much to worry about there: If you need page flipping, don’t use this mode. The direct setting of the monitor-oriented registers is another matter altogether.</p>
<p>I don’t know how likely this code is to produce problems with clone VGAs in general; however, I did find that I had to put an older Video Seven VRAM VGA into “pure” mode—where it treats the VRAMs as DRAMs and exactly emulates a plain-vanilla IBM VGA—before 360x480 256-color mode would work properly. Now, that particular problem was due to an inherent characteristic of VRAMs, and shouldn’t occur on Video Seven’s Fastwrite adapter or any other VGA clone. Nonetheless, 360x480 256-color mode is a good deal different from any standard VGA mode, and while the code in this chapter runs perfectly well on all other VGAs in my experience, I can’t guarantee its functionality on any particular VGA/monitor combination, unlike 320x400 256-color mode. Mind you, 360x480 256-color mode <em>should</em> work on all VGAs—there are just too many variables involved for me to be certain. Feedback from readers with broad 360x480 256-color experience is welcome.</p>
<p>The above notwithstanding, 360x480 256-color mode offers 64 times as many colors and nearly three times as many pixels as IBM’s original CGA color graphics mode, making startlingly realistic effects possible. No mode of the VGA (at least no mode that I know of!), documented or undocumented, offers a better combination of resolution and color; even 320x400 256-color mode has 26 percent fewer pixels.</p>
<p>In other words, 360x480 256-color mode is worth considering—so let’s have a look.</p>
</section>
<section id="x480-256-color-mode" class="level3">
<h3><a href="#x480-256-color-mode">360x480 256-Color Mode</a></h3>
<p>I’m going to start by showing you 360x480 256-color mode in action, after which we’ll look at how it works. I suspect that once you see what this mode looks like, you’ll be more than eager to learn how to use it.</p>
<p>Listing 32.1 contains three C-callable assembly functions. As you would expect, <code>Set360x480Mode</code> places the VGA into 360x480 256mode. <code>Draw360x480Dot</code> draws a pixel of the specified color at the specified location. Finally, <code>Read360x480Dot</code> returns the color of the pixel at the specified location. (This last function isn’t actually used in the example program in this chapter, but is included for completeness.)</p>
<p>Listing 32.2 contains an adaptation of some C linecode I’ll be presenting shortly in Chapter 35. If you’re reading this book in serial fashion and haven’t gotten there yet, simply take it on faith. If you really <em>really</em> need to know how the line-draw code works right <em>now</em>, by all means make a short forward call to Chapter 35 and digest it. The line-draw code presented below has been altered to select 360x480 256-color mode, and to cycle through all 256 colors that this mode supports, drawing each line in a different color.</p>
<p><strong>LISTING 32.1 L32-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Borland C/C++ tiny/small/medium model-callable assembler</span>
<span class="co">; subroutines to:</span>
<span class="co">;* Set 360x480 256-color VGA mode</span>
<span class="co">;* Draw a dot in 360x480 256-color VGA mode</span>
<span class="co">;* Read the color of a dot in 360x480 256-color VGA mode</span>
<span class="co">;</span>
<span class="co">; Assembled with TASM</span>
<span class="co">;</span>
<span class="co">; The 360x480 256-color mode set code and parameters were provided</span>
<span class="co">; by John Bridges, who has placed them into the public domain.</span>
<span class="co">;</span>
VGA_SEGMENT     <span class="dt">equ</span><span class="bn">    0a000h      </span><span class="co">;display memory segment</span>
SC_INDEX        <span class="dt">equ</span><span class="bn">    3c4h        </span><span class="co">;Sequence Controller Index register</span>
GC_INDEX        <span class="dt">equ</span><span class="bn">    3ceh        </span><span class="co">;Graphics Controller Index register</span>
MAP_MASK        <span class="dt">equ</span>    <span class="dv">2</span>           <span class="co">;Map Mask register index in SC</span>
READ_MAP        <span class="dt">equ</span>    <span class="dv">4</span>           <span class="co">;Read Map register index in GC</span>
SCREEN_WIDTH    <span class="dt">equ</span>    <span class="dv">360</span>         <span class="co">;# of pixels across screen</span>
WORD_OUTS_OK    <span class="dt">equ</span>    <span class="dv">1</span>           <span class="co">;set to 0 to assemble for</span>
                                   <span class="co">; computers that can&#39;t handle</span>
                                   <span class="co">; word outs to indexed VGA registers</span>
<span class="co">;</span>
_DATAsegmentpublic <span class="dt">byte</span> ‘DATA<span class="st">&#39;</span>
<span class="co">;</span>
<span class="co">; 360x480 256-color mode CRT Controller register settings.</span>
<span class="co">; (Courtesy of John Bridges.)</span>
<span class="co">;</span>
vptbl   <span class="dt">dw</span><span class="bn">      06b00h  </span><span class="co">; horz total</span>
        <span class="dt">dw</span><span class="bn">      05901h  </span><span class="co">; horz displayed</span>
        <span class="dt">dw</span><span class="bn">      05a02h  </span><span class="co">; start horz blanking</span>
        <span class="dt">dw</span><span class="bn">      08e03h  </span><span class="co">; end horz blanking</span>
        <span class="dt">dw</span><span class="bn">      05e04h  </span><span class="co">; start h sync</span>
        <span class="dt">dw</span><span class="bn">      08a05h  </span><span class="co">; end h sync</span>
        <span class="dt">dw</span><span class="bn">      00d06h  </span><span class="co">; vertical total</span>
        <span class="dt">dw</span><span class="bn">      03e07h  </span><span class="co">; overflow</span>
        <span class="dt">dw</span><span class="bn">      04009h  </span><span class="co">; cell height</span>
        <span class="dt">dw</span><span class="bn">      0ea10h  </span><span class="co">; v sync start</span>
        <span class="dt">dw</span><span class="bn">      0ac11h  </span><span class="co">; v sync end and protect cr0-cr7</span>
        <span class="dt">dw</span><span class="bn">      0df12h  </span><span class="co">; vertical displayed</span>
        <span class="dt">dw</span><span class="bn">      02d13h  </span><span class="co">; offset</span>
        <span class="dt">dw</span><span class="bn">      00014h  </span><span class="co">; turn off dword mode</span>
        <span class="dt">dw</span><span class="bn">      0e715h  </span><span class="co">; v blank start</span>
        <span class="dt">dw</span><span class="bn">      00616h  </span><span class="co">; v blank end</span>
        <span class="dt">dw</span><span class="bn">      0e317h  </span><span class="co">; turn on byte mode</span>
vpend   label   <span class="dt">word</span>
_DATAends
<span class="co">;</span>
<span class="co">; Macro to output a word value to a port.</span>
<span class="co">;</span>
OUT_WORDmacro
if WORD_OUTS_OK
      <span class="kw">out</span>   <span class="kw">dx</span>,<span class="kw">ax</span>
else
      <span class="kw">out</span>   <span class="kw">dx</span>,<span class="kw">al</span>
      <span class="kw">inc</span>   <span class="kw">dx</span>
      <span class="kw">xchg</span>  <span class="kw">ah</span>,<span class="kw">al</span>
      <span class="kw">out</span>   <span class="kw">dx</span>,<span class="kw">al</span>
      <span class="kw">dec</span>   <span class="kw">dx</span>
      <span class="kw">xchg</span>  <span class="kw">ah</span>,<span class="kw">al</span>
endif
      endm
<span class="co">;</span>
_TEXTsegment <span class="dt">byte</span> public ‘CODE<span class="st">&#39;</span>
<span class="fu">       assumecs:</span>_TEXT, <span class="kw">ds</span>:_DATA
<span class="co">;</span>
<span class="co">; Sets up 360x480 256-color mode.</span>
<span class="co">; (Courtesy of John Bridges.)</span>
<span class="co">;</span>
<span class="co">; Call as: void Set360By480Mode()</span>
<span class="co">;</span>
<span class="co">; Returns: nothing</span>
<span class="co">;</span>
      public _Set360x480Mode
_Set360x480Modeprocnear
      <span class="kw">push</span>   <span class="kw">si</span>                 <span class="co">;preserve C register vars</span>
      <span class="kw">push</span>   <span class="kw">di</span>
      <span class="kw">mov</span>    <span class="kw">ax</span><span class="bn">,12h             </span><span class="co">; start with mode 12h</span>
      <span class="kw">int</span><span class="bn">    10h                </span><span class="co">; let the BIOS clear the video memory</span>

      <span class="kw">mov</span>    <span class="kw">ax</span><span class="bn">,13h             </span><span class="co">; start with standard mode 13h</span>
      <span class="kw">int</span><span class="bn">    10h                </span><span class="co">; let the BIOS set the mode</span>

      <span class="kw">mov</span>    <span class="kw">dx</span><span class="bn">,3c4h            </span><span class="co">; alter sequencer registers</span>
      <span class="kw">mov</span>    <span class="kw">ax</span><span class="bn">,0604h           </span><span class="co">; disable chain 4</span>
      <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">ax</span>

      <span class="kw">mov</span>    <span class="kw">ax</span><span class="bn">,0100h           </span><span class="co">; synchronous reset</span>
      <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">ax</span>              <span class="co">; asserted</span>
      <span class="kw">mov</span>    <span class="kw">dx</span><span class="bn">,3c2h            </span><span class="co">; misc output</span>
      <span class="kw">mov</span>    <span class="kw">al</span><span class="bn">,0e7h            </span><span class="co">; use 28 mHz dot clock</span>
      <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">al</span>              <span class="co">; select it</span>
      <span class="kw">mov</span>    <span class="kw">dx</span><span class="bn">,3c4h            </span><span class="co">; sequencer again</span>
      <span class="kw">mov</span>    <span class="kw">ax</span><span class="bn">,0300h           </span><span class="co">; restart sequencer</span>
      <span class="kw">out</span>    <span class="kw">dx</span>,<span class="kw">ax</span>              <span class="co">; running again</span>

      <span class="kw">mov</span>    <span class="kw">dx</span><span class="bn">,3d4h            </span><span class="co">; alter crtc registers</span>

      <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,11h            </span><span class="co">; cr11</span>
      <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>             <span class="co">; current value</span>
      <span class="kw">inc</span>     <span class="kw">dx</span>                <span class="co">; point to data</span>
      <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>             <span class="co">; get cr11 value</span>
      <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,7fh            </span><span class="co">; remove cr0 -&gt; cr7</span>
      <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>             <span class="co">; write protect</span>
      <span class="kw">dec</span>     <span class="kw">dx</span>                <span class="co">; point to index</span>
      <span class="kw">cld</span>
      <span class="kw">mov</span>     <span class="kw">si</span>,offset vptbl
      <span class="kw">mov</span>     <span class="kw">cx</span>,((offset vpend)-(offset vptbl)) <span class="kw">shr</span> <span class="dv">1</span>
@b:   <span class="kw">lodsw</span>
      <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>
      <span class="kw">loop</span>    @b
      <span class="kw">pop</span>     <span class="kw">di</span>                <span class="co">;restore C register vars</span>
      <span class="kw">pop</span>     <span class="kw">si</span>
      <span class="kw">ret</span>
_Set360x480Modeendp
<span class="co">;</span>
<span class="co">; Draws a pixel in the specified color at the specified</span>
<span class="co">; location in 360x480 256-color mode.</span>
<span class="co">;</span>
<span class="co">; Call as: void Draw360x480Dot(int X, int Y, int Color)</span>
<span class="co">;</span>
<span class="co">; Returns: nothing</span>
<span class="co">;</span>
DParms     <span class="kw">struc</span>
      <span class="dt">dw</span>   ?            <span class="co">;pushed BP</span>
      <span class="dt">dw</span>   ?            <span class="co">;return address</span>
DrawX <span class="dt">dw</span>   ?            <span class="co">;X coordinate at which to draw</span>
DrawY <span class="dt">dw</span>   ?            <span class="co">;Y coordinate at which to draw</span>
Color <span class="dt">dw</span>   ?            <span class="co">;color in which to draw (in the</span>
                        <span class="co">; range 0-255; upper byte ignored)</span>
DParms     ends
<span class="co">;</span>
      public _Draw360x480Dot
_Draw360x480Dotprocnear
      <span class="kw">push</span>  <span class="kw">bp</span>            <span class="co">;preserve caller&#39;s BP</span>
      <span class="kw">mov</span>   <span class="kw">bp</span>,<span class="kw">sp</span>         <span class="co">;point to stack frame</span>
      <span class="kw">push</span>  <span class="kw">si</span>            <span class="co">;preserve C register vars</span>
      <span class="kw">push</span>  <span class="kw">di</span>
      <span class="kw">mov</span>   <span class="kw">ax</span>,VGA_SEGMENT
      <span class="kw">mov</span>   <span class="kw">es</span>,<span class="kw">ax</span>         <span class="co">;point to display memory</span>
      <span class="kw">mov</span>   <span class="kw">ax</span>,SCREEN_WIDTH/<span class="dv">4</span>
                          <span class="co">;there are 4 pixels at each address, so</span>
                           <span class="co">; each 360-pixel row is 90 bytes wide</span>
                           <span class="co">; in each plane</span>
      <span class="kw">mul</span>   [<span class="kw">bp</span>+DrawY] <span class="co">;point to start of desired row</span>
      <span class="kw">mov</span>   <span class="kw">di</span>,[<span class="kw">bp</span>+DrawX] <span class="co">;get the X coordinate</span>
      <span class="kw">shr</span>   <span class="kw">di</span>,<span class="dv">1</span>           <span class="co">;there are 4 pixels at each address</span>
      <span class="kw">shr</span>   <span class="kw">di</span>,<span class="dv">1</span>           <span class="co">; so divide the X coordinate by 4</span>
      <span class="kw">add</span>   <span class="kw">di</span>,<span class="kw">ax</span>          <span class="co">;point to the pixel&#39;s address</span>
      <span class="kw">mov</span>   <span class="kw">cl</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+DrawX] <span class="co">;get the X coordinate again</span>
      <span class="kw">and</span>   <span class="kw">cl</span>,<span class="dv">3</span>           <span class="co">;get the plane # of the pixel</span>
      <span class="kw">mov</span>   <span class="kw">ah</span>,<span class="dv">1</span>
      <span class="kw">shl</span>   <span class="kw">ah</span>,<span class="kw">cl</span>          <span class="co">;set the bit corresponding to the plane</span>
                           <span class="co">; the pixel is in</span>
      <span class="kw">mov</span>   <span class="kw">al</span>,MAP_MASK
      <span class="kw">mov</span>   <span class="kw">dx</span>,SC_INDEX
      OUT_WORD             <span class="co">;set to write to the proper plane for</span>
                           <span class="co">; the pixel</span>
      <span class="kw">mov</span>   <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Color] <span class="co">;get the color</span>
      <span class="kw">stosb</span>                <span class="co">;draw the pixel</span>
      <span class="kw">pop</span>   <span class="kw">di</span>             <span class="co">;restore C register vars</span>
      <span class="kw">pop</span>   <span class="kw">si</span>
      <span class="kw">pop</span>   <span class="kw">bp</span>             <span class="co">;restore caller&#39;s BP</span>
      <span class="kw">ret</span>
_Draw360x480Dotendp
<span class="co">;</span>
<span class="co">; Reads the color of the pixel at the specified</span>
<span class="co">; location in 360x480 256-color mode.</span>
<span class="co">;</span>
<span class="co">; Call as: int Read360x480Dot(int X, int Y)</span>
<span class="co">;</span>
<span class="co">; Returns: pixel color</span>
<span class="co">;</span>
RParms     <span class="kw">struc</span>
      <span class="dt">dw</span>   ?                <span class="co">;pushed BP</span>
      <span class="dt">dw</span>   ?                <span class="co">;return address</span>
ReadX <span class="dt">dw</span>   ?                <span class="co">;X coordinate from which to read</span>
ReadY <span class="dt">dw</span>   ?                <span class="co">;Y coordinate from which to read</span>
RParms     ends
<span class="co">;</span>
      public _Read360x480Dot
_Read360x480Dotprocnear
      <span class="kw">push</span>  <span class="kw">bp</span>              <span class="co">;preserve caller&#39;s BP</span>
      <span class="kw">mov</span>   <span class="kw">bp</span>,<span class="kw">sp</span>           <span class="co">;point to stack frame</span>
      <span class="kw">push</span>  <span class="kw">si</span>              <span class="co">;preserve C register vars</span>
      <span class="kw">push</span>  <span class="kw">di</span>
      <span class="kw">mov</span>   <span class="kw">ax</span>,VGA_SEGMENT
      <span class="kw">mov</span>   <span class="kw">es</span>,<span class="kw">ax</span>           <span class="co">;point to display memory</span>
      <span class="kw">mov</span>   <span class="kw">ax</span>,SCREEN_WIDTH/<span class="dv">4</span> <span class="co">;there are 4 pixels at each address, so</span>
                            <span class="co">; each 360-pixel row is 90 bytes wide</span>
                            <span class="co">; in each plane</span>

       <span class="kw">mul</span>  [<span class="kw">bp</span>+DrawY] <span class="co">;point to start of desired row</span>
       <span class="kw">mov</span>  <span class="kw">si</span>,[<span class="kw">bp</span>+DrawX] <span class="co">;get the X coordinate</span>
       <span class="kw">shr</span>  <span class="kw">si</span>,<span class="dv">1</span>            <span class="co">;there are 4 pixels at each address</span>
       <span class="kw">shr</span>  <span class="kw">si</span>,<span class="dv">1</span>            <span class="co">; so divide the X coordinate by 4</span>
       <span class="kw">add</span>  <span class="kw">si</span>,<span class="kw">ax</span>           <span class="co">;point to the pixel&#39;s address</span>
       <span class="kw">mov</span>  <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+DrawX] <span class="co">;get the X coordinate again</span>
       <span class="kw">and</span>  <span class="kw">ah</span>,<span class="dv">3</span>
                            <span class="co">;get the plane # of the pixel</span>
       <span class="kw">mov</span>  <span class="kw">al</span>,READ_MAP
       <span class="kw">mov</span>  <span class="kw">dx</span>,GC_INDEX
       OUT_WORD             <span class="co">;set to read from the proper plane for</span>
                            <span class="co">; the pixel</span>
       <span class="kw">lods</span> <span class="dt">byte</span> <span class="dt">ptr</span> <span class="kw">es</span>:[<span class="kw">si</span>] <span class="co">;read the pixel</span>
       <span class="kw">sub</span>  <span class="kw">ah</span>,<span class="kw">ah</span>           <span class="co">;make the return value a word for C</span>
       <span class="kw">pop</span>  <span class="kw">di</span>              <span class="co">;restore C register vars</span>
       <span class="kw">pop</span>  <span class="kw">si</span>
       <span class="kw">pop</span>  <span class="kw">bp</span>              <span class="co">;restore caller&#39;s BP</span>
       <span class="kw">ret</span>
_Read360x480Dot  endp
_TEX   Tends
       end</code></pre>
<p><strong>LISTING 32.2 L32-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Sample program to illustrate VGA line drawing in 360x480</span>
<span class="co"> * 256-color mode.</span>
<span class="co"> *</span>
<span class="co"> * Compiled with Borland C/C++.</span>
<span class="co"> *</span>
<span class="co"> * Must be linked with Listing 32.1 with a command line like:</span>
<span class="co"> *</span>
<span class="co"> *    bcc l10-2.c l10-1.asm</span>
<span class="co"> *</span>
<span class="co"> * By Michael Abrash</span>
<span class="co"> */</span>
<span class="ot">#include &lt;dos.h&gt;                 </span><span class="co">/* contains geninterrupt */</span>

<span class="ot">#define TEXT_MODE       0x03</span>
<span class="ot">#define BIOS_VIDEO_INT  0x10</span>
<span class="ot">#define X_MAX           360      </span><span class="co">/* working screen width */</span>
<span class="ot">#define Y_MAX           480      </span><span class="co">/* working screen height */</span>

<span class="kw">extern</span> <span class="dt">void</span> Draw360x480Dot();
<span class="kw">extern</span> <span class="dt">void</span> Set360x480Mode();

<span class="co">/*</span>
<span class="co"> * Draws a line in octant 0 or 3 ( |DeltaX| &gt;= DeltaY ).</span>
<span class="co"> * |DeltaX|+1 points are drawn.</span>
<span class="co"> */</span>
<span class="dt">void</span> Octant0(X0, Y0, DeltaX, DeltaY, XDirection, Color)
<span class="dt">unsigned</span> <span class="dt">int</span> X0, Y0;          <span class="co">/* coordinates of start of the line */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> DeltaX, DeltaY;  <span class="co">/* length of the line */</span>
<span class="dt">int</span> XDirection;               <span class="co">/* 1 if line is drawn left to right,</span>
<span class="co">                                 -1 if drawn right to left */</span>
<span class="dt">int</span> Color;                    <span class="co">/* color in which to draw line */</span>
{
   <span class="dt">int</span> DeltaYx2;
   <span class="dt">int</span> DeltaYx2MinusDeltaXx2;
   <span class="dt">int</span> ErrorTerm;

   <span class="co">/* Set up initial error term and values used inside drawing loop */</span>
   DeltaYx2 = DeltaY * <span class="dv">2</span>;
   DeltaYx2MinusDeltaXx2 = DeltaYx2 - (<span class="dt">int</span>) ( DeltaX * <span class="dv">2</span> );
   ErrorTerm = DeltaYx2 - (<span class="dt">int</span>) DeltaX;

   <span class="co">/* Draw the line */</span>
   Draw360x480Dot(X0, Y0, Color);   <span class="co">/* draw the first pixel */</span>
   <span class="kw">while</span> ( DeltaX-- ) {
      <span class="co">/* See if it&#39;s time to advance the Y coordinate */</span>
      <span class="kw">if</span> ( ErrorTerm &gt;= <span class="dv">0</span> ) {
         <span class="co">/* Advance the Y coordinate &amp; adjust the error term</span>
<span class="co">            back down */</span>
         Y0++;
         ErrorTerm += DeltaYx2MinusDeltaXx2;
      } <span class="kw">else</span> {
         <span class="co">/* Add to the error term */</span>
         ErrorTerm += DeltaYx2;
      }
      X0 += XDirection;          <span class="co">/* advance the X coordinate */</span>
      Draw360x480Dot(X0, Y0, Color);    <span class="co">/* draw a pixel */</span>
   }
}

<span class="co">/*</span>
<span class="co"> * Draws a line in octant 1 or 2 ( |DeltaX| &lt; DeltaY ).</span>
<span class="co"> * |DeltaY|+1 points are drawn.</span>
<span class="co"> */</span>
<span class="dt">void</span> Octant1(X0, Y0, DeltaX, DeltaY, XDirection, Color)
<span class="dt">unsigned</span> <span class="dt">int</span> X0, Y0;          <span class="co">/* coordinates of start of the line */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> DeltaX, DeltaY;  <span class="co">/* length of the line */</span>
<span class="dt">int</span> XDirection;               <span class="co">/* 1 if line is drawn left to right,</span>
<span class="co">                                 -1 if drawn right to left */</span>
<span class="dt">int</span> Color;                    <span class="co">/* color in which to draw line */</span>
{
   <span class="dt">int</span> DeltaXx2;
   <span class="dt">int</span> DeltaXx2MinusDeltaYx2;
   <span class="dt">int</span> ErrorTerm;

   <span class="co">/* Set up initial error term and values used inside drawing loop */</span>
   DeltaXx2 = DeltaX * <span class="dv">2</span>;
   DeltaXx2MinusDeltaYx2 = DeltaXx2 - (<span class="dt">int</span>) ( DeltaY * <span class="dv">2</span> );
   ErrorTerm = DeltaXx2 - (<span class="dt">int</span>) DeltaY;

   Draw360x480Dot(X0, Y0, Color);<span class="co">/* draw the first pixel */</span>
   <span class="kw">while</span> ( DeltaY-- ) {
      <span class="co">/* See if it&#39;s time to advance the X coordinate */</span>
      <span class="kw">if</span> ( ErrorTerm &gt;= <span class="dv">0</span> ) {
         <span class="co">/* Advance the X coordinate &amp; adjust the error term</span>
<span class="co">            back down */</span>
         X0 += XDirection;
         ErrorTerm += DeltaXx2MinusDeltaYx2;
      } <span class="kw">else</span> {
         <span class="co">/* Add to the error term */</span>
         ErrorTerm += DeltaXx2;
      }
      Y0++;                   <span class="co">/* advance the Y coordinate */</span>
      Draw360x480Dot(X0, Y0,Color);  <span class="co">/* draw a pixel */</span>
   }
}

<span class="co">/*</span>
<span class="co"> * Draws a line on the EGA or VGA.</span>
<span class="co"> */</span>
<span class="dt">void</span> EVGALine(X0, Y0, X1, Y1, Color)
<span class="dt">int</span> X0, Y0;             <span class="co">/* coordinates of one end of the line */</span>
<span class="dt">int</span> X1, Y1;             <span class="co">/* coordinates of the other end of the line */</span>
<span class="dt">unsigned</span> <span class="dt">char</span> Color;    <span class="co">/* color in which to draw line */</span>
{
   <span class="dt">int</span> DeltaX, DeltaY;
   <span class="dt">int</span> Temp;

   <span class="co">/* Save half the line-drawing cases by swapping Y0 with Y1</span>
<span class="co">      and X0 with X1 if Y0 is greater than Y1. As a result, DeltaY</span>
<span class="co">      is always &gt; 0, and only the octant 0-3 cases need to be</span>
<span class="co">      handled. */</span>
   <span class="kw">if</span> ( Y0 &gt; Y1 ) {
      Temp = Y0;
      Y0 = Y1;
      Y1 = Temp;
      Temp = X0;
      X0 = X1;
      X1 = Temp;
   }

   <span class="co">/* Handle as four separate cases, for the four octants in which</span>
<span class="co">      Y1 is greater than Y0 */</span>
   DeltaX = X1 - X0;    <span class="co">/* calculate the length of the line</span>
<span class="co">                           in each coordinate */</span>
   DeltaY = Y1 - Y0;
   <span class="kw">if</span> ( DeltaX &gt; <span class="dv">0</span> ) {
      <span class="kw">if</span> ( DeltaX &gt; DeltaY ) {
         Octant0(X0, Y0, DeltaX, DeltaY, <span class="dv">1</span>, Color);
      } <span class="kw">else</span> {
         Octant1(X0, Y0, DeltaX, DeltaY, <span class="dv">1</span>, Color);
      }
   } <span class="kw">else</span> {
      DeltaX = -DeltaX;             <span class="co">/* absolute value of DeltaX */</span>
      <span class="kw">if</span> ( DeltaX &gt; DeltaY ) {
         Octant0(X0, Y0, DeltaX, DeltaY, -<span class="dv">1</span>, Color);
      } <span class="kw">else</span> {
         Octant1(X0, Y0, DeltaX, DeltaY, -<span class="dv">1</span>, Color);
      }
   }
}

<span class="co">/*</span>
<span class="co"> * Subroutine to draw a rectangle full of vectors, of the</span>
<span class="co"> * specified length and in varying colors, around the</span>
<span class="co"> * specified rectangle center.</span>
<span class="co"> */</span>
<span class="dt">void</span> VectorsUp(XCenter, YCenter, XLength, YLength)
<span class="dt">int</span> XCenter, YCenter;   <span class="co">/* center of rectangle to fill */</span>
<span class="dt">int</span> XLength, YLength;   <span class="co">/* distance from center to edge</span>
<span class="co">                           of rectangle */</span>
{
   <span class="dt">int</span> WorkingX, WorkingY, Color = <span class="dv">1</span>;

   <span class="co">/* Lines from center to top of rectangle */</span>
   WorkingX = XCenter - XLength;
   WorkingY = YCenter - YLength;
   <span class="kw">for</span> ( ; WorkingX &lt; ( XCenter + XLength ); WorkingX++ )
      EVGALine(XCenter, YCenter, WorkingX, WorkingY, Color++);

   <span class="co">/* Lines from center to right of rectangle */</span>
   WorkingX = XCenter + XLength - <span class="dv">1</span>;
   WorkingY = YCenter - YLength;
   <span class="kw">for</span> ( ; WorkingY &lt; ( YCenter + YLength ); WorkingY++ )
      EVGALine(XCenter, YCenter, WorkingX, WorkingY, Color++);

   <span class="co">/* Lines from center to bottom of rectangle */</span>
   WorkingX = XCenter + XLength - <span class="dv">1</span>;
   WorkingY = YCenter + YLength - <span class="dv">1</span>;
   <span class="kw">for</span> ( ; WorkingX &gt;= ( XCenter - XLength ); WorkingX-- )
      EVGALine(XCenter, YCenter, WorkingX, WorkingY, Color++);

   <span class="co">/* Lines from center to left of rectangle */</span>
   WorkingX = XCenter - XLength;
   WorkingY = YCenter + YLength - <span class="dv">1</span>;
   <span class="kw">for</span> ( ; WorkingY &gt;= ( YCenter - YLength ); WorkingY-- )
      EVGALine(XCenter, YCenter, WorkingX, WorkingY, Color++);
}

<span class="co">/*</span>
<span class="co"> * Sample program to draw four rectangles full of lines.</span>
<span class="co"> */</span>
<span class="dt">void</span> main()
{
   <span class="dt">char</span> temp;

   Set360x480Mode();

   <span class="co">/* Draw each of four rectangles full of vectors */</span>
   VectorsUp(X_MAX / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, X_MAX / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, <span class="dv">1</span>);
   VectorsUp(X_MAX * <span class="dv">3</span> / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, X_MAX / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, <span class="dv">2</span>);
   VectorsUp(X_MAX / <span class="dv">4</span>, Y_MAX * <span class="dv">3</span> / <span class="dv">4</span>, X_MAX / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, <span class="dv">3</span>);
   VectorsUp(X_MAX * <span class="dv">3</span> / <span class="dv">4</span>, Y_MAX * <span class="dv">3</span> / <span class="dv">4</span>, X_MAX / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, <span class="dv">4</span>);

   <span class="co">/* Wait for the enter key to be pressed */</span>
   scanf(<span class="st">&quot;%c&quot;</span>, &amp;temp);

   <span class="co">/* Back to text mode */</span>
   _AX = TEXT_MODE;
   geninterrupt(BIOS_VIDEO_INT);
}</code></pre>
<p>The first thing you’ll notice when you run this code is that the speed of 360x480 256-color mode is pretty good, especially considering that most of the program is im-plemented in C.</p>
<blockquote>
<p><img src="images/i.jpg" /> Drawing in 360x480 256-color mode can sometimes actually be faster than in the 16-color modes, because the byte-per-pixel display memory organization of 256-color mode eliminates the need to read display memory before writing to it in order to isolate individual pixels coexisting within a single byte. In addition, 360x480 256-color mode is a variant of Mode X, which we’ll encounter in detail in Chapter 47, and supports all the high-performance features of Mode X.</p>
</blockquote>
<p>The second thing you’ll notice is that exquisite shading effects are possible in 360x480 256-color mode; adjacent lines blend together remarkably smoothly, even with the default palette. The VGA allows you to select your 256 colors from a palette of 256K, so you could, if you wished, set up the colors to produce still finer shading albeit with fewer distinctly different colors available. For more on this and related topics, see the coverage of palette reprogramming that begins in the next chapter.</p>
<p>The one thing you may not notice right away is just how much detail is visible on the screen, because the blending of colors tends to obscure the superior resolution of this mode. Each of the four rectangles displayed measures 180 pixels horizontally by 240 vertically. Put another way, each <em>one</em> of those rectangles has two-thirds as many pixels as the entire mode 13H screen; in all, 360x480 256-color mode has 2.7 times as many pixels as mode 13H! As mentioned above, the resolution is unevenly distributed, with vertical resolution matching that of mode 12H but horizontal resolution barely exceeding that of mode 13H—but resolution is hot stuff, no matter how it’s laid out, and 360x480 256-color mode has the highest 256-color resolution you’re ever likely to see on a standard VGA. (SuperVGAs are quite another matter—but when you <em>require</em> a SuperVGA you’re automatically excluding what might be a significant chunk of the market for your code.)</p>
<p>Now that we’ve seen the wonders of which our new mode is capable, let’s take the time to understand how it works.</p>
</section>
<section id="how-360x480-256-color-mode-works" class="level3">
<h3><a href="#how-360x480-256-color-mode-works">How 360x480 256-Color Mode Works</a></h3>
<p>In describing 360x480 256-color mode, I’m going to assume that you’re familiar with the discussion of 320x400 256-color mode in the last chapter. If not, go back to that chapter and read it; the two modes have a great deal in common, and I’m not going to bore you by repeating myself when the goods are just a few page flips (the paper kind) away.</p>
<p>360x480 256-color mode is essentially 320x400 256-color mode, but stretched in both dimensions. Let’s look at the vertical stretching first, since that’s the simpler of the two.</p>
<section id="scan-lines-per-screen-a-little-slower-but-no-big-deal" class="level4">
<h4><a href="#scan-lines-per-screen-a-little-slower-but-no-big-deal">480 Scan Lines per Screen: A Little Slower, But No Big Deal</a></h4>
<p>There’s nothing unusual about 480 scan lines; standard modes 11H and 12H support that vertical resolution. The number of scan lines has nothing to do with either the number of colors or the horizontal resolution, so converting 320x400 256mode to 320x480 256-color mode is a simple matter of reprogramming the VGA’s vertical control registers—which control the scan lines displayed, the vertical sync pulse, vertical blanking, and the total number of scan lines—to the 480-scansettings, and setting the polarities of the horizontal and vertical sync pulses to tell the monitor to adjust to a 480-line screen.</p>
<p>Switching to 480 scan lines has the effect of slowing the screen refresh rate. The VGA always displays at 70 Hz <em>except</em> in 480-scan-line modes; there, due to the time required to scan the extra lines, the refresh rate slows to 60 Hz. (VGA monitors always scan at the same rate horizontally; that is, the distance across the screen covered by the electron beam in a given period of time is the same in all modes. Consequently, adding extra lines per frame requires extra time.) 60 Hz isn’t <em>bad</em>—that’s the only refresh rate the EGA ever supported, and the EGA was the industry standard in its time—but it does tend to flicker a little more and so is a little harder on the eyes than 70 Hz.</p>
</section>
<section id="pixels-per-scan-line-no-mean-feat" class="level4">
<h4><a href="#pixels-per-scan-line-no-mean-feat">360 Pixels per Scan Line: No Mean Feat</a></h4>
<p>Converting from 320 to 360 pixels per scan line is more difficult than converting from 400 to 480 scan lines per screen. None of the VGA’s graphics modes supports 360 pixels across the screen, or anything like it; the standard choices are 320 and 640 pixels across. However, the VGA <em>does</em> support the horizontal resolution we seek—360 pixels—in 40-column <em>text</em> mode.</p>
<p>Unfortunately, the register settings that select those horizontal resolutions aren’t directly transferable to graphics mode. Text modes display 9 dots (the width of one character) for each time information is fetched from display memory, while graphics modes display just 4 or 8 dots per display memory fetch. (Although it’s a bit confusing, it’s standard terminology to refer to the interval required for one display memory fetch as a “character,” and I’ll follow that terminology from now on.) Consequently, both modes display either 40 or 80 characters per scan line; the only difference is that text modes display more pixels per character. Given that graphics modes <em>can’t</em> display 9 dots per character (there’s only enough information for eight 16pixels or four 256-color pixels in each memory fetch, and that’s that), we’d seem to be at an impasse.</p>
<p>The key to solving this problem lies in recalling that the VGA is designed to drive a monitor that sweeps the electron beam across the screen at exactly the same speed, no matter what mode the VGA is in. If the monitor always sweeps at the same speed, how does the VGA manage to display both 640 pixels across the screen (in high-resolution graphics modes) and 720 pixels across the screen (in 80-column text modes)? Good question indeed—and the answer is that the VGA has not one but <em>two</em> clocks on board, and one of those clocks is just sufficiently faster than the other clock so that an extra 80 (or 40) pixels can be displayed on each scan line.</p>
<p>In other words, there’s a slow clock (about 25 MHz) that’s usually used in graphics modes to get 640 (or 320) pixels on the screen during each scan line, and a second, fast clock (about 28 MHz) that’s usually used in text modes to crank out 720 (or 360) pixels per scan line. In particular, 320x400 256-color mode uses the 25 MHz clock.</p>
<p>I’ll bet that you can see where I’m headed: We can switch from the 25 MHz clock to the 28 MHz clock in 320x480 256mode in order to get more pixels. It takes two clocks to produce one 256-color pixel, so we’ll get 40 rather than 80 extra pixels by doing this, bringing our horizontal resolution to the desired 360 pixels.</p>
<p>Switching horizontal resolutions sounds easy, doesn’t it? Alas, it’s not. There’s no standard VGA mode that uses the 28 MHz clock to draw 8 rather than 9 dots per character, so the timing parameters have to be calculated from scratch. John Bridges has already done that for us, but I want you to appreciate that producing this mode took some work. The registers controlling the total number of characters per scan line, the number of characters displayed, the horizontal sync pulse, horizontal blanking, the offset from the start of one line to the start of the next, and the clock speed all have to be altered in order to set up 360x480 256-color mode. The function <code>Set360x480Mode</code> in Listing 32.1 does all that, and sets up the registers that control vertical resolution, as well.</p>
<p>Once all that’s done, the VGA is in 360x480 mode, awaiting our every high-resolution 256-color graphics whim.</p>
</section>
<section id="accessing-display-memory-in-360x480-256-color-mode" class="level4">
<h4><a href="#accessing-display-memory-in-360x480-256-color-mode">Accessing Display Memory in 360x480 256-Color Mode</a></h4>
<p>Setting up for 360x480 256-color mode proved to be quite a task. Is drawing in this mode going to be as difficult?</p>
<p>No. In fact, if you know how to draw in 320x400 256-color mode, you already know how to draw in 360x480 256-color mode; the conversion between the two is a simple matter of changing the working screen width from 320 pixels to 360 pixels. In fact, if you were to take the 320x400 256-color pixel reading and pixel writing code from Chapter 31 and change the <code>SCREEN_WIDTH</code> equate from 320 to 360, those routines would work perfectly in 360x480 256-color mode.</p>
<p>The organization of display memory in 360x480 256-color mode is almost exactly the same as in 320x400 256-color mode, which we covered in detail in the last chapter. However, as a quick refresher, each byte of display memory controls one 256-color pixel, just as in mode 13H. The VGA is reprogrammed by the mode set so that adjacent pixels lie in adjacent planes of display memory. Look back to Figure 31.1 in the last chapter to see the organization of the first few pixels on the screen; the bytes controlling those pixels run cross-plane, advancing to the next address only every fourth pixel. The address of the pixel at screen coordinate (<em>x,y</em>) is</p>
<p><em>address</em> = ((<em>y</em>*360)+<em>x</em>)/4</p>
<p>and the plane of a given pixel is:</p>
<p><em>plane</em> = <em>x</em> modulo 4</p>
<p>A new scan line starts every 360 pixels, or 90 bytes, as shown in Figure 32.1. This is the major programming difference between the 360x480 and 320x400 256-color modes; in the 320x400 mode, a new scan line starts every 80 bytes.</p>
<p>The other programming difference between the two modes is that the area of display memory mapped to the screen is longer in 360x480 256-color mode, which is only common sense given that there are more pixels in that mode. The exact amount of memory required in 360x480 256-color mode is 360 times 480 = 172,800 bytes. That’s more than half of the VGA’s 256 Kb memory complement, so page-flipping is out; however, there’s no reason you couldn’t use that extra memory to create a virtual screen larger than 360x480, around which you could then scroll, if you wish.</p>
<p>That’s really all there is to drawing in 360x480 256-color mode. From a programming perspective, this mode is no more complicated than 320x400 256-color mode once the mode set is completed, and should be capable of good performance given some clever coding. It’s not particular straightforward to implement bitblt, block move, or fast line-drawing code for any of the extended 256-color modes, but it can be done—and it’s worth the trouble. Even the small taste we’ve gotten of the capabilities of these modes shows that they put the traditional CGA, EGA, and generally even VGA modes to shame.</p>
<figure>
<img src="images/32-01.jpg" alt="Figure 32.1  Pixel organization in 360x480 256-color mode." /><figcaption><strong>Figure 32.1</strong>  <em>Pixel organization in 360x480 256-color mode.</em></figcaption>
</figure>
<p>There’s more and better to come, though; in later chapters, we’ll return to high-resolution 256-color programming in a big way, by exploring the tremendous potential of these modes for real time 2-D and 3-D animation.</p>
</section>
</section>
</section>
<section id="chapter-33-yogi-bear-and-eurythmics-confront-vga-colors" class="level2">
<h2><a href="#chapter-33-yogi-bear-and-eurythmics-confront-vga-colors">Chapter 33 – Yogi Bear and Eurythmics Confront VGA Colors</a></h2>
<section id="the-basics-of-vga-color-generation" class="level3">
<h3><a href="#the-basics-of-vga-color-generation">The Basics of VGA Color Generation</a></h3>
<p>Kevin Mangis wants to know about the VGA’s 4-bit to 8-bit to 18-bit color translation. Mansur Loloyan would like to find out how to generate a look-up table containing 256 colors and how to change the default color palette. And surely they are only the tip of the iceberg; hordes of screaming programmers from every corner of the planet are no doubt tearing the place up looking for a discussion of VGA color, and venting their frustration at my mailbox. <em>Let’s have it</em>, they’ve said, clearly and in considerable numbers. As Eurythmics might say, who is this humble writer to disagree?</p>
<p>On the other hand, I hope you all know what you’re getting into. To paraphrase Yogi, the VGA is smarter (and more confusing) than the average board. There’s the basic 8-bit to 18-bit translation, there’s the EGA-compatible 4-bit to 6-bit translation, there’s the 2- or 4-bit color paging register that’s used to pad 6- or 4-bit pixel values out to 8 bits, and then there’s 256-color mode. Fear not, it will all make sense in the end, but it may take us a couple of additional chapters to get there—so let’s get started.</p>
<p>Before we begin, though, I must refer you to Michael Covington’s excellent article, “Color Vision and the VGA,” in the June/July 1990 issue of <em>PC TECHNIQUES</em>. Michael, one of the most brilliant people it has ever been my pleasure to meet, is an expert in many areas I know nothing about, including linguistics and artificial intelligence. Add to that list the topic of color perception, for his article superbly describes the mechanisms by which we perceive color and ties that information to the VGA’s capabilities. After reading Michael’s article, you’ll understand what colors the VGA is capable of generating, and why.</p>
<p>Our topic in this chapter complements Michael’s article nicely. Where he focused on color perception, we’ll focus on color generation; that is, the ways in which the VGA can be programmed to generate those colors that lie within its capabilities. To find out why a VGA can’t generate as pure a red as an LED, read Michael’s article. If you want to find out how to flip between 16 different sets of 16 colors, though, don’t touch that dial!</p>
<p>I would be remiss if I didn’t point you in the direction of two more articles, these in the July 1990 issue of <em>Dr. Dobb’s Journal</em>. “Super VGA Programming,” by Chris Howard, provides a good deal of useful information about SuperVGA chipsets, modes, and programming. “Circles and the Digital Differential Analyzer,” by Tim Paterson, is a good article about fast circle drawing, a topic we’ll tackle soon. All in all, the dog days of 1990 were good times for graphics.</p>
</section>
<section id="vga-color-basics" class="level3">
<h3><a href="#vga-color-basics">VGA Color Basics</a></h3>
<p>Briefly put, the VGA color translation circuitry takes in one 4- or 8-bit pixel value at a time and translates it into three 6-bit values, one each of red, green, and blue, that are converted to corresponding analog levels and sent to the monitor. Seems simple enough, doesn’t it? Unfortunately, nothing is ever that simple on the VGA, and color translation is no exception.</p>
<section id="the-palette-ram" class="level4">
<h4><a href="#the-palette-ram">The Palette RAM</a></h4>
<p>The color path in the VGA involves two stages, as shown in Figure 33.1. The first stage fetches a 4-bit pixel from display memory and feeds it into the EGA-compatible palette RAM (so called because it is functionally equivalent to the palette RAM color translation circuitry of the EGA), which translates it into a 6-bit value and sends it on to the DAC. The translation involves nothing more complex than the 4-bit value of a pixel being used as the address of one of the 16 palette RAM registers; a pixel value of 0 selects the contents of palette RAM register 0, a pixel value of 1 selects register 1, and so on. Each palette RAM register stores 6 bits, so each time a palette RAM register is selected by an incoming 4-bit pixel value, 6 bits of information are sent out by the palette RAM. (The operation of the palette RAM was described back in Chapter 29.)</p>
<p>The process is much the same in text mode, except that in text mode each 4-bit pixel value is generated based on the character’s font pattern and attribute. In 256-color mode, which we’ll get to eventually, the palette RAM is not a factor from the programmer’s perspective and should be left alone.</p>
</section>
<section id="the-dac" class="level4">
<h4><a href="#the-dac">The DAC</a></h4>
<p>Once the EGA-compatible palette RAM has fulfilled its karma and performed 4-bit to 6-bit translation on a pixel, the resulting value is sent to the DAC (Digital/Analog Converter). The DAC performs an 8-bit to 18-bit conversion in much the same manner as the palette RAM, converts the 18-bit result to analog red, green, and blue signals (6 bits for each signal), and sends the three analog signals to the monitor. The DAC is a separate chip, external to the VGA chip, but it’s an integral part of the VGA standard and is present on every VGA.</p>
<figure>
<img src="images/33-01.jpg" alt="Figure 33.1  The VGA color generation path." /><figcaption><strong>Figure 33.1</strong>  <em>The VGA color generation path.</em></figcaption>
</figure>
<p>(I’d like to take a moment to point out that you can’t speak of “color” at any point in the color translation process until the output stage of the DAC. The 4-bit pixel values in memory, 6-bit values in the palette RAM, and 8-bit values sent to the DAC are all attributes, not colors, because they’re subject to translation by a later stage. For example, a pixel with a 4-bit value of 0 isn’t black, it’s attribute 0. It will be translated to 3FH if palette RAM register 0 is set to 3FH, but that’s not the color white, just another attribute. The value 3FH coming into the DAC isn’t white either, and if the value stored in DAC register 63 is red=7, green=0, and blue=0, the actual <em>color</em> displayed for that pixel that was 0 in display memory will be dim red. It isn’t color until the DAC says it’s color.)</p>
<p>The DAC contains 256 18-bit storage registers, used to translate one of 256 possible 8-bit values into one of 256K (262,144, to be precise) 18-bit values. The 18-bit values are actually composed of three 6-bit values, one each for red, green, and blue; for each color component, the higher the number, the brighter the color, with 0 turning that color off in the pixel and 63 (3FH) making that color maximum brightness. Got all that?</p>
</section>
<section id="color-paging-with-the-color-select-register" class="level4">
<h4><a href="#color-paging-with-the-color-select-register">Color Paging with the Color Select Register</a></h4>
<p>“Wait a minute,” you say bemusedly. “Aren’t you missing some bits between the palette RAM and the DAC?” Indeed I am. The palette RAM puts out 6 bits at a time, and the DAC takes in 8 bits at a time. The two missing bits—bits 6 and 7 going into the DAC—are supplied by bits 2 and 3 of the Color Select register (Attribute Controller register 14H). This has intriguing implications. In 16-color modes, pixel data can select only one of 16 attributes, which the EGA palette RAM translates into one of 64 attributes. Normally, those 64 attributes look up colors from registers 0 through 63 in the DAC, because bits 2 and 3 of the Color Select register are both zero. By changing the Color Select register, however, one of three other 64 color sets can be selected instantly. I’ll refer to the process of flipping through color sets in this manner as <em>color paging</em>.</p>
<p>That’s interesting, but frankly it seems somewhat half-baked; why bother expanding 16 attributes to 64 attributes before looking up the colors in the DAC? What we’d <em>really</em> like is to map the 16 attributes straight through the palette RAM without changing them and supply the upper <em>4</em> bits going to the DAC from a register, giving us 16 color pages. As it happens, all we have to do to make that happen is set bit 7 of the Attribute Controller Mode register (register 10H) to 1. Once that’s done, bits 0 through 3 of the Color Select register go straight to bits 4 through 7 of the DAC, and only bits 3 through 0 coming out of the palette RAM are used; bits 4 and 5 from the palette RAM are ignored. In this mode, the palette RAM effectively contains 4-bit, rather than 6-bit, registers, but that’s no problem because the palette RAM will be programmed to pass pixel values through unchanged by having register 0 set to 0, register 1 set to 1, and so on, a configuration in which the upper two bits of all the palette RAM registers are the same (zero) and therefore irrelevant. As a matter of fact, you’ll generally want to set the palette RAM to this pass-through state when working with VGA color, whether you’re using color paging or not.</p>
<p>Why is it a good idea to set the palette RAM to a pass-through state? It’s a good idea because the palette RAM is programmed by the BIOS to EGA-compatible settings and the first 64 DAC registers are programmed to emulate the 64 colors that an EGA can display during mode sets for 16-color modes. This is done for compatibility with EGA programs, and it’s useless if you’re going to tinker with the VGA’s colors. As a VGA programmer, you want to take a 4-bit pixel value and turn it into an 18-bit RGB value; you can do that without any help from the palette RAM, and setting the palette RAM to pass-through values effectively takes it out of the circuit and simplifies life something wonderful. The palette RAM exists solely for EGA compatibility, and serves no useful purpose that I know of for VGA-only color programming.</p>
</section>
<section id="color-mode" class="level4">
<h4><a href="#color-mode">256-Color Mode</a></h4>
<p>So far I’ve spoken only of 16-color modes; what of 256-color modes?</p>
<p>The rule in 256-color modes is: <em>Don’t tinker with the VGA palette</em>. Period. You can select any colors you want by reprogramming the DAC, and there’s no guarantee as to what will happen if you mess around with the palette RAM. There’s no benefit that I know of to changing the palette RAM in 256-color mode, and the effect may vary from VGA to VGA. So don’t do it unless you know something I don’t.</p>
<p>On the other hand, feel free to alter the DAC settings to your heart’s content in 256-color mode, all the more so because this is the only mode in which all 256 DAC settings can be displayed simultaneously. By the way, the Color Select register and bit 7 of the Attribute Controller Mode register are ignored in 256-color mode; all 8 bits sent from the VGA chip to the DAC come from display memory. Therefore, there is no color paging in 256-color mode. Of course, that makes sense given that all 256 DAC registers are simultaneously in use in 256-color mode.</p>
</section>
<section id="setting-the-palette-ram" class="level4">
<h4><a href="#setting-the-palette-ram">Setting the Palette RAM</a></h4>
<p>The palette RAM can be programmed either directly or through BIOS interrupt 10H, function 10H. I strongly recommend using the BIOS interrupt; a clone BIOS may mask incompatibilities with genuine IBM silicon. Such incompatibilities could include anything from flicker to trashing the palette RAM; or they may not exist at all, but why find out the hard way? My policy is to use the BIOS unless there’s a clear reason not to do so, and there’s no such reason that I know of in this case.</p>
<p>When programming specifically for the VGA, the palette RAM needs to be loaded only once, to store the pass-through values 0 through 15 in palette RAM registers 0 through 15. Setting the entire palette RAM is accomplished easily enough with subfunction 2 (AL=2) of function 10H (AH=10H) of interrupt 10H. A single call to this subfunction sets all 16 palette RAM registers (and the Overscan register) from a block of 17 bytes pointed to by ES:DX, with ES:DX pointing to the value for register 0, ES:DX+1 pointing to the value for register 1, and so on up to ES:DX+16, which points to the overscan value. The palette RAM registers store 6 bits each, so only the lower 6 bits of each of the first 16 bytes in the 17-byte block are significant. (The Overscan register, which specifies what’s displayed between the area of the screen that’s controlled by the values in display memory and the blanked region at the edges of the screen, is an 8-bit register, however.)</p>
<p>Alternatively, any one palette RAM register can be set via subfunction 0 (AL=0) of function 10H (AH=10H) of interrupt 10H. For this subfunction, BL contains the number of the palette RAM register to set and the lower 6 bits of BH contain the value to which to set that register.</p>
<p>Having said that, let’s leave the palette RAM behind (presumably in a pass-through state) and move on to the DAC, which is the right place to do color translation on the VGA.</p>
</section>
<section id="setting-the-dac" class="level4">
<h4><a href="#setting-the-dac">Setting the DAC</a></h4>
<p>Like the palette RAM, the DAC registers can be set either directly or through the BIOS. Again, the BIOS should be used whenever possible, but there are a few complications here. My experience is that varying degrees of flicker and screen bounce occur on many VGAs when a large block of DAC registers is set through the BIOS. That’s not a problem when the DAC is loaded just once and then left that way, as is the case in Listing 33.1, which we’ll get to shortly, but it can be a serious problem when the color set is changed rapidly (“cycled”) to produce on-screen effects such as rippling colors. My (limited) experience is that it’s necessary to program the DAC directly in order to cycle colors cleanly, although input from readers who have worked extensively with VGA color is welcome.</p>
<p>At any rate, the code in this chapter will use the BIOS to set the DAC, so I’ll describe the BIOS DAC-setting functions next. Later, I’ll briefly describe how to set both the palette RAM and DAC registers directly, and I’ll return to the topic in detail in an upcoming chapter when we discuss color cycling.</p>
<p>An individual DAC register can be set by interrupt 10H, function 10H (AH=10), subfunction 10H (AL=10H), with BX indicating the register to be set and the color to which that register is to be set stored in DH (6-bit red component), CH (6-bit green component), and CL (6-bit blue component).</p>
<p>A block of sequential DAC registers ranging in size from one register up to all 256 can be set via subfunction 12H (AL=12H) of interrupt 10H, function 10H (AH=10H). In this case, BX contains the number of the first register to set, CX contains the number of registers to set, and ES:DX contains the address of a table of color entries to which DAC registers BX through BX+CX-1 are to be set. The color entry for each DAC register consists of three bytes; the first byte is a 6-bit red component, the second byte is a 6-bit green component, and the third byte is a 6-bit blue component, as illustrated by Listing 33.1.</p>
</section>
</section>
<section id="if-you-cant-call-the-bios-who-ya-gonna-call" class="level3">
<h3><a href="#if-you-cant-call-the-bios-who-ya-gonna-call">If You Can’t Call the BIOS, Who Ya Gonna Call?</a></h3>
<p>Although the palette RAM and DAC registers should be set through the BIOS whenever possible, there are times when the BIOS is not the best choice or even a choice at all; for example, a protected-mode program may not have access to the BIOS. Also, as mentioned earlier, it may be necessary to program the DAC directly when performing color cycling. Therefore, I’ll briefly describe how to set the palette RAM and DAC registers directly; in Chapter A on the companion CD-ROM I’ll discuss programming the DAC directly in more detail.</p>
<p>The palette RAM registers are Attribute Controller registers 0 through 15. They are set by first reading the Input Status 1 register (at 3DAH in color mode or 3BAH in monochrome mode) to reset the Attribute Controller toggle to index mode, then loading the Attribute Controller Index register (at 3C0H) with the number (0 through 15) of the register to be loaded. Do <em>not</em> set bit 5 of the Index register to 1, as you normally would, but rather set bit 5 to 0. Setting bit 5 to 0 allows values to be written to the palette RAM registers, but it also causes the screen to blank, so you should wait for the start of vertical retrace before loading palette RAM registers if you don’t want the screen to flicker. (Do you see why it’s easier to go through the BIOS?) Then, write the desired register value to 3C0H, which has now toggled to become the Attribute Controller Data register. Write any desired number of additional register number/register data pairs to 3C0H, then write 20H to 3C0H to unblank the screen.</p>
<p>The process of loading the palette RAM registers depends heavily on the proper sequence being followed; if the Attribute Controller Index register or index/data toggle data gets changed in the middle of the loading process, you’ll probably end up with a hideous display, or no display at all. Consequently, for maximum safety you may want to disable interrupts while you load the palette RAM, to prevent any sort of interference from a TSR or the like that alters the state of the Attribute Controller in the middle of the loading sequence.</p>
<p>The DAC registers are set by writing the number of the first register to set to the DAC Write Index register at 3C8H, then writing three bytes—the 6-bit red component, the 6-bit green component, and the 6-bit blue component, in that order—to the DAC Data register at 3C9H. The DAC Write Index register then autoincrements, so if you write another three-byte RGB value to the DAC Data register, it’ll go to the next DAC register, and so on indefinitely; you can set all 256 registers by sending 256*3 = 768 bytes to the DAC Data Register.</p>
<p>Loading the DAC is just as sequence-dependent and potentially susceptible to interference as is loading the palette, so my personal inclination is to go through the whole process of disabling interrupts, loading the DAC Write Index, and writing a three-byte RGB value separately for each DAC register; although that doesn’t take advantage of the autoincrementing feature, it seems to me to be least susceptible to outside influences. (It would be even better to disable interrupts for the entire duration of DAC register loading, but that’s much too long a time to leave interrupts off.) However, I have no hard evidence to offer in support of my conservative approach to setting the DAC, just an uneasy feeling, so I’d be most interested in hearing from any readers.</p>
<p>A final point is that the process of loading both the palette RAM and DAC registers involves performing multiple <code>OUT</code>s to the same register. Many people whose opinions I respect recommend delaying between I/O accesses to the same port by performing a <code>JMP \$+2</code> (jumping flushes the prefetch queue and forces a memory access—or at least a cache access—to fetch the next instruction byte). In fact, some people recommend two <code>JMP \$+2</code> instructions between I/O accesses to the same port, and <em>three</em> jumps between I/O accesses to the same port that go in opposite directions (<code>OUT</code> followed by <code>IN</code> or <code>IN</code> followed by <code>OUT</code>). This is clearly necessary when accessing some motherboard chips, but I don’t know how applicable it is when accessing VGAs, so make of it what you will. Input from knowledgeable readers is eagerly solicited.</p>
<p>In the meantime, if you can use the BIOS to set the DAC, do so; then you won’t have to worry about the real and potential complications of setting the DAC directly.</p>
</section>
<section id="an-example-of-setting-the-dac" class="level3">
<h3><a href="#an-example-of-setting-the-dac">An Example of Setting the DAC</a></h3>
<p>This chapter has gotten about as big as a chapter really ought to be; the VGA color saga will continue in the next few. Quickly, then, Listing 33.1 is a simple example of setting the DAC that gives you a taste of the spectacular effects that color translation makes possible. There’s nothing particularly complex about Listing 33.1; it just selects 256-color mode, fills the screen with one-pixel-wide concentric diamonds drawn with sequential attributes, and sets the DAC to produce a smooth gradient of each of the three primary colors and of a mix of red and blue. Run the program; I suspect you’ll be surprised at the stunning display this short program produces. Clever color manipulation is perhaps the easiest way to produce truly eye-catching effects on the PC.</p>
<p><strong>LISTING 33.1 L33-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to demonstrate use of the DAC registers by selecting a</span>
<span class="co">; smoothly contiguous set of 256 colors, then filling the screen</span>
<span class="co">; with concentric diamonds in all 256 colors so that they blend</span>
<span class="co">; into one another to form a continuum of color.</span>
<span class="co">;</span>
       .model     small
       .stack<span class="bn">     200h</span>
       .data

<span class="co">; Table used to set all 256 DAC entries.</span>
<span class="co">;</span>
<span class="co">; Table format:</span>
<span class="co">;      Byte 0: DAC register 0 red value</span>
<span class="co">;      Byte 1: DAC register 0 green value</span>
<span class="co">;      Byte 2: DAC register 0 blue value</span>
<span class="co">;      Byte 3: DAC register 1 red value</span>
<span class="co">;      Byte 4: DAC register 1 green value</span>
<span class="co">;      Byte 5: DAC register 1 blue value</span>
<span class="co">;      :</span>
<span class="co">;      Byte 765: DAC register 255 red value</span>
<span class="co">;      Byte 766: DAC register 255 green value</span>
<span class="co">;      Byte 767: DAC register 255 blue value</span>

ColorTable label <span class="dt">byte</span>

<span class="co">; The first 64 entries are increasingly dim pure green.</span>
X=<span class="dv">0</span>
       REPT <span class="dv">64</span>
       <span class="dt">db</span>    <span class="dv">0</span>,<span class="dv">63</span>-X,<span class="dv">0</span>
X=X<span class="dv">+1</span>
       ENDM

<span class="co">; The next 64 entries are increasingly strong pure blue.</span>
X=<span class="dv">0</span>
       REPT <span class="dv">64</span>
       <span class="dt">db</span>   <span class="dv">0</span>,<span class="dv">0</span>,X
X=X<span class="dv">+1</span>
       ENDM

<span class="co">; The next 64 entries fade through violet to red.</span>
X=<span class="dv">0</span>
       REPT <span class="dv">64</span>
       <span class="dt">db</span>   X,<span class="dv">0</span>,<span class="dv">63</span>-X
X=X<span class="dv">+1</span>
       ENDM

<span class="co">; The last 64 entries are increasingly dim pure red.</span>
X=<span class="dv">0</span>
       REPT <span class="dv">64</span>
       <span class="dt">db</span>   <span class="dv">63</span>-X,<span class="dv">0</span>,<span class="dv">0</span>
X=X<span class="dv">+1</span>
ENDM

       .code
<span class="fu">Start:</span>
       <span class="kw">mov</span>  <span class="kw">ax</span><span class="bn">,0013h               </span><span class="co">;AH=0 selects set mode function,</span>
                                   <span class="co">; AL=13h selects 320x200 256-color</span>
       <span class="kw">int</span><span class="bn">  10h                    </span><span class="co">; mode</span>

                                   <span class="co">;load the DAC registers with the</span>
                                   <span class="co">; color settings</span>
       <span class="kw">mov</span>  <span class="kw">ax</span>,@data               <span class="co">;point ES to the default</span>
       <span class="kw">mov</span>  <span class="kw">es</span>,<span class="kw">ax</span>                  <span class="co">; data segment</span>
       <span class="kw">mov</span>  <span class="kw">dx</span>,offset ColorTable
                                   <span class="co">;point ES:DX to the start of the</span>
                                   <span class="co">; block of RGB three-byte values</span>
                                   <span class="co">; to load into the DAC registers</span>
       <span class="kw">mov</span>  <span class="kw">ax</span><span class="bn">,1012h               </span><span class="co">;AH=10h selects set color function,</span>
                                   <span class="co">; AL=12h selects set block of DAC</span>
                                   <span class="co">; registers subfunction</span>
       <span class="kw">sub</span>  <span class="kw">bx</span>,<span class="kw">bx</span>                  <span class="co">;load the block of registers</span>
                                   <span class="co">; starting at DAC register #0</span>
       <span class="kw">mov</span>  <span class="kw">cx</span><span class="bn">,100h                </span><span class="co">;set all 256 registers</span>
       <span class="kw">int</span><span class="bn">  10h                    </span><span class="co">;load the DAC registers</span>

                                   <span class="co">;now fill the screen with</span>
                                   <span class="co">; concentric diamonds in all 256</span>
                                   <span class="co">; color attributes</span>
       <span class="kw">mov</span>  <span class="kw">ax</span><span class="bn">,0a000h              </span><span class="co">;point DS to the display memory</span>
       <span class="kw">mov</span>  <span class="kw">ds</span>,<span class="kw">ax</span>                  <span class="co">; segment</span>
                                   <span class="co">;</span>
                                   <span class="co">;draw diagonal lines in the upper-</span>
                                   <span class="co">; left quarter of the screen</span>
       <span class="kw">mov</span>  <span class="kw">al</span>,<span class="dv">2</span>                   <span class="co">;start with color attribute #2</span>
       <span class="kw">mov</span>  <span class="kw">ah</span>,-<span class="dv">1</span>                  <span class="co">;cycle down through the colors</span>
       <span class="kw">mov</span>  <span class="kw">bx</span>,<span class="dv">320</span>                 <span class="co">;draw top to bottom (distance from</span>
                                   <span class="co">; one line to the next)</span>
       <span class="kw">mov</span>  <span class="kw">dx</span>,<span class="dv">160</span>                 <span class="co">;width of rectangle</span>
       <span class="kw">mov</span>  <span class="kw">si</span>,<span class="dv">100</span>                 <span class="co">;height of rectangle</span>
       <span class="kw">sub</span>  <span class="kw">di</span>,<span class="kw">di</span>                  <span class="co">;start at (0,0)</span>
       <span class="kw">mov</span>  <span class="kw">bp</span>,<span class="dv">1</span>                   <span class="co">;draw left to right (distance from</span>
                                   <span class="co">; one column to the next)</span>
       <span class="kw">call</span> FillBlock              <span class="co">;draw it</span>
                                   <span class="co">;</span>
                                   <span class="co">;draw diagonal lines in the upper-</span>
                                   <span class="co">; right quarter of the screen</span>
       <span class="kw">mov</span>  <span class="kw">al</span>,<span class="dv">2</span>                   <span class="co">;start with color attribute #2</span>
       <span class="kw">mov</span>  <span class="kw">ah</span>,-<span class="dv">1</span>                  <span class="co">;cycle down through the colors</span>
       <span class="kw">mov</span>  <span class="kw">bx</span>,<span class="dv">320</span>                 <span class="co">;draw top to bottom (distance from</span>
                                   <span class="co">; one line to the next)</span>
       <span class="kw">mov</span>  <span class="kw">dx</span>,<span class="dv">160</span>                 <span class="co">;width of rectangle</span>
       <span class="kw">mov</span>  <span class="kw">si</span>,<span class="dv">100</span>                 <span class="co">;height of rectangle</span>
       <span class="kw">mov</span>  <span class="kw">di</span>,<span class="dv">319</span>                 <span class="co">;start at (319,0)</span>
       <span class="kw">mov</span>  <span class="kw">bp</span>,-<span class="dv">1</span>                  <span class="co">;draw right to left (distance from</span>
                                   <span class="co">; one column to the next)</span>
callFillBlock<span class="co">;draw it</span>

                                   <span class="co">;draw diagonal lines in the lower-</span>
                                   <span class="co">; left quarter of the screen</span>
       <span class="kw">mov</span>  <span class="kw">al</span>,<span class="dv">2</span>                   <span class="co">;start with color attribute #2</span>
       <span class="kw">mov</span>  <span class="kw">ah</span>,-<span class="dv">1</span>                  <span class="co">;cycle down through the colors</span>
       <span class="kw">mov</span>  <span class="kw">bx</span>,-<span class="dv">320</span>                <span class="co">;draw bottom to top (distance from</span>
                                   <span class="co">; one line to the next)</span>
       <span class="kw">mov</span>  <span class="kw">dx</span>,<span class="dv">160</span>                 <span class="co">;width of rectangle</span>
       <span class="kw">mov</span>  <span class="kw">si</span>,<span class="dv">100</span>                 <span class="co">;height of rectangle</span>
       <span class="kw">mov</span>  <span class="kw">di</span>,<span class="dv">199</span>*<span class="dv">320</span>             <span class="co">;start at (0,199)</span>
       <span class="kw">mov</span>  <span class="kw">bp</span>,<span class="dv">1</span>                   <span class="co">;draw left to right (distance from</span>
                                   <span class="co">; one column to the next)</span>
callFillBlock<span class="co">;draw it</span>
                                   <span class="co">;</span>
                                   <span class="co">;draw diagonal lines in the lower-</span>
                                   <span class="co">; right quarter of the screen</span>
       <span class="kw">mov</span>  <span class="kw">al</span>,<span class="dv">2</span>                   <span class="co">;start with color attribute #2</span>
       <span class="kw">mov</span>  <span class="kw">ah</span>,-<span class="dv">1</span>                  <span class="co">;cycle down through the colors</span>
       <span class="kw">mov</span>  <span class="kw">bx</span>,-<span class="dv">320</span>                <span class="co">;draw bottom to top (distance from</span>
                                   <span class="co">; one line to the next)</span>
       <span class="kw">mov</span>  <span class="kw">dx</span>,<span class="dv">160</span>                 <span class="co">;width of rectangle</span>
       <span class="kw">mov</span>  <span class="kw">si</span>,<span class="dv">100</span>                 <span class="co">;height of rectangle</span>
       <span class="kw">mov</span>  <span class="kw">di</span>,<span class="dv">199</span>*<span class="dv">320+319</span>     <span class="co">;start at (319,199)</span>
       <span class="kw">mov</span>  <span class="kw">bp</span>,-<span class="dv">1</span>                  <span class="co">;draw right to left (distance from</span>
                                   <span class="co">; one column to the next)</span>
callFillBlock<span class="co">;draw it</span>

       <span class="kw">mov</span>  <span class="kw">ah</span>,<span class="dv">1</span>                   <span class="co">;wait for a key</span>
int21h<span class="co">;</span>

       <span class="kw">mov</span>  <span class="kw">ax</span><span class="bn">,0003h               </span><span class="co">;return to text mode</span>
int10h<span class="co">;</span>

       <span class="kw">mov</span>  <span class="kw">ah</span><span class="bn">,4ch                 </span><span class="co">;done--return to DOS</span>
int21h

<span class="co">; Fills the specified rectangular area of the screen with diagonal lines.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;      AL = initial attribute with which to draw</span>
<span class="co">;      AH = amount by which to advance the attribute from</span>
<span class="co">;            one pixel to the next</span>
<span class="co">;      BX = distance to advance from one pixel to the next</span>
<span class="co">;      DX = width of rectangle to fill</span>
<span class="co">;      SI = height of rectangle to fill</span>
<span class="co">;      DS:DN = screen address of first pixel to draw</span>
<span class="co">;      BP = offset from the start of one column to the start of</span>
<span class="co">;            the next</span>

<span class="fu">FillBlock:</span>
<span class="fu">FillHorzLoop:</span>
       <span class="kw">push</span> <span class="kw">di</span>                     <span class="co">;preserve pointer to top of column</span>
       <span class="kw">push</span> <span class="kw">ax</span>                     <span class="co">;preserve initial attribute</span>
       <span class="kw">mov</span>  <span class="kw">cx</span>,<span class="kw">si</span>                  <span class="co">;column height</span>
<span class="fu">FillVertLoop:</span>
       <span class="kw">mov</span>  [<span class="kw">di</span>],<span class="kw">al</span>                <span class="co">;set the pixel</span>
       <span class="kw">add</span>  <span class="kw">di</span>,<span class="kw">bx</span>                  <span class="co">;point to the next row in the column</span>
       <span class="kw">add</span>  <span class="kw">al</span>,<span class="kw">ah</span>                  <span class="co">;advance the attribute</span>
       <span class="kw">loop</span> FillVertLoop           <span class="co">;</span>
       <span class="kw">pop</span>  <span class="kw">ax</span>                     <span class="co">;restore initial attribute</span>
       <span class="kw">add</span>  <span class="kw">al</span>,<span class="kw">ah</span>                  <span class="co">;advance to the next attribute to</span>
                                   <span class="co">; start the next column</span>
       <span class="kw">pop</span>  <span class="kw">di</span>                     <span class="co">;retrieve pointer to top of column</span>
       <span class="kw">add</span>  <span class="kw">di</span>,<span class="kw">bp</span>                  <span class="co">;point to next column</span>
       <span class="kw">dec</span>  <span class="kw">dx</span>                     <span class="co">;have we done all columns?</span>
       <span class="kw">jnz</span>  FillHorzLoop           <span class="co">;no, do the next column</span>
       <span class="kw">ret</span><span class="co">;</span>

        endStart</code></pre>
<p>Note the jagged lines at the corners of the screen when you run Listing 33.1. This shows how coarse the 320x200 resolution of mode 13H actually is. Now look at how smoothly the colors blend together in the rest of the screen. This is an excellent example of how careful color selection can boost perceived resolution, as for example when drawing antialiased lines, as discussed in Chapter 42.</p>
<p>Finally, note that the border of the screen turns green when Listing 33.1 is run. Listing 33.1 reprograms DAC register 0 to green, and the border attribute (in the Overscan register) happens to be 0, so the border comes out green even though we haven’t touched the Overscan register. Normally, attribute 0 is black, causing the border to vanish, but the border is an 8-bit attribute that has to pass through the DAC just like any other pixel value, and it’s just as subject to DAC color translation as the pixels controlled by display memory. However, the border color is not affected by the palette RAM or by the Color Select register.</p>
<p>In this chapter, we traced the surprisingly complex path by which the VGA turns a pixel value into RGB analog signals headed for the monitor. In the next chapter and Chapter A on the companion CD-ROM, we’ll look at some more code that plays with VGA color. We’ll explore in more detail the process of reading and writing the palette RAM and DAC registers, and we’ll observe color paging and cycling in action.</p>
</section>
</section>
<section id="chapter-34-changing-colors-without-writing-pixels" class="level2">
<h2><a href="#chapter-34-changing-colors-without-writing-pixels">Chapter 34 – Changing Colors without Writing Pixels</a></h2>
<section id="special-effects-through-realtime-manipulation-of-dac-colors" class="level3">
<h3><a href="#special-effects-through-realtime-manipulation-of-dac-colors">Special Effects through Realtime Manipulation of DAC Colors</a></h3>
<p>Sometimes, strange as it may seem, the harder you try, the less you accomplish. Brute force is fine when it suffices, but it does not always suffice, and when it does not, finesse and alternative approaches are called for. Such is the case with rapidly cycling through colors by repeatedly loading the VGA’s Digital to Analog Converter (DAC). No matter how much you optimize your code, you just can’t reliably load the whole DAC cleanly in a single frame, so you had best find other ways to use the DAC to cycle colors. What’s more, BIOS support for DAC loading is so inconsistent that it’s unusable for color cycling; direct loading through the I/O ports is the only way to go. We’ll see why next, as we explore color cycling, and then finish up this chapter and this section by cleaning up some odds and ends about VGA color.</p>
<p>There’s a lot to be said about loading the DAC, so let’s dive right in and see where the complications lie.</p>
</section>
<section id="color-cycling" class="level3">
<h3><a href="#color-cycling">Color Cycling</a></h3>
<p>As we’ve learned in past chapters, the VGA’s DAC contains 256 storage locations, each holding one 18-bit value representing an RGB color triplet organized as 6 bits per primary color. Each and every pixel generated by the VGA is fed into the DAC as an 8-bit value (refer to Chapter 33 and to Chapter A on the companion CD-ROM to see how pixels become 8-bit values in non-256 color modes) and each 8-bit value is used to look up one of the 256 values stored in the DAC. The looked-up value is then converted to analog red, green, and blue signals and sent to the monitor to form one pixel.</p>
<p>That’s straightforward enough, and we’ve produced some pretty impressive color effects by loading the DAC once and then playing with the 8-bit path into the DAC. Now, however, we want to generate color effects by dynamically changing the values stored in the DAC in real time, a technique that I’ll call <em>color cycling</em>. The potential of color cycling should be obvious: Smooth motion can easily be simulated by altering the colors in an appropriate pattern, and all sorts of changing color effects can be produced without altering a single bit of display memory.</p>
<p>For example, a sunset can be made to color and darken by altering the DAC locations containing the colors used to draw the sunset, or a river can be made to appear to flow by cycling through the colors used to draw the river. Another use for color cycling is in providing more realistic displays for applications like realtime 3-D games, where the VGA’s 256 simultaneous colors can be made to seem like many more by changing the DAC settings from frame to frame to match the changing color demands of the rendered scene. Which leaves only one question: How do we load the DAC smoothly in realtime?</p>
<p>Actually, so far as I know, you can’t. At least you can’t load the <em>entire</em> DAC—all 256 locations—frame after frame without producing distressing on-screen effects on at least some computers. In non-256 color modes, it is indeed possible to load the DAC quickly enough to cycle all displayed colors (of which there are 16 or fewer), so color cycling could be used successfully to cycle all colors in such modes. On the other hand, color paging (which flips among a number of color sets stored within the DAC in all modes other than 256 color mode, as discussed in Chapter A on the companion CD-ROM) can be used in non-256 color modes to produce many of the same effects as color cycling and is considerably simpler and more reliable then color cycling, so color paging is generally superior to color cycling whenever it’s available. In short, color cycling is really the method of choice for dynamic color effects only in 256-color mode—but, regrettably, color cycling is at its least reliable and capable in that mode, as we’ll see next.</p>
</section>
<section id="the-heart-of-the-problem" class="level3">
<h3><a href="#the-heart-of-the-problem">The Heart of the Problem</a></h3>
<p>Here’s the problem with loading the entire DAC repeatedly: The DAC contains 256 color storage locations, each loaded via either 3 or 4 <code>OUT</code> instructions (more on that next), so at least 768 <code>OUT</code>s are needed to load the entire DAC. That many <code>OUT</code>s take a considerable amount of time, all the more so because <code>OUT</code>s are painfully slow on 486s and Pentiums, and because the DAC is frequently on the ISA bus (although VLB and PCI are increasingly common), where wait states are inserted in fast computers. In an 8 MHz AT, 768 <code>OUT</code>s alone would take 288 microseconds, and the data loading and looping that are also required would take in the ballpark of 1,800 microseconds more, for a minimum of 2 milliseconds total.</p>
<p>As it happens, the DAC should only be loaded during vertical blanking; that is, the time between the end of displaying the bottom border and the start of displaying the top border, when no video information at all is being sent to the screen by the DAC. Otherwise, small dots of snow appear on the screen, and while an occasional dot of this sort wouldn’t be a problem, the constant DAC loading required by color cycling would produce a veritable snowstorm on the screen. By the way, I do mean “border,” not “frame buffer”; the overscan pixels pass through the DAC just like the pixels controlled by the frame buffer, so you can’t even load the DAC while the border color is being displayed without getting snow.</p>
<p>The start of vertical blanking itself is not easy to find, but the leading edge of the vertical sync pulse is easy to detect via bit 3 of the Input Status 1 register at 3DAH; when bit 3 is 1, the vertical sync pulse is active. Conveniently, the vertical sync pulse starts partway through but not too far into vertical blanking, so it serves as a handy way to tell when it’s safe to load the DAC without producing snow on the screen.</p>
<p>So we wait for the start of the vertical sync pulse, then begin to load the DAC. There’s a catch, though. On many computers—Pentiums, 486s, and 386s sometimes, 286s most of the time, and 8088s all the time—there just isn’t enough time between the start of the vertical sync pulse and the end of vertical blanking to load all 256 DAC locations. That’s the crux of the problem with the DAC, and shortly we’ll get to a tool that will let you explore for yourself the extent of the problem on computers in which you’re interested. First, though, we must address <em>another</em> DAC loading problem: the BIOS.</p>
<section id="loading-the-dac-via-the-bios" class="level4">
<h4><a href="#loading-the-dac-via-the-bios">Loading the DAC via the BIOS</a></h4>
<p>The DAC can be loaded either directly or through subfunctions 10H (for a single DAC register) or 12H (for a block of DAC registers) of the BIOS video service interrupt 10H, function 10H, described in Chapter 33. For cycling the contents of the entire DAC, the block-load function (invoked by executing <code>INT</code> 10H with AH = 10H and AL = 12H to load a block of CX DAC locations, starting at location BX, from the block of RGB triplets—3 bytes per triplet—starting at ES:DX into the DAC) would be the better of the two, due to the considerably greater efficiency of calling the BIOS once rather than 256 times. At any rate, we’d like to use one or the other of the BIOS functions for color cycling, because we know that whenever possible, one should use a BIOS function in preference to accessing hardware directly, in the interests of avoiding compatibility problems. In the case of color cycling, however, it is emphatically <em>not</em> possible to use either of the BIOS functions, for they have problems. Serious problems.</p>
<p>The difficulty is this: IBM’s BIOS specification describes exactly how the parameters passed to the BIOS control the loading of DAC locations, and all clone BIOSes meet that specification scrupulously, which is to say that if you invoke <code>INT</code> 10H, function 10H, subfunction 12H with a given set of parameters, you can be sure that you will end up with the same values loaded into the same DAC locations on all VGAs from all vendors. IBM’s spec does <em>not</em>, however, describe whether vertical retrace should be waited for before loading the DAC, nor does it mention whether video should be left enabled while loading the DAC, leaving cloners to choose whatever approach they desire—and, alas, every VGA cloner seems to have selected a different approach.</p>
<p>I tested four clone VGAs from different manufacturers, some in a 20 MHz 386 machine and some in a 10 MHz 286 machine. Two of the four waited for vertical retrace before loading the DAC; two didn’t. Two of the four blanked the display while loading the DAC, resulting in flickering bars across the screen. One showed speckled pixels spattered across the top of the screen while the DAC was being loaded. Also, not one was able to load all 256 DAC locations without showing <em>some</em> sort of garbage on the screen for at least one frame, but that’s not the BIOS’s fault; it’s a problem endemic to the VGA.</p>
<blockquote>
<p><img src="images/i.jpg" /> These findings lead me inexorably to the conclusion that the BIOS should not be used to load the DAC dynamically. That is, if you’re loading the DAC just once in preparation for a graphics session—sort of a DAC mode set—by all means load by way of the BIOS. No one will care that some garbage is displayed for a single frame; heck, I have boards that bounce and flicker and show garbage every time I do a mode set, and the amount of garbage produced by loading the DAC once is far less noticeable. If, however, you intend to load the DAC repeatedly for color cycling, avoid the BIOS DAC load functions like the plague. They will bring you only heartache.</p>
</blockquote>
<p>As but one example of the unsuitability of the BIOS DAC-loading functions for color cycling, imagine that you want to cycle all 256 colors 70 times a second, which is once per frame. In order to accomplish that, you would normally wait for the start of the vertical sync signal (marking the end of the frame), then call the BIOS to load the DAC. On some boards—boards with BIOSes that don’t wait for vertical sync before loading the DAC—that will work pretty well; you will, in fact, load the DAC once a frame. On other boards, however, it will work very poorly indeed; your program will wait for the start of vertical sync, and then the BIOS will wait for the start of the next vertical sync, with the result being that the DAC gets loaded only once every <em>two</em> frames. Sadly, there’s no way, short of actually profiling the performance of BIOS DAC loads, for you to know which sort of BIOS is installed in a particular computer, so unless you can always control the brand of VGA your software will run on, you really can’t afford to color cycle by calling the BIOS.</p>
<p>Which is not to say that loading the DAC directly is a picnic either, as we’ll see next.</p>
</section>
<section id="loading-the-dac-directly" class="level4">
<h4><a href="#loading-the-dac-directly">Loading the DAC Directly</a></h4>
<p>So we must load the DAC directly in order to perform color cycling. The DAC is loaded directly by sending (with an <code>OUT</code> instruction) the number of the DAC location to be loaded to the DAC Write Index register at 3C8H and then performing three <code>OUT</code>s to write an RGB triplet to the DAC Data register at 3C9H. This approach must be repeated 256 times to load the entire DAC, requiring over a thousand <code>OUT</code>s in all.</p>
<p>There is another, somewhat faster approach, but one that has its risks. After an RGB triplet is written to the DAC Data register, the DAC Write Index register automatically increments to point to the next DAC location, and this repeats indefinitely as successive RGB triplets are written to the DAC. By taking advantage of this feature, the entire DAC can be loaded with just 769 <code>OUT</code>s: one <code>OUT</code> to the DAC Write Index register and 768 <code>OUT</code>s to the DAC Data register.</p>
<p>So what’s the drawback? Well, imagine that as you’re loading the DAC, an interrupt-driven TSR (such as a program switcher or multitasker) activates and writes to the DAC; you could end up with quite a mess on the screen, especially when your program resumes and continues writing to the DAC—but in all likelihood to the wrong locations. No problem, you say; just disable interrupts for the duration. Good idea—but it takes much longer to load the DAC than interrupts should be disabled for. If, on the other hand, you set the index for each DAC location separately, you can disable interrupts 256 times, once as each DAC location is loaded, without problems.</p>
<p>As I commented in the last chapter, I don’t have any gruesome tale to relate that mandates taking the slower but safer road and setting the index for each DAC location separately while interrupts are disabled. I’m merely hypothesizing as to what ghastly mishaps <em>could</em>. happen. However, it’s been my experience that anything that can happen on the PC <em>does</em> happen eventually; there are just too dang many PCs out there for it to be otherwise. However, load the DAC any way you like; just don’t blame me if you get a call from someone who’s claims that your program sometimes turns their screen into something resembling month-old yogurt. It’s not really your fault, of course—but try explaining that to <em>them!</em></p>
</section>
</section>
<section id="a-test-program-for-color-cycling" class="level3">
<h3><a href="#a-test-program-for-color-cycling">A Test Program for Color Cycling</a></h3>
<p>Anyway, the choice of how to load the DAC is yours. Given that I’m not providing you with any hard-and-fast rules (mainly because there don’t seem to be any), what you need is a tool so that you can experiment with various DAC-loading approaches for yourself, and that’s exactly what you’ll find in Listing 34.1.</p>
<p>Listing 34.1 draws a band of vertical lines, each one pixel wide, across the screen. The attribute of each vertical line is one greater than that of the preceding line, so there’s a smooth gradient of attributes from left to right. Once everything is set up, the program starts cycling the colors stored in however many DAC locations are specified by the <code>CYCLE_SIZE</code> equate; as many as all 256 DAC locations can be cycled. (Actually, <code>CYCLE_SIZE</code>-1 locations are cycled, because location 0 is kept constant in order to keep the background and border colors from changing, but <code>CYCLE_SIZE</code> locations are <em>loaded</em>, and it’s the number of locations we can load without problems that we’re interested in.)</p>
<p><strong>LISTING 34.1 L34-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Fills a band across the screen with vertical bars in all 256</span>
<span class="co">; attributes, then cycles a portion of the palette until a key is</span>
<span class="co">; pressed.</span>
<span class="co">; Assemble with MASM or TASM</span>

USE_BIOS           <span class="dt">equ</span> <span class="dv">1</span>                    <span class="co">;set to 1 to use BIOS functions to access the</span>
                                            <span class="co">; DAC, 0 to read and write the DAC directly</span>
GUARD_AGAINST_INTS <span class="dt">equ</span> <span class="dv">1</span>                    <span class="co">;1 to turn off interrupts and set write index</span>
                                            <span class="co">; before loading each DAC location, 0 to rely</span>
                                            <span class="co">; on the DAC auto-incrementing</span>
WAIT_VSYNC         <span class="dt">equ</span> <span class="dv">1</span>                    <span class="co">;set to 1 to wait for the leading edge of</span>
                                            <span class="co">; vertical sync before accessing the DAC, 0</span>
                                            <span class="co">; not to wait</span>
NOT_8088           <span class="dt">equ</span> <span class="dv">0</span>                    <span class="co">;set to 1 to use REP INSB and REP OUTSB when</span>
                                            <span class="co">; accessing the  DAC directly, 0 to use</span>
                                            <span class="co">; IN/STOSB and LODSB/OUT</span>
CYCLE_SIZE         <span class="dt">equ</span> <span class="dv">256</span>                  <span class="co">;# of DAC locations to cycle, 256 max</span>
SCREEN_SEGMENT     <span class="dt">equ</span><span class="bn"> 0a000h               </span><span class="co">;mode 13h display memory segment</span>
SCREEN_WIDTH_IN_BYTES <span class="dt">equ</span> <span class="dv">320</span>               <span class="co">;# of bytes across the screen in mode 13h</span>
INPUT_STATUS_1     <span class="dt">equ</span><span class="bn"> 03dah                </span><span class="co">;input status 1 register port</span>
DAC_READ_INDEX     <span class="dt">equ</span><span class="bn"> 03c7h                </span><span class="co">;DAC Read Index register</span>
DAC_WRITE_INDEX    <span class="dt">equ</span><span class="bn"> 03c8h                </span><span class="co">;DAC Write Index register</span>
DAC_DATA           <span class="dt">equ</span><span class="bn"> 03c9h                </span><span class="co">;DAC Data register</span>

if NOT_8088
        .<span class="dv">286</span>
endif   <span class="co">;NOT_8088</span>

        .model  small
        .stack<span class="bn">  100h</span>
        .data
<span class="co">;Storage for all 256 DAC locations, organized as one three-byte</span>
<span class="co">; (actually three 6-bit values; upper two bits of each byte aren&#39;t</span>
<span class="co">; significant) RGB triplet per color.</span>
PaletteTempdb   <span class="dv">256</span>*<span class="dv">3</span> dup(?)
        .code
<span class="fu">start:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,@data
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>

<span class="co">;Select VGA&#39;s standard 256-color graphics mode, mode 13h.</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0013h                    </span><span class="co">;AH = 0: set mode function,</span>
        <span class="kw">int</span><span class="bn">     10h                         </span><span class="co">; AL = 13h: mode # to set</span>

<span class="co">;Read all 256 DAC locations into PaletteTemp (3 6-bit values, one</span>
<span class="co">; each for red, green, and blue, per DAC location).</span>

if WAIT_VSYNC
<span class="co">;Wait for the leading edge of the vertical sync pulse; this ensures</span>
<span class="co">; that we read the DAC starting during the vertical non-display</span>
<span class="co">; period.</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,INPUT_STATUS_1
<span class="fu">WaitNotVSync:</span>                               <span class="co">;wait to be out of vertical sync</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,08h</span>
        <span class="kw">jnz</span>     WaitNotVSync
<span class="fu">WaitVSync:</span>                                  <span class="co">;wait until vertical sync begins</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,08h</span>
        <span class="kw">jz</span>      WaitVSync
endif                                       <span class="co">;WAIT_VSYNC</span>

if USE_BIOS
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,1017h                    </span><span class="co">;AH = 10h: set DAC function,</span>
                                            <span class="co">; AL = 17h: read DAC block subfunction</span>
        <span class="kw">sub</span>     <span class="kw">bx</span>,<span class="kw">bx</span>                       <span class="co">;start with DAC location 0</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">256</span>                      <span class="co">;read out all 256 locations</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="kw">seg</span> PaletteTemp
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,offset PaletteTemp       <span class="co">;point ES:DX to array in which</span>
                                            <span class="co">; the DAC values are to be stored</span>
        <span class="kw">int</span><span class="bn">     10h                         </span><span class="co">;read the DAC</span>
else                                        <span class="co">;!USE_BIOS</span>
 if GUARD_AGAINST_INTS
        <span class="kw">mov</span>     <span class="kw">cx</span>,CYCLE_SIZE               <span class="co">;# of DAC locations to load</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">seg</span> PaletteTemp
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,offset PaletteTemp       <span class="co">;dump the DAC into this array</span>
        <span class="kw">sub</span>     <span class="kw">ah</span>,<span class="kw">ah</span>                       <span class="co">;start with DAC location 0</span>
<span class="fu">DACStoreLoop:</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,DAC_READ_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">ah</span>
        <span class="kw">cli</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                       <span class="co">;set the DAC location #</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,DAC_DATA
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>                       <span class="co">;get the red component</span>
        <span class="kw">stosb</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>                       <span class="co">;get the green component</span>
        <span class="kw">stosb</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>                       <span class="co">;get the blue component</span>
        <span class="kw">stosb</span>
        <span class="kw">sti</span>
        <span class="kw">inc</span>     <span class="kw">ah</span>
        loopDACStoreLoop
 else<span class="co">;!GUARD_AGAINST_INTS</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,DAC_READ_INDEX
        <span class="kw">sub</span>     <span class="kw">al</span>,<span class="kw">al</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                       <span class="co">;set the initial DAC location to 0</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">seg</span> PaletteTemp
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,offset PaletteTemp       <span class="co">;dump the DAC into this array</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,DAC_DATA
  if NOT_8088
        <span class="kw">mov</span>     <span class="kw">cx</span>,CYCLE_SIZE*<span class="dv">3</span>
        rep     <span class="kw">insb</span>                        <span class="co">;read CYCLE_SIZE DAC locations at once</span>
  else<span class="co">;!NOT_8088</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,CYCLE_SIZE               <span class="co">;# of DAC locations to load</span>
<span class="fu">DACStoreLoop:</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>                       <span class="co">;get the red component</span>
        <span class="kw">stosb</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>                       <span class="co">;get the green component</span>
        <span class="kw">stosb</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>                       <span class="co">;get the blue component</span>
        <span class="kw">stosb</span>
        <span class="kw">loop</span>    DACStoreLoop
  endif                                     <span class="co">;NOT_8088</span>
 endif                                      <span class="co">;GUARD_AGAINST_INTS</span>
endif                                       <span class="co">;USE_BIOS</span>

<span class="co">;Draw a series of 1-pixel-wide vertical bars across the screen in</span>
<span class="co">; attributes 1 through 255.</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="dv">50</span>*SCREEN_WIDTH_IN_BYTES <span class="co">;point ES:DI to the start</span>
                                            <span class="co">; of line 50 on the screen</span>
        <span class="kw">cld</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dv">100</span>                      <span class="co">;draw 100 lines high</span>
<span class="fu">RowLoop:</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dv">1</span>                        <span class="co">;start each line with attr 1</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,SCREEN_WIDTH_IN_BYTES    <span class="co">;do a full line across</span>
<span class="fu">ColumnLoop:</span>
        <span class="kw">stosb</span>                               <span class="co">;draw a pixel</span>
        <span class="kw">add</span>     <span class="kw">al</span>,<span class="dv">1</span>                        <span class="co">;increment the attribute</span>
        ad      cal,<span class="dv">0</span>                       <span class="co">;if the attribute just turned</span>
                                            <span class="co">; over to 0, increment it to 1</span>
                                            <span class="co">; because we&#39;re not going to</span>
                                            <span class="co">; cycle DAC location 0, so</span>
                                            <span class="co">; attribute 0 won&#39;t change</span>
        <span class="kw">loop</span>    ColumnLoop
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">jnz</span>     RowLoop

<span class="co">;Cycle the specified range of DAC locations until a key is pressed.</span>
<span class="fu">CycleLoop:</span>
<span class="co">;Rotate colors 1-255 one position in the PaletteTemp array;</span>
<span class="co">; location 0 is always left unchanged so that the background</span>
<span class="co">; and border don&#39;t change.</span>
        <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> PaletteTemp+(<span class="dv">1</span>*<span class="dv">3</span>)  <span class="co">;set aside PaletteTemp</span>
        <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> PaletteTemp+(<span class="dv">1</span>*<span class="dv">3</span>)+<span class="dv">2</span><span class="co">; setting for attr 1</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">254</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,offset PaletteTemp+(<span class="dv">2</span>*<span class="dv">3</span>)
        <span class="kw">mov</span>     <span class="kw">di</span>,offset PaletteTemp+(<span class="dv">1</span>*<span class="dv">3</span>)
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">ds</span>
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">254</span>*<span class="dv">3</span>/<span class="dv">2</span>
        rep     <span class="kw">movsw</span>                       <span class="co">;rotate PaletteTemp settings</span>
                                            <span class="co">; for attrs 2 through 255 to</span>
                                            <span class="co">; attrs 1 through 254</span>
        <span class="kw">pop</span>     <span class="kw">bx</span>                          <span class="co">;get back original settings</span>
        <span class="kw">pop</span>     <span class="kw">ax</span>                          <span class="co">; for attribute 1 and move</span>
        <span class="kw">stosw</span>                               <span class="co">; them to the PaletteTemp</span>
        <span class="kw">mov</span>     <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">bl</span>                  <span class="co">; location for attribute 255</span>

if WAIT_VSYNC
<span class="co">;Wait for the leading edge of the vertical sync pulse; this ensures</span>
<span class="co">; that we reload the DAC starting during the vertical non-display</span>
<span class="co">; period.</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,INPUT_STATUS_1
<span class="fu">WaitNotVSync2:</span>                              <span class="co">;wait to be out of vertical sync</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,08h</span>
        <span class="kw">jnz</span>     WaitNotVSync2
<span class="fu">WaitVSync2:</span>                                 <span class="co">;wait until vertical sync begins</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,08h</span>
        <span class="kw">jz</span>      WaitVSync2
endif   <span class="co">;WAIT_VSYNC</span>

if USE_BIOS
<span class="co">;Set the new, rotated palette.</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,1012h                    </span><span class="co">;AH = 10h: set DAC function,</span>
                                            <span class="co">; AL = 12h: set DAC block subfunction</span>
        <span class="kw">sub</span>     <span class="kw">bx</span>,<span class="kw">bx</span>                       <span class="co">;start with DAC location 0</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,CYCLE_SIZE               <span class="co">;# of DAC locations to set</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="kw">seg</span> PaletteTemp
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,offset PaletteTemp       <span class="co">;point ES:DX to array from which</span>
                                            <span class="co">; to load the DAC</span>
        <span class="kw">int</span><span class="bn">     10h                         </span><span class="co">;load the DAC</span>
else    <span class="co">;!USE_BIOS</span>
 if GUARD_AGAINST_INTS
        <span class="kw">mov</span>     <span class="kw">cx</span>,CYCLE_SIZE               <span class="co">;# of DAC locations to load</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,offset PaletteTemp       <span class="co">;load the DAC from this array</span>
        <span class="kw">sub</span>     <span class="kw">ah</span>,<span class="kw">ah</span>                       <span class="co">;start with DAC location 0</span>
<span class="fu">DACLoadLoop:</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,DAC_WRITE_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">ah</span>
        <span class="kw">cli</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                       <span class="co">;set the DAC location #</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,DAC_DATA
        <span class="kw">lodsb</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                       <span class="co">;set the red component</span>
        <span class="kw">lodsb</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                       <span class="co">;set the green component</span>
        <span class="kw">lodsb</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                       <span class="co">;set the blue component</span>
        <span class="kw">sti</span>
        <span class="kw">inc</span>     <span class="kw">ah</span>
        <span class="kw">loop</span>    DACLoadLoop
 else<span class="co">;!GUARD_AGAINST_INTS</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,DAC_WRITE_INDEX
        <span class="kw">sub</span>     <span class="kw">al</span>,<span class="kw">al</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                       <span class="co">;set the initial DAC location to 0</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,offset PaletteTemp       <span class="co">;load the DAC from this array</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,DAC_DATA
  if NOT_8088
        <span class="kw">mov</span>     <span class="kw">cx</span>,CYCLE_SIZE*<span class="dv">3</span>
        rep     <span class="kw">outsb</span>                       <span class="co">;load CYCLE_SIZE DAC locations at once</span>
  else<span class="co">;!NOT_8088</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,CYCLE_SIZE               <span class="co">;# of DAC locations to load</span>
<span class="fu">DACLoadLoop:</span>
        <span class="kw">lodsb</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                       <span class="co">;set the red component</span>
        <span class="kw">lodsb</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                       <span class="co">;set the green component</span>
        <span class="kw">lodsb</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                       <span class="co">;set the blue component</span>
        <span class="kw">loop</span>    DACLoadLoop
  endif<span class="co">;NOT_8088</span>
 endif<span class="co">;GUARD_AGAINST_INTS</span>
endif<span class="co">;USE_BIOS</span>

<span class="co">;See if a key has been pressed.</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,0bh                      </span><span class="co">;DOS check standard input status fn</span>
        <span class="kw">int</span><span class="bn">     21h</span>
        <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">al</span>                       <span class="co">;is a key pending?</span>
        <span class="kw">jz</span>      CycleLoop                   <span class="co">;no, cycle some more</span>

<span class="co">;Clear the keypress.</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">1</span>                        <span class="co">;DOS keyboard input fn</span>
        <span class="kw">int</span><span class="bn">     21h</span>

<span class="co">;Restore text mode and done.</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0003h                    </span><span class="co">;AH = 0: set mode function,</span>
        <span class="kw">int</span><span class="bn">     10h                         </span><span class="co">; AL = 03h: mode # to set</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch                      </span><span class="co">;DOS terminate process fn</span>
        <span class="kw">int</span><span class="bn">     21h</span>

        endstart</code></pre>
<p>The big question is, How does Listing 34.1 cycle colors? Via the BIOS or directly? With interrupts enabled or disabled? <em>Et cetera?</em></p>
<p>However you like, actually. Four equates at the top of Listing 34.1 select the sort of color cycling performed; by changing these equates and <code>CYCLE_SIZE</code>, you can get a feel for how well various approaches to color cycling work with whatever combination of computer system and VGA you care to test.</p>
<p>The <code>USE_BIOS</code> equate is simple. Set <code>USE_BIOS</code> to 1 to load the DAC through the block-load-DAC BIOS function, or to 0 to load the DAC directly with <code>OUT</code>s.</p>
<p>If <code>USE_BIOS</code> is 1, the only other equate of interest is <code>WAIT_VSYNC</code>. If <code>WAIT_VSYNC</code> is 1, the program waits for the leading edge of vertical sync before loading the DAC; if <code>WAIT_VSYNC</code> is 0, the program doesn’t wait before loading. The effect of setting or not setting <code>WAIT_VSYNC</code> depends on whether the BIOS of the VGA the program is running on waits for vertical sync before loading the DAC. You may end up with a double wait, causing color cycling to proceed at half speed, you may end up with no wait at all, causing cycling to occur far too rapidly (and almost certainly with hideous on-screen effects), or you may actually end up cycling at the proper one-cycle-per-frame rate.</p>
<p>If <code>USE_BIOS</code> is 0, <code>WAIT_VSYNC</code> still applies. However, you will always want to set <code>WAIT_VSYNC</code> to 1 when <code>USE_BIOS</code> is 0; otherwise, cycling will occur much too fast, and a good deal of continuous on-screen garbage is likely to make itself evident as the program loads the DAC non-stop.</p>
<p>If <code>USE_BIOS</code> is 0, <code>GUARD_AGAINST_INTS</code> determines whether the possibility of the DAC loading process being interrupted is guarded against by disabling interrupts and setting the write index once for every location loaded and whether the DAC’s autoincrementing feature is relied upon or not.</p>
<p>If <code>GUARD_AGAINST_INTS</code> is 1, the following sequence is followed for the loading of each DAC location in turn: Interrupts are disabled, the DAC Write Index register is set appropriately, the RGB triplet for the location is written to the DAC Data register, and interrupts are enabled. This is the slow but safe approach described earlier.</p>
<p>Matters get still more interesting if <code>GUARD_AGAINST_INTS</code> is 0. In that case, if <code>NOT_8088</code> is 0, then an autoincrementing load is performed in a straightforward fashion; the DAC Write Index register is set to the index of the first location to load and the RGB triplet is sent to the DAC by way of three <code>LODSB/OUT DX,AL</code> pairs, with <code>LOOP</code> repeating the process for each of the locations in turn.</p>
<p>If, however, <code>NOT_8088</code> is 1, indicating that the processor is a 286 or better (perhaps <code>AT_LEAST_286</code> would have been a better name), then after the initial DAC Write Index value is set, all 768 DAC locations are loaded with a single <code>REP OUTSB</code>. This is clearly the fastest approach, but it runs the risk, albeit remote, that the loading sequence will be interrupted and the DAC registers will become garbled.</p>
<p>My own experience with Listing 34.1 indicates that it is sometimes possible to load all 256 locations cleanly but sometimes it is not; it all depends on the processor, the bus speed, the VGA, and the DAC, as well as whether autoincrementation and <code>REP OUTSB</code> are used. I’m not going to bother to report how many DAC locations I <em>could</em> successfully load with each of the various approaches, for the simple reason that I don’t have enough data points to make reliable suggestions, and I don’t want you acting on my comments and running into trouble down the pike. You now have a versatile tool with which to probe the limitations of various DAC-loading approaches; use it to perform your own tests on a sampling of the slowest hardware configurations you expect your programs to run on, then leave a generous safety margin.</p>
<p>One thing’s for sure, though—you’re not going to be able to cycle all 256 DAC locations cleanly once per frame on a reliable basis across the current generation of PCs. That’s why I said at the outset that brute force isn’t appropriate to the task of color cycling. That doesn’t mean that color cycling can’t be used, just that subtler approaches must be employed. Let’s look at some of those alternatives.</p>
</section>
<section id="color-cycling-approaches-that-work" class="level3">
<h3><a href="#color-cycling-approaches-that-work">Color Cycling Approaches that Work</a></h3>
<p>First of all, I’d like to point out that when color cycling does work, it’s a thing of beauty. Assemble Listing 34.1 so that it doesn’t use the BIOS to load the DAC, doesn’t guard against interrupts, and uses 286-specific instructions if your computer supports them. Then tinker with <code>CYCLE_SIZE</code> until the color cycling is perfectly clean on your computer. Color cycling looks stunningly smooth, doesn’t it? And this is crude color cycling, working with the default color set; switch over to a color set that gradually works its way through various hues and saturations, and you could get something that looks for all the world like true-color animation (albeit working with a small subset of the full spectrum at any one time).</p>
<p>Given that, how can we take advantage of color cycling within the limitations of loading the DAC? The simplest approach, and my personal favorite, is that of cycling a portion of the DAC while using the rest of the DAC locations for other, non-cycling purposes. For example, you might allocate 32 DAC locations to the aforementioned sunset, reserve 160 additional locations for use in drawing a static mountain scene, and employ the remaining 64 locations to draw images of planes, cars, and the like in the foreground. The 32 sunset colors could be cycled cleanly, and the other 224 colors would remain the same throughout the program, or would change only occasionally.</p>
<p>That suggests a second possibility: If you have several different color sets to be cycled, interleave the loading so that only one color set is cycled per frame. Suppose you are animating a night scene, with stars twinkling in the background, meteors streaking across the sky, and a spaceship moving across the screen with its jets flaring. One way to produce most of the necessary effects with little effort would be to draw the stars in several attributes and then cycle the colors for <em>those</em> attributes, draw the meteor paths in successive attributes, one for each pixel, and then cycle the colors for those attributes, and do much the same for the jets. The only remaining task would be to animate the spaceship across the screen, which is not a particularly difficult task.</p>
<blockquote>
<p><img src="images/i.jpg" /> The key to getting all the color cycling to work in the above example, however, would be to assign each color cycling task a different part of the DAC, with each part cycled independently as needed. If, as is likely, the total number of DAC locations cycled proved to be too great to manage in one frame, you could simply cycle the colors of the stars after one frame, the colors of the meteors after the next, and the colors of the jets after yet another frame, then back around to cycling the colors of the stars. By splitting up the DAC in this manner and interleaving the cycling tasks, you can perform a great deal of seemingly complex color animation without loading very much of the DAC during any one frame.</p>
</blockquote>
<p>Yet another and somewhat odder workaround is that of using only 128 DAC locations and page flipping. (Page flipping in 256-color modes involves using the VGA’s undocumented 256-color modes; see Chapters 31, 43, and 47 for details.) In this mode of operation, you’d first display page 0, which is drawn entirely with colors 0-127. Then you’d draw page 1 to look just like page 0, except that colors 128-255 are used instead. You’d load DAC locations 128-255 with the next cycle settings for the 128 colors you’re using, then you’d switch to display the second page with the new colors. Then you could modify page 0 as needed, drawing in colors 0-127, load DAC locations 0-127 with the next color cycle settings, and flip back to page 0.</p>
<p>The idea is that you modify only those DAC locations that are not used to display any pixels on the current screen. The advantage of this is <em>not</em>, as you might think, that you don’t generate garbage on the screen when modifying undisplayed DAC locations; in fact, you do, for a spot of interference will show up if you set a DAC location, displayed or not, during display time. No, you still have to wait for vertical sync and load only during vertical blanking before loading the DAC when page flipping with 128 colors; the advantage is that since none of the DAC locations you’re modifying is currently displayed, you can spread the loading out over two or more vertical blanking periods—however long it takes. If you did this without the 128-color page flipping, you might get odd on-screen effects as some of the colors changed after one frame, some after the next, and so on—or you might not; changing the entire DAC in chunks over several frames is another possibility worth considering.</p>
<p>Yet another approach to color cycling is that of loading a bit of the DAC during each horizontal blanking period. Combine that with counting scan lines, and you could vastly expand the number of simultaneous on-screen colors by cycling colors <em>as a frame is displayed</em>, so that the color set changes from scan line to scan line down the screen.</p>
<p>The possibilities are endless. However, were I to be writing 256-color software that used color cycling, I’d find out how many colors could be cycled after the start of vertical sync on the slowest computer I expected the software to run on, I’d lop off at least 10 percent for a safety margin, and I’d structure my program so that no color cycling set exceeded that size, interleaving several color cycling sets if necessary.</p>
<p>That’s what <em>I’d</em> do. Don’t let yourself be held back by my limited imagination, though! Color cycling may be the most complicated of all the color control techniques, but it’s also the most powerful.</p>
</section>
<section id="odds-and-ends" class="level3">
<h3><a href="#odds-and-ends">Odds and Ends</a></h3>
<p>In my experience, when relying on the autoincrementing feature while loading the DAC, the Write Index register wraps back from 255 to 0, and likewise when you load a block of registers through the BIOS. So far as I know, this is a characteristic of the hardware, and should be consistent; also, Richard Wilton documents this behavior for the BIOS in the VGA bible, <em>Programmer’s Guide to PC Video Systems, Second Edition</em> (Microsoft Press), so you should be able to count on it. Not that I see that DAC index wrapping is especially useful, but it never hurts to understand exactly how your resources behave, and I never know when one of you might come up with a serviceable application for any particular quirk.</p>
<section id="the-dac-mask" class="level4">
<h4><a href="#the-dac-mask">The DAC Mask</a></h4>
<p>There’s one register in the DAC that I haven’t mentioned yet, the DAC Mask register at 03C6H. The operation of this register is simple but powerful; it can mask off any or all of the 8 bits of pixel information coming into the DAC from the VGA. Whenever a bit of the DAC Mask register is 1, the corresponding bit of pixel information is passed along to the DAC to be used in looking up the RGB triplet to be sent to the screen. Whenever a bit of the DAC Mask register is 0, the corresponding pixel bit is ignored, and a 0 is used for that bit position in all look-ups of RGB triplets. At the extreme, a DAC Mask setting of 0 causes all 8 bits of pixel information to be ignored, so DAC location 0 is looked up for every pixel, and the entire screen displays the color stored in DAC location 0. This makes setting the DAC Mask register to 0 a quick and easy way to blank the screen.</p>
</section>
<section id="reading-the-dac" class="level4">
<h4><a href="#reading-the-dac">Reading the DAC</a></h4>
<p>The DAC can be read directly, via the DAC Read Index register at 3C7H and the DAC Data register at 3C9H, in much the same way as it can be written directly by way of the DAC Write Index register—complete with autoincrementing the DAC Read Index register after every three reads. Everything I’ve said about writing to the DAC applies to reading from the DAC. In fact, reading from the DAC can even cause snow, just as loading the DAC does, so it should ideally be performed during vertical blanking.</p>
<p>The DAC can also be read by way of the BIOS in either of two ways. <code>INT</code> 10H, function 10H (AH=10H), subfunction 15H (AL=15H) reads out a single DAC location, specified by BX; this function returns the RGB triplet stored in the specified location with the red component in the lower 6 bits of DH, the green component in the lower 6 bits of CH, and the blue component in the lower 6 bits of CL.</p>
<p><code>INT</code> 10H, function 10H (AH=10H), subfunction 17H (AL=17H) reads out a block of DAC locations of length CX, starting with the location specified by BX. ES:DX must point to the buffer in which the RGB values from the specified block of DAC locations are to be stored. The form of this buffer (RGB, RGB, RGB …, with three bytes per RGB triple) is exactly the same as that of the buffer used when calling the BIOS to load a block of registers.</p>
<p>Listing 34.1 illustrates reading the DAC both through the BIOS block-read function and directly, with the direct-read code capable of conditionally assembling to either guard against interrupts or not and to use <code>REP INSB</code> or not. As you can see, reading the DAC settings is very much symmetric with setting the DAC.</p>
</section>
<section id="cycling-down" class="level4">
<h4><a href="#cycling-down">Cycling Down</a></h4>
<p>And so, at long last, we come to the end of our discussion of color control on the VGA. If it has been more complex than anyone might have imagined, it has also been most rewarding. There’s as much obscure but very real potential in color control as there is anywhere on the VGA, which is to say that there’s a very great deal of potential indeed. Put color cycling or color paging together with the page flipping and image drawing techniques explored elsewhere in this book, and you’ll leave the audience gasping and wondering “How the heck did they <em>do</em> that?”</p>
</section>
</section>
</section>
<section id="chapter-35-bresenham-is-fast-and-fast-is-good" class="level2">
<h2><a href="#chapter-35-bresenham-is-fast-and-fast-is-good">Chapter 35 – Bresenham Is Fast, and Fast Is Good</a></h2>
<section id="implementing-and-optimizing-bresenhams-line-drawing-algorithm" class="level3">
<h3><a href="#implementing-and-optimizing-bresenhams-line-drawing-algorithm">Implementing and Optimizing Bresenham’s Line-Drawing Algorithm</a></h3>
<p>For all the complexity of graphics design and programming, surprisingly few primitive functions lie at the heart of most graphics software. Heavily used primitives include routines that draw dots, circles, area fills, bit block logical transfers, and, of course, lines. For many years, computer graphics were created primarily with specialized line-drawing hardware, so lines are in a way the <em>lingua franca</em> of computer graphics. Lines are used in a wide variety of microcomputer graphics applications today, notably CAD/CAM and computer-aided engineering.</p>
<p>Probably the best-known formula for drawing lines on a computer display is called Bresenham’s line-drawing algorithm. (We have to be specific here because there is also a less-well-known Bresenham’s circle-drawing algorithm.) In this chapter, I’ll present two implementations for the EGA and VGA of Bresenham’s line-drawing algorithm, which provides decent line quality and excellent drawing speed.</p>
<p>The first implementation is in rather plain C, with the second in not-so-plain assembly, and they’re both pretty good code. The assembly implementation is damned good code, in fact, but if you want to know whether it’s the fastest Bresenham’s implementation possible, I must tell you that it isn’t. First of all, the code could be sped up a bit by shuffling and combining the various error-term manipulations, but that results in <em>truly</em> cryptic code. I wanted you to be able to relate the original algorithm to the final code, so I skipped those optimizations. Also, write mode 3, which is unique to the VGA, could be used for considerably faster drawing. I’ve described write mode 3 in earlier chapters, and I strongly recommend its use in VGA-only line drawing.</p>
<p>Second, horizontal, vertical, and diagonal lines could be special-cased, since those particular lines require little calculation and can be drawn very rapidly. (This is especially true of horizontal lines, which can be drawn 8 pixels at a time.)</p>
<p>Third, run-length slice line drawing could be used to significantly reduce the number of calculations required per pixel, as I’ll demonstrate in the next two chapters.</p>
<p>Finally, unrolled loops and/or duplicated code could be used to eliminate most of the branches in the final assembly implementation, and because x86 processors are notoriously slow at branching, that would make quite a difference in overall performance. If you’re interested in unrolled loops and similar assembly techniques, I refer you to the first part of this book.</p>
<p>That brings us neatly to my final point: Even if I didn’t know that there were further optimizations to be made to my line-drawing implementation, I’d <em>assume</em> that there were. As I’m sure the experienced assembly programmers among you know, there are dozens of ways to tackle any problem in assembly, and someone else always seems to have come up with a trick that never occurred to you. I’ve incorporated a suggestion made by Jim Mackraz in the code in this chapter, and I’d be most interested in hearing of any other tricks or tips you may have.</p>
<p>Notwithstanding, the line-drawing implementation in Listing 35.3 is plenty fast enough for most purposes, so let’s get the discussion underway.</p>
</section>
<section id="the-task-at-hand" class="level3">
<h3><a href="#the-task-at-hand">The Task at Hand</a></h3>
<p>There are two important characteristics of any line-drawing function. First, it must draw a reasonable approximation of a line. A computer screen has limited resolution, and so a line-drawing function must actually approximate a straight line by drawing a series of pixels in what amounts to a jagged pattern that generally proceeds in the desired direction. That pattern of pixels must reliably suggest to the human eye the true line it represents. Second, to be usable, a line-drawing function must be <em>fast</em>. Minicomputers and mainframes generally have hardware that performs line drawing, but most microcomputers offer no such assistance. True, nowadays graphics accelerators such as the S3 and ATI chips have line drawing hardware, but some other accelerators don’t; when drawing lines on the latter sort of chip, when drawing on the CGA, EGA, and VGA, and when drawing sorts of lines not supported by line-drawing hardware as well, the PC’s CPU must draw lines on its own, and, as many users of graphics-oriented software know, that can be a slow process indeed.</p>
<p>Line drawing quality and speed derive from two factors: The algorithm used to draw the line and the implementation of that algorithm. The first implementation (written in Borland C++) that I’ll be presenting in this chapter illustrates the workings of the algorithm and draws lines at a good rate. The second implementation, written in assembly language and callable directly from Borland C++, draws lines at extremely high speed, on the order of three to six times faster than the C version. Between them, the two implementations illuminate Bresenham’s line-drawing algorithm and provide high-performance line-drawing capability.</p>
<p>The difficulty in drawing a line lies in generating a set of pixels that, taken together, are a reasonable facsimile of a true line. Only horizontal, vertical, and 1:1 diagonal lines can be drawn precisely along the true line being represented; all other lines must be approximated from the array of pixels that a given video mode supports, as shown in Figure 35.1.</p>
<p>Considerable thought has gone into the design of line-drawing algorithms, and a number of techniques for drawing high-quality lines have been developed. Unfortunately, most of these techniques were developed for powerful, expensive graphics workstations and require very high resolution, a large color palette, and/or floating-point hardware. These techniques tend to perform poorly and produce less visually impressive results on all but the best-endowed PCs.</p>
<p>Bresenham’s line-drawing algorithm, on the other hand, is uniquely suited to microcomputer implementation in that it requires no floating-point operations, no divides, and no multiplies inside the line-drawing loop. Moreover, it can be implemented with surprisingly little code.</p>
</section>
<section id="bresenhams-line-drawing-algorithm" class="level3">
<h3><a href="#bresenhams-line-drawing-algorithm">Bresenham’s Line-Drawing Algorithm</a></h3>
<p>The key to grasping Bresenham’s algorithm is to understand that when drawing an approximation of a line on a finite-resolution display, each pixel drawn will lie either exactly on the true line or to one side or the other of the true line. The amount by which the pixel actually drawn deviates from the true line is the <em>error</em> of the line drawing at that point. As the drawing of the line progresses from one pixel to the next, the error can be used to tell when, given the resolution of the display, a more accurate approximation of the line can be drawn by placing a given pixel one unit of screen resolution away from its predecessor in either the horizontal or the vertical direction, or both.</p>
<figure>
<img src="images/35-01.jpg" alt="Figure 35.1  Approximating a true line from a pixel array." /><figcaption><strong>Figure 35.1</strong>  <em>Approximating a true line from a pixel array.</em></figcaption>
</figure>
<p>Let’s examine the case of drawing a line where the horizontal, or X length of the line is greater than the vertical, or Y length, and both lengths are greater than 0. For example, suppose we are drawing a line from (0,0) to (5,2), as shown in Figure 35.2. Note that Figure 35.2 shows the upper-left-hand corner of the screen as (0,0), rather than placing (0,0) at its more traditional lower-left-hand corner location. Due to the way in which the PC’s graphics are mapped to memory, it is simpler to work within this framework, although a translation of Y from increasing downward to increasing upward could be effected easily enough by simply subtracting the Y coordinate from the screen height minus 1; if you are more comfortable with the traditional coordinate system, feel free to modify the code in Listings 35.1 and 35.3.</p>
<p>In Figure 35.2, the endpoints of the line fall exactly on displayed pixels. However, no other part of the line squarely intersects the center of a pixel, meaning that all other pixels will have to be plotted as approximations of the line. The approach to approximation that Bresenham’s algorithm takes is to move exactly 1 pixel along the major dimension of the line each time a new pixel is drawn, while moving 1 pixel along the minor dimension each time the line moves more than halfway between pixels along the minor dimension.</p>
<p>In Figure 35.2, the X dimension is the major dimension. This means that 6 dots, one at each of X coordinates 0, 1, 2, 3, 4, and 5, will be drawn. The trick, then, is to decide on the correct Y coordinates to accompany those X coordinates.</p>
<figure>
<img src="images/35-02.jpg" alt="Figure 35.2  Drawing between two pixel endpoints." /><figcaption><strong>Figure 35.2</strong>  <em>Drawing between two pixel endpoints.</em></figcaption>
</figure>
<p>It’s easy enough to select the Y coordinates by eye in Figure 35.2. The appropriate Y coordinates are 0, 0, 1, 1, 2, 2, based on the Y coordinate closest to the line for each X coordinate. Bresenham’s algorithm makes the same selections, based on the same criterion. The manner in which it does this is by keeping a running record of the error of the line—that is, how far from the true line the current Y coordinate is—at each X coordinate, as shown in Figure 35.3. When the running error of the line indicates that the current Y coordinate deviates from the true line to the extent that the adjacent Y coordinate would be closer to the line, then the current Y coordinate is changed to that adjacent Y coordinate.</p>
<p>Let’s take a moment to follow the steps Bresenham’s algorithm would go through in drawing the line in Figure 35.3. The initial pixel is drawn at (0,0), the starting point of the line. At this point the error of the line is 0.</p>
<p>Since X is the major dimension, the next pixel has an X coordinate of 1. The Y coordinate of this pixel will be whichever of 0 (the last Y coordinate) or 1 (the adjacent Y coordinate in the direction of the end point of the line) the true line at this X coordinate is closer to. The running error at this point is B minus A, as shown in Figure 35.3. This amount is less than 1/2 (that is, less than halfway to the next Y coordinate), so the Y coordinate does not change at X equal to 1. Consequently, the second pixel is drawn at (1,0).</p>
<p>The third pixel has an X coordinate of 2. The running error at this point is C minus A, which is greater than 1/2 and therefore closer to the next than to the current Y coordinate. The third pixel is drawn at (2,1), and 1 is subtracted from the running error to compensate for the adjustment of one pixel in the current Y coordinate. The running error of the pixel actually drawn at this point is C minus D.</p>
<figure>
<img src="images/35-03.jpg" alt="Figure 35.3  The error term in Bresenham’s algorithm." /><figcaption><strong>Figure 35.3</strong>  <em>The error term in Bresenham’s algorithm.</em></figcaption>
</figure>
<p>The fourth pixel has an X coordinate of 3. The running error at this point is E minus D; since this is less than 1/2, the current Y coordinate doesn’t change. The fourth pixel is drawn at (3,1).</p>
<p>The fifth pixel has an X coordinate of 4. The running error at this point is F minus D; since this is greater than 1/2, the current Y coordinate advances. The third pixel is drawn at (4,2), and 1 is subtracted from the running error. The error of the pixel drawn at this point is G minus F.</p>
<p>Finally, the sixth pixel is the end point of the line. This pixel has an X coordinate of 5. The running error at this point is G minus G, or 0, indicating that this point is squarely on the true line, as of course it should be given that it’s the end point, so the current Y coordinate remains the same. The end point of the line is drawn at (5,2), and the line is complete.</p>
<p>That’s really all there is to Bresenham’s algorithm. The algorithm is a process of drawing a pixel at each possible coordinate along the major dimension of the line, each with the closest possible coordinate along the minor dimension. The running error is used to keep track of when the coordinate along the minor dimension must change in order to remain as close as possible to the true line. The above description of the case where X is the major dimension, Y is the minor dimension, and both dimensions are greater than zero is readily generalized to all eight octants in which lines could be drawn, as we will see in the C implementation.</p>
<p>The above discussion summarizes the nature rather than the exact mechanism of Bresenham’s line-drawing algorithm. I’ll provide a brief seat-of-the-pants discussion of the algorithm in action when we get to the C implementation of the algorithm; for a full mathematical treatment, I refer you to pages 433-436 of Foley and Van Dam’s <em>Fundamentals of Interactive Computer Graphics</em> (Addison-Wesley, 1982), or pages 72-78 of the second edition of that book, which was published under the name <em>Computer Graphics: Principles and Practice</em> (Addison-Wesley, 1990). These sources provide the derivation of the integer-only, divide-free version of the algorithm, as well as Pascal code for drawing lines in one of the eight possible octants.</p>
<section id="strengths-and-weaknesses" class="level4">
<h4><a href="#strengths-and-weaknesses">Strengths and Weaknesses</a></h4>
<p>The overwhelming strength of Bresenham’s line-drawing algorithm is speed. With no divides, no floating-point operations, and no need for variables that won’t fit in 16 bits, it is perfectly suited for PCs.</p>
<p>The weakness of Bresenham’s algorithm is that it produces relatively low-quality lines by comparison with most other line-drawing algorithms. In particular, lines generated with Bresenham’s algorithm can tend to look a little jagged. On the PC, however, jagged lines are an inevitable consequence of relatively low resolution and a small color set, so lines drawn with Bresenham’s algorithm don’t look all that much different from lines drawn in other ways. Besides, in most applications, users are far more interested in the overall picture than in the primitive elements from which that picture is built. As a general rule, any collection of pixels that trend from point A to point B in a straight fashion is accepted by the eye as a line. Bresenham’s algorithm is successfully used by many current PC programs, and by the standard of this wide acceptance the algorithm is certainly good enough.</p>
<p>Then, too, users hate waiting for their computer to finish drawing. By any standard of drawing performance, Bresenham’s algorithm excels.</p>
</section>
</section>
<section id="an-implementation-in-c" class="level3">
<h3><a href="#an-implementation-in-c">An Implementation in C</a></h3>
<p>It’s time to get down and look at some actual working code. Listing 35.1 is a C implementation of Bresenham’s line-drawing algorithm for modes 0EH, 0FH, 10H, and 12H of the VGA, called as function <code>EVGALine</code>. Listing 35.2 is a sample program to demonstrate the use of <code>EVGALine</code>.</p>
<p><strong>LISTING 35.1 L35-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * C implementation of Bresenham&#39;s line drawing algorithm</span>
<span class="co"> * for the EGA and VGA. Works in modes 0xE, 0xF, 0x10, and 0x12.</span>
<span class="co"> *</span>
<span class="co"> * Compiled with Borland C++</span>
<span class="co"> *</span>
<span class="co"> * By Michael Abrash</span>
<span class="co"> */</span>

<span class="ot">#include &lt;dos.h&gt;     </span><span class="co">/* contains MK_FP macro */</span>

<span class="ot">#define EVGA_SCREEN_WIDTH_IN_BYTES     80</span>
                                       <span class="co">/* memory offset from start of</span>
<span class="co">                                          one row to start of next */</span>
<span class="ot">#define EVGA_SCREEN_SEGMENT            0xA000</span>
                                       <span class="co">/* display memory segment */</span>
<span class="ot">#define GC_INDEX                       0x3CE</span>
                                       <span class="co">/* Graphics Controller</span>
<span class="co">                                          Index register port */</span>
<span class="ot">#define GC_DATA                        0x3CF</span>
                                       <span class="co">/* Graphics Controller</span>
<span class="co">                                          Data register port */</span>
<span class="ot">#define SET_RESET_INDEX                0  </span><span class="co">/* indexes of needed */</span>
<span class="ot">#define ENABLE_SET_RESET_INDEX         1  </span><span class="co">/* Graphics Controller */</span>
<span class="ot">#define BIT_MASK_INDEX                 8  </span><span class="co">/* registers */</span>

<span class="co">/*</span>
<span class="co"> * Draws a dot at (X0,Y0) in whatever color the EGA/VGA hardware is</span>
<span class="co"> * set up for. Leaves the bit mask set to whatever value the</span>
<span class="co"> * dot required.</span>
<span class="co"> */</span>
<span class="dt">void</span> EVGADot(X0, Y0)
<span class="dt">unsigned</span> <span class="dt">int</span> X0;     <span class="co">/* coordinates at which to draw dot, with */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> Y0;     <span class="co">/* (0,0) at the upper left of the screen */</span>
{
   <span class="dt">unsigned</span> <span class="dt">char</span> far *PixelBytePtr;
   <span class="dt">unsigned</span> <span class="dt">char</span> PixelMask;

   <span class="co">/* Calculate the offset in the screen segment of the byte in</span>
<span class="co">      which the pixel lies */</span>
   PixelBytePtr = MK_FP(EVGA_SCREEN_SEGMENT,
      ( Y0 * EVGA_SCREEN_WIDTH_IN_BYTES ) + ( X0 / <span class="dv">8</span> ));

   <span class="co">/* Generate a mask with a 1 bit in the pixel&#39;s position within the</span>
<span class="co">      screen byte */</span>
   PixelMask = <span class="bn">0x80</span> &gt;&gt; ( X0 &amp; <span class="bn">0x07</span> );

   <span class="co">/* Set up the Graphics Controller&#39;s Bit Mask register to allow</span>
<span class="co">      only the bit corresponding to the pixel being drawn to</span>
<span class="co">      be modified */</span>
   outportb(GC_INDEX, BIT_MASK_INDEX);
   outportb(GC_DATA, PixelMask);

   <span class="co">/* Draw the pixel. Because of the operation of the set/reset</span>
<span class="co">      feature of the EGA/VGA, the value written doesn&#39;t matter.</span>
<span class="co">      The screen byte is ORed in order to perform a read to latch the</span>
<span class="co">      display memory, then perform a write in order to modify it. */</span>
   *PixelBytePtr |= <span class="bn">0xFE</span>;
}

<span class="co">/*</span>
<span class="co"> * Draws a line in octant 0 or 3 ( |DeltaX| &gt;= DeltaY ).</span>
<span class="co"> */</span>
<span class="dt">void</span> Octant0(X0, Y0, DeltaX, DeltaY, XDirection)
<span class="dt">unsigned</span> <span class="dt">int</span> X0, Y0;          <span class="co">/* coordinates of start of the line */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> DeltaX, DeltaY;  <span class="co">/* length of the line (both &gt; 0) */</span>
<span class="dt">int</span> XDirection;               <span class="co">/* 1 if line is drawn left to right,</span>
<span class="co">                                 -1 if drawn right to left */</span>
{
   <span class="dt">int</span> DeltaYx2;
   <span class="dt">int</span> DeltaYx2MinusDeltaXx2;
   <span class="dt">int</span> ErrorTerm;

   <span class="co">/* Set up initial error term and values used inside drawing loop */</span>
   DeltaYx2 = DeltaY * <span class="dv">2</span>;
   DeltaYx2MinusDeltaXx2 = DeltaYx2 - (<span class="dt">int</span>) ( DeltaX * <span class="dv">2</span> );
   ErrorTerm = DeltaYx2 - (<span class="dt">int</span>) DeltaX;

   <span class="co">/* Draw the line */</span>
   EVGADot(X0, Y0);              <span class="co">/* draw the first pixel */</span>
   <span class="kw">while</span> ( DeltaX— ) {
      <span class="co">/* See if it&#39;s time to advance the Y coordinate */</span>
      <span class="kw">if</span> ( ErrorTerm &gt;= <span class="dv">0</span> ) {
         <span class="co">/* Advance the Y coordinate &amp; adjust the error term</span>
<span class="co">            back down */</span>
         Y0++;
         ErrorTerm += DeltaYx2MinusDeltaXx2;
      } <span class="kw">else</span> {
         <span class="co">/* Add to the error term */</span>
         ErrorTerm += DeltaYx2;
      }
      X0 += XDirection;          <span class="co">/* advance the X coordinate */</span>
      EVGADot(X0, Y0);           <span class="co">/* draw a pixel */</span>
   }
}

<span class="co">/*</span>
<span class="co"> * Draws a line in octant 1 or 2 ( |DeltaX| &lt; DeltaY ).</span>
<span class="co"> */</span>
<span class="dt">void</span> Octant1(X0, Y0, DeltaX, DeltaY, XDirection)
<span class="dt">unsigned</span> <span class="dt">int</span> X0, Y0;          <span class="co">/* coordinates of start of the line */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> DeltaX, DeltaY;  <span class="co">/* length of the line (both &gt; 0) */</span>
<span class="dt">int</span> XDirection;               <span class="co">/* 1 if line is drawn left to right,</span>
<span class="co">                                 -1 if drawn right to left */</span>
{
   <span class="dt">int</span> DeltaXx2;
   <span class="dt">int</span> DeltaXx2MinusDeltaYx2;
   <span class="dt">int</span> ErrorTerm;

   <span class="co">/* Set up initial error term and values used inside drawing loop */</span>
   DeltaXx2 = DeltaX * <span class="dv">2</span>;
   DeltaXx2MinusDeltaYx2 = DeltaXx2 - (<span class="dt">int</span>) ( DeltaY * <span class="dv">2</span> );
   ErrorTerm = DeltaXx2 - (<span class="dt">int</span>) DeltaY;

   EVGADot(X0, Y0);           <span class="co">/* draw the first pixel */</span>
   <span class="kw">while</span> ( DeltaY— ) {
      <span class="co">/* See if it&#39;s time to advance the X coordinate */</span>
      <span class="kw">if</span> ( ErrorTerm &gt;= <span class="dv">0</span> ) {
         <span class="co">/* Advance the X coordinate &amp; adjust the error term</span>
<span class="co">            back down */</span>
         X0 += XDirection;
         ErrorTerm += DeltaXx2MinusDeltaYx2;
      } <span class="kw">else</span> {
         <span class="co">/* Add to the error term */</span>
         ErrorTerm += DeltaXx2;
      }
      Y0++;                   <span class="co">/* advance the Y coordinate */</span>
      EVGADot(X0, Y0);        <span class="co">/* draw a pixel */</span>
   }
}

<span class="co">/*</span>
<span class="co"> * Draws a line on the EGA or VGA.</span>
<span class="co"> */</span>
<span class="dt">void</span> EVGALine(X0, Y0, X1, Y1, Color)
<span class="dt">int</span> X0, Y0;    <span class="co">/* coordinates of one end of the line */</span>
<span class="dt">int</span> X1, Y1;    <span class="co">/* coordinates of the other end of the line */</span>
<span class="dt">char</span> Color;    <span class="co">/* color to draw line in */</span>
{
   <span class="dt">int</span> DeltaX, DeltaY;
   <span class="dt">int</span> Temp;

   <span class="co">/* Set the drawing color */</span>

   <span class="co">/* Put the drawing color in the Set/Reset register */</span>
   outportb(GC_INDEX, SET_RESET_INDEX);
   outportb(GC_DATA, Color);
   <span class="co">/* Cause all planes to be forced to the Set/Reset color */</span>
   outportb(GC_INDEX, ENABLE_SET_RESET_INDEX);
   outportb(GC_DATA, <span class="bn">0xF</span>);

   <span class="co">/* Save half the line-drawing cases by swapping Y0 with Y1</span>
<span class="co">      and X0 with X1 if Y0 is greater than Y1. As a result, DeltaY</span>
<span class="co">      is always &gt; 0, and only the octant 0-3 cases need to be</span>
<span class="co">      handled. */</span>
   <span class="kw">if</span> ( Y0 &gt; Y1 ) {
      Temp = Y0;
      Y0 = Y1;
      Y1 = Temp;
      Temp = X0;
      X0 = X1;
      X1 = Temp;
   }

   <span class="co">/* Handle as four separate cases, for the four octants in which</span>
<span class="co">      Y1 is greater than Y0 */</span>
   DeltaX = X1 - X0;    <span class="co">/* calculate the length of the line</span>
<span class="co">                           in each coordinate */</span>
   DeltaY = Y1 - Y0;
   <span class="kw">if</span> ( DeltaX &gt; <span class="dv">0</span> ) {
      <span class="kw">if</span> ( DeltaX &gt; DeltaY ) {
         Octant0(X0, Y0, DeltaX, DeltaY, <span class="dv">1</span>);
      } <span class="kw">else</span> {
         Octant1(X0, Y0, DeltaX, DeltaY, <span class="dv">1</span>);
      }
   } <span class="kw">else</span> {
      DeltaX = -DeltaX;             <span class="co">/* absolute value of DeltaX */</span>
      <span class="kw">if</span> ( DeltaX &gt; DeltaY ) {
         Octant0(X0, Y0, DeltaX, DeltaY, -<span class="dv">1</span>);
      } <span class="kw">else</span> {
         Octant1(X0, Y0, DeltaX, DeltaY, -<span class="dv">1</span>);
      }
   }

   <span class="co">/* Return the state of the EGA/VGA to normal */</span>
   outportb(GC_INDEX, ENABLE_SET_RESET_INDEX);
   outportb(GC_DATA, <span class="dv">0</span>);
   outportb(GC_INDEX, BIT_MASK_INDEX);
   outportb(GC_DATA, <span class="bn">0xFF</span>);
}</code></pre>
<p><strong>LISTING 35.2 L35-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Sample program to illustrate EGA/VGA line drawing routines.</span>
<span class="co"> *</span>
<span class="co"> * Compiled with Borland C++</span>
<span class="co"> *</span>
<span class="co"> * By Michael Abrash</span>
<span class="co"> */</span>

<span class="ot">#include &lt;dos.h&gt;     </span><span class="co">/* contains geninterrupt */</span>

<span class="ot">#define GRAPHICS_MODE   0x10</span>
<span class="ot">#define TEXT_MODE       0x03</span>
<span class="ot">#define BIOS_VIDEO_INT  0x10</span>
<span class="ot">#define X_MAX           640      </span><span class="co">/* working screen width */</span>
<span class="ot">#define Y_MAX           348      </span><span class="co">/* working screen height */</span>

<span class="kw">extern</span> <span class="dt">void</span> EVGALine();

<span class="co">/*</span>
<span class="co"> * Subroutine to draw a rectangle full of vectors, of the specified</span>
<span class="co"> * length and color, around the specified rectangle center.</span>
<span class="co"> */</span>
<span class="dt">void</span> VectorsUp(XCenter, YCenter, XLength, YLength, Color)
<span class="dt">int</span> XCenter, YCenter;   <span class="co">/* center of rectangle to fill */</span>
<span class="dt">int</span> XLength, YLength;   <span class="co">/* distance from center to edge</span>
<span class="co">                           of rectangle */</span>
<span class="dt">int</span> Color;              <span class="co">/* color to draw lines in */</span>
{
   <span class="dt">int</span> WorkingX, WorkingY;

   <span class="co">/* Lines from center to top of rectangle */</span>
   WorkingX = XCenter - XLength;
   WorkingY = YCenter - YLength;
   <span class="kw">for</span> ( ; WorkingX &lt; ( XCenter + XLength ); WorkingX++ )
      EVGALine(XCenter, YCenter, WorkingX, WorkingY, Color);

   <span class="co">/* Lines from center to right of rectangle */</span>
   WorkingX = XCenter + XLength - <span class="dv">1</span>;
   WorkingY = YCenter - YLength;
   <span class="kw">for</span> ( ; WorkingY &lt; ( YCenter + YLength ); WorkingY++ )
      EVGALine(XCenter, YCenter, WorkingX, WorkingY, Color);

   <span class="co">/* Lines from center to bottom of rectangle */</span>
   WorkingX = XCenter + XLength - <span class="dv">1</span>;
   WorkingY = YCenter + YLength - <span class="dv">1</span>;
   <span class="kw">for</span> ( ; WorkingX &gt;= ( XCenter - XLength ); WorkingX— )
      EVGALine(XCenter, YCenter, WorkingX, WorkingY, Color);

   <span class="co">/* Lines from center to left of rectangle */</span>
   WorkingX = XCenter - XLength;
   WorkingY = YCenter + YLength - <span class="dv">1</span>;
   <span class="kw">for</span> ( ; WorkingY &gt;= ( YCenter - YLength ); WorkingY— )
      EVGALine(XCenter, YCenter, WorkingX, WorkingY, Color );
}

<span class="co">/*</span>
<span class="co"> * Sample program to draw four rectangles full of lines.</span>
<span class="co"> */</span>
<span class="dt">void</span> main()
{
   <span class="dt">char</span> temp;

   <span class="co">/* Set graphics mode */</span>
   _AX = GRAPHICS_MODE;
   geninterrupt(BIOS_VIDEO_INT);

   <span class="co">/* Draw each of four rectangles full of vectors */</span>
   VectorsUp(X_MAX / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, X_MAX / <span class="dv">4</span>,
      Y_MAX / <span class="dv">4</span>, <span class="dv">1</span>);
   VectorsUp(X_MAX * <span class="dv">3</span> / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, X_MAX / <span class="dv">4</span>,
      Y_MAX / <span class="dv">4</span>, <span class="dv">2</span>);
   VectorsUp(X_MAX / <span class="dv">4</span>, Y_MAX * <span class="dv">3</span> / <span class="dv">4</span>, X_MAX / <span class="dv">4</span>,
      Y_MAX / <span class="dv">4</span>, <span class="dv">3</span>);
   VectorsUp(X_MAX * <span class="dv">3</span> / <span class="dv">4</span>, Y_MAX * <span class="dv">3</span> / <span class="dv">4</span>, X_MAX / <span class="dv">4</span>,
      Y_MAX / <span class="dv">4</span>, <span class="dv">4</span>);

   <span class="co">/* Wait for the enter key to be pressed */</span>
   scanf(<span class="st">&quot;%c&quot;</span>, &amp;temp);

   <span class="co">/* Return back to text mode */</span>
   _AX = TEXT_MODE;
   geninterrupt(BIOS_VIDEO_INT);
}</code></pre>
<section id="looking-at-evgaline" class="level4">
<h4><a href="#looking-at-evgaline">Looking at EVGALine</a></h4>
<p>The <code>EVGALine</code> function itself performs four operations. <code>EVGALine</code> first sets up the VGA’s hardware so that all pixels drawn will be in the desired color. This is accomplished by setting two of the VGA’s registers, the Enable Set/Reset register and the Set/Reset register. Setting the Enable Set/Reset to the value 0FH, as is done in <code>EVGALine</code>, causes all drawing to produce pixels in the color contained in the Set/Reset register. Setting the Set/Reset register to the passed color, in conjunction with the Enable Set/Reset setting of 0FH, causes all drawing done by <code>EVGALine</code> and the functions it calls to generate the passed color. In summary, setting up the Enable Set/Reset and Set/Reset registers in this way causes the remainder of <code>EVGALine</code> to draw a line in the specified color.</p>
<p><code>EVGALine</code> next performs a simple check to cut in half the number of line orientations that must be handled separately. Figure 35.4 shows the eight possible line orientations among which a Bresenham’s algorithm implementation must distinguish. (In interpreting Figure 35.4, assume that lines radiate outward from the center of the figure, falling into one of eight octants delineated by the horizontal and vertical axes and the two diagonals.) The need to categorize lines into these octants falls out of the major/minor axis nature of the algorithm; the orientations are distinguished by which coordinate forms the major axis and by whether each of X and Y increases or decreases from the line start to the line end.</p>
<blockquote>
<p><img src="images/i.jpg" /> A moment of thought will show, however, that four of the line orientations are redundant. Each of the four orientations for which <code>DeltaY</code>, the Y component of the line, is less than 0 (that is, for which the line start Y coordinate is greater than the line end Y coordinate) can be transformed into one of the four orientations for which the line start Y coordinate is less than the line end Y coordinate simply by reversing the line start and end coordinates, so that the line is drawn in the other direction. <code>EVGALine</code> does this by swapping (X0,Y0) (the line start coordinates) with (X1,Y1) (the line end coordinates) whenever Y0 is greater than Y1.</p>
</blockquote>
<p>This accomplished, <code>EVGALine</code> must still distinguish among the four remaining line orientations. Those four orientations form two major categories, orientations for which the X dimension is the major axis of the line and orientations for which the Y dimension is the major axis. As shown in Figure 35.4, octants 1 (where X increases from start to finish) and 2 (where X decreases from start to finish) fall into the latter category, and differ in only one respect, the direction in which the X coordinate moves when it changes. Handling of the running error of the line is exactly the same for both cases, as one would expect given the symmetry of lines differing only in the sign of <code>DeltaX</code>, the X coordinate of the line. Consequently, for those cases where <code>DeltaX</code> is less than zero, the direction of X movement is made negative, and the absolute value of <code>DeltaX</code> is used for error term calculations.</p>
<p>Similarly, octants 0 (where X increases from start to finish) and 3 (where X decreases from start to finish) differ only in the direction in which the X coordinate moves when it changes. The difference between line drawing in octants 0 and 3 and line drawing in octants 1 and 2 is that in octants 0 and 3, since X is the major axis, the X coordinate changes on every pixel of the line and the Y coordinate changes only when the running error of the line dictates. In octants 1 and 2, the Y coordinate changes on every pixel and the X coordinate changes only when the running error dictates, since Y is the major axis.</p>
<figure>
<img src="images/35-04.jpg" alt="Figure 35.4  Bresenham’s eight possible line orientations." /><figcaption><strong>Figure 35.4</strong>  <em>Bresenham’s eight possible line orientations.</em></figcaption>
</figure>
<p>There is one line-drawing function for octants 0 and 3, <code>Octant0</code>, and one line-drawing function for octants 1 and 2, <code>Octant1</code>. A single function with <code>if</code> statements could certainly be used to handle all four octants, but at a significant performance cost. There is, on the other hand, very little performance cost to grouping octants 0 and 3 together and octants 1 and 2 together, since the two octants in each pair differ only in the direction of change of the X coordinate.</p>
<p><code>EVGALine</code> determines which line-drawing function to call and with what value for the direction of change of the X coordinate based on two criteria: whether <code>DeltaX</code> is negative or not, and whether the absolute value of <code>DeltaX</code> (|<code>DeltaX</code>|) is less than <code>DeltaY</code> or not, as shown in Figure 35.5. Recall that the value of <code>DeltaY</code>, and hence the direction of change of the Y coordinate, is guaranteed to be non-negative as a result of the earlier elimination of four of the line orientations.</p>
<p>After calling the appropriate function to draw the line (more on those functions shortly), <code>EVGALine</code> restores the state of the Enable Set/Reset register to its default of zero. In this state, the Set/Reset register has no effect, so it is not necessary to restore the state of the Set/Reset register as well. <code>EVGALine</code> also restores the state of the Bit Mask register (which, as we will see, is modified by <code>EVGADot</code>, the pixel-drawing routine actually used to draw each pixel of the lines produced by <code>EVGALine</code>) to its default of 0FFH. While it would be more modular to have <code>EVGADot</code> restore the state of the Bit Mask register after drawing each pixel, it would also be considerably slower to do so. The same could be said of having <code>EVGADot</code> set the Enable Set/Reset and Set/Reset registers for each pixel: While modularity would improve, speed would suffer markedly.</p>
<figure>
<img src="images/35-05.jpg" alt="Figure 35.5  EVGALine’s decision logic." /><figcaption><strong>Figure 35.5</strong>  <em>EVGALine’s decision logic.</em></figcaption>
</figure>
</section>
<section id="drawing-each-line" class="level4">
<h4><a href="#drawing-each-line">Drawing Each Line</a></h4>
<p>The <code>Octant0</code> and <code>Octant1</code> functions draw lines for which |<code>DeltaX</code>| is greater than <code>DeltaY</code> and lines for which |<code>DeltaX</code>| is less than or equal to <code>DeltaY</code>, respectively. The parameters to <code>Octant0</code> and <code>Octant1</code> are the starting point of the line, the length of the line in each dimension, and <code>XDirection</code>, the amount by which the X coordinate should be changed when it moves. <code>XDirection</code> must be either 1 (to draw toward the right edge of the screen) or -1 (to draw toward the left edge of the screen). No value is required for the amount by which the Y coordinate should be changed; since <code>DeltaY</code> is guaranteed to be positive, the Y coordinate always changes by 1 pixel.</p>
<p><code>Octant0</code> draws lines for which |<code>DeltaX</code>| is greater than <code>DeltaY</code>. For such lines, the X coordinate of each pixel drawn differs from the previous pixel by either 1 or -1, depending on the value of <code>XDirection</code>. (This makes it possible for <code>Octant0</code> to draw lines in both octant 0 and octant 3.) Whenever <code>ErrorTerm</code> becomes non-negative, indicating that the next Y coordinate is a better approximation of the line being drawn, the Y coordinate is increased by 1.</p>
<p><code>Octant1</code> draws lines for which |<code>DeltaX</code>| is less than or equal to DeltaY. For these lines, the Y coordinate of each pixel drawn is 1 greater than the Y coordinate of the previous pixel. Whenever <code>ErrorTerm</code> becomes non-negative, indicating that the next X coordinate is a better approximation of the line being drawn, the X coordinate is advanced by either 1 or -1, depending on the value of <code>XDirection</code>. (This makes it possible for <code>Octant1</code> to draw lines in both octant 1 and octant 2.)</p>
</section>
<section id="drawing-each-pixel" class="level4">
<h4><a href="#drawing-each-pixel">Drawing Each Pixel</a></h4>
<p>At the core of <code>Octant0</code> and <code>Octant1</code> is a pixel-drawing function, <code>EVGADot</code>. <code>EVGADot</code> draws a pixel at the specified coordinates in whatever color the hardware of the VGA happens to be set up for. As described earlier, since the entire line drawn by <code>EVGALine</code> is of the same color, line-drawing performance is improved by setting the VGA’s hardware up once in <code>EVGALine</code> before the line is drawn, and then drawing all the pixels in the line in the same color via <code>EVGADot</code>.</p>
<p><code>EVGADot</code> makes certain assumptions about the screen. First, it assumes that the address of the byte controlling the pixels at the start of a given row on the screen is 80 bytes after the start of the row immediately above it. In other words, this implementation of <code>EVGADot</code> only works for screens configured to be 80 bytes wide. Since this is the standard configuration of all of the modes <code>EVGALine</code> is designed to work in, the assumption of 80 bytes per row should be no problem. If it is a problem, however, <code>EVGADot</code> could easily be modified to retrieve the BIOS integer variable at address 0040:004A, which contains the number of bytes per row for the current video mode.</p>
<p>Second, <code>EVGADot</code> assumes that screen memory is organized as a linear bitmap starting at address A000:0000, with the pixel at the upper left of the screen controlled by bit 7 of the byte at offset 0, the next pixel to the right controlled by bit 6, the ninth pixel controlled by bit 7 of the byte at offset 1, and so on. Further, it assumes that the graphics adapter’s hardware is configured such that setting the Bit Mask register to allow modification of only the bit controlling the pixel of interest and then ORing a value of 0FEH with display memory will draw that pixel correctly without affecting any other dots. (Note that 0FEH is used rather than 0FFH or 0 because some optimizing compilers turn ORs with the latter values into simpler operations or optimize them away entirely. As explained later, however, it’s not the value that’s ORed that matters, given the way we’ve set up the VGA’s hardware; it’s the act of ORing itself, and the value 0FEH forces the compiler to perform the OR operation.) Again, this is the normal way in which modes 0EH, 0FH, 10H, and 12H operate. As described earlier, <code>EVGADot</code> also assumes that the VGA is set up so that each pixel drawn in the above-mentioned manner will be drawn in the correct color.</p>
<p>Given those assumptions, <code>EVGADot</code> becomes a surprisingly simple function. First, <code>EVGADot</code> builds a far pointer that points to the byte of display memory controlling the pixel to be drawn. Second, a mask is generated consisting of zeros for all bits except the bit controlling the pixel to be drawn. Third, the Bit Mask register is set to that mask, so that when display memory is read and then written, all bits except the one that controls the pixel to be drawn will be left unmodified.</p>
<p>Finally, 0FEH is ORed with the display memory byte controlling the pixel to be drawn. ORing with 0FEH first reads display memory, thereby loading the VGA’s internal latches with the contents of the display memory byte controlling the pixel to be drawn, and then writes to display memory with the value 0FEH. Because of the unusual way in which the VGA’s data paths work and the way in which <code>EVGALine</code> sets up the VGA’s Enable Set/Reset and Set/Reset registers, the value that is written by the <code>OR</code> instruction is ignored. Instead, the value that actually gets placed in display memory is the color that was passed to <code>EVGALine</code> and placed in the Set/Reset register. The Bit Mask register, which was set up in step three above, allows only the single bit controlling the pixel to be drawn to be set to this color value. For more on the various machineries the VGA brings to bear on graphics data, look back to Chapter 25.</p>
<p>The result of all this is simply a single pixel drawn in the color set up in <code>EVGALine</code>. <code>EVGADot</code> may seem excessively complex for a function that does nothing more that draw one pixel, but programming the VGA isn’t trivial (as we’ve seen in the early chapters of this part). Besides, while the explanation of <code>EVGADot</code> is lengthy, the code itself is only five lines long.</p>
<p>Line drawing would be somewhat faster if the code of <code>EVGADot</code> were made an inline part of <code>Octant0</code> and <code>Octant1</code>, thereby saving the overhead of preparing parameters and calling the function. Feel free to do this if you wish; I maintained <code>EVGADot</code> as a separate function for clarity and for ease of inserting a pixel-drawing function for a different graphics adapter, should that be desired. If you do install a pixel-drawing function for a different adapter, or a fundamentally different mode such as a 256-color SuperVGA mode, remember to remove the hardware-dependent <code>outportb</code> lines in <code>EVGALine</code> itself.</p>
</section>
</section>
<section id="comments-on-the-c-implementation" class="level3">
<h3><a href="#comments-on-the-c-implementation">Comments on the C Implementation</a></h3>
<p><code>EVGALine</code> does no error checking whatsoever. My assumption in writing <code>EVGALine</code> was that it would be ultimately used as the lowest-level primitive of a graphics software package, with operations such as error checking and clipping performed at a higher level. Similarly, <code>EVGALine</code> is tied to the VGA’s screen coordinate system of (0,0) to (639,199) (in mode 0EH), (0,0) to (639,349) (in modes 0FH and 10H), or (0,0) to (639,479) (in mode 12H), with the upper left corner considered to be (0,0). Again, transformation from any coordinate system to the coordinate system used by <code>EVGALine</code> can be performed at a higher level. <code>EVGALine</code> is specifically designed to do one thing: draw lines into the display memory of the VGA. Additional functionality can be supplied by the code that calls <code>EVGALine</code>.</p>
<p>The version of <code>EVGALine</code> shown in Listing 35.1 is reasonably fast, but it is not as fast as it might be. Inclusion of <code>EVGADot</code> directly into <code>Octant0</code> and <code>Octant1</code>, and, indeed, inclusion of <code>Octant0</code> and <code>Octant1</code> directly into <code>EVGALine</code> would speed execution by saving the overhead of calling and parameter passing. Handpicked register variables might speed performance as well, as would the use of word <code>OUT</code>s rather than byte <code>OUT</code>s. A more significant performance increase would come from eliminating separate calculation of the address and mask for each pixel. Since the location of each pixel relative to the previous pixel is known, the address and mask could simply be adjusted from one pixel to the next, rather than recalculated from scratch.</p>
<p>These enhancements are not incorporated into the code in Listing 35.1 for a couple of reasons. One reason is that it’s important that the workings of the algorithm be clearly visible in the code, for learning purposes. Once the implementation is understood, rewriting it for improved performance would certainly be a worthwhile exercise. Another reason is that when flat-out speed is needed, assembly language is the best way to go. Why produce hard-to-understand C code to boost speed a bit when assembly-language code can perform the same task at two or more times the speed?</p>
<p>Given which, a high-speed assembly language version of <code>EVGALine</code> would seem to be a logical next step.</p>
</section>
<section id="bresenhams-algorithm-in-assembly" class="level3">
<h3><a href="#bresenhams-algorithm-in-assembly">Bresenham’s Algorithm in Assembly</a></h3>
<p>Listing 35.3 is a high-performance implementation of Bresenham’s algorithm, written entirely in assembly language. The code is callable from C just as is Listing 35.1, with the same name, <code>EVGALine</code>, and with the same parameters. Either of the two can be linked to any program that calls <code>EVGALine</code>, since they appear to be identical to the calling program. The only difference between the two versions is that the sample program in Listing 35.2 runs over three times as fast on a 486 with an ISA-bus VGA when calling the assembly-language version of <code>EVGALine</code> as when calling the C version, and the difference would be considerably greater yet on a local bus, or with the use of write mode 3. Link each version with Listing 35.2 and compare performance—the difference is startling.</p>
<p><strong>LISTING 35.3 L35-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Fast assembler implementation of Bresenham&#39;s line-drawing algorithm</span>
<span class="co">; for the EGA and VGA. Works in modes 0Eh, 0Fh, 10h, and 12h.</span>
<span class="co">; Borland C++ near-callable.</span>
<span class="co">; Bit mask accumulation technique when |DeltaX| &gt;= |DeltaY|</span>
<span class="co">;  suggested by Jim Mackraz.</span>
<span class="co">;</span>
<span class="co">; Assembled with TASM</span>
<span class="co">;</span>
<span class="co">; By Michael Abrash</span>
<span class="co">;</span>
<span class="co">;****************************************************************</span>
<span class="co">; C-compatible line-drawing entry point at _EVGALine.           *</span>
<span class="co">; Near C-callable as:                                           *</span>
<span class="co">;       EVGALine(X0, Y0, X1, Y1, Color);                        *</span>
<span class="co">;****************************************************************</span>
<span class="co">;</span>

       model small
       .code

<span class="co">;</span>
<span class="co">; Equates.</span>
<span class="co">;</span>
EVGA_SCREEN_WIDTH_IN_BYTES  <span class="dt">equ</span>  <span class="dv">80</span>        <span class="co">;memory offset from start of</span>
                                           <span class="co">; one row to start of next</span>
                                           <span class="co">; in display memory</span>
EVGA_SCREEN_SEGMENT         <span class="dt">equ</span><span class="bn">  0a000h    </span><span class="co">;display memory segment</span>
GC_INDEX                    <span class="dt">equ</span><span class="bn">  3ceh      </span><span class="co">;Graphics Controller</span>
                                           <span class="co">; Index register port</span>
SET_RESET_INDEX             <span class="dt">equ</span>  <span class="dv">0</span>         <span class="co">;indexes of needed</span>
ENABLE_SET_RESET_INDEX      <span class="dt">equ</span>  <span class="dv">1</span>         <span class="co">; Graphics Controller</span>
BIT_MASK_INDEX              <span class="dt">equ</span>  <span class="dv">8</span>         <span class="co">; registers</span>

<span class="co">;</span>
<span class="co">; Stack frame.</span>
<span class="co">;</span>
EVGALineParms   <span class="kw">struc</span>
                <span class="dt">dw</span>      ?               <span class="co">;pushed BP</span>
                <span class="dt">dw</span>      ?               <span class="co">;pushed return address (make double</span>
                                        <span class="co">; word for far call)</span>
X0              <span class="dt">dw</span>      ?               <span class="co">;starting X coordinate of line</span>
Y0              <span class="dt">dw</span>      ?               <span class="co">;starting Y coordinate of line</span>
X1              <span class="dt">dw</span>      ?               <span class="co">;ending X coordinate of line</span>
Y1              <span class="dt">dw</span>      ?               <span class="co">;ending Y coordinate of line</span>
Color           <span class="dt">db</span>      ?               <span class="co">;color of line</span>
                <span class="dt">db</span>      ?               <span class="co">;dummy to pad to word size</span>
EVGALineParms   ends

<span class="co">;****************************************************************</span>
<span class="co">; Line drawing macros.                                          *</span>
<span class="co">;****************************************************************</span>

<span class="co">;</span>
<span class="co">; Macro to loop through length of line, drawing each pixel in turn.</span>
<span class="co">; Used for case of |DeltaX| &gt;= |DeltaY|.</span>
<span class="co">; Input:</span>
<span class="co">;       MOVE_LEFT: 1 if DeltaX &lt; 0, 0 else</span>
<span class="co">;       AL: pixel mask for initial pixel</span>
<span class="co">;       BX: |DeltaX|</span>
<span class="co">;       DX: address of GC data register, with index register set to</span>
<span class="co">;               index of Bit Mask register</span>
<span class="co">;       SI: DeltaY</span>
<span class="co">;       ES:DI: display memory address of byte containing initial</span>
<span class="co">;               pixel</span>
<span class="co">;</span>
LINE1   macro   MOVE_LEFT
        local   LineLoop, MoveXCoord, NextPixel, Line1End
        local   MoveToNextByte, ResetBitMaskAccumulator
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">bx</span>                   <span class="co">;# of pixels in line</span>
        <span class="kw">jcxz</span>    Line1End                <span class="co">;done if there are no more pixels</span>
                                        <span class="co">; (there&#39;s always at least the one pixel</span>
                                        <span class="co">; at the start location)</span>
        <span class="kw">shl</span>     <span class="kw">si</span>,<span class="dv">1</span>                    <span class="co">;DeltaY * 2</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">si</span>                   <span class="co">;error term</span>
        <span class="kw">sub</span>     <span class="kw">bp</span>,<span class="kw">bx</span>                   <span class="co">;error term starts at DeltaY * 2 - DeltaX</span>
        <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>                    <span class="co">;DeltaX * 2</span>
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">bx</span>                   <span class="co">;DeltaY * 2 - DeltaX * 2 (used in loop)</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,<span class="kw">si</span>                   <span class="co">;DeltaY * 2 (used in loop)</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">al</span>                   <span class="co">;set aside pixel mask for initial pixel</span>
                                        <span class="co">; with AL (the pixel mask accumulator) set</span>
                                        <span class="co">; for the initial pixel</span>
<span class="fu">LineLoop:</span>
<span class="co">;</span>
<span class="co">; See if it&#39;s time to advance the Y coordinate yet.</span>
<span class="co">;</span>
        <span class="kw">and</span>     <span class="kw">bp</span>,<span class="kw">bp</span>                   <span class="co">;see if error term is negative</span>
        <span class="kw">js</span>      MoveXCoord              <span class="co">;yes, stay at the same Y coordinate</span>
<span class="co">;</span>
<span class="co">; Advance the Y coordinate, first writing all pixels in the current</span>
<span class="co">; byte, then move the pixel mask either left or right, depending</span>
<span class="co">; on MOVE_LEFT.</span>
<span class="co">;</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                   <span class="co">;set up bit mask for pixels in this byte</span>
        <span class="kw">xchg</span>    <span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">di</span>],<span class="kw">al</span>
                                        <span class="co">;load latches and write pixels, with bit mask</span>
                                        <span class="co">; preserving other latched bits. Because</span>
                                        <span class="co">; set/reset is enabled for all planes, the</span>
                                        <span class="co">; value written actually doesn&#39;t matter</span>
        <span class="kw">add</span>     <span class="kw">di</span>,EVGA_SCREEN_WIDTH_IN_BYTES   <span class="co">;increment Y coordinate</span>
        <span class="kw">add</span>     <span class="kw">bp</span>,<span class="kw">si</span>                   <span class="co">;adjust error term back down</span>
<span class="co">;</span>
<span class="co">; Move pixel mask one pixel (either right or left, depending</span>
<span class="co">; on MOVE_LEFT), adjusting display memory address when pixel mask wraps.</span>
<span class="co">;</span>
if MOVE_LEFT
        <span class="kw">rol</span>     <span class="kw">ah</span>,<span class="dv">1</span>                    <span class="co">;move pixel mask 1 pixel to the left</span>
else
        <span class="kw">ror</span>     <span class="kw">ah</span>,<span class="dv">1</span>                    <span class="co">;move pixel mask 1 pixel to the right</span>
endif
        <span class="kw">jnc</span>     ResetBitMaskAccumulator <span class="co">;didn&#39;t wrap to next byte</span>
        <span class="kw">jmp</span>     <span class="dt">short</span> MoveToNextByte    <span class="co">;did wrap to next byte</span>
<span class="co">;</span>
<span class="co">; Move pixel mask one pixel (either right or left, depending</span>
<span class="co">; on MOVE_LEFT), adjusting display memory address and writing pixels</span>
<span class="co">; in this byte when pixel mask wraps.</span>
<span class="co">;</span>
<span class="fu">MoveXCoord:</span>
        <span class="kw">add</span>     <span class="kw">bp</span>,<span class="kw">bx</span>                   <span class="co">;increment error term &amp; keep same</span>
if MOVE_LEFT
        <span class="kw">rol</span>     <span class="kw">ah</span>,<span class="dv">1</span>                    <span class="co">;move pixel mask 1 pixel to the left</span>
else
        <span class="kw">ror</span>     <span class="kw">ah</span>,<span class="dv">1</span>                    <span class="co">;move pixel mask 1 pixel to the right</span>
endif
        <span class="kw">jnc</span>     NextPixel               <span class="co">;if still in same byte, no need to</span>
                                        <span class="co">; modify display memory yet</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                   <span class="co">;set up bit mask for pixels in this byte.</span>
        <span class="kw">xchg</span>    <span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">di</span>],<span class="kw">al</span>
                                        <span class="co">;load latches and write pixels, with bit mask</span>
                                        <span class="co">; preserving other latched bits. Because</span>
                                        <span class="co">; set/reset is enabled for all planes, the</span>
                                        <span class="co">; value written actually doesn&#39;t matter</span>
<span class="fu">MoveToNextByte:</span>
if MOVE_LEFT
        <span class="kw">dec</span>     <span class="kw">di</span>                      <span class="co">;next pixel is in byte to left</span>
else
        <span class="kw">inc</span>     <span class="kw">di</span>                      <span class="co">;next pixel is in byte to right</span>
endif
<span class="fu">ResetBitMaskAccumulator:</span>
        <span class="kw">sub</span>     <span class="kw">al</span>,<span class="kw">al</span>                   <span class="co">;reset pixel mask accumulator</span>
<span class="fu">NextPixel:</span>
        <span class="kw">or</span>      <span class="kw">al</span>,<span class="kw">ah</span>                   <span class="co">;add the next pixel to the pixel mask</span>
                                        <span class="co">; accumulator</span>
        <span class="kw">loop</span>    LineLoop
<span class="co">;</span>
<span class="co">; Write the pixels in the final byte.</span>
<span class="co">;</span>
<span class="fu">Line1End:</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                   <span class="co">;set up bit mask for pixels in this byte</span>
        <span class="kw">xchg</span>    <span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">di</span>],<span class="kw">al</span>
                                        <span class="co">;load latches and write pixels, with bit mask</span>
                                        <span class="co">; preserving other latched bits. Because</span>
                                        <span class="co">; set/reset is enabled for all planes, the</span>
                                        <span class="co">; value written actually doesn&#39;t matter</span>
        endm

<span class="co">;</span>
<span class="co">; Macro to loop through length of line, drawing each pixel in turn.</span>
<span class="co">; Used for case of DeltaX &lt; DeltaY.</span>
<span class="co">; Input:</span>
<span class="co">;       MOVE_LEFT: 1 if DeltaX &lt; 0, 0 else</span>
<span class="co">;       AL: pixel mask for initial pixel</span>
<span class="co">;       BX: |DeltaX|</span>
<span class="co">;       DX: address of GC data register, with index register set to</span>
<span class="co">;               index of Bit Mask register</span>
<span class="co">;       SI: DeltaY</span>
<span class="co">;       ES:DI: display memory address of byte containing initial</span>
<span class="co">;               pixel</span>
<span class="co">;</span>
LINE2   macro   MOVE_LEFT
        local   LineLoop, MoveYCoord, ETermAction, Line2End
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">si</span>                  <span class="co">;# of pixels in line</span>
        <span class="kw">jcxz</span>    Line2End               <span class="co">;done if there are no more pixels</span>
        <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>                   <span class="co">;DeltaX * 2</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">bx</span>                  <span class="co">;error term</span>
        <span class="kw">sub</span>     <span class="kw">bp</span>,<span class="kw">si</span>                  <span class="co">;error term starts at DeltaX * 2 - DeltaY</span>
        <span class="kw">shl</span>     <span class="kw">si</span>,<span class="dv">1</span>                   <span class="co">;DeltaY * 2</span>
        <span class="kw">sub</span>     <span class="kw">bx</span>,<span class="kw">si</span>                  <span class="co">;DeltaX * 2 - DeltaY * 2 (used in loop)</span>
        <span class="kw">add</span>     <span class="kw">si</span>,<span class="kw">bx</span>                  <span class="co">;DeltaX * 2 (used in loop)</span>
<span class="co">;</span>
<span class="co">; Set up initial bit mask &amp; write initial pixel.</span>
<span class="co">;</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">xchg</span>    <span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">di</span>],<span class="kw">ah</span>
                                       <span class="co">;load latches and write pixel, with bit mask</span>
                                       <span class="co">; preserving other latched bits. Because</span>
                                       <span class="co">; set/reset is enabled for all planes, the</span>
                                       <span class="co">; value written actually doesn&#39;t matter</span>
<span class="fu">LineLoop:</span>
<span class="co">;</span>
<span class="co">; See if it&#39;s time to advance the X coordinate yet.</span>
<span class="co">;</span>
        <span class="kw">and</span>     <span class="kw">bp</span>,<span class="kw">bp</span>                  <span class="co">;see if error term is negative</span>
        <span class="kw">jns</span>     ETermAction            <span class="co">;no, advance X coordinate</span>
        <span class="kw">add</span>     <span class="kw">bp</span>,<span class="kw">si</span>                  <span class="co">;increment error term &amp; keep same</span>
        <span class="kw">jmp</span>     <span class="dt">short</span> MoveYCoord       <span class="co">; X coordinate</span>
<span class="fu">ETermAction:</span>
<span class="co">;</span>
<span class="co">; Move pixel mask one pixel (either right or left, depending</span>
<span class="co">; on MOVE_LEFT), adjusting display memory address when pixel mask wraps.</span>
<span class="co">;</span>
if MOVE_LEFT
        <span class="kw">rol</span>     <span class="kw">al</span>,<span class="dv">1</span>
        <span class="kw">sbb</span>     <span class="kw">di</span>,<span class="dv">0</span>
else
        <span class="kw">ror</span>     <span class="kw">al</span>,<span class="dv">1</span>
        <span class="kw">adc</span>     <span class="kw">di</span>,<span class="dv">0</span>
endif
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                  <span class="co">;set new bit mask</span>
        <span class="kw">add</span>     <span class="kw">bp</span>,<span class="kw">bx</span>                  <span class="co">;adjust error term back down</span>
<span class="co">;</span>
<span class="co">; Advance Y coordinate.</span>
<span class="co">;</span>
<span class="fu">MoveYCoord:</span>
        <span class="kw">add</span>     <span class="kw">di</span>,EVGA_SCREEN_WIDTH_IN_BYTES
<span class="co">;</span>
<span class="co">; Write the next pixel.</span>
<span class="co">;</span>
        <span class="kw">xchg</span>    <span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">di</span>],<span class="kw">ah</span>
                                       <span class="co">;load latches and write pixel, with bit mask</span>
                                       <span class="co">; preserving other latched bits. Because</span>
                                       <span class="co">; set/reset is enabled for all planes, the</span>
                                       <span class="co">; value written actually doesn&#39;t matter</span>
<span class="co">;</span>
        <span class="kw">loop</span>    LineLoop
<span class="fu">Line2End:</span>
        endm

<span class="co">;****************************************************************</span>
<span class="co">; Line drawing routine.                                         *</span>
<span class="co">;****************************************************************</span>

        public  _EVGALine
_EVGALine       proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>
        <span class="kw">push</span>    <span class="kw">si</span>                     <span class="co">;preserve register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">push</span>    <span class="kw">ds</span>
<span class="co">;</span>
<span class="co">; Point DS to display memory.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,EVGA_SCREEN_SEGMENT
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Set the Set/Reset and Set/Reset Enable registers for</span>
<span class="co">; the selected color.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,SET_RESET_INDEX
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,[<span class="kw">bp</span>+Color]
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,ENABLE_SET_RESET_INDEX
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ffh</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
<span class="co">;</span>
<span class="co">; Get DeltaY.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+Y1]                 <span class="co">;line Y start</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+Y0]                 <span class="co">;line Y end, used later in</span>
                                               <span class="co">;calculating the start address</span>
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">ax</span>                          <span class="co">;calculate DeltaY</span>
        <span class="kw">jns</span>     CalcStartAddress               <span class="co">;if positive, we&#39;re set</span>
<span class="co">;</span>
<span class="co">; DeltaY is negative — swap coordinates so we&#39;re always working</span>
<span class="co">; with a positive DeltaY.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+Y1]                 <span class="co">;set line start to Y1, for use</span>
                                               <span class="co">; in calculating the start address</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bp</span>+X0]
        <span class="kw">xchg</span>    <span class="kw">dx</span>,[<span class="kw">bp</span>+X1]
        <span class="kw">mov</span>     [<span class="kw">bp</span>+X0],<span class="kw">dx</span>                 <span class="co">;swap X coordinates</span>
        <span class="kw">neg</span>     <span class="kw">si</span>                             <span class="co">;convert to positive DeltaY</span>
<span class="co">;</span>
<span class="co">; Calculate the starting address in display memory of the line.</span>
<span class="co">; Hardwired for a screen width of 80 bytes.</span>
<span class="co">;</span>
<span class="fu">CalcStartAddress:</span>
        <span class="kw">shl</span>     <span class="kw">ax</span>,<span class="dv">1</span>                   <span class="co">;Y0 * 2 ;Y0 is already in AX</span>
        <span class="kw">shl</span>     <span class="kw">ax</span>,<span class="dv">1</span>                   <span class="co">;Y0 * 4</span>
        <span class="kw">shl</span>     <span class="kw">ax</span>,<span class="dv">1</span>                   <span class="co">;Y0 * 8</span>
        <span class="kw">shl</span>     <span class="kw">ax</span>,<span class="dv">1</span>                   <span class="co">;Y0 * 16</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">ax</span>
        <span class="kw">shl</span>     <span class="kw">ax</span>,<span class="dv">1</span>                   <span class="co">;Y0 * 32</span>
        <span class="kw">shl</span>     <span class="kw">ax</span>,<span class="dv">1</span>                   <span class="co">;Y0 * 64</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>                  <span class="co">;Y0 * 80</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bp</span>+X0]
        <span class="kw">mov</span>     <span class="kw">cl</span>,<span class="kw">dl</span>                  <span class="co">;set aside lower 3 bits of column for</span>
        <span class="kw">and</span>     <span class="kw">cl</span>,<span class="dv">7</span>                   <span class="co">; pixel masking</span>
        <span class="kw">shr</span>     <span class="kw">dx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">dx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">dx</span>,<span class="dv">1</span>                   <span class="co">;get byte address of column (X0/8)</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">dx</span>                  <span class="co">;offset of line start in display segment</span>
<span class="co">;</span>
<span class="co">; Set up GC Index register to point to the Bit Mask register.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,BIT_MASK_INDEX
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>                     <span class="co">;leave DX pointing to the GC Data register</span>
<span class="co">;</span>
<span class="co">; Set up pixel mask (in-byte pixel address).</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,80h</span>
        <span class="kw">shr</span>     <span class="kw">al</span>,<span class="kw">cl</span>
<span class="co">;</span>
<span class="co">; Calculate DeltaX.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+X1]
        <span class="kw">sub</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+X0]
<span class="co">;</span>
<span class="co">; Handle correct one of four octants.</span>
<span class="co">;</span>
        <span class="kw">js</span>      NegDeltaX
        <span class="kw">cmp</span>     <span class="kw">bx</span>,<span class="kw">si</span>
        <span class="kw">jb</span>      Octant1
<span class="co">;</span>
<span class="co">; DeltaX &gt;= DeltaY &gt;= 0.</span>
<span class="co">;</span>
        LINE1   <span class="dv">0</span>
        <span class="kw">jmp</span>     EVGALineDone
<span class="co">;</span>
<span class="co">; DeltaY &gt; DeltaX &gt;= 0.</span>
<span class="co">;</span>
<span class="fu">Octant1:</span>
        LINE2   <span class="dv">0</span>
        <span class="kw">jmp</span>     <span class="dt">short</span> EVGALineDone
<span class="co">;</span>
<span class="fu">NegDeltaX:</span>
        <span class="kw">neg</span>     <span class="kw">bx</span>      <span class="co">;|DeltaX|</span>
        <span class="kw">cmp</span>     <span class="kw">bx</span>,<span class="kw">si</span>
        <span class="kw">jb</span>      Octant2
<span class="co">;</span>
<span class="co">; |DeltaX| &gt;= DeltaY and DeltaX &lt; 0.</span>
<span class="co">;</span>
        LINE1   <span class="dv">1</span>
        <span class="kw">jmp</span>     <span class="dt">short</span> EVGALineDone
<span class="co">;</span>
<span class="co">; |DeltaX| &lt; DeltaY and DeltaX &lt; 0.</span>
<span class="co">;</span>
<span class="fu">Octant2:</span>
        LINE2   <span class="dv">1</span>
<span class="co">;</span>
<span class="fu">EVGALineDone:</span>
<span class="co">;</span>
<span class="co">; Restore EVGA state.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ffh</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                  <span class="co">;set Bit Mask register to 0ffh</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,ENABLE_SET_RESET_INDEX
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">sub</span>     <span class="kw">al</span>,<span class="kw">al</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                  <span class="co">;set Enable Set/Reset register to 0</span>
<span class="co">;</span>
        <span class="kw">pop</span>     <span class="kw">ds</span>
        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>
        <span class="kw">ret</span>
_EVGALine       endp

        end</code></pre>
<p>An explanation of the workings of the code in Listing 35.3 would be a lengthy one, and would be redundant since the basic operation of the code in Listing 35.3 is no different from that of the code in Listing 35.1, although the implementation is much changed due to the nature of assembly language and also due to designing for speed rather than for clarity. Given that you thoroughly understand the C implementation in Listing 35.1, the assembly language implementation in Listing 35.3, which is well-commented, should speak for itself.</p>
<p>One point I do want to make is that Listing 35.3 incorporates a clever notion for which credit is due Jim Mackraz, who described the notion in a letter written in response to an article I wrote long ago in the late and lamented <em>Programmer’s Journal</em>. Jim’s suggestion was that when drawing lines for which |<code>DeltaX</code>| is greater than |<code>DeltaY</code>|, bits set to 1 for each of the pixels controlled by a given byte can be accumulated in a register, rather than drawing each pixel individually. All the pixels controlled by that byte can then be drawn at once, with a single access to display memory, when all pixel processing associated with that byte has been completed. This approach can save many <code>OUT</code>s and many display memory reads and writes when drawing nearly-horizontal lines, and that’s important because EGAs and VGAs hold the CPU up for a considerable period of time on each I/O operation and display memory access.</p>
<p>All too many PC programmers fall into the high-level-language trap of thinking that a good algorithm guarantees good performance. Not so: As our two implementations of Bresenham’s algorithm graphically illustrate (pun not originally intended, but allowed to stand once recognized), truly great PC code requires both a good algorithm <em>and</em> a good assembly implementation. In Listing 35.3, we’ve got y-oh-my, isn’t it fun?</p>
</section>
</section>
<section id="chapter-36-the-good-the-bad-and-the-run-sliced" class="level2">
<h2><a href="#chapter-36-the-good-the-bad-and-the-run-sliced">Chapter 36 – The Good, the Bad, and the Run-Sliced</a></h2>
<section id="faster-bresenham-lines-with-run-length-slice-line-drawing" class="level3">
<h3><a href="#faster-bresenham-lines-with-run-length-slice-line-drawing">Faster Bresenham Lines with Run-Length Slice Line Drawing</a></h3>
<p>Years ago, I worked at a company that asked me to write blazingly fast line-drawing code for an AutoCAD driver. I implemented the basic Bresenham’s line-drawing algorithm; streamlined it as much as possible; special-cased horizontal, diagonal, and vertical lines; broke out separate, optimized routines for lines in each octant; and massively unrolled the loops. When I was done, I had line drawing down to a mere five or six instructions per pixel, and I handed the code over to the AutoCAD driver person, content in the knowledge that I had pushed the theoretical limits of the Bresenham’s algorithm on the 80x86 architecture, and that this was as fast as line drawing could get on a PC. That feeling lasted for about a week, until Dave Miller, who these days is a Windows display-driver whiz at Engenious Solutions, casually mentioned Bresenham’s faster run-length slice line-drawing algorithm.</p>
<p>Remember Bill Murray’s safety tip in <em>Ghostbusters</em>? It goes something like this. Harold Ramis tells the Ghostbusters not to cross the beams of the antighost guns. “Why?” Murray asks.</p>
<p>“It would be bad,” Ramis says.</p>
<p>Murray says, “I’m fuzzy on the whole good/bad thing. What exactly do you mean by ‘bad’?” It turns out that what Ramis means by bad is basically the destruction of the universe.</p>
<p>“Important safety tip,” Murray comments dryly.</p>
<p>I learned two important safety tips from my line-drawing experience; neither involves the possible destruction of the universe, so far as I know, but they are nonetheless worth keeping in mind. First, never, never, never think you’ve written the fastest possible code. Odds are, you haven’t. Run your code past another good programmer, and he or she will probably say, “But why don’t you do this?” and you’ll realize that you could indeed do that, and your code would then be faster. Or relax and come back to your code later, and you may well see another, faster approach. There are a million ways to implement code for any task, and you can almost always find a faster way if you need to.</p>
<p>Second, when performance matters, never have your code perform the same calculation more than once. This sounds obvious, but it’s astonishing how often it’s ignored. For example, consider this snippet of code:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;RunLength; i++)
{
   *WorkingScreenPtr = Color;
   <span class="kw">if</span> (XDelta &gt; <span class="dv">0</span>)
   {
      WorkingScreenPtr++;
   }
   <span class="kw">else</span>
   {
      WorkingScreenPtr--;
   }
}</code></pre>
<p>Here, the programmer knows which way the line is going before the main loop begins—but nonetheless performs that test every time through the loop, when calculating the address of the next pixel. Far better to perform the test only once, outside the loop, as shown here:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (XDelta &gt; <span class="dv">0</span>)
{
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;RunLength; i++)
   {
      *WorkingScreenPtr++ = Color;
   }
}
<span class="kw">else</span>
{
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;RunLength; i++)
   {
      *WorkingScreenPtr-- = Color;
   }
}</code></pre>
<p>Think of it this way: A program is a state machine. It takes a set of inputs and produces a corresponding set of outputs by passing through a set of states. Your primary job as a programmer is to implement the desired state machine. Your additional job as a performance programmer is to minimize the lengths of the paths through the state machine. This means performing as many tests and calculations as possible outside the loops, so that the loops themselves can do as little work—that is, pass through as few states—as possible.</p>
<p>Which brings us full circle to Bresenham’s run-length slice line-drawing algorithm, which just happens to be an excellent example of a minimized state machine. In case you’re fuzzy on the good/bad performance thing, that’s “good”—as in <em>fast</em>.</p>
</section>
<section id="run-length-slice-fundamentals" class="level3">
<h3><a href="#run-length-slice-fundamentals">Run-Length Slice Fundamentals</a></h3>
<p>First off, I have a confession to make: I’m not sure that the algorithm I’ll discuss is actually, precisely Bresenham’s run-length slice algorithm. It’s been a long time since I read about this algorithm; in the intervening years, I’ve misplaced Bresenham’s article, and have been unable to unearth it. As a result, I had to derive the algorithm from scratch, which was admittedly more fun than reading about it, and also ensured that I understood it inside and out. The upshot is that what I discuss may or may not be Bresenham’s run-length slice algorithm—but it surely is fast.</p>
<p>The place to begin understanding the run-length slice algorithm is the standard Bresenham’s line-drawing algorithm. (I discussed the standard Bresenham’s line-drawing algorithm at length in the previous chapter.) The basis of the standard approach is stepping one pixel at a time along the major axis (the longer dimension of the line), while maintaining an integer error term that indicates at each major-axis step how close the line is to advancing halfway to the next pixel along the minor axis. Figure 36.1 illustrates standard Bresenham’s line drawing. The key point here is that a calculation and a test are performed once for each step along the major axis.</p>
<figure>
<img src="images/36-01.jpg" alt="Figure 36.1  Standard Bresenham’s line drawing." /><figcaption><strong>Figure 36.1</strong>  <em>Standard Bresenham’s line drawing.</em></figcaption>
</figure>
<p>The run-length slice algorithm rotates matters 90 degrees, with salubrious results. The basis of the run-length slice algorithm is stepping one pixel at a time along the minor axis (the shorter dimension), while maintaining an integer error term indicating how close the line is to advancing an extra pixel along the major axis, as illustrated by Figure 36.2.</p>
<p>Consider this: When you’re called upon to draw a line with an X-dimension of 35 and a Y-dimension of 10, you have a great deal of information available, some of which is ignored by standard Bresenham’s. In particular, because the slope is between 1/3 and 1/4, you know that every single run—a <em>run</em> being a set of pixels at the same minor-axis coordinate—must be either three or four pixels long. No other length is possible, as shown in Figure 36.3 (apart from the first and last runs, which are special cases that I’ll discuss shortly). Therefore, for this line, there’s no need to perform an error-term calculation and test for each pixel. Instead, we can just perform one test per run, to see whether the run is three or four pixels long, thereby eliminating about 70 percent of the calculations in drawing this line.</p>
<p>Take a moment to let the idea behind run-length slice drawing soak in. Periodic decisions must be made to control pixel placement. The key to speed is to make those decisions as infrequently and as quickly as possible. Of course, it will work to make a decision at each pixel—that’s standard Bresenham’s. However, most of those per-pixel decisions are redundant, and in fact we have enough information before we begin drawing to know which are the redundant decisions. Run-length slice drawing is exactly equivalent to standard Bresenham’s, but it pares the decision-making process down to a minimum. It’s somewhat analogous to the difference between finding the greatest common divisor of two numbers using Euclid’s algorithm and finding it by trying every possible divisor. Both approaches produce the desired result, but that which takes maximum advantage of the available information and minimizes redundant work is preferable.</p>
<figure>
<img src="images/36-02.jpg" alt="Figure 36.2  Run-length slice line drawing." /><figcaption><strong>Figure 36.2</strong>  <em>Run-length slice line drawing.</em></figcaption>
</figure>
<figure>
<img src="images/36-03.jpg" alt="Figure 36.3  Runs in a slope 1/3.5 line." /><figcaption><strong>Figure 36.3</strong>  <em>Runs in a slope 1/3.5 line.</em></figcaption>
</figure>
</section>
<section id="run-length-slice-implementation" class="level3">
<h3><a href="#run-length-slice-implementation">Run-Length Slice Implementation</a></h3>
<p>We know that for any line, a given run will always be one of two possible lengths. How, though, do we know which length to select? Surprisingly, this is easy to determine. For the following discussion, assume that we have a slope of 1/3.5, so that X is the major axis; however, the discussion also applies to Y-major lines, with X and Y reversed.</p>
<p>The minimum possible length for any run in an X-major line is <code>int(XDelta/YDelta)</code>, where <code>XDelta</code> is the X-dimension of the line and <code>YDelta</code> is the Y-dimension. The maximum possible length is <code>int(XDelta/YDelta)+ 1</code>. The trick, then, is knowing which of these two lengths to select for each run. To see how we can make this selection, refer to Figure 36.4. For each one-pixel step along the minor axis (Y, in this case), we advance at least three pixels. The full advance distance along X (the major axis) is actually three-plus pixels, because there is also a fractional portion to the advance along X for a single-pixel Y step. This fractional advance is the key to deciding when to add an extra pixel to a run. The fraction indicates what portion of an extra pixel we advance along X (the major axis) during each run. If we keep a running sum of the fractional parts, we have a measure of how close we are to needing an extra pixel; when the fractional sum reaches 1, it’s time to add an extra pixel to the current run. Then, we can subtract 1 from the running sum (because we just advanced one pixel), and continue on.</p>
<figure>
<img src="images/36-04.jpg" alt="Figure 36.4  How the error term determines run length." /><figcaption><strong>Figure 36.4</strong>  <em>How the error term determines run length.</em></figcaption>
</figure>
<p>Practically speaking, however, we can’t work with fractions because floating-point arithmetic is slow and fixed-point arithmetic is imprecise. Therefore, we take a cue from standard Bresenham’s and scale all the error-term calculations up so that we can work with integers. The fractional X (major axis) advance per one-pixel Y (minor axis) advance is the fractional portion of <code>XDelta/YDelta</code>. This value is exactly equivalent <code>to (XDelta % YDelta)/YDelta</code>. We’ll scale this up by multiplying it by <code>YDelta*2</code>, so that the amount by which we adjust the error term up for each one-pixel minor-axis advance is <code>(XDelta % YDelta)*2</code>.</p>
<p>We’ll similarly scale up the one pixel by which we adjust the error term down after it turns over, so our downward error-term adjustment is <code>YDelta*2</code>. Therefore, before drawing each run, we’ll add <code>(XDelta % YDelta)*2</code> to the error term. If the error term runs over (reaches one full pixel), we’ll lengthen the run by 1, and subtract <code>YDelta*2</code> from the error term. (All values are multiplied by 2 so that the initial error term, which involves a 0.5 term, can be scaled up to an integer, as discussed next.)</p>
<p>This is not a complicated process; it involves only integer addition and subtraction and a single test, and it lends itself to many and varied optimizations. For example, you could break out hardwired optimizations for drawing each possible pair of run lengths. For the aforementioned line with a slope of 1/3.5, for example, you could have one routine hardwired to blast in a run of three pixels as quickly as possible, and another hardwired to blast in a run of four pixels. These routines would ideally have no looping, but rather just a series of instructions customized to draw the desired number of pixels at maximum speed. Each routine would know that the only possibilities for the length of the next run would be three and four, so they could increment the error term, then jump directly to the appropriate one of the two routines depending on whether the error term turned over. Properly implemented, it should be possible to reduce the average per-run overhead of line drawing to less than one branch, with only two additions and two tests (the number of runs must also be counted down), plus a subtraction half the time. On a 486, this amounts to something on the order of 150 nanoseconds of overhead per pixel, exclusive of the time required to actually write the pixel to display memory.</p>
<p>That’s good.</p>
</section>
<section id="run-length-slice-details" class="level3">
<h3><a href="#run-length-slice-details">Run-Length Slice Details</a></h3>
<p>A couple of run-length slice implementation details yet remain. First is the matter of how error-term turnover is detected. This is done in much the same way as it is with standard Bresenham’s: The error term is maintained as a negative valve and advances for each step; when the error term reaches 0, it’s time to add an extra pixel to the current run. This means that we only have to test for carry after advancing the error term to determine whether or not to add an extra pixel to each run. (Actually, the code in this chapter tests for the error term being greater than zero, but the assembly code in the next chapter will use the very efficient carry approach.)</p>
<p>The second and more difficult detail is balancing the runs so that they’re centered around the ideal line, and therefore draw the same pixels that standard Bresenham’s would draw. If we just drew full-length runs from the start, we’d end up with an unbalanced line, as shown in Figure 36.5. Instead, we have to split the initial pixel plus one full run as evenly as possible between the first and last runs of the line, and adjust the initial error term appropriately for the initial half-run.</p>
<p>The initial error term is advanced by one-half of the normal per-step fractional advance, because the initial step is only one-half pixel along the minor axis. This half-step gets us exactly halfway between the initial pixel and the next pixel along the minor axis. All the error-term adjustments are scaled up by two times precisely so that we can scale up this halved error term for the initial run by two times, and thereby make it an integer.</p>
<p>The other trick here is that if an odd number of pixels are allocated between the first and last partial runs, we’ll end up with an odd pixel, since we are unable to draw a half-pixel. This odd pixel is accounted for by adding half a pixel to the error term.</p>
<p>That’s all there is to run-length slice line drawing; the partial first and last runs are the only tricky part. Listing 36.1 is a run-length slice implementation in C. This is not an optimized implementation, nor is it meant to be; this listing is provided so that you can see how the run-length slice algorithm works. In the next chapter, I’ll move on to an optimized version, but for now, Listing 36.1 will make it much easier to grasp the principles of run-length slice drawing, and to understand the optimized code I’ll present in the next chapter.</p>
<figure>
<img src="images/36-05.jpg" alt="Figure 36.5  Balancing run-length slice lines: a) unbalanced; b) balanced." /><figcaption><strong>Figure 36.5</strong>  <em>Balancing run-length slice lines: a) unbalanced; b) balanced.</em></figcaption>
</figure>
<p><strong>LISTING 36.1 L36-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Run-length slice line drawing implementation for mode 0x13, the VGA&#39;s</span>
<span class="co">320x200 256-color mode. Not optimized! Tested with Borland C++ in</span>
<span class="co">the small model. */</span>

<span class="ot">#include &lt;dos.h&gt;</span>

<span class="ot">#define SCREEN_WIDTH    320</span>
<span class="ot">#define SCREEN_SEGMENT  0xA000</span>

<span class="dt">void</span> DrawHorizontalRun(<span class="dt">char</span> far **ScreenPtr, <span class="dt">int</span> XAdvance, <span class="dt">int</span> RunLength,
                 <span class="dt">int</span> Color);
<span class="dt">void</span> DrawVerticalRun(<span class="dt">char</span> far **ScreenPtr, <span class="dt">int</span> XAdvance, <span class="dt">int</span> RunLength,
                  <span class="dt">int</span> Color);
<span class="co">/* Draws a line between the specified endpoints in color Color. */</span>
<span class="dt">void</span> LineDraw(<span class="dt">int</span> XStart, <span class="dt">int</span> YStart, <span class="dt">int</span> XEnd, <span class="dt">int</span> YEnd, <span class="dt">int</span> Color)
{
   <span class="dt">int</span> Temp, AdjUp, AdjDown, ErrorTerm, XAdvance, XDelta, YDelta;
   <span class="dt">int</span> WholeStep, InitialPixelCount, FinalPixelCount, i, RunLength;
   <span class="dt">char</span> far *ScreenPtr;

   <span class="co">/* We&#39;ll always draw top to bottom, to reduce the number of cases we have to</span>
<span class="co">   handle, and to make lines between the same endpoints draw the same pixels */</span>
   <span class="kw">if</span> (YStart &gt; YEnd) {
      Temp = YStart;
      YStart = YEnd;
      YEnd = Temp;
      Temp = XStart;
      XStart = XEnd;
      XEnd = Temp;
   }
   <span class="co">/* Point to the bitmap address first pixel to draw */</span>
   ScreenPtr = MK_FP(SCREEN_SEGMENT, YStart * SCREEN_WIDTH + XStart);

   <span class="co">/* Figure out whether we&#39;re going left or right, and how far we&#39;re</span>
<span class="co">      going horizontally */</span>
   <span class="kw">if</span> ((XDelta = XEnd - XStart) &lt; <span class="dv">0</span>)
   {
      XAdvance = -<span class="dv">1</span>;
      XDelta = -XDelta;
   }
   <span class="kw">else</span>
   {
      XAdvance = <span class="dv">1</span>;
   }
   <span class="co">/* Figure out how far we&#39;re going vertically */</span>
   YDelta = YEnd - YStart;

   <span class="co">/* Special-case horizontal, vertical, and diagonal lines, for speed</span>
<span class="co">      and to avoid nasty boundary conditions and division by 0 */</span>
   <span class="kw">if</span> (XDelta == <span class="dv">0</span>)
   {
      <span class="co">/* Vertical line */</span>
      <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;=YDelta; i++)
      {
         *ScreenPtr = Color;
         ScreenPtr += SCREEN_WIDTH;
      }
      <span class="kw">return</span>;
   }
   <span class="kw">if</span> (YDelta == <span class="dv">0</span>)
   {
      <span class="co">/* Horizontal line */</span>
      <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;=XDelta; i++)
      {
         *ScreenPtr = Color;
         ScreenPtr += XAdvance;
      }
      <span class="kw">return</span>;
   }
   <span class="kw">if</span> (XDelta == YDelta)
   {
      <span class="co">/* Diagonal line */</span>
      <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;=XDelta; i++)
      {
         *ScreenPtr = Color;
         ScreenPtr += XAdvance + SCREEN_WIDTH;
      }
      <span class="kw">return</span>;
   }

   <span class="co">/* Determine whether the line is X or Y major, and handle accordingly */</span>
   <span class="kw">if</span> (XDelta &gt;= YDelta)
   {
      <span class="co">/* X major line */</span>
      <span class="co">/* Minimum # of pixels in a run in this line */</span>
      WholeStep = XDelta / YDelta;

      <span class="co">/* Error term adjust each time Y steps by 1; used to tell when one</span>
<span class="co">         extra pixel should be drawn as part of a run, to account for</span>
<span class="co">         fractional steps along the X axis per 1-pixel steps along Y */</span>
      AdjUp = (XDelta % YDelta) * <span class="dv">2</span>;

      <span class="co">/* Error term adjust when the error term turns over, used to factor</span>
<span class="co">         out the X step made at that time */</span>
      AdjDown = YDelta * <span class="dv">2</span>;

      <span class="co">/* Initial error term; reflects an initial step of 0.5 along the Y</span>
<span class="co">         axis */</span>
      ErrorTerm = (XDelta % YDelta) - (YDelta * <span class="dv">2</span>);

      <span class="co">/* The initial and last runs are partial, because Y advances only 0.5</span>
<span class="co">         for these runs, rather than 1. Divide one full run, plus the</span>
<span class="co">         initial pixel, between the initial and last runs */</span>
      InitialPixelCount = (WholeStep / <span class="dv">2</span>) + <span class="dv">1</span>;
      FinalPixelCount = InitialPixelCount;

      <span class="co">/* If the basic run length is even and there&#39;s no fractional</span>
<span class="co">         advance, we have one pixel that could go to either the initial</span>
<span class="co">         or last partial run, which we&#39;ll arbitrarily allocate to the</span>
<span class="co">         last run */</span>
      <span class="kw">if</span> ((AdjUp == <span class="dv">0</span>) &amp;&amp; ((WholeStep &amp; <span class="bn">0x01</span>) == <span class="dv">0</span>))
      {
         InitialPixelCount--;
      }
      <span class="co">/* If there&#39;re an odd number of pixels per run, we have 1 pixel that can&#39;t</span>
<span class="co">         be allocated to either the initial or last partial run, so we&#39;ll add 0.5</span>
<span class="co">         to error term so this pixel will be handled by the normal full-run loop */</span>
         <span class="kw">if</span> ((WholeStep &amp; <span class="bn">0x01</span>) != <span class="dv">0</span>)
      {
         ErrorTerm += YDelta;
      }
      <span class="co">/* Draw the first, partial run of pixels */</span>
      DrawHorizontalRun(&amp;ScreenPtr, XAdvance, InitialPixelCount, Color);
      <span class="co">/* Draw all full runs */</span>
      <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;(YDelta<span class="dv">-1</span>); i++)
      {
         RunLength = WholeStep;  <span class="co">/* run is at least this long */</span>
         <span class="co">/* Advance the error term and add an extra pixel if the error</span>
<span class="co">            term so indicates */</span>
         <span class="kw">if</span> ((ErrorTerm += AdjUp) &gt; <span class="dv">0</span>)
         {
            RunLength++;
            ErrorTerm -= AdjDown;   <span class="co">/* reset the error term */</span>
         }
         <span class="co">/* Draw this scan line&#39;s run */</span>
         DrawHorizontalRun(&amp;ScreenPtr, XAdvance, RunLength, Color);
      }
      <span class="co">/* Draw the final run of pixels */</span>
      DrawHorizontalRun(&amp;ScreenPtr, XAdvance, FinalPixelCount, Color);
      <span class="kw">return</span>;
   }
   <span class="kw">else</span>
   {
      <span class="co">/* Y major line */</span>

      <span class="co">/* Minimum # of pixels in a run in this line */</span>
      WholeStep = YDelta / XDelta;

      <span class="co">/* Error term adjust each time X steps by 1; used to tell when 1 extra</span>
<span class="co">         pixel should be drawn as part of a run, to account for</span>
<span class="co">         fractional steps along the Y axis per 1-pixel steps along X */</span>
      AdjUp = (YDelta % XDelta) * <span class="dv">2</span>;

      <span class="co">/* Error term adjust when the error term turns over, used to factor</span>
<span class="co">         out the Y step made at that time */</span>
      AdjDown = XDelta * <span class="dv">2</span>;

      <span class="co">/* Initial error term; reflects initial step of 0.5 along the X axis */</span>
      ErrorTerm = (YDelta % XDelta) - (XDelta * <span class="dv">2</span>);

      <span class="co">/* The initial and last runs are partial, because X advances only 0.5</span>
<span class="co">         for these runs, rather than 1. Divide one full run, plus the</span>
<span class="co">         initial pixel, between the initial and last runs */</span>
      InitialPixelCount = (WholeStep / <span class="dv">2</span>) + <span class="dv">1</span>;
      FinalPixelCount = InitialPixelCount;

      <span class="co">/* If the basic run length is even and there&#39;s no fractional advance, we</span>
<span class="co">         have 1 pixel that could go to either the initial or last partial run,</span>
<span class="co">         which we&#39;ll arbitrarily allocate to the last run */</span>
      <span class="kw">if</span> ((AdjUp == <span class="dv">0</span>) &amp;&amp; ((WholeStep &amp; <span class="bn">0x01</span>) == <span class="dv">0</span>))
      {
         InitialPixelCount--;
      }
      <span class="co">/* If there are an odd number of pixels per run, we have one pixel</span>
<span class="co">         that can&#39;t be allocated to either the initial or last partial</span>
<span class="co">         run, so we&#39;ll add 0.5 to the error term so this pixel will be</span>
<span class="co">         handled by the normal full-run loop */</span>
      <span class="kw">if</span> ((WholeStep &amp; <span class="bn">0x01</span>) != <span class="dv">0</span>)
      {
         ErrorTerm += XDelta;
      }
      <span class="co">/* Draw the first, partial run of pixels */</span>
      DrawVerticalRun(&amp;ScreenPtr, XAdvance, InitialPixelCount, Color);

      <span class="co">/* Draw all full runs */</span>
      <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;(XDelta<span class="dv">-1</span>); i++)
      {
         RunLength = WholeStep;  <span class="co">/* run is at least this long */</span>
         <span class="co">/* Advance the error term and add an extra pixel if the error</span>
<span class="co">            term so indicates */</span>
         <span class="kw">if</span> ((ErrorTerm += AdjUp) &gt; <span class="dv">0</span>)
         {
            RunLength++;
            ErrorTerm -= AdjDown;   <span class="co">/* reset the error term */</span>
         }
         <span class="co">/* Draw this scan line&#39;s run */</span>
         DrawVerticalRun(&amp;ScreenPtr, XAdvance, RunLength, Color);
      }
      <span class="co">/* Draw the final run of pixels */</span>
      DrawVerticalRun(&amp;ScreenPtr, XAdvance, FinalPixelCount, Color);
      <span class="kw">return</span>;
   }
}
<span class="co">/* Draws a horizontal run of pixels, then advances the bitmap pointer to</span>
<span class="co">   the first pixel of the next run. */</span>
<span class="dt">void</span> DrawHorizontalRun(<span class="dt">char</span> far **ScreenPtr, <span class="dt">int</span> XAdvance,
   <span class="dt">int</span> RunLength, <span class="dt">int</span> Color)
{
   <span class="dt">int</span> i;
   <span class="dt">char</span> far *WorkingScreenPtr = *ScreenPtr;

   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;RunLength; i++)
   {
      *WorkingScreenPtr = Color;
      WorkingScreenPtr += XAdvance;
   }
   <span class="co">/* Advance to the next scan line */</span>
   WorkingScreenPtr += SCREEN_WIDTH;
   *ScreenPtr = WorkingScreenPtr;
}
<span class="co">/* Draws a vertical run of pixels, then advances the bitmap pointer to</span>
<span class="co">   the first pixel of the next run. */</span>
<span class="dt">void</span> DrawVerticalRun(<span class="dt">char</span> far **ScreenPtr, <span class="dt">int</span> XAdvance,
   <span class="dt">int</span> RunLength, <span class="dt">int</span> Color)
{
   <span class="dt">int</span> i;
   <span class="dt">char</span> far *WorkingScreenPtr = *ScreenPtr;

   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;RunLength; i++)
   {
      *WorkingScreenPtr = Color;
      WorkingScreenPtr += SCREEN_WIDTH;
   }
   <span class="co">/* Advance to the next column */</span>
   WorkingScreenPtr += XAdvance;
   *ScreenPtr = WorkingScreenPtr;
}</code></pre>
<p>Notwithstanding that it’s not optimized, Listing 36.1 is reasonably fast. If you run Listing 36.2 (a sample line-drawing program that you can use to test-drive Listing 36.1), you may be as surprised as I was at how quickly the screen fills with vectors, considering that Listing 36.1 is entirely in C and has some redundant divides. Or perhaps you won’t be surprised—in which case I suggest you <em>not</em> miss the next chapter.</p>
<p><strong>LISTING 36.2 L36-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Sample line-drawing program. Uses the optimized</span>
<span class="co">line-drawing functions coded in LListing L36.1.C.</span>
<span class="co">Tested with Borland C++ in the small model. */</span>

<span class="ot">#include &lt;dos.h&gt;</span>

<span class="ot">#define GRAPHICS_MODE   0x13</span>
<span class="ot">#define TEXT_MODE       0x03</span>
<span class="ot">#define BIOS_VIDEO_INT  0x10</span>
<span class="ot">#define X_MAX           320      </span><span class="co">/* working screen width */</span>
<span class="ot">#define Y_MAX           200      </span><span class="co">/* working screen height */</span>

<span class="kw">extern</span> <span class="dt">void</span> LineDraw(<span class="dt">int</span> XStart, <span class="dt">int</span> YStart, <span class="dt">int</span> XEnd, <span class="dt">int</span> YEnd, <span class="dt">int</span> Color);

<span class="co">/* Subroutine to draw a rectangle full of vectors, of the specified</span>
<span class="co"> * length and color, around the specified rectangle center.  */</span>
<span class="dt">void</span> VectorsUp(XCenter, YCenter, XLength, YLength, Color)
<span class="dt">int</span> XCenter, YCenter;   <span class="co">/* center of rectangle to fill */</span>
<span class="dt">int</span> XLength, YLength;   <span class="co">/* distance from center to edge of rectangle */</span>
<span class="dt">int</span> Color;              <span class="co">/* color to draw lines in */</span>
{
   <span class="dt">int</span> WorkingX, WorkingY;

   <span class="co">/* lines from center to top of rectangle */</span>
   WorkingX = XCenter - XLength;
   WorkingY = YCenter - YLength;
   <span class="kw">for</span> ( ; WorkingX &lt; ( XCenter + XLength ); WorkingX++ )
   {
      LineDraw(XCenter, YCenter, WorkingX, WorkingY, Color);
   }
   <span class="co">/* lines from center to right of rectangle */</span>
   WorkingX = XCenter + XLength - <span class="dv">1</span>;
   WorkingY = YCenter - YLength;
   <span class="kw">for</span> ( ; WorkingY &lt; ( YCenter + YLength ); WorkingY++ )
   {
      LineDraw(XCenter, YCenter, WorkingX, WorkingY, Color);
   }
   <span class="co">/* lines from center to bottom of rectangle */</span>
   WorkingX = XCenter + XLength - <span class="dv">1</span>;
   WorkingY = YCenter + YLength - <span class="dv">1</span>;
   <span class="kw">for</span> ( ; WorkingX &gt;= ( XCenter - XLength ); WorkingX-- )
   {
      LineDraw(XCenter, YCenter, WorkingX, WorkingY, Color);
   }
   <span class="co">/* lines from center to left of rectangle */</span>
   WorkingX = XCenter - XLength;
   WorkingY = YCenter + YLength - <span class="dv">1</span>;
   <span class="kw">for</span> ( ; WorkingY &gt;= ( YCenter - YLength ); WorkingY-- )
   {
      LineDraw(XCenter, YCenter, WorkingX, WorkingY, Color);
   }
}
<span class="co">/* Sample program to draw four rectangles full of lines.  */</span>
<span class="dt">int</span> main()
{
   <span class="kw">union</span> REGS regs;

   <span class="co">/* Set graphics mode */</span>
   regs.x.ax = GRAPHICS_MODE;
   int86(BIOS_VIDEO_INT, &amp;regs, &amp;regs);

   <span class="co">/* Draw each of four rectangles full of vectors */</span>
   VectorsUp(X_MAX / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, X_MAX / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, <span class="dv">1</span>);
   VectorsUp(X_MAX * <span class="dv">3</span> / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, X_MAX / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, <span class="dv">2</span>);
   VectorsUp(X_MAX / <span class="dv">4</span>, Y_MAX * <span class="dv">3</span> / <span class="dv">4</span>, X_MAX / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, <span class="dv">3</span>);
   VectorsUp(X_MAX * <span class="dv">3</span> / <span class="dv">4</span>, Y_MAX * <span class="dv">3</span> / <span class="dv">4</span>, X_MAX / <span class="dv">4</span>, Y_MAX / <span class="dv">4</span>, <span class="dv">4</span>);

   <span class="co">/* Wait for a key to be pressed */</span>
   getch();

   <span class="co">/* Return back to text mode */</span>
   regs.x.ax = TEXT_MODE;
   int86(BIOS_VIDEO_INT, &amp;regs, &amp;regs);
}</code></pre>
</section>
</section>
<section id="chapter-37-dead-cats-and-lightning-lines" class="level2">
<h2><a href="#chapter-37-dead-cats-and-lightning-lines">Chapter 37 – Dead Cats and Lightning Lines</a></h2>
<section id="optimizing-run-length-slice-line-drawing-in-a-major-way" class="level3">
<h3><a href="#optimizing-run-length-slice-line-drawing-in-a-major-way">Optimizing Run-Length Slice Line Drawing in a Major Way</a></h3>
<p>As I write this, the wife, the kid, and I are in the throes of yet another lightning-quick transcontinental move, this time to Redmond, Washington, to work for You Know Who. Moving is never fun, but what makes it worse for us is the pets. Getting them into kennels and to the airport is hard; there’s always the possibility that they might not be allowed to fly because of the weather; and, worst of all, they might not make it. Animals don’t usually end up injured or dead, but it does happen.</p>
<p>In a (not notably successful) effort to cheer me up about the prospect of shipping my animals, a friend told me the following story, which he swears actually happened to a friend of his. I don’t know—to me, it has the ring of an urban legend, which is to say it makes a good story, but you can never track down the person it really happened to; it’s always a friend of a friend. But maybe it is true, and anyway, it’s a good story.</p>
<p>This friend of a friend (henceforth referred to as FOF), worked in an air-freight terminal. Consequently, he handled a lot of animals, which was fine by him, because he liked animals; in fact, he had quite a few cats at home. You can imagine his dismay when, one day, he took a kennel off the plane to find that the cat it carried was quite thoroughly dead. (No, it wasn’t resting, nor pining for the fjords; this cat was bloody <em>deceased</em>.)</p>
<p>FOF knew how upset the owner would be, and came up with a plan to make everything better. At home, he had a cat of the same size, shape, and markings. He would substitute that cat, and since all cats treat all humans with equal disdain, the owner would never know the difference, and would never suffer the trauma of the loss of her cat. So FOF drove home, got his cat, put it in the kennel, and waited for the owner to show up—at which point, she took one look at the kennel and said, “This isn’t my cat. My cat is dead.”</p>
<p>As it turned out, she had shipped her recently deceased feline home to be buried. History does not record how our FOF dug himself out of this one.</p>
<p>Okay, but what’s the point? The point is, if it isn’t broken, don’t fix it. And if it is broken, maybe that’s all right, too. Which brings us, neat as a pin, to the topic of drawing lines in a serious hurry.</p>
</section>
<section id="fast-run-length-slice-line-drawing" class="level3">
<h3><a href="#fast-run-length-slice-line-drawing">Fast Run-Length Slice Line Drawing</a></h3>
<p>In the last chapter, we examined the principles of run-length slice line drawing, which draws lines a run at a time rather than a pixel at a time, a run being a series of pixels along the major (longer) axis. It’s time to turn theory into useful practice by developing a fast assembly version. Listing 37.1 is the assembly version, in a form that’s plug-compatible with the C code from the previous chapter.</p>
<p><strong>LISTING 37.1 L37-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Fast run-length slice line drawing implementation for mode 0x13, the VGA&#39;s</span>
<span class="co">; 320x200 256-color mode.</span>
<span class="co">; Draws a line between the specified endpoints in color Color.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;  void LineDraw(int XStart, int YStart, int XEnd, int YEnd, int Color)</span>
<span class="co">; Tested with TASM</span>

SCREEN_WIDTH       <span class="dt">equ</span> <span class="dv">320</span>
SCREEN_SEGMENT     <span class="dt">equ</span><span class="bn"> 0a000h</span>
    .model  small
    .code

<span class="co">; Parameters to call.</span>
parms   <span class="kw">struc</span>
           <span class="dt">dw</span>    ?              <span class="co">;pushed BP</span>
           <span class="dt">dw</span>    ?              <span class="co">;pushed return address</span>
XStart     <span class="dt">dw</span>    ?              <span class="co">;X start coordinate of line</span>
YStart     <span class="dt">dw</span>    ?              <span class="co">;Y start coordinate of line</span>
XEnd       <span class="dt">dw</span>    ?              <span class="co">;X end coordinate of line</span>
YEnd       <span class="dt">dw</span>    ?              <span class="co">;Y end coordinate of line</span>
Color      <span class="dt">db</span>    ?              <span class="co">;color in which to draw line</span>
           <span class="dt">db</span>    ?              <span class="co">;dummy byte because Color is really a word</span>
parms ends

<span class="co">; Local variables.</span>
AdjUp          <span class="dt">equ</span> -<span class="dv">2</span>          <span class="co">;error term adjust up on each advance</span>
AdjDown        <span class="dt">equ</span> -<span class="dv">4</span>          <span class="co">;error term adjust down when error term turns over</span>
WholeStep      <span class="dt">equ</span> -<span class="dv">6</span>          <span class="co">;minimum run length</span>
XAdvance       <span class="dt">equ</span> -<span class="dv">8</span>          <span class="co">;1 or -1, for direction in which X advances</span>
LOCAL_SIZE     <span class="dt">equ</span>  <span class="dv">8</span>
    public  _LineDraw
_LineDraw   proc  near
      <span class="kw">cld</span>
      <span class="kw">push</span>        <span class="kw">bp</span>                  <span class="co">;preserve caller&#39;s stack frame</span>
      <span class="kw">mov</span>         <span class="kw">bp</span>,<span class="kw">sp</span>               <span class="co">;point to our stack frame</span>
      <span class="kw">sub</span> <span class="kw">sp</span>,     LOCAL_SIZE          <span class="co">;allocate space for local variables</span>
      <span class="kw">push</span>        <span class="kw">si</span>                  <span class="co">;preserve C register variables</span>
      <span class="kw">push</span>        <span class="kw">di</span>
      <span class="kw">push</span>        <span class="kw">ds</span>                  <span class="co">;preserve caller&#39;s DS</span>
<span class="co">; We&#39;ll draw top to bottom, to reduce the number of cases we have to handle,</span>
<span class="co">; and to make lines between the same endpoints always draw the same pixels.</span>
      <span class="kw">mov</span>         <span class="kw">ax</span>,[<span class="kw">bp</span>].YStart
      <span class="kw">cmp</span>         <span class="kw">ax</span>,[<span class="kw">bp</span>].YEnd
      <span class="kw">jle</span>         LineIsTopToBottom
      <span class="kw">xchg</span>        [<span class="kw">bp</span>].YEnd,<span class="kw">ax</span><span class="co">;          swap endpoints</span>
      <span class="kw">mov</span>         [<span class="kw">bp</span>].YStart,<span class="kw">ax</span>
      movbx,      [<span class="kw">bp</span>].XStart
      <span class="kw">xchg</span>        [<span class="kw">bp</span>].XEnd,<span class="kw">bx</span>
      <span class="kw">mov</span>         [<span class="kw">bp</span>].XStart,<span class="kw">bx</span>
<span class="fu">LineIsTopToBottom:</span>
<span class="co">; Point DI to the first pixel to draw.</span>
      <span class="kw">mov</span>         <span class="kw">dx</span>,SCREEN_WIDTH
      <span class="kw">mul</span>         <span class="kw">dx</span>                    <span class="co">;YStart * SCREEN_WIDTH</span>
      <span class="kw">mov</span>         <span class="kw">si</span>,[<span class="kw">bp</span>].XStart
      <span class="kw">mov</span>         <span class="kw">di</span>,<span class="kw">si</span>
      <span class="kw">add</span>         <span class="kw">di</span>,<span class="kw">ax</span>                 <span class="co">;DI = YStart * SCREEN_WIDTH + XStart</span>
                                        <span class="co">; = offset of initial pixel</span>
<span class="co">; Figure out how far we&#39;re going vertically (guaranteed to be positive).</span>
      <span class="kw">mov</span>         <span class="kw">cx</span>,[<span class="kw">bp</span>].YEnd
      <span class="kw">sub</span>         <span class="kw">cx</span>,[<span class="kw">bp</span>].YStart        <span class="co">;CX = YDelta</span>
<span class="co">; Figure out whether we&#39;re going left or right, and how far we&#39;re going</span>
<span class="co">; horizontally. In the process, special-case vertical lines, for speed and</span>
<span class="co">; to avoid nasty boundary conditions and division by 0.</span>
      <span class="kw">mov</span>         <span class="kw">dx</span>,[<span class="kw">bp</span>].XEnd
      <span class="kw">sub</span>         <span class="kw">dx</span>,<span class="kw">si</span>                 <span class="co">;XDelta</span>
      <span class="kw">jnz</span>         NotVerticalLine       <span class="co">;XDelta == 0 means vertical line</span>
                                        <span class="co">;it is a vertical line</span>
                                        <span class="co">;yes, special case vertical line</span>
      <span class="kw">mov</span>         <span class="kw">ax</span>,SCREEN_SEGMENT
      <span class="kw">mov</span>         <span class="kw">ds</span>,<span class="kw">ax</span>                 <span class="co">;point DS:DI to the first byte to draw</span>
      <span class="kw">mov</span>         <span class="kw">al</span>,[<span class="kw">bp</span>].Color
<span class="fu">VLoop:</span>
      <span class="kw">mov</span>         [<span class="kw">di</span>],<span class="kw">al</span>
      <span class="kw">add</span>         <span class="kw">di</span>,SCREEN_WIDTH
      <span class="kw">dec</span>         <span class="kw">cx</span>
      <span class="kw">jns</span>         VLoop
      <span class="kw">jmp</span>         Done
<span class="co">; Special-case code for horizontal lines.</span>
      <span class="kw">align</span>       <span class="dv">2</span>
<span class="fu">IsHorizontalLine:</span>
      <span class="kw">mov</span>         <span class="kw">ax</span>,SCREEN_SEGMENT
      <span class="kw">mov</span>         <span class="kw">es</span>,<span class="kw">ax</span>                 <span class="co">;point ES:DI to the first byte to draw</span>
      <span class="kw">mov</span>         <span class="kw">al</span>,[<span class="kw">bp</span>].Color
      <span class="kw">mov</span>         <span class="kw">ah</span>,<span class="kw">al</span>                 <span class="co">;duplicate in high byte for word access</span>
      <span class="kw">and</span>         <span class="kw">bx</span>,<span class="kw">bx</span>                 <span class="co">;left to right?</span>
      <span class="kw">jns</span>         DirSet                <span class="co">;yes</span>
      <span class="kw">sub</span>         <span class="kw">di</span>,<span class="kw">dx</span>                 <span class="co">;currently right to left, point to left</span>
                                        <span class="co">; end so we can go left to right</span>
                                        <span class="co">; (avoids unpleasantness withright to</span>
                                        <span class="co">;  left REP STOSW)</span>
<span class="fu">DirSet:</span>
      <span class="kw">mov</span>         <span class="kw">cx</span>,<span class="kw">dx</span>
      <span class="kw">inc</span>         <span class="kw">cx</span>                    <span class="co">;# of pixels to draw</span>
      <span class="kw">shr</span>         <span class="kw">cx</span>,<span class="dv">1</span>                  <span class="co">;# of words to draw</span>
      rep         <span class="kw">stosw</span>                 <span class="co">;do as many words as possible</span>
      <span class="kw">adc</span>         <span class="kw">cx</span>,<span class="kw">cx</span>
      rep         <span class="kw">stosb</span>                 <span class="co">;do the odd byte, if there is one</span>
      <span class="kw">jmp</span>         Done
<span class="co">; Special-case code for diagonal lines.</span>
      <span class="kw">align</span>       <span class="dv">2</span>
<span class="fu">IsDiagonalLine:</span>
      <span class="kw">mov</span>         <span class="kw">ax</span>,SCREEN_SEGMENT
      <span class="kw">mov</span>         <span class="kw">ds</span>,<span class="kw">ax</span>                 <span class="co">;point DS:DI to the first byte to draw</span>
      <span class="kw">mov</span>         <span class="kw">al</span>,[<span class="kw">bp</span>].Color
      <span class="kw">add</span>         <span class="kw">bx</span>,SCREEN_WIDTH       <span class="co">;advance distance from one pixel to next</span>
<span class="fu">DLoop:</span>
      <span class="kw">mov</span>         [<span class="kw">di</span>],<span class="kw">al</span>
      <span class="kw">add</span>         <span class="kw">di</span>,<span class="kw">bx</span>
      <span class="kw">dec</span>         <span class="kw">cx</span>
      <span class="kw">jns</span>         DLoop
      <span class="kw">jmp</span>         Done

      <span class="kw">align</span>       <span class="dv">2</span>
<span class="fu">NotVerticalLine:</span>
      <span class="kw">mov</span>         <span class="kw">bx</span>,<span class="dv">1</span>                  <span class="co">;assume left to right, so XAdvance = 1</span>
                                        <span class="co">;***leaves flags unchanged***</span>
      <span class="kw">jns</span>         LeftToRight           <span class="co">;left to right, all set</span>
      <span class="kw">neg</span>         <span class="kw">bx</span>                    <span class="co">;right to left, so XAdvance = -1</span>
      <span class="kw">neg</span>         <span class="kw">dx</span>                    <span class="co">;|XDelta|</span>
<span class="fu">LeftToRight:</span>
<span class="co">; Special-case horizontal lines.</span>
            <span class="kw">and</span>       <span class="kw">cx</span>,<span class="kw">cx</span>             <span class="co">;YDelta == 0?</span>
            <span class="kw">jz</span>        IsHorizontalLine  <span class="co">;yes</span>




<span class="co">; Special-case diagonal lines.</span>
      <span class="kw">cmp</span>         <span class="kw">cx</span>,<span class="kw">dx</span>                 <span class="co">;YDelta == XDelta?</span>
      <span class="kw">jz</span>         IsDiagonalLine         <span class="co">;yes</span>
<span class="co">; Determine whether the line is X or Y major, and handle accordingly.</span>
      <span class="kw">cmp</span>         <span class="kw">dx</span>,<span class="kw">cx</span>
      <span class="kw">jae</span>         XMa<span class="kw">jo</span>r
           <span class="kw">jmp</span>         YMa<span class="kw">jo</span>r
<span class="co">; X-major (more horizontal than vertical) line.</span>
      <span class="kw">align</span>       <span class="dv">2</span>
<span class="fu">XMajor:</span>
      <span class="kw">mov</span>         <span class="kw">ax</span>,SCREEN_SEGMENT
      <span class="kw">mov</span>         <span class="kw">es</span>,<span class="kw">ax</span>                 <span class="co">;point ES:DI to the first byte to draw</span>
      <span class="kw">and</span>         <span class="kw">bx</span>,<span class="kw">bx</span>                 <span class="co">;left to right?</span>
      <span class="kw">jns</span>         DFSet                 <span class="co">;yes, CLD is already set</span>
      <span class="kw">std</span>                               <span class="co">;right to left, so draw backwards</span>
<span class="fu">DFSet:</span>
      <span class="kw">mov</span>         <span class="kw">ax</span>,<span class="kw">dx</span>                 <span class="co">;XDelta</span>
      <span class="kw">sub</span>         <span class="kw">dx</span>,<span class="kw">dx</span>                 <span class="co">;prepare for division</span>
      <span class="kw">div</span>         <span class="kw">cx</span>                    <span class="co">;AX = XDelta/YDelta</span>
                                        <span class="co">; (minimum # of pixels in a run in this line)</span>
                                        <span class="co">;DX = XDelta % YDelta</span>
      <span class="kw">mov</span>         <span class="kw">bx</span>,<span class="kw">dx</span>                 <span class="co">;error term adjust each time Y steps by 1;</span>
      <span class="kw">add</span>         <span class="kw">bx</span>,<span class="kw">bx</span>                 <span class="co">; used to tell when one extra pixel should be</span>
      <span class="kw">mov</span>         [<span class="kw">bp</span>].AdjUp,<span class="kw">bx</span>         <span class="co">; drawn as part of a run, to account for</span>
                                        <span class="co">; fractional steps along the X axis per</span>
                                        <span class="co">; 1-pixel steps along Y</span>
      <span class="kw">mov</span>         <span class="kw">si</span>,<span class="kw">cx</span>                 <span class="co">;error term adjust when the error term turns</span>
      <span class="kw">add</span>         <span class="kw">si</span>,<span class="kw">si</span>                 <span class="co">; over, used to factor out the X step made at</span>
      <span class="kw">mov</span>         [<span class="kw">bp</span>].AdjDown,<span class="kw">si</span>       <span class="co">; that time</span>
<span class="co">; Initial error term; reflects an initial step of 0.5 along the Y axis.</span>
      <span class="kw">sub</span>         <span class="kw">dx</span>,<span class="kw">si</span>                 <span class="co">;(XDelta % YDelta) - (YDelta * 2)</span>
                                        <span class="co">;DX = initial error term</span>
<span class="co">; The initial and last runs are partial, because Y advances only 0.5 for</span>
<span class="co">; these runs, rather than 1. Divide one full run, plus the initial pixel,</span>
<span class="co">; between the initial and last runs.</span>
      <span class="kw">mov</span>         <span class="kw">si</span>,<span class="kw">cx</span>                 <span class="co">;SI = YDelta</span>
      <span class="kw">mov</span>         <span class="kw">cx</span>,<span class="kw">ax</span>                 <span class="co">;whole step (minimum run length)</span>
      <span class="kw">shr</span>         <span class="kw">cx</span>,<span class="dv">1</span>
      <span class="kw">inc</span>         <span class="kw">cx</span>                    <span class="co">;initial pixel count = (whole step / 2) + 1;</span>
                                        <span class="co">; (may be adjusted later). This is also the</span>
                                        <span class="co">; final run pixel count</span>
      <span class="kw">push</span>        <span class="kw">cx</span>                    <span class="co">;remember final run pixel count for later</span>
<span class="co">; If the basic run length is even and there&#39;s no fractional advance, we have</span>
<span class="co">; one pixel that could go to either the initial or last partial run, which</span>
<span class="co">; we&#39;ll arbitrarily allocate to the last run.</span>
<span class="co">; If there is an odd number of pixels per run, we have one pixel that can&#39;t</span>
<span class="co">; be allocated to either the initial or last partial run, so we&#39;ll add 0.5 to</span>
<span class="co">; the error term so this pixel will be handled by the normal full-run loop.</span>
      <span class="kw">add</span>         <span class="kw">dx</span>,<span class="kw">si</span>                 <span class="co">;assume odd length, add YDelta to error term</span>
                                        <span class="co">; (add 0.5 of a pixel to the error term)</span>
      <span class="kw">test</span>        <span class="kw">al</span>,<span class="dv">1</span>                  <span class="co">;is run length even?</span>
      <span class="kw">jnz</span>         XMa<span class="kw">jo</span>rAdjustDone      <span class="co">;no, already did work for odd case, all set</span>
      <span class="kw">sub</span>         <span class="kw">dx</span>,<span class="kw">si</span>                 <span class="co">;length is even, undo odd stuff we just did</span>
      <span class="kw">and</span>         <span class="kw">bx</span>,<span class="kw">bx</span>                 <span class="co">;is the adjust up equal to 0?</span>
      <span class="kw">jnz</span>         XMa<span class="kw">jo</span>rAdjustDone      <span class="co">;no (don&#39;t need to check for odd length,</span>
                                        <span class="co">; because of the above test)</span>
      <span class="kw">dec</span>         <span class="kw">cx</span>                    <span class="co">;both conditions met; make initial run 1</span>
                                        <span class="co">; shorter</span>
<span class="fu">XMajorAdjustDone:</span>
      <span class="kw">mov</span>         [<span class="kw">bp</span>].WholeStep,<span class="kw">ax</span>     <span class="co">;whole step (minimum run length)</span>
      <span class="kw">mov</span>         <span class="kw">al</span>,[<span class="kw">bp</span>].Color         <span class="co">;AL = drawing color</span>
<span class="co">; Draw the first, partial run of pixels.</span>
      rep         <span class="kw">stosb</span>                 <span class="co">;draw the final run</span>
      <span class="kw">add</span>         <span class="kw">di</span>,SCREEN_WIDTH       <span class="co">;advance along the minor axis (Y)</span>
<span class="co">; Draw all full runs.</span>
      <span class="kw">cmp</span>         <span class="kw">si</span>,<span class="dv">1</span>                  <span class="co">;are there more than 2 scans, so there are</span>
                                        <span class="co">; some full runs? (SI = # scans - 1)</span>
      <span class="kw">jna</span>         XMa<span class="kw">jo</span>rDrawLast        <span class="co">;no, no full runs</span>
      <span class="kw">dec</span>         <span class="kw">dx</span>                    <span class="co">;adjust error term by -1 so we can use</span>
                                        <span class="co">; carry test</span>
      <span class="kw">shr</span>         <span class="kw">si</span>,<span class="dv">1</span>                  <span class="co">;convert from scan to scan-pair count</span>
      <span class="kw">jnc</span>         XMa<span class="kw">jo</span>rFullRunsOddEntry <span class="co">;if there is an odd umber of scans,</span>
                                        <span class="co">; do the odd scan now</span>
<span class="fu">XMajorFullRunsLoop:</span>
      <span class="kw">mov</span>         <span class="kw">cx</span>,[<span class="kw">bp</span>].WholeStep     <span class="co">;run is at least this long</span>
      <span class="kw">add</span>         <span class="kw">dx</span>,<span class="kw">bx</span>                 <span class="co">;advance the error term and add an extra</span>
      <span class="kw">jnc</span>         XMa<span class="kw">jo</span>rNoExtra         <span class="co">; pixel if the error term so indicates</span>
      <span class="kw">inc</span>         <span class="kw">cx</span>                    <span class="co">;one extra pixel in run</span>
      <span class="kw">sub</span>         <span class="kw">dx</span>,[<span class="kw">bp</span>].AdjDown       <span class="co">;reset the error term</span>
<span class="fu">XMajorNoExtra:</span>
      rep         <span class="kw">stosb</span>                 <span class="co">;draw this scan line&#39;s run</span>
      <span class="kw">add</span>         <span class="kw">di</span>,SCREEN_WIDTH       <span class="co">;advance along the minor axis (Y)</span>
<span class="fu">XMajorFullRunsOddEntry:</span>                 <span class="co">;enter loop here if there is an odd number</span>
                                        <span class="co">; of full runs</span>
      <span class="kw">mov</span>         <span class="kw">cx</span>,[<span class="kw">bp</span>].WholeStep     <span class="co">;run is at least this long</span>
      <span class="kw">add</span>         <span class="kw">dx</span>,<span class="kw">bx</span>                 <span class="co">;advance the error term and add an extra</span>
      <span class="kw">jnc</span>         XMa<span class="kw">jo</span>rNoExtra2        <span class="co">; pixel if the error term so indicates</span>
      <span class="kw">inc</span>         <span class="kw">cx</span>                    <span class="co">;one extra pixel in run</span>
      <span class="kw">sub</span>         <span class="kw">dx</span>,[<span class="kw">bp</span>].AdjDown       <span class="co">;reset the error term</span>
<span class="fu">XMajorNoExtra2:</span>
      rep         <span class="kw">stosb</span>                 <span class="co">;draw this scan line&#39;s run</span>
      <span class="kw">add</span>         <span class="kw">di</span>,SCREEN_WIDTH       <span class="co">;advance along the minor axis (Y)</span>

      <span class="kw">dec</span>         <span class="kw">si</span>
      <span class="kw">jnz</span>         XMa<span class="kw">jo</span>rFullRunsLoop
<span class="co">; Draw the final run of pixels.</span>
<span class="fu">XMajorDrawLast:</span>
      <span class="kw">pop</span>         <span class="kw">cx</span>                    <span class="co">;get back the final run pixel length</span>
      rep         <span class="kw">stosb</span>                 <span class="co">;draw the final run</span>

      <span class="kw">cld</span>                               <span class="co">;restore normal direction flag</span>
      <span class="kw">jmp</span>         Done
<span class="co">; Y-major (more vertical than horizontal) line.</span>
      <span class="kw">align</span>       <span class="dv">2</span>
<span class="fu">YMajor:</span>
      <span class="kw">mov</span>         [<span class="kw">bp</span>].XAdvance,<span class="kw">bx</span>      <span class="co">;remember which way X advances</span>
      <span class="kw">mov</span>         <span class="kw">ax</span>,SCREEN_SEGMENT
      <span class="kw">mov</span>         <span class="kw">ds</span>,<span class="kw">ax</span>                 <span class="co">;point DS:DI to the first byte to draw</span>
      <span class="kw">mov</span>         <span class="kw">ax</span>,<span class="kw">cx</span>                 <span class="co">;YDelta</span>
      <span class="kw">mov</span>         <span class="kw">cx</span>,<span class="kw">dx</span>                 <span class="co">;XDelta</span>
      <span class="kw">sub</span>         <span class="kw">dx</span>,<span class="kw">dx</span>                 <span class="co">;prepare for division</span>
      <span class="kw">div</span>         <span class="kw">cx</span>                    <span class="co">;AX = YDelta/XDelta</span>
                                        <span class="co">; (minimum # of pixels in a run in this line)</span>
                                        <span class="co">;DX = YDelta % XDelta</span>
      <span class="kw">mov</span>         <span class="kw">bx</span>,<span class="kw">dx</span>                 <span class="co">;error term adjust each time X steps by 1;</span>
      <span class="kw">add</span>         <span class="kw">bx</span>,<span class="kw">bx</span>                 <span class="co">; used to tell when one extra pixel should be</span>
      <span class="kw">mov</span>         [<span class="kw">bp</span>].AdjUp,<span class="kw">bx</span>         <span class="co">; drawn as part of a run, to account for</span>
                                        <span class="co">; fractional steps along the Y axis per</span>
                                        <span class="co">; 1-pixel steps along X</span>
      <span class="kw">mov</span>         <span class="kw">si</span>,<span class="kw">cx</span>                 <span class="co">;error term adjust when the error term turns</span>
      <span class="kw">add</span>         <span class="kw">si</span>,<span class="kw">si</span>                 <span class="co">; over, used to factor out the Y step made at</span>
      <span class="kw">mov</span>         [<span class="kw">bp</span>].AdjDown,<span class="kw">si</span>       <span class="co">; that time</span>

<span class="co">; Initial error term; reflects an initial step of 0.5 along the X axis.</span>
      <span class="kw">sub</span>         <span class="kw">dx</span>,<span class="kw">si</span>                 <span class="co">;(YDelta % XDelta) - (XDelta * 2)</span>
                                        <span class="co">;DX = initial error term</span>
<span class="co">; The initial and last runs are partial, because X advances only 0.5 for</span>
<span class="co">; these runs, rather than 1. Divide one full run, plus the initial pixel,</span>
<span class="co">; between the initial and last runs.</span>
      <span class="kw">mov</span>         <span class="kw">si</span>,<span class="kw">cx</span>                 <span class="co">;SI = XDelta</span>
      <span class="kw">mov</span>         <span class="kw">cx</span>,<span class="kw">ax</span>                 <span class="co">;whole step (minimum run length)</span>
      <span class="kw">shr</span>         <span class="kw">cx</span>,<span class="dv">1</span>
      <span class="kw">inc</span>         <span class="kw">cx</span>                    <span class="co">;initial pixel count = (whole step / 2) + 1;</span>
                                        <span class="co">; (may be adjusted later)</span>
      <span class="kw">push</span>         <span class="kw">cx</span>                   <span class="co">;remember final run pixel count for later</span>

<span class="co">; If the basic run length is even and there&#39;s no fractional advance, we have</span>
<span class="co">; one pixel that could go to either the initial or last partial run, which</span>
<span class="co">; we&#39;ll arbitrarily allocate to the last run.</span>
<span class="co">; If there is an odd number of pixels per run, we have one pixel that can&#39;t</span>
<span class="co">; be allocated to either the initial or last partial run, so we&#39;ll add 0.5 to</span>
<span class="co">; the error term so this pixel will be handled by the normal full-run loop.</span>
      <span class="kw">add</span>         <span class="kw">dx</span>,<span class="kw">si</span>                 <span class="co">;assume odd length, add XDelta to error term</span>
      <span class="kw">test</span>        <span class="kw">al</span>,<span class="dv">1</span>                  <span class="co">;is run length even?</span>
      <span class="kw">jnz</span>         YMa<span class="kw">jo</span>rAdjustDone      <span class="co">;no, already did work for odd case, all set</span>
      <span class="kw">sub</span>         <span class="kw">dx</span>,<span class="kw">si</span>                 <span class="co">;length is even, undo odd stuff we just did</span>
      <span class="kw">and</span>         <span class="kw">bx</span>,<span class="kw">bx</span>                 <span class="co">;is the adjust up equal to 0?</span>
      <span class="kw">jnz</span>         YMa<span class="kw">jo</span>rAdjustDone      <span class="co">;no (don&#39;t need to check for odd length,</span>
                                        <span class="co">; because of the above test)</span>
      <span class="kw">dec</span>         <span class="kw">cx</span>                    <span class="co">;both conditions met; make initial run 1</span>
                                        <span class="co">; shorter</span>
<span class="fu">YMajorAdjustDone:</span>
      <span class="kw">mov</span>         [<span class="kw">bp</span>].WholeStep,<span class="kw">ax</span>     <span class="co">;whole step (minimum run length)</span>
      <span class="kw">mov</span>         <span class="kw">al</span>,[<span class="kw">bp</span>].Color         <span class="co">;AL = drawing color</span>
      <span class="kw">mov</span>         <span class="kw">bx</span>,[<span class="kw">bp</span>].XAdvance      <span class="co">;which way X advances</span>
<span class="co">; Draw the first, partial run of pixels.</span>
<span class="fu">YMajorFirstLoop:</span>
      <span class="kw">mov</span>         [<span class="kw">di</span>],<span class="kw">al</span>               <span class="co">;draw the pixel</span>
      <span class="kw">add</span>         <span class="kw">di</span>,SCREEN_WIDTH       <span class="co">;advance along the major axis (Y)</span>
      <span class="kw">dec</span>         <span class="kw">cx</span>
      <span class="kw">jnz</span>         YMa<span class="kw">jo</span>rFirstLoop
      <span class="kw">add</span>         <span class="kw">di</span>,<span class="kw">bx</span>                 <span class="co">;advance along the minor axis (X)</span>
        <span class="co">; Draw all full runs.</span>
      <span class="kw">cmp</span>         <span class="kw">si</span>,<span class="dv">1</span>                  <span class="co">;# of full runs. Are there more than 2</span>
                                        <span class="co">; columns, so there are some full runs?</span>
                                        <span class="co">; (SI = # columns - 1)</span>
      <span class="kw">jna</span>         YMa<span class="kw">jo</span>rDrawLast        <span class="co">;no, no full runs</span>
      <span class="kw">dec</span>         <span class="kw">dx</span>                    <span class="co">;adjust error term by -1 so we can use</span>
                                        <span class="co">; carry test</span>
      <span class="kw">shr</span>         <span class="kw">si</span>,<span class="dv">1</span>                  <span class="co">;convert from column to column-pair count</span>
      <span class="kw">jnc</span>         YMa<span class="kw">jo</span>rFullRunsOddEntry <span class="co">;if there is an odd number of</span>
                                        <span class="co">; columns, do the odd column now</span>
<span class="fu">YMajorFullRunsLoop:</span>
      <span class="kw">mov</span>         <span class="kw">cx</span>,[<span class="kw">bp</span>].WholeStep     <span class="co">;run is at least this long</span>
      <span class="kw">add</span>         <span class="kw">dx</span>,[<span class="kw">bp</span>].AdjUp         <span class="co">;advance the error term and add an extra</span>
      <span class="kw">jnc</span>         YMa<span class="kw">jo</span>rNoExtra         <span class="co">; pixel if the error term so indicates</span>
      <span class="kw">inc</span>         <span class="kw">cx</span>                    <span class="co">;one extra pixel in run</span>
      <span class="kw">sub</span>         <span class="kw">dx</span>,[<span class="kw">bp</span>].AdjDown       <span class="co">;reset the error term</span>
<span class="fu">YMajorNoExtra:</span>
  <span class="co">;draw the run</span>
<span class="fu">YMajorRunLoop:</span>
      <span class="kw">mov</span>         [<span class="kw">di</span>],<span class="kw">al</span>               <span class="co">;draw the pixel</span>
      <span class="kw">add</span>         <span class="kw">di</span>,SCREEN_WIDTH       <span class="co">;advance along the major axis (Y)</span>
      <span class="kw">dec</span>         <span class="kw">cx</span>
      <span class="kw">jnz</span>         YMa<span class="kw">jo</span>rRunLoop
      <span class="kw">add</span>         <span class="kw">di</span>,<span class="kw">bx</span>                 <span class="co">;advance along the minor axis (X)</span>
<span class="fu">YMajorFullRunsOddEntry:</span>                 <span class="co">;enter loop here if there is an odd number</span>
                                        <span class="co">; of full runs</span>
      <span class="kw">mov</span>         <span class="kw">cx</span>,[<span class="kw">bp</span>].WholeStep     <span class="co">;run is at least this long</span>
      <span class="kw">add</span>         <span class="kw">dx</span>,[<span class="kw">bp</span>].AdjUp         <span class="co">;advance the error term and add an extra</span>
      <span class="kw">jnc</span>         YMa<span class="kw">jo</span>rNoExtra2        <span class="co">; pixel if the error term so indicates</span>
      <span class="kw">inc</span>         <span class="kw">cx</span>                    <span class="co">;one extra pixel in run</span>
      <span class="kw">sub</span>         <span class="kw">dx</span>,[<span class="kw">bp</span>].AdjDown       <span class="co">;reset the error term</span>
<span class="fu">YMajorNoExtra2:</span>
  <span class="co">;draw the run</span>
<span class="fu">YMajorRunLoop2:</span>
      <span class="kw">mov</span>         [<span class="kw">di</span>],<span class="kw">al</span>               <span class="co">;draw the pixel</span>
      <span class="kw">add</span>         <span class="kw">di</span>,SCREEN_WIDTH       <span class="co">;advance along the major axis (Y)</span>
      <span class="kw">dec</span>         <span class="kw">cx</span>
      <span class="kw">jnz</span>         YMa<span class="kw">jo</span>rRunLoop2
      <span class="kw">add</span>         <span class="kw">di</span>,<span class="kw">bx</span>                 <span class="co">;advance along the minor axis (X)</span>

      <span class="kw">dec</span>         <span class="kw">si</span>
      <span class="kw">jnz</span>         YMa<span class="kw">jo</span>rFullRunsLoop
<span class="co">; Draw the final run of pixels.</span>
<span class="fu">YMajorDrawLast:</span>
      <span class="kw">pop</span>         <span class="kw">cx</span>                    <span class="co">;get back the final run pixel length</span>
<span class="fu">YMajorLastLoop:</span>
      <span class="kw">mov</span>         [<span class="kw">di</span>],<span class="kw">al</span>               <span class="co">;draw the pixel</span>
      <span class="kw">add</span>         <span class="kw">di</span>,SCREEN_WIDTH       <span class="co">;advance along the major axis (Y)</span>
      <span class="kw">dec</span>         <span class="kw">cx</span>
      <span class="kw">jnz</span>         YMa<span class="kw">jo</span>rLastLoop
<span class="fu">Done:</span>
      <span class="kw">pop</span>         <span class="kw">ds</span>                    <span class="co">;restore caller&#39;s DS</span>
      <span class="kw">pop</span>         <span class="kw">di</span>
      <span class="kw">pop</span>         <span class="kw">si</span>                    <span class="co">;restore C register variables</span>
      <span class="kw">mov</span>         <span class="kw">sp</span>,<span class="kw">bp</span>                 <span class="co">;deallocate local variables</span>
      <span class="kw">pop</span>         <span class="kw">bp</span>                    <span class="co">;restore caller&#39;s stack frame</span>
      <span class="kw">ret</span>
_LineDraw   endp
      end</code></pre>
<section id="how-fast-is-fast" class="level4">
<h4><a href="#how-fast-is-fast">How Fast Is Fast?</a></h4>
<p>Your first question is likely to be the following: Just how fast is Listing 37.1? Is it optimized to the hilt or just pretty fast? The quick answer is: It’s <em>fast</em>. Listing 37.1 draws lines at a rate of nearly 1 million pixels per second on my 486/33, and is capable of still faster drawing, as I’ll discuss shortly. (The heavily optimized AutoCAD line-drawing code that I mentioned in the last chapter drew 150,000 pixels per second on an EGA in a 386/16, and I thought I had died and gone to Heaven. Such is progress.) The full answer is a more complicated one, and ties in to the principle that if it is broken, maybe that’s okay—and to the principle of looking before you leap, also known as profiling before you optimize.</p>
<p>When I went to speed up run-length slice lines, I initially manually converted the last chapter’s C code into assembly. Then I streamlined the register usage and used <code>REP STOS</code> wherever possible. Listing 37.1 is that code. At that point, line drawing was surely faster, although I didn’t know exactly how much faster. Equally surely, there were significant optimizations yet to be made, and I was itching to get on to them, for they were bound to be a lot more interesting than a basic C-to-assembly port.</p>
<p>Ego intervened at this point, however. I wanted to know how much of a speed-up I had already gotten, so I timed the performance of the C code and compared it to the assembly code. To my horror, I found that I had not gotten even a two-times improvement! I couldn’t understand how that could be—the C code was decidedly unoptimized—until I hit on the idea of measuring the maximum memory speed of the VGA to which I was drawing.</p>
<p>Bingo. The Paradise VGA in my 486/33 is fast for a single display-memory write, because it buffers the data, lets the CPU go on its merry way, and finishes the write when display memory is ready. However, the maximum rate at which data can be written to the adapter turns out to be no more than one byte every microsecond. Put another way, you can only write one byte to this adapter every 33 clock cycles on a 486/33. Therefore, no matter how fast I made the line-drawing code, it could never draw more than 1,000,000 pixels per second in 256-color mode in my system. The C code was already drawing at about half that rate, so the potential speed-up for the assembly code was limited to a maximum of two times, which is pretty close to what Listing 37.1 did, in fact, achieve. When I compared the C and assembly implementations drawing to normal system (nondisplay) memory, I found that the assembly code was actually four times as fast as the C code.</p>
<blockquote>
<p><img src="images/i.jpg" /> In fact, Listing 37.1 draws VGA lines at about 92 percent of the maximum possible rate in my system—that is, it draws very nearly as fast as the VGA hardware will allow. All the optimization in the world would get me less than 10 percent faster line drawing—and only if I eliminated all overhead, an unlikely proposition at best. The code isn’t fully optimized, but so what?</p>
</blockquote>
<p>Now it’s true that faster line-drawing code would likely be more beneficial on faster VGAs, especially local-bus VGAs, and in slower systems. For that reason, I’ll list a variety of potential optimizations to Listing 37.1. On the other hand, it’s also true that Listing 37.1 is capable of drawing lines at a rate of 2.2 million pixels per second on a 486/ 33, given fast enough VGA memory, so it should be able to drive almost any non-local-bus VGA at nearly full speed. In short, Listing 37.1 is very fast, and, in many systems, further optimization is basically a waste of time.</p>
<p>Profile before you optimize.</p>
</section>
<section id="further-optimizations" class="level4">
<h4><a href="#further-optimizations">Further Optimizations</a></h4>
<p>Following is a quick tour of some of the many possible further optimizations to Listing 37.1.</p>
<p>The run-handling loops could be unrolled more than the current two times. However, bear in mind that a two-times unrolling gets more than half the maximum unrolling benefit with less overhead than a more heavily unrolled loop.</p>
<p>BX could be freed up in the Y-major code by breaking out separate loops for X advances of 1 and -1. DX could be freed up by using AH as the counter for the run loops, although this would limit the maximum line length that could be handled. The freed registers could be used to keep more of the whole-step and error variables in registers. Alternatively, the freed registers could be used to implement more esoteric approaches like unrolling the Y-major inner loop; such unrolling could take advantage of the knowledge that only two run lengths are possible for any given line. Strangely enough, on the 486 it might also be worth unrolling the X-major inner loop, which consists of <code>REP STOSB</code>, because of the slow start-up time of <code>REP</code> relative to the speed of branching on that processor.</p>
<p>Special code could be implemented for lines with integral slopes, because all runs are exactly the same length in such lines. Also, the X-major code could try to write an aligned word at a time to display memory whenever possible; this would improve the maximum possible performance on some 16-bit VGAs.</p>
<p>One weakness of Listing 37.1 is that for lines with slopes between 0.5 and 2, the average run length is less than two, rendering run-length slicing ineffective. This can be remedied by viewing lines in that range as being composed of diagonal, rather than horizontal or vertical runs. I haven’t space to take this idea any further in this book, but it’s not very complicated, and it guarantees a minimum run length of 2, which renders run drawing considerably more efficient, and makes techniques such as unrolling the inner run-drawing loops more attractive.</p>
<p>Finally, be aware that run-length slice drawing is best for long lines, because it has more and slower setup than a standard Bresenham’s line draw, including a divide. Run-length slice is great for 100-pixel lines, but not necessarily for 20-pixel lines, and it’s a sure thing that it’s not terrific for 3-pixel lines. Both approaches will work, but if line-drawing performance is critical, whether you’ll want to use run-length slice or standard Bresenham’s depends on the typical lengths of the lines you’ll be drawing. For lines of widely varying lengths, you might want to implement both approaches, and choose the best one for each line, depending on the line length—assuming, of course, that your display memory is fast enough and your application demanding enough to make that level of optimization worthwhile.</p>
<p>If your code looks broken from a performance perspective, think before you fix it; that particular cat may be dead for a perfectly good reason. I’ll say it again: <em>Profile before you optimize</em>.</p>
</section>
</section>
</section>
<section id="chapter-38-the-polygon-primeval" class="level2">
<h2><a href="#chapter-38-the-polygon-primeval">Chapter 38 – The Polygon Primeval</a></h2>
<section id="drawing-polygons-efficiently-and-quickly" class="level3">
<h3><a href="#drawing-polygons-efficiently-and-quickly">Drawing Polygons Efficiently and Quickly</a></h3>
<p><em>“Give me but one firm spot on which to stand, and I will move the Earth.”</em></p>
<p>—Archimedes</p>
<p>Were Archimedes alive today, he might say, “Give me but one fast polygon-fill routine on which to call, and I will draw the Earth.” Programmers often think of pixel drawing as being the basic graphics primitive, but filled polygons are equally fundamental and far more useful. Filled polygons can be used for constructs as diverse as a single pixel or a 3-D surface, and virtually everything in between.</p>
<p>I’ll spend some time in this chapter and the next several developing routines to draw filled polygons and building more sophisticated graphics operations atop those routines. Once we have that foundation, I’ll get into 2-D manipulation and animation of polygon-based entities as preface to an exploration of 3-D graphics. You can’t get there from here without laying some groundwork, though, so in this chapter I’ll begin with the basics of filling a polygon. In the next chapter, we’ll see how to draw a polygon considerably faster. That’s my general approach for this sort of topic: High-level exploration of a graphics topic first, followed by a speedy hardware-specific implementation for the IBM PC/VGA combination, the most widely used graphics system around. Abstract, machine-independent graphics is a thing of beauty, but only by understanding graphics at all levels, including the hardware, can you boost performance into the realm of the sublime.</p>
<p>And slow computer graphics is scarcely worth the bother.</p>
</section>
<section id="filled-polygons" class="level3">
<h3><a href="#filled-polygons">Filled Polygons</a></h3>
<p>A polygon is simply a shape formed by lines laid end to end to form a continuous, closed path. A polygon is filled by setting all pixels within the polygon’s boundaries to a color or pattern. For now, we’ll work only with polygons filled with solid colors.</p>
<p>You can divide polygons into three categories: convex, nonconvex, and complex, as shown in Figure 38.1. Convex polygons include what you’d normally think of as “convex” and more; as far as we’re concerned, a convex polygon is one for which any horizontal line drawn through the polygon encounters the right edge exactly once and the left edge exactly once, excluding horizontal and zero-length edge segments. Put another way, neither the right nor left edge of a convex polygon ever reverses direction from up to down, or vice-versa. Also, the right and left edges of a convex polygon may not cross one another, although they may touch so long as the right edge never crosses over to the left side of the left edge. (Check out the second polygon drawn in Listing 38.3, which certainly isn’t convex in the normal sense.) The boundaries of nonconvex polygons, on the other hand, can go in whatever directions they please, so long as they never cross. Complex polygons can have any boundaries you might imagine, which makes for interesting problems in deciding which interior spaces to fill and which not to fill. Each category is a superset of the previous one.</p>
<p>(See Chapter 41 for a more detailed discussion of polygon types and naming.)</p>
<p>Why bother to distinguish between convex, nonconvex, and complex polygons? Easy: performance, especially when it comes to filling convex polygons. We’re going to start with filled convex polygons; they’re widely useful and will serve well to introduce some of the subtler complexities of polygon drawing, not the least of which is the slippery concept of “inside.”</p>
<section id="which-side-is-inside" class="level4">
<h4><a href="#which-side-is-inside">Which Side Is Inside?</a></h4>
<p>The basic principle of polygon filling is decomposing each polygon into a series of horizontal lines, one for each horizontal row of pixels, or scan line, within the polygon (a process I’ll call <em>scan conversion</em>), and drawing the horizontal lines. I’ll refer to the entire process as rasterization. Rasterization of convex polygons is easily done by starting at the top of the polygon and tracing down the left and right sides, one scan line (one vertical pixel) at a time, filling the extent between the two edges on each scan line, until the bottom of the polygon is reached. At first glance, rasterization does not seem to be particularly complicated, although it should be apparent that this simple approach is inadequate for nonconvex polygons.</p>
<figure>
<img src="images/38-01.jpg" alt="Figure 38.1  Convex, nonconvex, and complex polygons." /><figcaption><strong>Figure 38.1</strong>  <em>Convex, nonconvex, and complex polygons.</em></figcaption>
</figure>
<p>There are a couple of complications, however. The lesser complication is how to rasterize the polygon efficiently, given that it’s difficult to write fast code that simultaneously traces two edges and fills the space between them. The solution is to decouple the process of scan-converting the polygon into a list of horizontal lines from that of drawing the horizontal lines. One device-independent routine can trace along the two edges and build a list of the beginning and end coordinates of the polygon on each raster line. Then a second, device-specific, routine can draw from the list after the entire polygon has been scanned. We’ll see this in action shortly.</p>
<p>The second, greater complication arises because the definition of which pixels are “within” a polygon is a more complicated matter than you might imagine. You might think that scan-converting an edge of a polygon is analogous to drawing a line from one vertex to the next, but this is not so. A line by itself is a one-dimensional construct, and as such is approximated on a display by drawing the pixels nearest to the line on either side of the true line. A line serving as a polygon boundary, on the other hand, is part of a two-dimensional object. When filling a polygon, we want to draw the pixels within the polygon, but a standard vertex-to-vertex line-drawing algorithm will draw many pixels outside the polygon, as shown in Figure 38.2.</p>
<p>It’s no crime to use standard lines to trace out a polygon, rather than drawing only interior pixels. In fact, there are certain advantages: For example, the edges of a filled polygon will match the edges of the same polygon drawn unfilled. Such polygons will look pretty much as they’re supposed to, and all drawing on raster displays is, after all, only an approximation of an ideal.</p>
<figure>
<img src="images/38-02.jpg" alt="Figure 38.2  Drawing polygons with standard line-drawing algorithms." /><figcaption><strong>Figure 38.2</strong>  <em>Drawing polygons with standard line-drawing algorithms.</em></figcaption>
</figure>
<p>There’s one great drawback to tracing polygons with standard lines, however: Adjacent polygons won’t fit together properly, as shown in Figure 38.3. If you use six equilateral triangles to make a hexagon, for example, the edges of the triangles will overlap when traced with standard lines, and more recently drawn triangles will wipe out portions of their predecessors. Worse still, odd color effects will show up along the polygon boundaries if XOR drawing is used. Consequently, filling out to the boundary lines just won’t do for drawing images composed of fitted-together polygons. And because fitting polygons together is exactly what I have in mind, we need a different approach.</p>
</section>
<section id="how-do-you-fit-polygons-together" class="level4">
<h4><a href="#how-do-you-fit-polygons-together">How Do You Fit Polygons Together?</a></h4>
<p>How, then, do you fit polygons together? <em>Very</em> carefully. First, the line-tracing algorithm must be adjusted so that it selects only those pixels that are truly inside the polygon. This basically requires shifting a standard line-drawing algorithm horizontally by one half-pixel toward the polygon’s interior. That leaves the issue of how to handle points that are exactly on the boundary, and points that lie at vertices, so that those points are drawn once and only once. To deal with that, we’re going to adopt the following rules:</p>
<ul>
<li><p>Points located exactly on nonhorizontal edges are drawn only if the interior of the polygon is directly to the right (left edges are drawn, right edges aren’t).</p>
<figure>
<img src="images/38-03.jpg" alt="Figure 38.3  The adjacent polygons problem." /><figcaption><strong>Figure 38.3</strong>  <em>The adjacent polygons problem.</em></figcaption>
</figure></li>
<li>Points located exactly on horizontal edges are drawn only if the interior of the polygon is directly below them (horizontal top edges are drawn, horizontal bottom edges aren’t).</li>
<li><p>A vertex is drawn only if all lines ending at that point meet the above conditions (no right or bottom edges end at that point).</p></li>
</ul>
<p>All edges of a polygon except those that are flat tops or flat bottoms will be considered either right edges or left edges, regardless of slope. The left edge is the one that starts with the leftmost line down from the top of the polygon.</p>
<p>These rules ensure that no pixel is drawn more than once when adjacent polygons are filled, and that if polygons cover the full 360-degree range around a pixel, then that pixel will be drawn once and only once—just what we need in order to be able to fit filled polygons together seamlessly.</p>
<blockquote>
<p><img src="images/i.jpg" /> This sort of non-overlapping polygon filling isn’t ideal for all purposes. Polygons are skewed toward the top and left edges, which not only introduces drawing error relative to the ideal polygon but also means that a filled polygon won’t match the same polygon drawn unfilled. Narrow wedges and one-pixel-wide polygons will show up spottily. All in all, the choice of polygon-filling approach depends entirely on the ways in which the filled polygons must be used.</p>
</blockquote>
<p>For our purposes, nonoverlapping polygons are the way to go, so let’s have at them.</p>
</section>
</section>
<section id="filling-non-overlapping-convex-polygons" class="level3">
<h3><a href="#filling-non-overlapping-convex-polygons">Filling Non-Overlapping Convex Polygons</a></h3>
<p>Without further ado, Listing 38.1 contains a function, <code>FillConvexPolygon</code>, that accepts a list of points that describe a convex polygon, with the last point assumed to connect to the first, and scans it into a list of lines to fill, then passes that list to the function <code>DrawHorizontalLineList</code> in Listing 38.2. Listing 38.3 is a sample program that calls <code>FillConvexPolygon</code> to draw polygons of various sorts, and Listing 38.4 is a header file included by the other listings. Here are the listings; we’ll pick up discussion on the other side.</p>
<p><strong>LISTING 38.1 L38-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Color-fills a convex polygon. All vertices are offset by (XOffset,</span>
<span class="co">  YOffset). &quot;Convex&quot; means that every horizontal line drawn through</span>
<span class="co">  the polygon at any point would cross exactly two active edges</span>
<span class="co">  (neither horizontal lines nor zero-length edges count as active</span>
<span class="co">  edges; both are acceptable anywhere in the polygon), and that the</span>
<span class="co">  right &amp; left edges never cross. (It&#39;s OK for them to touch, though,</span>
<span class="co">  so long as the right edge never crosses over to the left of the</span>
<span class="co">  left edge.) Nonconvex polygons won&#39;t be drawn properly. Returns 1</span>
<span class="co">  for success, 0 if memory allocation failed. */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#ifdef __TURBOC__</span>
<span class="ot">#include &lt;alloc.h&gt;</span>
<span class="ot">#else    </span><span class="co">/* MSC */</span>
<span class="ot">#include &lt;malloc.h&gt;</span>
<span class="ot">#endif</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="co">/* Advances the index by one vertex forward through the vertex list,</span>
<span class="co">   wrapping at the end of the list */</span>
<span class="ot">#define INDEX_FORWARD(Index) \</span>
   Index = (Index + <span class="dv">1</span>) % VertexList-&gt;Length;

<span class="co">/* Advances the index by one vertex backward through the vertex list,</span>
<span class="co">   wrapping at the start of the list */</span>
<span class="ot">#define INDEX_BACKWARD(Index) \</span>
   Index = (Index - <span class="dv">1</span> + VertexList-&gt;Length) % VertexList-&gt;Length;

<span class="co">/* Advances the index by one vertex either forward or backward through</span>
<span class="co">   the vertex list, wrapping at either end of the list */</span>
<span class="ot">#define INDEX_MOVE(Index,Direction)                                  \</span>
   <span class="kw">if</span> (Direction &gt; <span class="dv">0</span>)                                                \
      Index = (Index + <span class="dv">1</span>) % VertexList-&gt;Length;                      \
   <span class="kw">else</span>                                                              \
      Index = (Index - <span class="dv">1</span> + VertexList-&gt;Length) % VertexList-&gt;Length;

<span class="kw">extern</span> <span class="dt">void</span> DrawHorizontalLineList(<span class="kw">struct</span> HLineList *, <span class="dt">int</span>);
<span class="dt">static</span> <span class="dt">void</span> ScanEdge(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="kw">struct</span> HLine **);

<span class="dt">int</span> FillConvexPolygon(<span class="kw">struct</span> PointListHeader * VertexList, <span class="dt">int</span> Color,
      <span class="dt">int</span> XOffset, <span class="dt">int</span> YOffset)
{
  <span class="dt">int</span> i, MinIndexL, MaxIndex, MinIndexR, SkipFirst, Temp;
  <span class="dt">int</span> MinPoint_Y, MaxPoint_Y, TopIsFlat, LeftEdgeDir;
  <span class="dt">int</span> NextIndex, CurrentIndex, PreviousIndex;
  <span class="dt">int</span> DeltaXN, DeltaYN, DeltaXP, DeltaYP;
  <span class="kw">struct</span> HLineList WorkingHLineList;
  <span class="kw">struct</span> HLine *EdgePointPtr;
  <span class="kw">struct</span> Point *VertexPtr;

  <span class="co">/* Point to the vertex list */</span>
  VertexPtr = VertexList-&gt;PointPtr;

  <span class="co">/* Scan the list to find the top and bottom of the polygon */</span>
  <span class="kw">if</span> (VertexList-&gt;Length == <span class="dv">0</span>)
     <span class="kw">return</span>(<span class="dv">1</span>);  <span class="co">/* reject null polygons */</span>
  MaxPoint_Y = MinPoint_Y = VertexPtr[MinIndexL = MaxIndex = <span class="dv">0</span>].Y;
  <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt; VertexList-&gt;Length; i++) {
     <span class="kw">if</span> (VertexPtr[i].Y &lt; MinPoint_Y)
        MinPoint_Y = VertexPtr[MinIndexL = i].Y; <span class="co">/* new top */</span>
     <span class="kw">else</span> <span class="kw">if</span> (VertexPtr[i].Y &gt; MaxPoint_Y)
        MaxPoint_Y = VertexPtr[MaxIndex = i].Y; <span class="co">/* new bottom */</span>
  }
  <span class="kw">if</span> (MinPoint_Y == MaxPoint_Y)
     <span class="kw">return</span>(<span class="dv">1</span>);  <span class="co">/* polygon is 0-height; avoid infinite loop below */</span>

  <span class="co">/* Scan in ascending order to find the last top-edge point */</span>
  MinIndexR = MinIndexL;
  <span class="kw">while</span> (VertexPtr[MinIndexR].Y == MinPoint_Y)
     INDEX_FORWARD(MinIndexR);
  INDEX_BACKWARD(MinIndexR); <span class="co">/* back up to last top-edge point */</span>

  <span class="co">/* Now scan in descending order to find the first top-edge point */</span>
  <span class="kw">while</span> (VertexPtr[MinIndexL].Y == MinPoint_Y)
     INDEX_BACKWARD(MinIndexL);
  INDEX_FORWARD(MinIndexL); <span class="co">/* back up to first top-edge point */</span>

  <span class="co">/* Figure out which direction through the vertex list from the top</span>
<span class="co">     vertex is the left edge and which is the right */</span>
  LeftEdgeDir = -<span class="dv">1</span>; <span class="co">/* assume left edge runs down thru vertex list */</span>
  <span class="kw">if</span> ((TopIsFlat = (VertexPtr[MinIndexL].X !=
        VertexPtr[MinIndexR].X) ? <span class="dv">1</span> : <span class="dv">0</span>) == <span class="dv">1</span>) {
     <span class="co">/* If the top is flat, just see which of the ends is leftmost */</span>
     <span class="kw">if</span> (VertexPtr[MinIndexL].X &gt; VertexPtr[MinIndexR].X) {
        LeftEdgeDir = <span class="dv">1</span>;  <span class="co">/* left edge runs up through vertex list */</span>
        Temp = MinIndexL;       <span class="co">/* swap the indices so MinIndexL   */</span>
        MinIndexL = MinIndexR;  <span class="co">/* points to the start of the left */</span>
        MinIndexR = Temp;       <span class="co">/* edge, similarly for MinIndexR   */</span>
     }
  } <span class="kw">else</span> {
     <span class="co">/* Point to the downward end of the first line of each of the</span>
<span class="co">        two edges down from the top */</span>
     NextIndex = MinIndexR;
     INDEX_FORWARD(NextIndex);
     PreviousIndex = MinIndexL;
     INDEX_BACKWARD(PreviousIndex);
     <span class="co">/* Calculate X and Y lengths from the top vertex to the end of</span>
<span class="co">        the first line down each edge; use those to compare slopes</span>
<span class="co">        and see which line is leftmost */</span>
     DeltaXN = VertexPtr[NextIndex].X - VertexPtr[MinIndexL].X;
     DeltaYN = VertexPtr[NextIndex].Y - VertexPtr[MinIndexL].Y;
     DeltaXP = VertexPtr[PreviousIndex].X - VertexPtr[MinIndexL].X;
     DeltaYP = VertexPtr[PreviousIndex].Y - VertexPtr[MinIndexL].Y;
     <span class="kw">if</span> (((<span class="dt">long</span>)DeltaXN * DeltaYP - (<span class="dt">long</span>)DeltaYN * DeltaXP) &lt; 0L) {
        LeftEdgeDir = <span class="dv">1</span>;  <span class="co">/* left edge runs up through vertex list */</span>
        Temp = MinIndexL;       <span class="co">/* swap the indices so MinIndexL   */</span>
        MinIndexL = MinIndexR;  <span class="co">/* points to the start of the left */</span>
        MinIndexR = Temp;       <span class="co">/* edge, similarly for MinIndexR   */</span>
     }
  }

  <span class="co">/* Set the # of scan lines in the polygon, skipping the bottom edge</span>
<span class="co">     and also skipping the top vertex if the top isn&#39;t flat because</span>
<span class="co">     in that case the top vertex has a right edge component, and set</span>
<span class="co">     the top scan line to draw, which is likewise the second line of</span>
<span class="co">     the polygon unless the top is flat */</span>
  <span class="kw">if</span> ((WorkingHLineList.Length =
        MaxPoint_Y - MinPoint_Y - <span class="dv">1</span> + TopIsFlat) &lt;= <span class="dv">0</span>)
     <span class="kw">return</span>(<span class="dv">1</span>);  <span class="co">/* there&#39;s nothing to draw, so we&#39;re done */</span>
  WorkingHLineList.YStart = YOffset + MinPoint_Y + <span class="dv">1</span> - TopIsFlat;

  <span class="co">/* Get memory in which to store the line list we generate */</span>
  <span class="kw">if</span> ((WorkingHLineList.HLinePtr =
        (<span class="kw">struct</span> HLine *) (malloc(<span class="kw">sizeof</span>(<span class="kw">struct</span> HLine) *
        WorkingHLineList.Length))) == NULL)
     <span class="kw">return</span>(<span class="dv">0</span>);  <span class="co">/* couldn&#39;t get memory for the line list */</span>

  <span class="co">/* Scan the left edge and store the boundary points in the list */</span>
  <span class="co">/* Initial pointer for storing scan converted left-edge coords */</span>
  EdgePointPtr = WorkingHLineList.HLinePtr;
  <span class="co">/* Start from the top of the left edge */</span>
  PreviousIndex = CurrentIndex = MinIndexL;
  <span class="co">/* Skip the first point of the first line unless the top is flat;</span>
<span class="co">     if the top isn&#39;t flat, the top vertex is exactly on a right</span>
<span class="co">     edge and isn&#39;t drawn */</span>
  SkipFirst = TopIsFlat ? <span class="dv">0</span> : <span class="dv">1</span>;
  <span class="co">/* Scan convert each line in the left edge from top to bottom */</span>
  <span class="kw">do</span> {
     INDEX_MOVE(CurrentIndex,LeftEdgeDir);
     ScanEdge(VertexPtr[PreviousIndex].X + XOffset,
           VertexPtr[PreviousIndex].Y,
           VertexPtr[CurrentIndex].X + XOffset,
           VertexPtr[CurrentIndex].Y, <span class="dv">1</span>, SkipFirst, &amp;EdgePointPtr);
     PreviousIndex = CurrentIndex;
     SkipFirst = <span class="dv">0</span>; <span class="co">/* scan convert the first point from now on */</span>
  } <span class="kw">while</span> (CurrentIndex != MaxIndex);

  <span class="co">/* Scan the right edge and store the boundary points in the list */</span>
  EdgePointPtr = WorkingHLineList.HLinePtr;
  PreviousIndex = CurrentIndex = MinIndexR;
  SkipFirst = TopIsFlat ? <span class="dv">0</span> : <span class="dv">1</span>;
  <span class="co">/* Scan convert the right edge, top to bottom. X coordinates are</span>
<span class="co">     adjusted 1 to the left, effectively causing scan conversion of</span>
<span class="co">     the nearest points to the left of but not exactly on the edge */</span>
  <span class="kw">do</span> {
     INDEX_MOVE(CurrentIndex,-LeftEdgeDir);
     ScanEdge(VertexPtr[PreviousIndex].X + XOffset - <span class="dv">1</span>,
           VertexPtr[PreviousIndex].Y,
           VertexPtr[CurrentIndex].X + XOffset - <span class="dv">1</span>,
           VertexPtr[CurrentIndex].Y, <span class="dv">0</span>, SkipFirst, &amp;EdgePointPtr);
     PreviousIndex = CurrentIndex;
     SkipFirst = <span class="dv">0</span>; <span class="co">/* scan convert the first point from now on */</span>
  } <span class="kw">while</span> (CurrentIndex != MaxIndex);

  <span class="co">/* Draw the line list representing the scan converted polygon */</span>
  DrawHorizontalLineList(&amp;WorkingHLineList, Color);

  <span class="co">/* Release the line list&#39;s memory and we&#39;re successfully done */</span>
  free(WorkingHLineList.HLinePtr);
  <span class="kw">return</span>(<span class="dv">1</span>);
}

<span class="co">/* Scan converts an edge from (X1,Y1) to (X2,Y2), not including the</span>
<span class="co">   point at (X2,Y2). This avoids overlapping the end of one line with</span>
<span class="co">   the start of the next, and causes the bottom scan line of the</span>
<span class="co">   polygon not to be drawn. If SkipFirst != 0, the point at (X1,Y1)</span>
<span class="co">   isn&#39;t drawn. For each scan line, the pixel closest to the scanned</span>
<span class="co">   line without being to the left of the scanned line is chosen. */</span>
<span class="dt">static</span> <span class="dt">void</span> ScanEdge(<span class="dt">int</span> X1, <span class="dt">int</span> Y1, <span class="dt">int</span> X2, <span class="dt">int</span> Y2, <span class="dt">int</span> SetXStart,
      <span class="dt">int</span> SkipFirst, <span class="kw">struct</span> HLine **EdgePointPtr)
{
  <span class="dt">int</span> Y, DeltaX, DeltaY;
  <span class="dt">double</span> InverseSlope;
  <span class="kw">struct</span> HLine *WorkingEdgePointPtr;

  <span class="co">/* Calculate X and Y lengths of the line and the inverse slope */</span>
  DeltaX = X2 - X1;
  <span class="kw">if</span> ((DeltaY = Y2 - Y1) &lt;= <span class="dv">0</span>)
     <span class="kw">return</span>;     <span class="co">/* guard against 0-length and horizontal edges */</span>
  InverseSlope = (<span class="dt">double</span>)DeltaX / (<span class="dt">double</span>)DeltaY;

  <span class="co">/* Store the X coordinate of the pixel closest to but not to the</span>
<span class="co">     left of the line for each Y coordinate between Y1 and Y2, not</span>
<span class="co">     including Y2 and also not including Y1 if SkipFirst != 0 */</span>
  WorkingEdgePointPtr = *EdgePointPtr; <span class="co">/* avoid double dereference */</span>
  <span class="kw">for</span> (Y = Y1 + SkipFirst; Y &lt; Y2; Y++, WorkingEdgePointPtr++) {
     <span class="co">/* Store the X coordinate in the appropriate edge list */</span>
     <span class="kw">if</span> (SetXStart == <span class="dv">1</span>)
        WorkingEdgePointPtr-&gt;XStart =
              X1 + (<span class="dt">int</span>)(ceil((Y-Y1) * InverseSlope));
     <span class="kw">else</span>
        WorkingEdgePointPtr-&gt;XEnd =
              X1 + (<span class="dt">int</span>)(ceil((Y-Y1) * InverseSlope));
  }
  *EdgePointPtr = WorkingEdgePointPtr;   <span class="co">/* advance caller&#39;s ptr */</span>
}</code></pre>
<p><strong>LISTING 38.2 L38-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Draws all pixels in the list of horizontal lines passed in, in</span>
<span class="co">   mode 13h, the VGA&#39;s 320x200 256-color mode. Uses a slow pixel-by-</span>
<span class="co">   pixel approach, which does have the virtue of being easily ported</span>
<span class="co">   to any environment. */</span>

<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="ot">#define SCREEN_WIDTH    320</span>
<span class="ot">#define SCREEN_SEGMENT  0xA000</span>

<span class="dt">static</span> <span class="dt">void</span> DrawPixel(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);

<span class="dt">void</span> DrawHorizontalLineList(<span class="kw">struct</span> HLineList * HLineListPtr,
      <span class="dt">int</span> Color)
{
  <span class="kw">struct</span> HLine *HLinePtr;
  <span class="dt">int</span> Y, X;

  <span class="co">/* Point to the XStart/XEnd descriptor for the first (top)</span>
<span class="co">     horizontal line */</span>
  HLinePtr = HLineListPtr-&gt;HLinePtr;
  <span class="co">/* Draw each horizontal line in turn, starting with the top one and</span>
<span class="co">     advancing one line each time */</span>
  <span class="kw">for</span> (Y = HLineListPtr-&gt;YStart; Y &lt; (HLineListPtr-&gt;YStart +
        HLineListPtr-&gt;Length); Y++, HLinePtr++) {
     <span class="co">/* Draw each pixel in the current horizontal line in turn,</span>
<span class="co">        starting with the leftmost one */</span>
     <span class="kw">for</span> (X = HLinePtr-&gt;XStart; X &lt;= HLinePtr-&gt;XEnd; X++)
        DrawPixel(X, Y, Color);
  }
}

<span class="co">/* Draws the pixel at (X, Y) in color Color in VGA mode 13h */</span>
<span class="dt">static</span> <span class="dt">void</span> DrawPixel(<span class="dt">int</span> X, <span class="dt">int</span> Y, <span class="dt">int</span> Color) {
   <span class="dt">unsigned</span> <span class="dt">char</span> far *ScreenPtr;

<span class="ot">#ifdef __TURBOC__</span>
   ScreenPtr = MK_FP(SCREEN_SEGMENT, Y * SCREEN_WIDTH + X);
<span class="ot">#else    </span><span class="co">/* MSC 5.0 */</span>
   FP_SEG(ScreenPtr) = SCREEN_SEGMENT;
   FP_OFF(ScreenPtr) = Y * SCREEN_WIDTH + X;
<span class="ot">#endif</span>
   *ScreenPtr = (<span class="dt">unsigned</span> <span class="dt">char</span>)Color;
}</code></pre>
<p><strong>LISTING 38.3 L38-3.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Sample program to exercise the polygon-filling routines. This code</span>
<span class="co">   and all polygon-filling code has been tested with Borland and</span>
<span class="co">   Microsoft compilers. */</span>

<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="co">/* Draws the polygon described by the point list PointList in color</span>
<span class="co">   Color with all vertices offset by (X,Y) */</span>
<span class="ot">#define DRAW_POLYGON(PointList,Color,X,Y)                   \</span>
   Polygon.Length = <span class="kw">sizeof</span>(PointList)/<span class="kw">sizeof</span>(<span class="kw">struct</span> Point); \
   Polygon.PointPtr = PointList;                            \
   FillConvexPolygon(&amp;Polygon, Color, X, Y);
  
<span class="dt">void</span> main(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">int</span> FillConvexPolygon(<span class="kw">struct</span> PointListHeader *, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);

<span class="dt">void</span> main() {
  <span class="dt">int</span> i, j;
  <span class="kw">struct</span> PointListHeader Polygon;
  <span class="dt">static</span> <span class="kw">struct</span> Point ScreenRectangle[] =
        {{<span class="dv">0</span>,<span class="dv">0</span>},{<span class="dv">320</span>,<span class="dv">0</span>},{<span class="dv">320</span>,<span class="dv">200</span>},{<span class="dv">0</span>,<span class="dv">200</span>}};
  <span class="dt">static</span> <span class="kw">struct</span> Point ConvexShape[] =
        {{<span class="dv">0</span>,<span class="dv">0</span>},{<span class="dv">121</span>,<span class="dv">0</span>},{<span class="dv">320</span>,<span class="dv">0</span>},{<span class="dv">200</span>,<span class="dv">51</span>},{<span class="dv">301</span>,<span class="dv">51</span>},{<span class="dv">250</span>,<span class="dv">51</span>},{<span class="dv">319</span>,<span class="dv">143</span>},
        {<span class="dv">320</span>,<span class="dv">200</span>},{<span class="dv">22</span>,<span class="dv">200</span>},{<span class="dv">0</span>,<span class="dv">200</span>},{<span class="dv">50</span>,<span class="dv">180</span>},{<span class="dv">20</span>,<span class="dv">160</span>},{<span class="dv">50</span>,<span class="dv">140</span>},
        {<span class="dv">20</span>,<span class="dv">120</span>},{<span class="dv">50</span>,<span class="dv">100</span>},{<span class="dv">20</span>,<span class="dv">80</span>},{<span class="dv">50</span>,<span class="dv">60</span>},{<span class="dv">20</span>,<span class="dv">40</span>},{<span class="dv">50</span>,<span class="dv">20</span>}};
  <span class="dt">static</span> <span class="kw">struct</span> Point Hexagon[] =
        {{<span class="dv">90</span>,-<span class="dv">50</span>},{<span class="dv">0</span>,-<span class="dv">90</span>},{-<span class="dv">90</span>,-<span class="dv">50</span>},{-<span class="dv">90</span>,<span class="dv">50</span>},{<span class="dv">0</span>,<span class="dv">90</span>},{<span class="dv">90</span>,<span class="dv">50</span>}};
  <span class="dt">static</span> <span class="kw">struct</span> Point Triangle1[] = {{<span class="dv">30</span>,<span class="dv">0</span>},{<span class="dv">15</span>,<span class="dv">20</span>},{<span class="dv">0</span>,<span class="dv">0</span>}};
  <span class="dt">static</span> <span class="kw">struct</span> Point Triangle2[] = {{<span class="dv">30</span>,<span class="dv">20</span>},{<span class="dv">15</span>,<span class="dv">0</span>},{<span class="dv">0</span>,<span class="dv">20</span>}};
  <span class="dt">static</span> <span class="kw">struct</span> Point Triangle3[] = {{<span class="dv">0</span>,<span class="dv">20</span>},{<span class="dv">20</span>,<span class="dv">10</span>},{<span class="dv">0</span>,<span class="dv">0</span>}};
  <span class="dt">static</span> <span class="kw">struct</span> Point Triangle4[] = {{<span class="dv">20</span>,<span class="dv">20</span>},{<span class="dv">20</span>,<span class="dv">0</span>},{<span class="dv">0</span>,<span class="dv">10</span>}};
  <span class="kw">union</span> REGS regset;

  <span class="co">/* Set the display to VGA mode 13h, 320x200 256-color mode */</span>
  regset.x.ax = <span class="bn">0x0013</span>;   <span class="co">/* AH = 0 selects mode set function,</span>
<span class="co">                             AL = 0x13 selects mode 0x13</span>
<span class="co">                             when set as parameters for INT 0x10 */</span>
  int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);

  <span class="co">/* Clear the screen to cyan */</span>
  DRAW_POLYGON(ScreenRectangle, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">0</span>);

  <span class="co">/* Draw an irregular shape that meets our definition of convex but</span>
<span class="co">     is not convex by any normal description */</span>
  DRAW_POLYGON(ConvexShape, <span class="dv">6</span>, <span class="dv">0</span>, <span class="dv">0</span>);
  getch();    <span class="co">/* wait for a keypress */</span>

  <span class="co">/* Draw adjacent triangles across the top half of the screen */</span>
  <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;=<span class="dv">80</span>; j+=<span class="dv">20</span>) {
     <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">290</span>; i += <span class="dv">30</span>) {
        DRAW_POLYGON(Triangle1, <span class="dv">2</span>, i, j);
        DRAW_POLYGON(Triangle2, <span class="dv">4</span>, i<span class="dv">+15</span>, j);
     }
  }

  <span class="co">/* Draw adjacent triangles across the bottom half of the screen */</span>
  <span class="kw">for</span> (j=<span class="dv">100</span>; j&lt;=<span class="dv">170</span>; j+=<span class="dv">20</span>) {
     <span class="co">/* Do a row of pointing-right triangles */</span>
     <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">290</span>; i += <span class="dv">20</span>) {
        DRAW_POLYGON(Triangle3, <span class="dv">40</span>, i, j);
     }
     <span class="co">/* Do a row of pointing-left triangles halfway between one row</span>
<span class="co">        of pointing-right triangles and the next, to fit between */</span>
     <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">290</span>; i += <span class="dv">20</span>) {
        DRAW_POLYGON(Triangle4, <span class="dv">1</span>, i, j<span class="dv">+10</span>);
     }
  }
  getch();    <span class="co">/* wait for a keypress */</span>

  <span class="co">/* Finally, draw a series of concentric hexagons of approximately</span>
<span class="co">     the same proportions in the center of the screen */</span>
  <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">16</span>; i++) {
     DRAW_POLYGON(Hexagon, i, <span class="dv">160</span>, <span class="dv">100</span>);
     <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;<span class="kw">sizeof</span>(Hexagon)/<span class="kw">sizeof</span>(<span class="kw">struct</span> Point); j++) {
        <span class="co">/* Advance each vertex toward the center */</span>
        <span class="kw">if</span> (Hexagon[j].X != <span class="dv">0</span>) {
           Hexagon[j].X -= Hexagon[j].X &gt;= <span class="dv">0</span> ? <span class="dv">3</span> : -<span class="dv">3</span>;
           Hexagon[j].Y -= Hexagon[j].Y &gt;= <span class="dv">0</span> ? <span class="dv">2</span> : -<span class="dv">2</span>;
        } <span class="kw">else</span> {
           Hexagon[j].Y -= Hexagon[j].Y &gt;= <span class="dv">0</span> ? <span class="dv">3</span> : -<span class="dv">3</span>;
        }
     }
  }
  getch();    <span class="co">/* wait for a keypress */</span>

  <span class="co">/* Return to text mode and exit */</span>
  regset.x.ax = <span class="bn">0x0003</span>;   <span class="co">/* AL = 3 selects 80x25 text mode */</span>
  int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}</code></pre>
<p><strong>LISTING 38.4 POLYGON.H</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* POLYGON.H: Header file for polygon-filling code */</span>

<span class="co">/* Describes a single point (used for a single vertex) */</span>
<span class="kw">struct</span> Point {
  <span class="dt">int</span> X;   <span class="co">/* X coordinate */</span>
  <span class="dt">int</span> Y;   <span class="co">/* Y coordinate */</span>
};

<span class="co">/* Describes a series of points (used to store a list of vertices that</span>
<span class="co">   describe a polygon; each vertex is assumed to connect to the two</span>
<span class="co">   adjacent vertices, and the last vertex is assumed to connect to the</span>
<span class="co">   first) */</span>
<span class="kw">struct</span> PointListHeader {
  <span class="dt">int</span> Length;                <span class="co">/* # of points */</span>
  <span class="kw">struct</span> Point * PointPtr;   <span class="co">/* pointer to list of points */</span>
};

<span class="co">/* Describes the beginning and ending X coordinates of a single</span>
<span class="co">   horizontal line */</span>
<span class="kw">struct</span> HLine {
  <span class="dt">int</span> XStart; <span class="co">/* X coordinate of leftmost pixel in line */</span>
  <span class="dt">int</span> XEnd;   <span class="co">/* X coordinate of rightmost pixel in line */</span>
};

<span class="co">/* Describes a Length-long series of horizontal lines, all assumed to</span>
<span class="co">   be on contiguous scan lines starting at YStart and proceeding</span>
<span class="co">   downward (used to describe a scan-converted polygon to the</span>
<span class="co">   low-level hardware-dependent drawing code) */</span>
<span class="kw">struct</span> HLineList {
  <span class="dt">int</span> Length;                <span class="co">/* # of horizontal lines */</span>
  <span class="dt">int</span> YStart;                <span class="co">/* Y coordinate of topmost line */</span>
  <span class="kw">struct</span> HLine * HLinePtr;   <span class="co">/* pointer to list of horz lines */</span>
};</code></pre>
<p>Listing 38.2 isn’t particularly interesting; it merely draws each horizontal line in the passed-in list in the simplest possible way, one pixel at a time. (No, that doesn’t make the pixel the fundamental primitive; in the next chapter I’ll replace Listing 38.2 with a much faster version that doesn’t bother with individual pixels at all.)</p>
<p>Listing 38.1 is where the action is in this chapter. Our goal is to scan out the left and right edges of each polygon so that all points inside and no points outside the polygon are drawn, and so that all points located exactly on the boundary are drawn only if they are not on right or bottom edges. That’s precisely what Listing 38.1 does. Here’s how:</p>
<p>Listing 38.1 first finds the top and bottom of the polygon, then works out from the top point to find the two ends of the top edge. If the ends are at different locations, the top is flat, which has two implications. First, it’s easy to find the starting vertices and directions through the vertex list for the left and right edges. (To scan-convert them properly, we must first determine which edge is which.) Second, the top scan line of the polygon should be drawn without the rightmost pixel, because only the rightmost pixel of the horizontal edge that makes up the top scan line is part of a right edge.</p>
<p>If, on the other hand, the ends of the top edge are at the same location, the top is pointed. In that case, the top scan line of the polygon isn’t drawn; it’s part of the right-edge line that starts at the top vertex. (It’s part of a left-edge line, too, but the right edge overrides.) When the top isn’t flat, it’s more difficult to tell in which direction through the vertex list the right and left edges go, because both edges start at the top vertex. The solution is to compare the slopes from the top vertex to the ends of the two lines coming out of it in order to see which is leftmost. The calculations in Listing 38.1 involving the various deltas do this, using a rearranged form of the slope-based equation:</p>
<pre><code>(DeltaYN/DeltaXN)&gt;(DeltaYP/DeltaXP)</code></pre>
<p>Once we know where the left edge starts in the vertex list, we can scan-convert it a line segment at a time until the bottom vertex is reached. Each point is stored as the starting X coordinate for the corresponding scan line in the list we’ll pass to <code>DrawHorizontalLineList</code>. The nearest X coordinate on each scan line that’s on or to the right of the left edge is selected. The last point of each line segment making up the left edge isn’t scan-converted, producing two desirable effects. First, it avoids drawing each vertex twice; two lines come into every vertex, but we want to scan-convert each vertex only once. Second, not scan-converting the last point of each line causes the bottom scan line of the polygon not to be drawn, as required by our rules. The first scan line of the polygon is also skipped if the top isn’t flat.</p>
<p>Now we need to scan-convert the right edge into the ending X coordinate fields of the line list. This is performed in the same manner as for the left edge, except that every line in the right edge is moved one pixel to the left before being scan-converted. Why? We want the nearest point to the left of but not on the right edge, so that the right edge itself isn’t drawn. As it happens, drawing the nearest point on or to the right of a line moved one pixel to the left is exactly the same as drawing the nearest point to the left of but not on that line in its original location. Sketch it out and you’ll see what I mean.</p>
<p>Once the two edges are scan-converted, the whole line list is passed to <code>DrawHorizontalLineList</code>, and the polygon is drawn.</p>
<p>Finis.</p>
</section>
<section id="oddball-cases" class="level3">
<h3><a href="#oddball-cases">Oddball Cases</a></h3>
<p>Listing 38.1 handles zero-length segments (multiple vertices at the same location) by ignoring them, which will be useful down the road because scaled-down polygons can end up with nearby vertices moved to the same location. Horizontal line segments are fine anywhere in a polygon, too. Basically, Listing 38.1 scan-converts between active edges (the edges that define the extent of the polygon on each scan line) and both horizontal and zero-length lines are non-active; neither advances to another scan line, so they don’t affect the edges being scanned.</p>
<p>I’ve limited this chapter’s code to merely demonstrating the principles of filling convex polygons, and the listings given are by no means fast. In the next chapter, we’ll spice things up by eliminating the floating point calculations and pixel-at-a-time drawing and tossing a little assembly language into the mix.</p>
</section>
</section>
<section id="chapter-39-fast-convex-polygons" class="level2">
<h2><a href="#chapter-39-fast-convex-polygons">Chapter 39 – Fast Convex Polygons</a></h2>
<section id="filling-polygons-in-a-hurry" class="level3">
<h3><a href="#filling-polygons-in-a-hurry">Filling Polygons in a Hurry</a></h3>
<p>In the previous chapter, we explored the surprisingly intricate process of filling convex polygons. Now we’re going to fill them an order of magnitude or so faster.</p>
<p>Two thoughts may occur to some of you at this point: “Oh, no, he’s not going to get into assembly language and device-dependent code, is he?” and, “Why bother with polygon filling—or, indeed, any drawing primitives—anyway? Isn’t that what GUIs and third-party libraries are for?”</p>
<p>To which I answer, “Well, yes, I am,” and, “If you have to ask, you’ve missed the magic of microcomputer programming.” Actually, both questions ask the same thing, and that is: “Why should I, as a programmer, have any idea how my program actually works?”</p>
<p>Put that way, it sounds a little different, doesn’t it?</p>
<p>GUIs, reusable code, portable code written entirely in high-level languages, and object-oriented programming are all the rage now, and promise to remain so for the foreseeable future. The thrust of this technology is to enhance the software development process by offloading as much responsibility as possible to other programmers, and by writing all remaining code in modular, generic form. This modular code then becomes a black box to be reused endlessly without another thought about what actually lies inside. GUIs also reduce development time by making many interface choices for you. That, in turn, makes it possible to create quickly and reliably programs that will be easy for new users to pick up, so software becomes easier to both produce and learn. This is, without question, a Good Thing.</p>
<p>The “black box” approach does not, however, necessarily cause the software itself to become faster, smaller, or more innovative; quite the opposite, I suspect. I’ll reserve judgement on whether that is a good thing or not, but I’ll make a prediction: In the short run, the aforementioned techniques will lead to noticeably larger, slower programs, as programmers understand less and less of what the key parts of their programs do and rely increasingly on general-purpose code written by other people. (In the long run, programs will be bigger and slower yet, but computers will be so fast and will have so much memory that no one will care.) Over time, PC programs will also come to be more similar to one another—and to programs running on other platforms, such as the Mac—as regards both user interface and performance.</p>
<p>Again, I am not saying that this is bad. It does, however, have major implications for the future nature of PC graphics programming, in ways that will directly affect the means by which many of you earn your livings. Not so very long from now, graphics programming—all programming, for that matter—will become mostly a matter of assembling in various ways components written by other people, and will cease to be the all-inclusively creative, mindbendingly complex pursuit it is today. (Using legally certified black boxes is, by the way, one direction in which the patent lawyers are leading us; legal considerations may be the final nail in the coffin of homegrown code.) For now, though, it’s still within your power, as a PC programmer, to understand and even control every single thing that happens on a computer if you so desire, to realize any vision you may have. Take advantage of this unique window of opportunity to create some magic!</p>
<p>Neither does it hurt to understand what’s involved in drawing, say, a filled polygon, even if you are using a GUI. You will better understand the performance implications of the available GUI functions, and you will be able to fill in any gaps in the functions provided. You may even find that you can outperform the GUI on occasion by doing your own drawing into a system memory bitmap, then copying the result to the screen; for instance, you can do this under Windows by using the WinG library available from Microsoft. You will also be able to understand why various quirks exist, and will be able to put them to good use. For example, the X Window System follows the polygon drawing rules described in the previous chapter (although it’s not obvious from the X Window System documentation); if you understood the previous chapter’s discussion, you’re in good shape to use polygons under X.</p>
<p>In short, even though doing so runs counter to current trends, it helps to understand how things work, especially when they’re very visible parts of the software you develop. That said, let’s learn more about filling convex polygons.</p>
</section>
<section id="fast-convex-polygon-filling" class="level3">
<h3><a href="#fast-convex-polygon-filling">Fast Convex Polygon Filling</a></h3>
<p>In addressing the topic of filling convex polygons in the previous chapter, the implementation we came up with met all of our functional requirements. In particular, it met stringent rules that guaranteed that polygons would never overlap or have gaps at shared edges, an important consideration when building polygon-based images. Unfortunately, the implementation was also slow as molasses. In this chapter we’ll work up polygon-filling code that’s fast enough to be truly usable.</p>
<p>Our original polygon filling code involved three major tasks, each performed by a separate function:</p>
<ul>
<li>Tracing each polygon edge to generate a coordinate list (performed by the function <code>ScanEdge</code>);</li>
<li>Drawing the scanned-out horizontal lines that constitute the filled polygon (<code>DrawHorizontalLineList</code>); and</li>
<li>Characterizing the polygon and coordinating the tracing and drawing (<code>FillConvexPolygon</code>).</li>
</ul>
<p>The amount of time that the previous chapter’s sample program spent in each of these areas is shown in Table 39.1. As you can see, half the time was spent drawing and the other half was spent tracing the polygon edges (the time spent in <code>FillConvexPolygon</code> was relatively minuscule), so we have our choice of where to begin optimizing.</p>
<section id="fast-drawing" class="level4">
<h4><a href="#fast-drawing">Fast Drawing</a></h4>
<p>Let’s start with drawing, which is easily sped up. The previous chapter’s code used a double-nested loop that called a draw-pixel function to plot each pixel in the polygon individually. That’s a ridiculous approach in a graphics mode that offers linearly mapped memory, as does VGA mode 13H, the mode in which we’re working. At the very least, we could point a far pointer to the left edge of each polygon scan line, then draw each pixel in that scan line in quick succession, using something along the lines of <code>*ScrPtr++ = FillColor;</code> inside a loop.</p>
<p>However, it seems silly to use a loop when the x86 has an instruction, <code>REP STOS</code>, that’s uniquely suited to filling linear memory buffers. There’s no way to use <code>REP STOS</code> directly in C code, but it’s a good bet that the <code>memset</code> library function uses <code>REP STOS</code>, so you could greatly enhance performance by using <code>memset</code> to draw each scan line of the polygon in a single shot. That, however, is easier said than done. The <code>memset</code> function linked in from the library is tied to the memory model in use; in small (which includes Tiny, Small, or Medium) data models <code>memset</code> accepts only near pointers, so it can’t be used to access screen memory. Consequently, a large (which includes Compact, Large, or Huge) data model must be used to allow <code>memset</code> to draw to display memory—a clear case of the tail wagging the dog. This is an excellent example of why, although it is possible to use C to do virtually anything, it’s sometimes much simpler just to use a little assembly code and be done with it.</p>
<p>At any rate, Listing 39.1 for this chapter shows a version of <code>DrawHorizontalLineList</code> that uses memset to draw each scan line of the polygon in a single call. When linked to Chapter 38’s test program, Listing 39.1 increases pure drawing speed (disregarding edge tracing and other nondrawing time) by more than an order of magnitude over Chapter 38’s draw-pixel-based code, despite the fact that Listing 39.1 requires a large (in this case, the Compact) data model. Listing 39.1 works fine with Borland C++, but may not work with other compilers, for it relies on the aforementioned interaction between memset and the selected memory model.</p>
<table>
<caption>Table 39.1 Polygon fill performance.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Implementation</th>
<th style="text-align: left;">Total Polygon Filling Time</th>
<th style="text-align: left;">DrawHorizontal LineList</th>
<th style="text-align: left;">ScanEdge</th>
<th style="text-align: left;">FillConvex Polygon</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Drawing to display memory in mode 13h</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">C floating point scan/DrawPixel drawing code from Chapter 38, (small model)</td>
<td style="text-align: left;">11.69</td>
<td style="text-align: left;">5.80 seconds (50% of total)</td>
<td style="text-align: left;">5.86 (50%)</td>
<td style="text-align: left;">0.03 (&lt;1%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">C floating point scan/memset drawing (Listing 39.1, compact model)</td>
<td style="text-align: left;">6.64</td>
<td style="text-align: left;">0.49 (7%)</td>
<td style="text-align: left;">6.11 (92%)</td>
<td style="text-align: left;">0.04 (&lt;1%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">C integer scan/memset drawing (Listing 39.1 &amp; Listing 39.2, compact model)</td>
<td style="text-align: left;">0.60</td>
<td style="text-align: left;">0.49 (82%)</td>
<td style="text-align: left;">0.07 (12%)</td>
<td style="text-align: left;">0.04 (7%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">C integer scan/ASM drawing (Listing 39.2 &amp; Listing 39.3, small model)</td>
<td style="text-align: left;">0.45</td>
<td style="text-align: left;">0.36 (80%)</td>
<td style="text-align: left;">0.06 (13%)</td>
<td style="text-align: left;">0.03 (7%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">ASM integer scan/ASM drawing (Listing 40.3 &amp; Listing 40.4, small model)</td>
<td style="text-align: left;">0.42</td>
<td style="text-align: left;">0.36 (86%)</td>
<td style="text-align: left;">0.03 (7%)</td>
<td style="text-align: left;">0.03 (7%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Drawing to system memory</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">C integer scan/memset drawing (Listing 39.1 &amp; Listing 39.2, compact model)</td>
<td style="text-align: left;">0.31</td>
<td style="text-align: left;">0.20 (65%)</td>
<td style="text-align: left;">0.07 (23%)</td>
<td style="text-align: left;">0.04 (13%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ASM integer scan/ASM drawing (Listing 39.3 &amp; Listing 39.4, small model)</td>
<td style="text-align: left;">0.13</td>
<td style="text-align: left;">0.07 (54%)</td>
<td style="text-align: left;">0.03 (23%)</td>
<td style="text-align: left;">0.03 (23%)</td>
</tr>
</tbody>
</table>
<p>All times are in seconds, as measured with Turbo Profiler on a 20-MHz cached 386 with no math coprocessor installed. Note that time spent in <code>main()</code> is not included. C code was compiled with Borland C++ with maximum optimization (-G -O -Z -r -a); assembly language code was assembled with TASM. Percentages of combined times are rounded to the nearest percent, so the sum of the three percentages does not always equal 100.</p>
<p><strong>LISTING 39.1 L39-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Draws all pixels in the list of horizontal lines passed in, in</span>
<span class="co">   mode 13h, the VGA&#39;s 320x200 256-color mode. Uses memset to fill</span>
<span class="co">   each line, which is much faster than using DrawPixel but requires</span>
<span class="co">   that a large data model (compact, large, or huge) be in use when</span>
<span class="co">   running in real mode or 286 protected mode.</span>
<span class="co">   All C code tested with Borland C++. */</span>

<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="ot">#define SCREEN_WIDTH    320</span>
<span class="ot">#define SCREEN_SEGMENT  0xA000</span>

<span class="dt">void</span> DrawHorizontalLineList(<span class="kw">struct</span> HLineList * HLineListPtr,
      <span class="dt">int</span> Color)
{
   <span class="kw">struct</span> HLine *HLinePtr;
   <span class="dt">int</span> Length, Width;
   <span class="dt">unsigned</span> <span class="dt">char</span> far *ScreenPtr;

   <span class="co">/* Point to the start of the first scan line on which to draw */</span>
   ScreenPtr = MK_FP(SCREEN_SEGMENT,
         HLineListPtr-&gt;YStart * SCREEN_WIDTH);

   <span class="co">/* Point to the XStart/XEnd descriptor for the first (top)</span>
<span class="co">      horizontal line */</span>
   HLinePtr = HLineListPtr-&gt;HLinePtr;
   <span class="co">/* Draw each horizontal line in turn, starting with the top one and</span>
<span class="co">      advancing one line each time */</span>
   Length = HLineListPtr-&gt;Length;
   <span class="kw">while</span> (Length-- &gt; <span class="dv">0</span>) {
      <span class="co">/* Draw the whole horizontal line if it has a positive width */</span>
      <span class="kw">if</span> ((Width = HLinePtr-&gt;XEnd - HLinePtr-&gt;XStart + <span class="dv">1</span>) &gt; <span class="dv">0</span>)
         memset(ScreenPtr + HLinePtr-&gt;XStart, Color, Width);
      HLinePtr++;                <span class="co">/* point to next scan line X info */</span>
      ScreenPtr += SCREEN_WIDTH; <span class="co">/* point to next scan line start */</span>
   }
}</code></pre>
<p>At this point, I’d like to mention that benchmarks are notoriously unreliable; the results in Table 39.1 are accurate <em>only</em> for the test program, and only when running on a particular system. Results could be vastly different if smaller, larger, or more complex polygons were drawn, or if a faster or slower computer/VGA combination were used. These factors notwithstanding, the test program does fill a variety of polygons of varying complexity sized from large to small and in between, and certainly the order of magnitude difference between Listing 39.1 and the old version of <code>DrawHorizontalLineList</code> is a clear indication of which code is superior.</p>
<p>Anyway, Listing 39.1 has the desired effect of vastly improving drawing time. There are cycles yet to be had in the drawing code, but as tracing polygon edges now takes 92 percent of the polygon filling time, it’s logical to optimize the tracing code next.</p>
</section>
<section id="fast-edge-tracing" class="level4">
<h4><a href="#fast-edge-tracing">Fast Edge Tracing</a></h4>
<p>There’s no secret as to why last chapter’s <code>ScanEdge</code> was so slow: It used floating point calculations. One secret of fast graphics is using integer or fixed-point calculations, instead. (Sure, the floating point code would run faster if a math coprocessor were installed, but it would still be slower than the alternatives; besides, why require a math coprocessor when you don’t have to?) Both integer and fixed-point calculations are fast. In many cases, fixed-point is faster, but integer calculations have one tremendous virtue: They’re completely accurate. The tiny imprecision inherent in either fixed or floating-point calculations can result in occasional pixels being one position off from their proper location. This is no great tragedy, but after going to so much trouble to ensure that polygons don’t overlap at common edges, why not get it exactly right?</p>
<p>In fact, when I tested out the integer edge tracing code by comparing an integer-based test image to one produced by floating-point calculations, two pixels out of the whole screen differed, leading me to suspect a bug in the integer code. It turned out, however, that’s in those two cases, the floating point results were sufficiently imprecise to creep from just under an integer value to just over it, so that the <code>ceil</code> function returned a coordinate that was one too large.</p>
<blockquote>
<p><img src="images/i.jpg" /> Floating point is very accurate—but it is not precise. Integer calculations, properly performed, are.</p>
</blockquote>
<p>Listing 39.2 shows a C implementation of integer edge tracing. Vertical and diagonal lines, which are trivial to trace, are special-cased. Other lines are broken into two categories: Y-major (closer to vertical) and X-major (closer to horizontal). The handlers for the Y-major and X-major cases operate on the principle of similar triangles: The number of X pixels advanced per scan line is the same as the ratio of the X delta of the edge to the Y delta. Listing 39.2 is more complex than the original floating point implementation, but not painfully so. In return for that complexity, Listing 39.2 is more than 80 times faster at scanning edges—and, as just mentioned, it’s actually more accurate than the floating point code.</p>
<p>Ya gotta love that integer arithmetic.</p>
<p><strong>LISTING 39.2 L39-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Scan converts an edge from (X1,Y1) to (X2,Y2), not including the</span>
<span class="co">   point at (X2,Y2). If SkipFirst == 1, the point at (X1,Y1) isn&#39;t</span>
<span class="co">   drawn; if SkipFirst == 0, it is. For each scan line, the pixel</span>
<span class="co">   closest to the scanned edge without being to the left of the</span>
<span class="co">   scanned edge is chosen. Uses an all-integer approach for speed and</span>
<span class="co">   precision. */</span>

<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="dt">void</span> ScanEdge(<span class="dt">int</span> X1, <span class="dt">int</span> Y1, <span class="dt">int</span> X2, <span class="dt">int</span> Y2, <span class="dt">int</span> SetXStart,
      <span class="dt">int</span> SkipFirst, <span class="kw">struct</span> HLine **EdgePointPtr)
{
   <span class="dt">int</span> Y, DeltaX, Height, Width, AdvanceAmt, ErrorTerm, i;
   <span class="dt">int</span> ErrorTermAdvance, XMajorAdvanceAmt;
   <span class="kw">struct</span> HLine *WorkingEdgePointPtr;

   WorkingEdgePointPtr = *EdgePointPtr; <span class="co">/* avoid double dereference */</span>
   AdvanceAmt = ((DeltaX = X2 - X1) &gt; <span class="dv">0</span>) ? <span class="dv">1</span> : -<span class="dv">1</span>;
                            <span class="co">/* direction in which X moves (Y2 is</span>
<span class="co">                               always &gt; Y1, so Y always counts up) */</span>

   <span class="kw">if</span> ((Height = Y2 - Y1) &lt;= <span class="dv">0</span>)  <span class="co">/* Y length of the edge */</span>
      <span class="kw">return</span>;     <span class="co">/* guard against 0-length and horizontal edges */</span>

   <span class="co">/* Figure out whether the edge is vertical, diagonal, X-major</span>
<span class="co">      (mostly horizontal), or Y-major (mostly vertical) and handle</span>
<span class="co">      appropriately */</span>
   <span class="kw">if</span> ((Width = abs(DeltaX)) == <span class="dv">0</span>) {
      <span class="co">/* The edge is vertical; special-case by just storing the same</span>
<span class="co">         X coordinate for every scan line */</span>
      <span class="co">/* Scan the edge for each scan line in turn */</span>
      <span class="kw">for</span> (i = Height - SkipFirst; i-- &gt; <span class="dv">0</span>; WorkingEdgePointPtr++) {
         <span class="co">/* Store the X coordinate in the appropriate edge list */</span>
         <span class="kw">if</span> (SetXStart == <span class="dv">1</span>)
            WorkingEdgePointPtr-&gt;XStart = X1;
         <span class="kw">else</span>
            WorkingEdgePointPtr-&gt;XEnd = X1;
      }
   } <span class="kw">else</span> <span class="kw">if</span> (Width == Height) {
      <span class="co">/* The edge is diagonal; special-case by advancing the X</span>
<span class="co">         coordinate 1 pixel for each scan line */</span>
      <span class="kw">if</span> (SkipFirst) <span class="co">/* skip the first point if so indicated */</span>
         X1 += AdvanceAmt; <span class="co">/* move 1 pixel to the left or right */</span>
      <span class="co">/* Scan the edge for each scan line in turn */</span>
      <span class="kw">for</span> (i = Height - SkipFirst; i-- &gt; <span class="dv">0</span>; WorkingEdgePointPtr++) {
         <span class="co">/* Store the X coordinate in the appropriate edge list */</span>
         <span class="kw">if</span> (SetXStart == <span class="dv">1</span>)
            WorkingEdgePointPtr-&gt;XStart = X1;
         <span class="kw">else</span>
            WorkingEdgePointPtr-&gt;XEnd = X1;
         X1 += AdvanceAmt; <span class="co">/* move 1 pixel to the left or right */</span>
      }
   } <span class="kw">else</span> <span class="kw">if</span> (Height &gt; Width) {
      <span class="co">/* Edge is closer to vertical than horizontal (Y-major) */</span>
      <span class="kw">if</span> (DeltaX &gt;= <span class="dv">0</span>)
         ErrorTerm = <span class="dv">0</span>; <span class="co">/* initial error term going left-&gt;right */</span>
      <span class="kw">else</span>
         ErrorTerm = -Height + <span class="dv">1</span>;   <span class="co">/* going right-&gt;left */</span>
      <span class="kw">if</span> (SkipFirst) {   <span class="co">/* skip the first point if so indicated */</span>
         <span class="co">/* Determine whether it&#39;s time for the X coord to advance */</span>
         <span class="kw">if</span> ((ErrorTerm += Width) &gt; <span class="dv">0</span>) {
            X1 += AdvanceAmt; <span class="co">/* move 1 pixel to the left or right */</span>
            ErrorTerm -= Height; <span class="co">/* advance ErrorTerm to next point */</span>
         }
      }
      <span class="co">/* Scan the edge for each scan line in turn */</span>
      <span class="kw">for</span> (i = Height - SkipFirst; i-- &gt; <span class="dv">0</span>; WorkingEdgePointPtr++) {
         <span class="co">/* Store the X coordinate in the appropriate edge list */</span>
         <span class="kw">if</span> (SetXStart == <span class="dv">1</span>)
            WorkingEdgePointPtr-&gt;XStart = X1;
         <span class="kw">else</span>
            WorkingEdgePointPtr-&gt;XEnd = X1;
         <span class="co">/* Determine whether it&#39;s time for the X coord to advance */</span>
         <span class="kw">if</span> ((ErrorTerm += Width) &gt; <span class="dv">0</span>) {
            X1 += AdvanceAmt; <span class="co">/* move 1 pixel to the left or right */</span>
            ErrorTerm -= Height; <span class="co">/* advance ErrorTerm to correspond */</span>
         }
      }
   } <span class="kw">else</span> {
      <span class="co">/* Edge is closer to horizontal than vertical (X-major) */</span>
      <span class="co">/* Minimum distance to advance X each time */</span>
      XMajorAdvanceAmt = (Width / Height) * AdvanceAmt;
      <span class="co">/* Error term advance for deciding when to advance X 1 extra */</span>
      ErrorTermAdvance = Width % Height;
      <span class="kw">if</span> (DeltaX &gt;= <span class="dv">0</span>)
         ErrorTerm = <span class="dv">0</span>; <span class="co">/* initial error term going left-&gt;right */</span>
      <span class="kw">else</span>
         ErrorTerm = -Height + <span class="dv">1</span>;   <span class="co">/* going right-&gt;left */</span>
      <span class="kw">if</span> (SkipFirst) {   <span class="co">/* skip the first point if so indicated */</span>
         X1 += XMajorAdvanceAmt;    <span class="co">/* move X minimum distance */</span>
         <span class="co">/* Determine whether it&#39;s time for X to advance one extra */</span>
         <span class="kw">if</span> ((ErrorTerm += ErrorTermAdvance) &gt; <span class="dv">0</span>) {
            X1 += AdvanceAmt;       <span class="co">/* move X one more */</span>
            ErrorTerm -= Height; <span class="co">/* advance ErrorTerm to correspond */</span>
         }
      }
      <span class="co">/* Scan the edge for each scan line in turn */</span>
      <span class="kw">for</span> (i = Height - SkipFirst; i-- &gt; <span class="dv">0</span>; WorkingEdgePointPtr++) {
         <span class="co">/* Store the X coordinate in the appropriate edge list */</span>
         <span class="kw">if</span> (SetXStart == <span class="dv">1</span>)
            WorkingEdgePointPtr-&gt;XStart = X1;
         <span class="kw">else</span>
            WorkingEdgePointPtr-&gt;XEnd = X1;
         X1 += XMajorAdvanceAmt;    <span class="co">/* move X minimum distance */</span>
         <span class="co">/* Determine whether it&#39;s time for X to advance one extra */</span>
         <span class="kw">if</span> ((ErrorTerm += ErrorTermAdvance) &gt; <span class="dv">0</span>) {
            X1 += AdvanceAmt;       <span class="co">/* move X one more */</span>
            ErrorTerm -= Height; <span class="co">/* advance ErrorTerm to correspond */</span>
         }
      }
   }

   *EdgePointPtr = WorkingEdgePointPtr;   <span class="co">/* advance caller&#39;s ptr */</span>
}</code></pre>
</section>
</section>
<section id="the-finishing-touch-assembly-language" class="level3">
<h3><a href="#the-finishing-touch-assembly-language">The Finishing Touch: Assembly Language</a></h3>
<p>The C implementation in Listing 39.2 is now nearly 20 times as fast as the original, which is good enough for most purposes. Still, it requires that one of the large data models be used (for <code>memset</code> ), and it’s certainly not the fastest possible code. The obvious next step is assembly language.</p>
<p>Listing 39.3 is an assembly language version of <code>DrawHorizontalLineList</code> . In actual use, it proved to be about 36 percent faster than Listing 39.1; better than a poke in the eye with a sharp stick, but just barely. There’s more to these timing results than meets that eye, though. Display memory generally responds much more slowly than system memory, especially in 386 and 486 systems. That means that much of the time taken by Listing 39.3 is actually spent waiting for display memory accesses to complete, with the processor forced to idle by wait states. If, instead, Listing 39.3 drew to a local buffer in system memory or to a particularly fast VGA, the assembly implementation might well display a far more substantial advantage over the C code.</p>
<p>And indeed it does. When the test program is modified to draw to a local buffer, both the C and assembly language versions get 0.29 seconds faster, that being a measure of the time taken by display memory wait states. With those wait states factored out, the assembly language version of <code>DrawHorizontalLineList</code> becomes almost three times as fast as the C code.</p>
<blockquote>
<p><img src="images/i.jpg" /> There is a lesson here. An optimization has no fixed payoff; its value fluctuates according to the context in which it is used. There’s relatively little benefit to further optimizing code that already spends half its time waiting for display memory; no matter how good your optimizations, you’ll get only a two-times speedup at best, and generally much less than that. There is, on the other hand, potential for tremendous improvement when drawing to system memory, so if that’s where most of your drawing will occur, optimizations such as Listing 39.3 are well worth the effort.</p>
<p>Know the environments in which your code will run, and know where the cycles go in those environments.</p>
</blockquote>
<p><strong>LISTING 39.3 L39-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Draws all pixels in the list of horizontal lines passed in, in</span>
<span class="co">; mode 13h, the VGA&#39;s 320x200 256-color mode. Uses REP STOS to fill</span>
<span class="co">; each line.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;     void DrawHorizontalLineList(struct HLineList * HLineListPtr,</span>
<span class="co">;          int Color);</span>
<span class="co">; All assembly code tested with TASM and MASM</span>

SCREEN_WIDTH        <span class="dt">equ</span>   <span class="dv">320</span>
SCREEN_SEGMENT      <span class="dt">equ</span><span class="bn">   0a000h</span>

HLinestruc
XStart        <span class="dt">dw</span>   ?          <span class="co">;X coordinate of leftmost pixel in line</span>
XEnd          <span class="dt">dw</span>   ?          <span class="co">;X coordinate of rightmost pixel in line</span>
HLine         ends

HLineList <span class="kw">struc</span>
Lngth         <span class="dt">dw</span>   ?          <span class="co">;# of horizontal lines</span>
YStart        <span class="dt">dw</span>   ?          <span class="co">;Y coordinate of topmost line</span>
HLinePtr      <span class="dt">dw</span>   ?          <span class="co">;pointer to list of horz lines</span>
HLineList     ends

Parms <span class="kw">struc</span>
              <span class="dt">dw</span>   <span class="dv">2</span> dup(?)   <span class="co">;return address &amp; pushed BP</span>
HLineListPtr  <span class="dt">dw</span>   ?          <span class="co">;pointer to HLineList structure</span>
Color         <span class="dt">dw</span>   ?          <span class="co">;color with which to fill</span>
Parms         ends

      .model small
      .code
      public _DrawHorizontalLineList
      <span class="kw">align</span>   <span class="dv">2</span>
_DrawHorizontalLineList   proc
   <span class="kw">push</span> <span class="kw">bp</span>                    <span class="co">;preserve caller&#39;s stack frame</span>
   <span class="kw">mov</span>  <span class="kw">bp</span>,<span class="kw">sp</span>                 <span class="co">;point to our stack frame</span>
   <span class="kw">push</span>   <span class="kw">si</span>                  <span class="co">;preserve caller&#39;s register variables</span>
   <span class="kw">push</span>   <span class="kw">di</span>
   <span class="kw">cld</span>                        <span class="co">;make string instructions inc pointers</span>

   <span class="kw">mov</span>   <span class="kw">ax</span>,SCREEN_SEGMENT
   <span class="kw">mov</span>   <span class="kw">es</span>,<span class="kw">ax</span>                <span class="co">;point ES to display memory for REP STOS</span>

   <span class="kw">mov</span>   <span class="kw">si</span>,[<span class="kw">bp</span>+HLineListPtr] <span class="co">;point to the line list</span>
   <span class="kw">mov</span>   <span class="kw">ax</span>,SCREEN_WIDTH      <span class="co">;point to the start of the first scan</span>
   <span class="kw">mul</span>   [<span class="kw">si</span>+YStart]          <span class="co">; line in which to draw</span>
   <span class="kw">mov</span>   <span class="kw">dx</span>,<span class="kw">ax</span>                <span class="co">;ES:DX points to first scan line to</span>
                              <span class="co">; draw</span>
   <span class="kw">mov</span>   <span class="kw">bx</span>,[<span class="kw">si</span>+HLinePtr]     <span class="co">;point to the XStart/XEnd descriptor</span>
                              <span class="co">; for the first (top) horizontal line</span>
   <span class="kw">mov</span>   <span class="kw">si</span>,[<span class="kw">si</span>+Lngth]        <span class="co">;# of scan lines to draw</span>
   <span class="kw">and</span>   <span class="kw">si</span>,<span class="kw">si</span>                <span class="co">;are there any lines to draw?</span>
   <span class="kw">jz</span>    FillDone             <span class="co">;no, so we&#39;re done</span>
   <span class="kw">mov</span>   <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Color]<span class="co">;color with which to fill</span>
   <span class="kw">mov</span>   <span class="kw">ah</span>,<span class="kw">al</span>                <span class="co">;duplicate color for STOSW</span>
<span class="fu">FillLoop:</span>
   <span class="kw">mov</span>   <span class="kw">di</span>,[<span class="kw">bx</span>+XStart]       <span class="co">;left edge of fill on this line</span>
   <span class="kw">mov</span>   <span class="kw">cx</span>,[<span class="kw">bx</span>+XEnd]         <span class="co">;right edge of fill</span>
   <span class="kw">sub</span>   <span class="kw">cx</span>,<span class="kw">di</span>
   <span class="kw">js</span>    LineFillDone         <span class="co">;skip if negative width</span>
   <span class="kw">inc</span>   <span class="kw">cx</span>                   <span class="co">;width of fill on this line</span>
   <span class="kw">add</span>   <span class="kw">di</span>,<span class="kw">dx</span>                <span class="co">;offset of left edge of fill</span>
   <span class="kw">test</span>  <span class="kw">di</span>,<span class="dv">1</span>                 <span class="co">;does fill start at an odd address?</span>
   <span class="kw">jz</span>    MainFill             <span class="co">;no</span>
   <span class="kw">stosb</span>                      <span class="co">;yes, draw the odd leading byte to</span>
                              <span class="co">; word-align the rest of the fill</span>
   <span class="kw">dec</span>   <span class="kw">cx</span>                   <span class="co">;count off the odd leading byte</span>
   <span class="kw">jz</span>    LineFillDone         <span class="co">;done if that was the only byte</span>
<span class="fu">MainFill:</span>
   <span class="kw">shr</span>   <span class="kw">cx</span>,<span class="dv">1</span>                 <span class="co">;# of words in fill</span>
   rep   <span class="kw">stosw</span>                <span class="co">;fill as many words as possible</span>
   <span class="kw">adc</span>   <span class="kw">cx</span>,<span class="kw">cx</span>                <span class="co">;1 if there&#39;s an odd trailing byte to</span>
                              <span class="co">; do, 0 otherwise</span>
   rep   <span class="kw">stosb</span>                <span class="co">;fill any odd trailing byte</span>
<span class="fu">LineFillDone:</span>
   <span class="kw">add</span>   <span class="kw">bx</span>,size HLine        <span class="co">;point to the next line descriptor</span>
   <span class="kw">add</span>   <span class="kw">dx</span>,SCREEN_WIDTH      <span class="co">;point to the next scan line</span>
   <span class="kw">dec</span>   <span class="kw">si</span>                   <span class="co">;count off lines to fill</span>
   <span class="kw">jnz</span>   FillLoop
<span class="fu">FillDone:</span>
   <span class="kw">pop</span>   <span class="kw">di</span>                   <span class="co">;restore caller&#39;s register variables</span>
   <span class="kw">pop</span>   <span class="kw">si</span>
   <span class="kw">pop</span>   <span class="kw">bp</span>                   <span class="co">;restore caller&#39;s stack frame</span>
   <span class="kw">ret</span>
_DrawHorizontalLineList   endp
   end</code></pre>
<section id="maximizing-rep-stos" class="level4">
<h4><a href="#maximizing-rep-stos">Maximizing REP STOS</a></h4>
<p>Listing 39.3 doesn’t take the easy way out and use <code>REP STOSB</code> to fill each scan line; instead, it uses <code>REP STOSW</code> to fill as many pixel pairs as possible via word-sized accesses, using <code>STOSB</code> only to do odd bytes. Word accesses to odd addresses are always split by the processor into 2-byte accesses. Such word accesses take twice as long as word accesses to even addresses, so Listing 39.3 makes sure that all word accesses occur at even addresses, by performing a leading <code>STOSB</code> first if necessary.</p>
<p>Listing 39.3 is another case in which it’s worth knowing the environment in which your code will run. Extra code is required to perform aligned word-at-a-time filling, resulting in extra overhead. For very small or narrow polygons, that overhead might overwhelm the advantage of drawing a word at a time, making plain old <code>REP STOSB</code> faster.</p>
</section>
</section>
<section id="faster-edge-tracing" class="level3">
<h3><a href="#faster-edge-tracing">Faster Edge Tracing</a></h3>
<p>Finally, Listing 39.4 is an assembly language version of <code>ScanEdge</code>. Listing 39.4 is a relatively straightforward translation from C to assembly, but is nonetheless about twice as fast as Listing 39.2.</p>
<p>The version of <code>ScanEdge</code> in Listing 39.4 could certainly be sped up still further by unrolling the loops. <code>FillConvexPolygon</code>, the overall coordination routine, hasn’t even been converted to assembly language, so that could be sped up as well. I haven’t bothered with these optimizations because all code other than <code>DrawHorizontalLineList</code> takes only 14 percent of the overall polygon filling time when drawing to display memory; the potential return on optimizing nondrawing code simply isn’t great enough to justify the effort. Part of the value of a profiler is being able to tell when to stop optimizing; with Listings 39.3 and 39.4 in use, more than two-thirds of the time taken to draw polygons is spent waiting for display memory, so optimization is pretty much maxed out. However, further optimization might be worthwhile when drawing to system memory, where wait states are out of the picture and the nondrawing code takes a significant portion (46 percent) of the overall time.</p>
<p>Again, <em>know where the cycles go</em> .</p>
<p>By the way, note that all the versions of <code>ScanEdge</code> and <code>FillConvexPolygon</code> that we’ve looked at are adapter-independent, and that the C code is also machine-independent; all adapter-specific code is isolated in <code>DrawHorizontalLineList</code>. This makes it easy to add support for other graphics systems, such as the 8514/A, the XGA, or, for that matter, a completely non-PC system.</p>
<p><strong>LISTING 39.4 L39-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Scan converts an edge from (X1,Y1) to (X2,Y2), not including the</span>
<span class="co">; point at (X2,Y2). If SkipFirst == 1, the point at (X1,Y1) isn&#39;t</span>
<span class="co">; drawn; if SkipFirst == 0, it is. For each scan line, the pixel</span>
<span class="co">; closest to the scanned edge without being to the left of the scanned</span>
<span class="co">; edge is chosen. Uses an all-integer approach for speed &amp; precision.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;    void ScanEdge(int X1, int Y1, int X2, int Y2, int SetXStart,</span>
<span class="co">;     int SkipFirst, struct HLine **EdgePointPtr);</span>
<span class="co">; Edges must not go bottom to top; that is, Y1 must be &lt;= Y2.</span>
<span class="co">; Updates the pointer pointed to by EdgePointPtr to point to the next</span>
<span class="co">;  free entry in the array of HLine structures.</span>

HLine   <span class="kw">struc</span>
XStart          <span class="dt">dw</span>     ?           <span class="co">;X coordinate of leftmost pixel in scan line</span>
XEnd            <span class="dt">dw</span>     ?           <span class="co">;X coordinate of rightmost pixel in scan line</span>
HLine   ends

Parms   <span class="kw">struc</span>
                <span class="dt">dw</span>     <span class="dv">2</span> dup(?)    <span class="co">;return address &amp; pushed BP</span>
X1              <span class="dt">dw</span>     ?           <span class="co">;X start coord of edge</span>
Y1              <span class="dt">dw</span>     ?           <span class="co">;Y start coord of edge</span>
X2              <span class="dt">dw</span>     ?           <span class="co">;X end coord of edge</span>
Y2              <span class="dt">dw</span>     ?           <span class="co">;Y end coord of edge</span>
SetXStart       <span class="dt">dw</span>     ?           <span class="co">;1 to set the XStart field of each</span>
                                   <span class="co">; HLine struc, 0 to set XEnd</span>
SkipFirst       <span class="dt">dw</span>     ?           <span class="co">;1 to skip scanning the first point</span>
                                   <span class="co">; of the edge, 0 to scan first point</span>
EdgePointPtr     <span class="dt">dw</span>    ?           <span class="co">;pointer to a pointer to the array of</span>
                                   <span class="co">; HLine structures in which to store</span>
                                   <span class="co">; the scanned X coordinates</span>
Parms   ends

<span class="co">;Offsets from BP in stack frame of local variables.</span>
AdvanceAmt      <span class="dt">equ</span>     -<span class="dv">2</span>
Height          <span class="dt">equ</span>     -<span class="dv">4</span>
LOCAL_SIZE      <span class="dt">equ</span>      <span class="dv">4</span>         <span class="co">;total size of local variables</span>

        .model small
        .code
        public _ScanEdge
        <span class="kw">align</span>  <span class="dv">2</span>
_ScanEdge   proc
        <span class="kw">push</span>  <span class="kw">bp</span>                   <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>   <span class="kw">bp</span>,<span class="kw">sp</span>                <span class="co">;point to our stack frame</span>
        <span class="kw">sub</span>   <span class="kw">sp</span>,LOCAL_SIZE        <span class="co">;allocate space for local variables</span>
        <span class="kw">push</span>  <span class="kw">si</span>                   <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>  <span class="kw">di</span>
        <span class="kw">mov</span>   <span class="kw">di</span>,[<span class="kw">bp</span>+EdgePointPtr]
        <span class="kw">mov</span>   <span class="kw">di</span>,[<span class="kw">di</span>]              <span class="co">;point to the HLine array</span>
        <span class="kw">cmp</span>   [<span class="kw">bp</span>+SetXStart],<span class="dv">1</span>     <span class="co">;set the XStart field of each HLine</span>
                                   <span class="co">; struc?</span>
        <span class="kw">jz</span>    HLinePtrSet          <span class="co">;yes, DI points to the first XStart</span>
        <span class="kw">add</span>   <span class="kw">di</span>,XEnd              <span class="co">;no, point to the XEnd field of the</span>
                                   <span class="co">; first HLine struc</span>
<span class="fu">HLinePtrSet:</span>
        <span class="kw">mov</span>   <span class="kw">bx</span>,[<span class="kw">bp</span>+Y2]
        <span class="kw">sub</span>   <span class="kw">bx</span>,[<span class="kw">bp</span>+Y1]           <span class="co">;edge height</span>
        <span class="kw">jle</span>   ToScanEdgeExit       <span class="co">;guard against 0-length &amp; horz edges</span>
        <span class="kw">mov</span>   [<span class="kw">bp</span>+Height],<span class="kw">bx</span>       <span class="co">;Height = Y2 - Y1</span>
        <span class="kw">sub</span>   <span class="kw">cx</span>,<span class="kw">cx</span>                <span class="co">;assume ErrorTerm starts at 0 (true if</span>
                                   <span class="co">; we&#39;re moving right as we draw)</span>
        <span class="kw">mov</span>   <span class="kw">dx</span>,<span class="dv">1</span>                 <span class="co">;assume AdvanceAmt = 1 (move right)</span>
        <span class="kw">mov</span>   <span class="kw">ax</span>,[<span class="kw">bp</span>+X2]
        <span class="kw">sub</span>   <span class="kw">ax</span>,[<span class="kw">bp</span>+X1]           <span class="co">;DeltaX = X2 - X1</span>
        <span class="kw">jz</span>    IsVertical           <span class="co">;it&#39;s a vertical edge--special case it</span>
        <span class="kw">jns</span>   SetAdvanceAmt        <span class="co">;DeltaX &gt;= 0</span>
        <span class="kw">mov</span>   <span class="kw">cx</span>,<span class="dv">1</span>                 <span class="co">;DeltaX &lt; 0 (move left as we draw)</span>
        <span class="kw">sub</span>   <span class="kw">cx</span>,<span class="kw">bx</span>                <span class="co">;ErrorTerm = -Height + 1</span>
        <span class="kw">neg</span>   <span class="kw">dx</span>                   <span class="co">;AdvanceAmt = -1 (move left)</span>
        <span class="kw">neg</span>   <span class="kw">ax</span>                   <span class="co">;Width = abs(DeltaX)</span>
<span class="fu">SetAdvanceAmt:</span>
        <span class="kw">mov</span>   [<span class="kw">bp</span>+AdvanceAmt],<span class="kw">dx</span>
<span class="co">; Figure out whether the edge is diagonal, X-major (more horizontal),</span>
<span class="co">; or Y-major (more vertical) and handle appropriately.</span>
        <span class="kw">cmp</span>   <span class="kw">ax</span>,<span class="kw">bx</span>                 <span class="co">;if Width==Height, it&#39;s a diagonal edge</span>
        <span class="kw">jz</span>    IsDiagonal            <span class="co">;it&#39;s a diagonal edge--special case</span>
        <span class="kw">jb</span>    YMa<span class="kw">jo</span>r                <span class="co">;it&#39;s a Y-major (more vertical) edge</span>
                                    <span class="co">;it&#39;s an X-major (more horz) edge</span>
        <span class="kw">sub</span>   <span class="kw">dx</span>,<span class="kw">dx</span>                 <span class="co">;prepare DX:AX (Width) for division</span>
        <span class="kw">div</span>   <span class="kw">bx</span>                    <span class="co">;Width/Height</span>
                                    <span class="co">;DX = error term advance per scan line</span>
        <span class="kw">mov</span>   <span class="kw">si</span>,<span class="kw">ax</span>                 <span class="co">;SI = minimum # of pixels to advance X</span>
                                    <span class="co">; on each scan line</span>
        <span class="kw">test</span>  [<span class="kw">bp</span>+AdvanceAmt]<span class="bn">,8000h </span><span class="co">;move left or right?</span>
        <span class="kw">jz</span>    XMa<span class="kw">jo</span>rAdvanceAmtSet   <span class="co">;right, already set</span>
        <span class="kw">neg</span>   <span class="kw">si</span>                    <span class="co">;left, negate the distance to advance</span>
                                    <span class="co">; on each scan line</span>
<span class="fu">XMajorAdvanceAmtSet:</span>                <span class="co">;</span>
        <span class="kw">mov</span>   <span class="kw">ax</span>,[<span class="kw">bp</span>+X1]            <span class="co">;starting X coordinate</span>
        <span class="kw">cmp</span>   [<span class="kw">bp</span>+SkipFirst],<span class="dv">1</span>      <span class="co">;skip the first point?</span>
        <span class="kw">jz</span>    XMa<span class="kw">jo</span>rSkipEntry       <span class="co">;yes</span>
<span class="fu">XMajorLoop:</span>
        <span class="kw">mov</span>   [<span class="kw">di</span>],<span class="kw">ax</span>               <span class="co">;store the current X value</span>
        <span class="kw">add</span>   <span class="kw">di</span>,size HLine         <span class="co">;point to the next HLine struc</span>
<span class="fu">XMajorSkipEntry:</span>
        <span class="kw">add</span>   <span class="kw">ax</span>,<span class="kw">si</span>                 <span class="co">;set X for the next scan line</span>
        <span class="kw">add</span>   <span class="kw">cx</span>,<span class="kw">dx</span>                 <span class="co">;advance error term</span>
        <span class="kw">jle</span>   XMa<span class="kw">jo</span>rNoAdvance       <span class="co">;not time for X coord to advance one</span>
                                    <span class="co">; extra</span>
        <span class="kw">add</span>   <span class="kw">ax</span>,[<span class="kw">bp</span>+AdvanceAmt]    <span class="co">;advance X coord one extra</span>
        <span class="kw">sub</span>   <span class="kw">cx</span>,[<span class="kw">bp</span>+Height]        <span class="co">;adjust error term back</span>
<span class="fu">XMajorNoAdvance:</span>
        <span class="kw">dec</span>   <span class="kw">bx</span>                    <span class="co">;count off this scan line</span>
        <span class="kw">jnz</span>   XMa<span class="kw">jo</span>rLoop
        <span class="kw">jmp</span>   ScanEdgeDone
        <span class="kw">align</span> <span class="dv">2</span>
<span class="fu">ToScanEdgeExit:</span>
        <span class="kw">jmp</span>   ScanEdgeExit
        align2
<span class="fu">IsVertical:</span>
        <span class="kw">mov</span>   <span class="kw">ax</span>,[<span class="kw">bp</span>+X1]            <span class="co">;starting (and only) X coordinate</span>
        <span class="kw">sub</span>   <span class="kw">bx</span>,[<span class="kw">bp</span>+SkipFirst]     <span class="co">;loop count = Height - SkipFirst</span>
        <span class="kw">jz</span>    ScanEdgeExit          <span class="co">;no scan lines left after skipping 1st</span>
<span class="fu">VerticalLoop:</span>
        <span class="kw">mov</span>   [<span class="kw">di</span>],<span class="kw">ax</span>               <span class="co">;store the current X value</span>
        <span class="kw">add</span>   <span class="kw">di</span>,size HLine         <span class="co">;point to the next HLine struc</span>
        <span class="kw">dec</span>   <span class="kw">bx</span>                    <span class="co">;count off this scan line</span>
        <span class="kw">jnz</span>   VerticalLoop
        <span class="kw">jmp</span>   ScanEdgeDone
        <span class="kw">align</span> <span class="dv">2</span>
<span class="fu">IsDiagonal:</span>
        <span class="kw">mov</span>   <span class="kw">ax</span>,[<span class="kw">bp</span>+X1]            <span class="co">;starting X coordinate</span>
        <span class="kw">cmp</span>   [<span class="kw">bp</span>+SkipFirst],<span class="dv">1</span>      <span class="co">;skip the first point?</span>
        <span class="kw">jz</span>    DiagonalSkipEntry     <span class="co">;yes</span>
<span class="fu">DiagonalLoop:</span>
        <span class="kw">mov</span>   [<span class="kw">di</span>],<span class="kw">ax</span>               <span class="co">;store the current X value</span>
        <span class="kw">add</span>   <span class="kw">di</span>,size HLine         <span class="co">;point to the next HLine struc</span>
<span class="fu">DiagonalSkipEntry:</span>
        <span class="kw">add</span>   <span class="kw">ax</span>,<span class="kw">dx</span>                 <span class="co">;advance the X coordinate</span>
        <span class="kw">dec</span>   <span class="kw">bx</span>                    <span class="co">;count off this scan line</span>
        <span class="kw">jnz</span>   DiagonalLoop
        <span class="kw">jmp</span>   ScanEdgeDone
        <span class="kw">align</span> <span class="dv">2</span>
<span class="fu">YMajor:</span>
        pushbp                      <span class="co">;preserve stack frame pointer</span>
        <span class="kw">mov</span>   <span class="kw">si</span>,[<span class="kw">bp</span>+X1]            <span class="co">;starting X coordinate</span>
        <span class="kw">cmp</span>   [<span class="kw">bp</span>+SkipFirst],<span class="dv">1</span>      <span class="co">;skip the first point?</span>
        <span class="kw">mov</span>   <span class="kw">bp</span>,<span class="kw">bx</span>                 <span class="co">;put Height in BP for error term calcs</span>
        <span class="kw">jz</span>    YMa<span class="kw">jo</span>rSkipEntry       <span class="co">;yes, skip the first point</span>
<span class="fu">YMajorLoop:</span>
        <span class="kw">mov</span>   [<span class="kw">di</span>],<span class="kw">si</span>               <span class="co">;store the current X value</span>
        <span class="kw">add</span>   <span class="kw">di</span>,size HLine         <span class="co">;point to the next HLine struc</span>
<span class="fu">YMajorSkipEntry:</span>
        <span class="kw">add</span>   <span class="kw">cx</span>,<span class="kw">ax</span>                 <span class="co">;advance the error term</span>
        <span class="kw">jle</span>   YMa<span class="kw">jo</span>rNoAdvance       <span class="co">;not time for X coord to advance</span>
        <span class="kw">add</span>   <span class="kw">si</span>,<span class="kw">dx</span>                 <span class="co">;advance the X coordinate</span>
        <span class="kw">sub</span>   <span class="kw">cx</span>,<span class="kw">bp</span>                 <span class="co">;adjust error term back</span>
<span class="fu">YMajorNoAdvance:</span>
        <span class="kw">dec</span>   <span class="kw">bx</span>                    <span class="co">;count off this scan line</span>
        <span class="kw">jnz</span>   YMa<span class="kw">jo</span>rLoop
        popbp                       <span class="co">;restore stack frame pointer</span>
<span class="fu">ScanEdgeDone:</span>
        <span class="kw">cmp</span>   [<span class="kw">bp</span>+SetXStart],<span class="dv">1</span>       <span class="co">;were we working with XStart field?</span>
        <span class="kw">jz</span>    UpdateHLinePtr         <span class="co">;yes, DI points to the next XStart</span>
        <span class="kw">sub</span>   <span class="kw">di</span>,XEnd                <span class="co">;no, point back to the XStart field</span>
<span class="fu">UpdateHLinePtr:</span>
        <span class="kw">mov</span>   <span class="kw">bx</span>,[<span class="kw">bp</span>+EdgePointPtr]   <span class="co">;point to pointer to HLine array</span>
        <span class="kw">mov</span>   [<span class="kw">bx</span>],<span class="kw">di</span>                <span class="co">;update caller&#39;s HLine array pointer</span>
<span class="fu">ScanEdgeExit:</span>
        <span class="kw">pop</span>   <span class="kw">di</span>                     <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>   <span class="kw">si</span>
        <span class="kw">mov</span>   <span class="kw">sp</span>,<span class="kw">bp</span>                  <span class="co">;deallocate local variables</span>
        <span class="kw">pop</span>   <span class="kw">bp</span>                     <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_ScanEdge   endp
        end</code></pre>
</section>
</section>
<section id="chapter-40-of-songs-taxes-and-the-simplicity-of-complex-polygons" class="level2">
<h2><a href="#chapter-40-of-songs-taxes-and-the-simplicity-of-complex-polygons">Chapter 40 – Of Songs, Taxes, and the Simplicity of Complex Polygons</a></h2>
<section id="dealing-with-irregular-polygonal-areas" class="level3">
<h3><a href="#dealing-with-irregular-polygonal-areas">Dealing with Irregular Polygonal Areas</a></h3>
<p>Every so often, my daughter asks me to sing her to sleep. (If you’ve ever heard me sing, this may cause you concern about either her hearing or her judgement, but love knows no bounds.) As any parent is well aware, singing a young child to sleep can easily take several hours, or until sunrise, whichever comes last. One night, running low on children’s songs, I switched to a Beatles medley, and at long last her breathing became slow and regular. At the end, I softly sang “A Hard Day’s Night,” then quietly stood up to leave. As I tiptoed out, she said, in a voice not even faintly tinged with sleep, “Dad, what do they mean, ‘working like a dog’? Chasing a stick? That doesn’t make sense; people don’t chase sticks.”</p>
<p>That led us into a discussion of idioms, which made about as much sense to her as an explanation of quantum mechanics. Finally, I fell back on my standard explanation of the Universe, which is that a lot of the time it simply doesn’t make sense.</p>
<p>As a general principle, that explanation holds up remarkably well. (In fact, having just done my taxes, I think Earth is actually run by blob-creatures from the planet Mrxx, who are helplessly doubled over with laughter at the ridiculous things they can make us do. “Let’s make them get Social Security numbers for their pets next year!” they’re saying right now, gasping for breath.) Occasionally, however, one has the rare pleasure of finding a corner of the Universe that makes sense, where everything fits together as if preordained.</p>
<p>Filling arbitrary polygons is such a case.</p>
</section>
<section id="filling-arbitrary-polygons" class="level3">
<h3><a href="#filling-arbitrary-polygons">Filling Arbitrary Polygons</a></h3>
<p>In Chapter 38, I described three types of polygons: convex, nonconvex, and complex. <em>The RenderMan Companion</em>, a terrific book by Steve Upstill (Addison-Wesley, 1990) has an intuitive definition of <em>convex</em>: If a rubber band stretched around a polygon touches all vertices in the order they’re defined, then the polygon is convex. If a polygon has intersecting edges, it’s complex. If a polygon doesn’t have intersecting edges but isn’t convex, it’s nonconvex. Nonconvex is a special case of complex, and convex is a special case of nonconvex. (Which, I’m well aware, makes nonconvex a lousy name—noncomplex would have been better—but I’m following X Window System nomenclature here.)</p>
<p>The reason for distinguishing between these three types of polygons is that the more specialized types can be filled with markedly faster approaches. Complex polygons require the slowest approach; however, that approach will serve to fill any polygon of any sort. Nonconvex polygons require less sorting, because edges never cross. Convex polygons can be filled fastest of all by simply scanning the two sides of the polygon, as we saw in Chapter 39.</p>
<p>Before we dive into complex polygon filling, I’d like to point out that the code in this chapter, like all polygon filling code I’ve ever seen, requires that the caller describe the type of the polygon to be filled. Often, however, the caller doesn’t know what type of polygon it’s passing, or specifies complex for simplicity, because that will work for all polygons; in such a case, the polygon filler will use the slow complex-fill code even if the polygon is, in fact, a convex polygon. In Chapter 41, I’ll discuss one way to improve this situation.</p>
<section id="active-edges" class="level4">
<h4><a href="#active-edges">Active Edges</a></h4>
<p>The basic premise of filling a complex polygon is that for a given scan line, we determine all intersections between the polygon’s edges and that scan line and then fill the spans between the intersections, as shown in Figure 40.1. (Section 3.6 of Foley and van Dam’s <em>Computer Graphics</em>, Second Edition provides an overview of this and other aspects of polygon filling.) There are several rules that might be used to determine which spans are drawn and which aren’t; we’ll use the odd/even rule, which specifies that drawing turns on after odd-numbered intersections (first, third, and so on) and off after even-numbered intersections.</p>
<p>The question then becomes how can we most efficiently determine which edges cross each scan line and where? As it happens, there is a great deal of coherence from one scan line to the next in a polygon edge list, because each edge starts at a given Y coordinate and continues unbroken until it ends. In other words, edges don’t leap about and stop and start randomly; the X coordinate of an edge at one scan line is a consistent delta from that edge’s X coordinate at the last scan line, and that is consistent for the length of the line.</p>
<figure>
<img src="images/40-01.jpg" alt="Figure 40.1  Filling one scan line by finding intersecting edges." /><figcaption><strong>Figure 40.1</strong>  <em>Filling one scan line by finding intersecting edges.</em></figcaption>
</figure>
<p>This allows us to reduce the number of edges that must be checked for intersection; on any given scan line, we only need to check for intersections with the currently active edges—edges that start on that scan line, plus all edges that start on earlier (above) scan lines and haven’t ended yet—as shown in Figure 40.2. This suggests that we can proceed from the top scan line of the polygon to the bottom, keeping a running list of currently active edges—called the <em>active edge table</em> (AET)—with the edges sorted in order of ascending X coordinate of intersection with the current scan line. Then, we can simply fill each scan line in turn according to the list of active edges at that line.</p>
<figure>
<img src="images/40-02.jpg" alt="Figure 40.2  Checking currently active edges (solid lines)." /><figcaption><strong>Figure 40.2</strong>  <em>Checking currently active edges (solid lines).</em></figcaption>
</figure>
<p>Maintaining the AET from one scan line to the next involves three steps: First, we must add to the AET any edges that start on the current scan line, making sure to keep the AET X-sorted for efficient odd/even scanning. Second, we must remove edges that end on the current scan line. Third, we must advance the X coordinates of active edges with the same sort of error term-based, Bresenham’s-like approach we used for convex polygons, again ensuring that the AET is X-sorted after advancing the edges.</p>
<p>Advancing the X coordinates is easy. For each edge, we’ll store the current X coordinate and all required error term information, and we’ll use that to advance the edge one scan line at a time; then, we’ll resort the AET by X coordinate as needed. Removing edges as they end is also easy; we’ll just count down the length of each active edge on each scan line and remove an edge when its count reaches zero. Adding edges as their tops are encountered is a tad more complex. While there are a number of ways to do this, one particularly efficient approach is to start out by putting all the edges of the polygon, sorted by increasing Y coordinate, into a single list, called the <em>global edge table</em> (GET). Then, as each scan line is encountered, all edges at the start of the GET that begin on the current scan line are moved to the AET; because the GET is Y-sorted, there’s no need to search the entire GET. For still greater efficiency, edges in the GET that share common Y coordinates can be sorted by increasing X coordinate; this ensures that no more than one pass through the AET per scan line is ever needed when adding new edges from the GET in such a way as to keep the AET sorted in ascending X order.</p>
<p>What form should the GET and AET take? Linked lists of edge structures, as shown in Figure 40.3. With linked lists, all that’s required to move edges from the GET to the AET as they become active, sort the AET, and remove edges that have been fully drawn is the exchanging of a few pointers.</p>
<p>In summary, we’ll initially store all the polygon edges in Y-primary/X-secondary sort order in the GET, complete with initial X and Y coordinates, error terms and error term adjustments, lengths, and directions of X movement for each edge. Once the GET is built, we’ll do the following:</p>
<ol type="1">
<li><p>Set the current Y coordinate to the Y coordinate of the first edge in the GET.</p></li>
<li><p>Move all edges with the current Y coordinate from the GET to the AET, removing them from the GET and maintaining the X-sorted order of the AET.</p></li>
<li><p>Draw all odd-to-even spans in the AET at the current Y coordinate.</p></li>
<li><p>Count down the lengths of all edges in the AET, removing any edges that are done, and advancing the X coordinates of all remaining edges in the AET by one scan line.</p></li>
<li><p>Sort the AET in order of ascending X coordinate.</p></li>
<li><p>Advance the current Y coordinate by one scan line.</p></li>
<li><p>If either the AET or GET isn’t empty, go to step 2.</p></li>
</ol>
<figure>
<img src="images/40-03.jpg" alt="Figure 40.3  The global and active edge tables as linked lists." /><figcaption><strong>Figure 40.3</strong>  <em>The global and active edge tables as linked lists.</em></figcaption>
</figure>
<p>That’s really all there is to it. Compare Listing 40.1 to the fast convex polygon filling code from Chapter 39, and you’ll see that, contrary to expectation, complex polygon filling is indeed one of the more sane and sensible corners of the universe.</p>
<p><strong>LISTING 40.1 L40-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Color-fills an arbitrarily-shaped polygon described by VertexList.</span>
<span class="co">   If the first and last points in VertexList are not the same, the path</span>
<span class="co">   around the polygon is automatically closed. All vertices are offset</span>
<span class="co">   by (XOffset, YOffset). Returns 1 for success, 0 if memory allocation</span>
<span class="co">   failed. All C code tested with Borland C++.</span>
<span class="co">   If the polygon shape is known in advance, speedier processing may be</span>
<span class="co">   enabled by specifying the shape as follows: &quot;convex&quot; - a rubber band</span>
<span class="co">   stretched around the polygon would touch every vertex in order;</span>
<span class="co">   &quot;nonconvex&quot; - the polygon is not self-intersecting, but need not be</span>
<span class="co">   convex; &quot;complex&quot; - the polygon may be self-intersecting, or, indeed,</span>
<span class="co">   any sort of polygon at all. Complex will work for all polygons; convex</span>
<span class="co">   is fastest. Undefined results will occur if convex is specified for a</span>
<span class="co">   nonconvex or complex polygon.</span>
<span class="co">   Define CONVEX_CODE_LINKED if the fast convex polygon filling code from</span>
<span class="co">   Chapter 38 is linked in. Otherwise, convex polygons are</span>
<span class="co">   handled by the complex polygon filling code.</span>
<span class="co">   Nonconvex is handled as complex in this implementation. See text for a</span>
<span class="co">   discussion of faster nonconvex handling. */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#ifdef __TURBOC__</span>
<span class="ot">#include &lt;alloc.h&gt;</span>
<span class="ot">#else    </span><span class="co">/* MSC */</span>
<span class="ot">#include &lt;malloc.h&gt;</span>
<span class="ot">#endif</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="ot">#define SWAP(a,b) {temp = a; a = b; b = temp;}</span>

<span class="kw">struct</span> EdgeState {
  <span class="kw">struct</span> EdgeState *NextEdge;
  <span class="dt">int</span> X;
  <span class="dt">int</span> StartY;
  <span class="dt">int</span> WholePixelXMove;
  <span class="dt">int</span> XDirection;
  <span class="dt">int</span> ErrorTerm;
  <span class="dt">int</span> ErrorTermAdjUp;
  <span class="dt">int</span> ErrorTermAdjDown;
  <span class="dt">int</span> Count;
};

<span class="kw">extern</span> <span class="dt">void</span> DrawHorizontalLineSeg(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">int</span> FillConvexPolygon(<span class="kw">struct</span> PointListHeader *, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="dt">static</span> <span class="dt">void</span> BuildGET(<span class="kw">struct</span> PointListHeader *, <span class="kw">struct</span> EdgeState *, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="dt">static</span> <span class="dt">void</span> MoveXSortedToAET(<span class="dt">int</span>);
<span class="dt">static</span> <span class="dt">void</span> ScanOutAET(<span class="dt">int</span>, <span class="dt">int</span>);
<span class="dt">static</span> <span class="dt">void</span> AdvanceAET(<span class="dt">void</span>);
<span class="dt">static</span> <span class="dt">void</span> XSortAET(<span class="dt">void</span>);

<span class="co">/* Pointers to global edge table (GET) and active edge table (AET) */</span>
<span class="dt">static</span> <span class="kw">struct</span> EdgeState *GETPtr, *AETPtr;

<span class="dt">int</span> FillPolygon(<span class="kw">struct</span> PointListHeader * VertexList, <span class="dt">int</span> Color,
      <span class="dt">int</span> PolygonShape, <span class="dt">int</span> XOffset, <span class="dt">int</span> YOffset)
{
  <span class="kw">struct</span> EdgeState *EdgeTableBuffer;
  <span class="dt">int</span> CurrentY;

<span class="ot">#ifdef CONVEX_CODE_LINKED</span>
  <span class="co">/* Pass convex polygons through to fast convex polygon filler */</span>
  <span class="kw">if</span> (PolygonShape == CONVEX)
     <span class="kw">return</span>(FillConvexPolygon(VertexList, Color, XOffset, YOffset));
<span class="ot">#endif</span>

  <span class="co">/* It takes a minimum of 3 vertices to cause any pixels to be</span>
<span class="co">     drawn; reject polygons that are guaranteed to be invisible */</span>
  <span class="kw">if</span> (VertexList-&gt;Length &lt; <span class="dv">3</span>)
     <span class="kw">return</span>(<span class="dv">1</span>);
  <span class="co">/* Get enough memory to store the entire edge table */</span>
  <span class="kw">if</span> ((EdgeTableBuffer =
        (<span class="kw">struct</span> EdgeState *) (malloc(<span class="kw">sizeof</span>(<span class="kw">struct</span> EdgeState) *
        VertexList-&gt;Length))) == NULL)
     <span class="kw">return</span>(<span class="dv">0</span>);  <span class="co">/* couldn&#39;&#39;t get memory for the edge table */</span>
  <span class="co">/* Build the global edge table */</span>
  BuildGET(VertexList, EdgeTableBuffer, XOffset, YOffset);
  <span class="co">/* Scan down through the polygon edges, one scan line at a time,</span>
<span class="co">     so long as at least one edge remains in either the GET or AET */</span>
  AETPtr = NULL;    <span class="co">/* initialize the active edge table to empty */</span>
  CurrentY = GETPtr-&gt;StartY; <span class="co">/* start at the top polygon vertex */</span>
  <span class="kw">while</span> ((GETPtr != NULL) || (AETPtr != NULL)) {
     MoveXSortedToAET(CurrentY);  <span class="co">/* update AET for this scan line */</span>
     ScanOutAET(CurrentY, Color); <span class="co">/* draw this scan line from AET */</span>
     AdvanceAET();                <span class="co">/* advance AET edges 1 scan line */</span>
     XSortAET();                  <span class="co">/* resort on X */</span>
     CurrentY++;                  <span class="co">/* advance to the next scan line */</span>
  }
  <span class="co">/* Release the memory we&#39;ve allocated and we&#39;re done */</span>
  free(EdgeTableBuffer);
  <span class="kw">return</span>(<span class="dv">1</span>);
}

<span class="co">/* Creates a GET in the buffer pointed to by NextFreeEdgeStruc from</span>
<span class="co">   the vertex list. Edge endpoints are flipped, if necessary, to</span>
<span class="co">   guarantee all edges go top to bottom. The GET is sorted primarily</span>
<span class="co">   by ascending Y start coordinate, and secondarily by ascending X</span>
<span class="co">   start coordinate within edges with common Y coordinates. */</span>
<span class="dt">static</span> <span class="dt">void</span> BuildGET(<span class="kw">struct</span> PointListHeader * VertexList,
      <span class="kw">struct</span> EdgeState * NextFreeEdgeStruc, <span class="dt">int</span> XOffset, <span class="dt">int</span> YOffset)
{
  <span class="dt">int</span> i, StartX, StartY, EndX, EndY, DeltaY, DeltaX, Width, temp;
  <span class="kw">struct</span> EdgeState *NewEdgePtr;
  <span class="kw">struct</span> EdgeState *FollowingEdge, **FollowingEdgeLink;
  <span class="kw">struct</span> Point *VertexPtr;

  <span class="co">/* Scan through the vertex list and put all non-0-height edges into</span>
<span class="co">     the GET, sorted by increasing Y start coordinate */</span>
  VertexPtr = VertexList-&gt;PointPtr;   <span class="co">/* point to the vertex list */</span>
  GETPtr = NULL;    <span class="co">/* initialize the global edge table to empty */</span>
  <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; VertexList-&gt;Length; i++) {
     <span class="co">/* Calculate the edge height and width */</span>
     StartX = VertexPtr[i].X + XOffset;
     StartY = VertexPtr[i].Y + YOffset;
     <span class="co">/* The edge runs from the current point to the previous one */</span>
     <span class="kw">if</span> (i == <span class="dv">0</span>) {
        <span class="co">/* Wrap back around to the end of the list */</span>
        EndX = VertexPtr[VertexList-&gt;Length<span class="dv">-1</span>].X + XOffset;
        EndY = VertexPtr[VertexList-&gt;Length<span class="dv">-1</span>].Y + YOffset;
     } <span class="kw">else</span> {
        EndX = VertexPtr[i<span class="dv">-1</span>].X + XOffset;
        EndY = VertexPtr[i<span class="dv">-1</span>].Y + YOffset;
     }
     <span class="co">/* Make sure the edge runs top to bottom */</span>
     <span class="kw">if</span> (StartY &gt; EndY) {
        SWAP(StartX, EndX);
        SWAP(StartY, EndY);
     }
     <span class="co">/* Skip if this can&#39;t ever be an active edge (has 0 height) */</span>
     <span class="kw">if</span> ((DeltaY = EndY - StartY) != <span class="dv">0</span>) {
        <span class="co">/* Allocate space for this edge&#39;s info, and fill in the</span>
<span class="co">           structure */</span>
        NewEdgePtr = NextFreeEdgeStruc++;
        NewEdgePtr-&gt;XDirection =   <span class="co">/* direction in which X moves */</span>
              ((DeltaX = EndX - StartX) &gt; <span class="dv">0</span>) ? <span class="dv">1</span> : -<span class="dv">1</span>;
        Width = abs(DeltaX);
        NewEdgePtr-&gt;X = StartX;
        NewEdgePtr-&gt;StartY = StartY;
        NewEdgePtr-&gt;Count = DeltaY;
        NewEdgePtr-&gt;ErrorTermAdjDown = DeltaY;
        <span class="kw">if</span> (DeltaX &gt;= <span class="dv">0</span>)  <span class="co">/* initial error term going L-&gt;R */</span>
           NewEdgePtr-&gt;ErrorTerm = <span class="dv">0</span>;
        <span class="kw">else</span>              <span class="co">/* initial error term going R-&gt;L */</span>
           NewEdgePtr-&gt;ErrorTerm = -DeltaY + <span class="dv">1</span>;
        <span class="kw">if</span> (DeltaY &gt;= Width) {     <span class="co">/* Y-major edge */</span>
           NewEdgePtr-&gt;WholePixelXMove = <span class="dv">0</span>;
           NewEdgePtr-&gt;ErrorTermAdjUp = Width;
        } <span class="kw">else</span> {                   <span class="co">/* X-major edge */</span>
           NewEdgePtr-&gt;WholePixelXMove =
                 (Width / DeltaY) * NewEdgePtr-&gt;XDirection;
           NewEdgePtr-&gt;ErrorTermAdjUp = Width % DeltaY;
        }
        <span class="co">/* Link the new edge into the GET so that the edge list is</span>
<span class="co">           still sorted by Y coordinate, and by X coordinate for all</span>
<span class="co">           edges with the same Y coordinate */</span>
        FollowingEdgeLink = &amp;GETPtr;
        <span class="kw">for</span> (;;) {
           FollowingEdge = *FollowingEdgeLink;
           <span class="kw">if</span> ((FollowingEdge == NULL) ||
                 (FollowingEdge-&gt;StartY &gt; StartY) ||
                 ((FollowingEdge-&gt;StartY == StartY) &amp;&amp;
                 (FollowingEdge-&gt;X &gt;= StartX))) {
              NewEdgePtr-&gt;NextEdge = FollowingEdge;
              *FollowingEdgeLink = NewEdgePtr;
              <span class="kw">break</span>;
           }
           FollowingEdgeLink = &amp;FollowingEdge-&gt;NextEdge;
        }
     }
  }
}

<span class="co">/* Sorts all edges currently in the active edge table into ascending</span>
<span class="co">   order of current X coordinates */</span>
<span class="dt">static</span> <span class="dt">void</span> XSortAET() {
  <span class="kw">struct</span> EdgeState *CurrentEdge, **CurrentEdgePtr, *TempEdge;
  <span class="dt">int</span> SwapOccurred;

  <span class="co">/* Scan through the AET and swap any adjacent edges for which the</span>
<span class="co">     second edge is at a lower current X coord than the first edge.</span>
<span class="co">     Repeat until no further swapping is needed */</span>
  <span class="kw">if</span> (AETPtr != NULL) {
     <span class="kw">do</span> {
        SwapOccurred = <span class="dv">0</span>;
        CurrentEdgePtr = &amp;AETPtr;
        <span class="kw">while</span> ((CurrentEdge = *CurrentEdgePtr)-&gt;NextEdge != NULL) {
           <span class="kw">if</span> (CurrentEdge-&gt;X &gt; CurrentEdge-&gt;NextEdge-&gt;X) {
              <span class="co">/* The second edge has a lower X than the first;</span>
<span class="co">                 swap them in the AET */</span>
              TempEdge = CurrentEdge-&gt;NextEdge-&gt;NextEdge;
              *CurrentEdgePtr = CurrentEdge-&gt;NextEdge;
              CurrentEdge-&gt;NextEdge-&gt;NextEdge = CurrentEdge;
              CurrentEdge-&gt;NextEdge = TempEdge;
              SwapOccurred = <span class="dv">1</span>;
           }
           CurrentEdgePtr = &amp;(*CurrentEdgePtr)-&gt;NextEdge;
        }
     } <span class="kw">while</span> (SwapOccurred != <span class="dv">0</span>);
  }
}

<span class="co">/* Advances each edge in the AET by one scan line.</span>
<span class="co">   Removes edges that have been fully scanned. */</span>
<span class="dt">static</span> <span class="dt">void</span> AdvanceAET() {
  <span class="kw">struct</span> EdgeState *CurrentEdge, **CurrentEdgePtr;

  <span class="co">/* Count down and remove or advance each edge in the AET */</span>
  CurrentEdgePtr = &amp;AETPtr;
  <span class="kw">while</span> ((CurrentEdge = *CurrentEdgePtr) != NULL) {
     <span class="co">/* Count off one scan line for this edge */</span>
     <span class="kw">if</span> ((--(CurrentEdge-&gt;Count)) == <span class="dv">0</span>) {
        <span class="co">/* This edge is finished, so remove it from the AET */</span>
        *CurrentEdgePtr = CurrentEdge-&gt;NextEdge;
     } <span class="kw">else</span> {
        <span class="co">/* Advance the edge&#39;s X coordinate by minimum move */</span>
        CurrentEdge-&gt;X += CurrentEdge-&gt;WholePixelXMove;
        <span class="co">/* Determine whether it&#39;s time for X to advance one extra */</span>
        <span class="kw">if</span> ((CurrentEdge-&gt;ErrorTerm +=
              CurrentEdge-&gt;ErrorTermAdjUp) &gt; <span class="dv">0</span>) {
           CurrentEdge-&gt;X += CurrentEdge-&gt;XDirection;
           CurrentEdge-&gt;ErrorTerm -= CurrentEdge-&gt;ErrorTermAdjDown;
        }
        CurrentEdgePtr = &amp;CurrentEdge-&gt;NextEdge;
     }
  }
}

<span class="co">/* Moves all edges that start at the specified Y coordinate from the</span>
<span class="co">   GET to the AET, maintaining the X sorting of the AET. */</span>
<span class="dt">static</span> <span class="dt">void</span> MoveXSortedToAET(<span class="dt">int</span> YToMove) {
  <span class="kw">struct</span> EdgeState *AETEdge, **AETEdgePtr, *TempEdge;
  <span class="dt">int</span> CurrentX;

  <span class="co">/* The GET is Y sorted. Any edges that start at the desired Y</span>
<span class="co">     coordinate will be first in the GET, so we&#39;ll move edges from</span>
<span class="co">     the GET to AET until the first edge left in the GET is no longer</span>
<span class="co">     at the desired Y coordinate. Also, the GET is X sorted within</span>
<span class="co">     each Y coordinate, so each successive edge we add to the AET is</span>
<span class="co">     guaranteed to belong later in the AET than the one just added. */</span>
  AETEdgePtr = &amp;AETPtr;
  <span class="kw">while</span> ((GETPtr != NULL) &amp;&amp; (GETPtr-&gt;StartY == YToMove)) {
     CurrentX = GETPtr-&gt;X;
     <span class="co">/* Link the new edge into the AET so that the AET is still</span>
<span class="co">        sorted by X coordinate */</span>
     <span class="kw">for</span> (;;) {
        AETEdge = *AETEdgePtr;
        <span class="kw">if</span> ((AETEdge == NULL) || (AETEdge-&gt;X &gt;= CurrentX)) {
           TempEdge = GETPtr-&gt;NextEdge;
           *AETEdgePtr = GETPtr;  <span class="co">/* link the edge into the AET */</span>
           GETPtr-&gt;NextEdge = AETEdge;
           AETEdgePtr = &amp;GETPtr-&gt;NextEdge;
           GETPtr = TempEdge;   <span class="co">/* unlink the edge from the GET */</span>
           <span class="kw">break</span>;
        } <span class="kw">else</span> {
           AETEdgePtr = &amp;AETEdge-&gt;NextEdge;
        }
     }
  }
}

<span class="co">/* Fills the scan line described by the current AET at the specified Y</span>
<span class="co">   coordinate in the specified color, using the odd/even fill rule */</span>
<span class="dt">static</span> <span class="dt">void</span> ScanOutAET(<span class="dt">int</span> YToScan, <span class="dt">int</span> Color) {
  <span class="dt">int</span> LeftX;
  <span class="kw">struct</span> EdgeState *CurrentEdge;

  <span class="co">/* Scan through the AET, drawing line segments as each pair of edge</span>
<span class="co">     crossings is encountered. The nearest pixel on or to the right</span>
<span class="co">     of left edges is drawn, and the nearest pixel to the left of but</span>
<span class="co">     not on right edges is drawn */</span>
  CurrentEdge = AETPtr;
  <span class="kw">while</span> (CurrentEdge != NULL) {
     LeftX = CurrentEdge-&gt;X;
     CurrentEdge = CurrentEdge-&gt;NextEdge;
     DrawHorizontalLineSeg(YToScan, LeftX, CurrentEdge-&gt;X<span class="dv">-1</span>, Color);
     CurrentEdge = CurrentEdge-&gt;NextEdge;
  }
}</code></pre>
</section>
</section>
<section id="complex-polygon-filling-an-implementation" class="level3">
<h3><a href="#complex-polygon-filling-an-implementation">Complex Polygon Filling: An Implementation</a></h3>
<p>Listing 40.1 just shown presents a function, <code>FillPolygon()</code>, that fills polygons of all shapes. If <code>CONVEX_FILL_LINKED</code> is defined, the fast convex fill code from Chapter 39 is linked in and used to draw convex polygons. Otherwise, convex polygons are handled as if they were complex. Nonconvex polygons are also handled as complex, although this is not necessary, as discussed shortly.</p>
<p>Listing 40.1 is a faithful implementation of the complex polygon filling approach just described, with separate functions corresponding to each of the tasks, such as building the GET and X-sorting the AET. Listing 40.2 provides the actual drawing code used to fill spans, built on a draw pixel routine that is the only hardware dependency anywhere in the C code. Listing 40.3 is the header file for the polygon filling code; note that it is an expanded version of the header file used by the fast convex polygon fill code from Chapter 39. (They may have the same name but are <em>not</em> the same file!) Listing 40.4 is a sample program that, when linked to Listings 40.1 and 40.2, demonstrates drawing polygons of various sorts.</p>
<p><strong>LISTING 40.2 L40-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Draws all pixels in the horizontal line segment passed in, from</span>
<span class="co">  (LeftX,Y) to (RightX,Y), in the specified color in mode 13h, the</span>
<span class="co">  VGA&#39;s 320x200 256-color mode. Both LeftX and RightX are drawn. No</span>
<span class="co">  drawing will take place if LeftX &gt; RightX. */</span>

<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="ot">#define SCREEN_WIDTH    320</span>
<span class="ot">#define SCREEN_SEGMENT  0xA000</span>

<span class="dt">static</span> <span class="dt">void</span> DrawPixel(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);

<span class="dt">void</span> DrawHorizontalLineSeg(Y, LeftX, RightX, Color) {
  <span class="dt">int</span> X;

  <span class="co">/* Draw each pixel in the horizontal line segment, starting with</span>
<span class="co">     the leftmost one */</span>
  <span class="kw">for</span> (X = LeftX; X &lt;= RightX; X++)
     DrawPixel(X, Y, Color);
}

<span class="co">/* Draws the pixel at (X, Y) in color Color in VGA mode 13h */</span>
<span class="dt">static</span> <span class="dt">void</span> DrawPixel(<span class="dt">int</span> X, <span class="dt">int</span> Y, <span class="dt">int</span> Color) {
  <span class="dt">unsigned</span> <span class="dt">char</span> far *ScreenPtr;

<span class="ot">#ifdef __TURBOC__</span>
  ScreenPtr = MK_FP(SCREEN_SEGMENT, Y * SCREEN_WIDTH + X);
<span class="ot">#else    </span><span class="co">/* MSC 5.0 */</span>
  FP_SEG(ScreenPtr) = SCREEN_SEGMENT;
  FP_OFF(ScreenPtr) = Y * SCREEN_WIDTH + X;
<span class="ot">#endif</span>
  *ScreenPtr = (<span class="dt">unsigned</span> <span class="dt">char</span>) Color;
}</code></pre>
<p><strong>LISTING 40.3 POLYGON.H</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* POLYGON.H: Header file for polygon-filling code */</span>

<span class="ot">#define CONVEX    0</span>
<span class="ot">#define NONCONVEX 1</span>
<span class="ot">#define COMPLEX   2</span>

<span class="co">/* Describes a single point (used for a single vertex) */</span>
<span class="kw">struct</span> Point {
  <span class="dt">int</span> X;   <span class="co">/* X coordinate */</span>
  <span class="dt">int</span> Y;   <span class="co">/* Y coordinate */</span>
};
<span class="co">/* Describes a series of points (used to store a list of vertices that</span>
<span class="co">  describe a polygon; each vertex connects to the two adjacent</span>
<span class="co">  vertices; the last vertex is assumed to connect to the first) */</span>
<span class="kw">struct</span> PointListHeader {
  <span class="dt">int</span> Length;                <span class="co">/* # of points */</span>
  <span class="kw">struct</span> Point * PointPtr;   <span class="co">/* pointer to list of points */</span>
};
<span class="co">/* Describes the beginning and ending X coordinates of a single</span>
<span class="co">  horizontal line (used only by fast polygon fill code) */</span>
<span class="kw">struct</span> HLine {
  <span class="dt">int</span> XStart; <span class="co">/* X coordinate of leftmost pixel in line */</span>
  <span class="dt">int</span> XEnd;   <span class="co">/* X coordinate of rightmost pixel in line */</span>
};
<span class="co">/* Describes a length-long series of horizontal lines, all assumed to</span>
<span class="co">  be on contiguous scan lines starting at YStart and proceeding</span>
<span class="co">  downward (used to describe a scan-converted polygon to the</span>
<span class="co">  low-level hardware-dependent drawing code) (used only by fast</span>
<span class="co">  polygon fill code). */</span>
<span class="kw">struct</span> HLineList {
  <span class="dt">int</span> Length;                <span class="co">/* # of horizontal lines */</span>
  <span class="dt">int</span> YStart;                <span class="co">/* Y coordinate of topmost line */</span>
  <span class="kw">struct</span> HLine * HLinePtr;   <span class="co">/* pointer to list of horz lines */</span>
};</code></pre>
<p><strong>LISTING 40.4 L40-4.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Sample program to exercise the polygon-filling routines */</span>

<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="ot">#define DRAW_POLYGON(PointList,Color,Shape,X,Y)             \</span>
  Polygon.Length = <span class="kw">sizeof</span>(PointList)/<span class="kw">sizeof</span>(<span class="kw">struct</span> Point); \
  Polygon.PointPtr = PointList;                            \
  FillPolygon(&amp;Polygon, Color, Shape, X, Y);

<span class="dt">void</span> main(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">int</span> FillPolygon(<span class="kw">struct</span> PointListHeader *, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);

<span class="dt">void</span> main() {
  <span class="dt">int</span> i, j;
  <span class="kw">struct</span> PointListHeader Polygon;
  <span class="dt">static</span> <span class="kw">struct</span> Point Polygon1[] =
        {{<span class="dv">0</span>,<span class="dv">0</span>},{<span class="dv">100</span>,<span class="dv">150</span>},{<span class="dv">320</span>,<span class="dv">0</span>},{<span class="dv">0</span>,<span class="dv">200</span>},{<span class="dv">220</span>,<span class="dv">50</span>},{<span class="dv">320</span>,<span class="dv">200</span>}};
  <span class="dt">static</span> <span class="kw">struct</span> Point Polygon2[] =
        {{<span class="dv">0</span>,<span class="dv">0</span>},{<span class="dv">320</span>,<span class="dv">0</span>},{<span class="dv">320</span>,<span class="dv">200</span>},{<span class="dv">0</span>,<span class="dv">200</span>},{<span class="dv">0</span>,<span class="dv">0</span>},{<span class="dv">50</span>,<span class="dv">50</span>},
         {<span class="dv">270</span>,<span class="dv">50</span>},{<span class="dv">270</span>,<span class="dv">150</span>},{<span class="dv">50</span>,<span class="dv">150</span>},{<span class="dv">50</span>,<span class="dv">50</span>}};
  <span class="dt">static</span> <span class="kw">struct</span> Point Polygon3[] =
        {{<span class="dv">0</span>,<span class="dv">0</span>},{<span class="dv">10</span>,<span class="dv">0</span>},{<span class="dv">105</span>,<span class="dv">185</span>},{<span class="dv">260</span>,<span class="dv">30</span>},{<span class="dv">15</span>,<span class="dv">150</span>},{<span class="dv">5</span>,<span class="dv">150</span>},{<span class="dv">5</span>,<span class="dv">140</span>},
         {<span class="dv">260</span>,<span class="dv">5</span>},{<span class="dv">300</span>,<span class="dv">5</span>},{<span class="dv">300</span>,<span class="dv">15</span>},{<span class="dv">110</span>,<span class="dv">200</span>},{<span class="dv">100</span>,<span class="dv">200</span>},{<span class="dv">0</span>,<span class="dv">10</span>}};
  <span class="dt">static</span> <span class="kw">struct</span> Point Polygon4[] =
        {{<span class="dv">0</span>,<span class="dv">0</span>},{<span class="dv">30</span>,-<span class="dv">20</span>},{<span class="dv">30</span>,<span class="dv">0</span>},{<span class="dv">0</span>,<span class="dv">20</span>},{-<span class="dv">30</span>,<span class="dv">0</span>},{-<span class="dv">30</span>,-<span class="dv">20</span>}};
  <span class="dt">static</span> <span class="kw">struct</span> Point Triangle1[] = {{<span class="dv">30</span>,<span class="dv">0</span>},{<span class="dv">15</span>,<span class="dv">20</span>},{<span class="dv">0</span>,<span class="dv">0</span>}};
  <span class="dt">static</span> <span class="kw">struct</span> Point Triangle2[] = {{<span class="dv">30</span>,<span class="dv">20</span>},{<span class="dv">15</span>,<span class="dv">0</span>},{<span class="dv">0</span>,<span class="dv">20</span>}};
  <span class="dt">static</span> <span class="kw">struct</span> Point Triangle3[] = {{<span class="dv">0</span>,<span class="dv">20</span>},{<span class="dv">20</span>,<span class="dv">10</span>},{<span class="dv">0</span>,<span class="dv">0</span>}};
  <span class="dt">static</span> <span class="kw">struct</span> Point Triangle4[] = {{<span class="dv">20</span>,<span class="dv">20</span>},{<span class="dv">20</span>,<span class="dv">0</span>},{<span class="dv">0</span>,<span class="dv">10</span>}};
  <span class="kw">union</span> REGS regset;

  <span class="co">/* Set the display to VGA mode 13h, 320x200 256-color mode */</span>
  regset.x.ax = <span class="bn">0x0013</span>;
  int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);

  <span class="co">/* Draw three complex polygons */</span>
  DRAW_POLYGON(Polygon1, <span class="dv">15</span>, COMPLEX, <span class="dv">0</span>, <span class="dv">0</span>);
  getch();    <span class="co">/* wait for a keypress */</span>
  DRAW_POLYGON(Polygon2, <span class="dv">5</span>, COMPLEX, <span class="dv">0</span>, <span class="dv">0</span>);
  getch();    <span class="co">/* wait for a keypress */</span>
  DRAW_POLYGON(Polygon3, <span class="dv">3</span>, COMPLEX, <span class="dv">0</span>, <span class="dv">0</span>);
  getch();    <span class="co">/* wait for a keypress */</span>

  <span class="co">/* Draw some adjacent nonconvex polygons */</span>
  <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">5</span>; i++) {
     <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;<span class="dv">8</span>; j++) {
        DRAW_POLYGON(Polygon4, <span class="dv">16</span>+i*<span class="dv">8</span>+j, NONCONVEX, <span class="dv">40</span>+(i*<span class="dv">60</span>),
              <span class="dv">30</span>+(j*<span class="dv">20</span>));
     }
  }
  getch();    <span class="co">/* wait for a keypress */</span>

  <span class="co">/* Draw adjacent triangles across the screen */</span>
  <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;=<span class="dv">80</span>; j+=<span class="dv">20</span>) {
     <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">290</span>; i += <span class="dv">30</span>) {
        DRAW_POLYGON(Triangle1, <span class="dv">2</span>, CONVEX, i, j);
        DRAW_POLYGON(Triangle2, <span class="dv">4</span>, CONVEX, i<span class="dv">+15</span>, j);
     }
  }
  <span class="kw">for</span> (j=<span class="dv">100</span>; j&lt;=<span class="dv">170</span>; j+=<span class="dv">20</span>) {
     <span class="co">/* Do a row of pointing-right triangles */</span>
     <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">290</span>; i += <span class="dv">20</span>) {
        DRAW_POLYGON(Triangle3, <span class="dv">40</span>, CONVEX, i, j);
     }
     <span class="co">/* Do a row of pointing-left triangles halfway between one row</span>
<span class="co">        of pointing-right triangles and the next, to fit between */</span>
     <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">290</span>; i += <span class="dv">20</span>) {
        DRAW_POLYGON(Triangle4, <span class="dv">1</span>, CONVEX, i, j<span class="dv">+10</span>);
     }
  }
  getch();    <span class="co">/* wait for a keypress */</span>

  <span class="co">/* Return to text mode and exit */</span>
  regset.x.ax = <span class="bn">0x0003</span>;
  int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}</code></pre>
<p>Listing 40.4 illustrates several interesting aspects of polygon filling. The first and third polygons drawn illustrate the operation of the odd/even fill rule. The second polygon drawn illustrates how holes can be created in seemingly solid objects; an edge runs from the outside of the rectangle to the inside, the edges comprising the hole are defined, and then the same edge is used to move back to the outside; because the edges join seamlessly, the rectangle appears to form a solid boundary around the hole.</p>
<p>The set of V-shaped polygons drawn by Listing 40.4 demonstrate that polygons sharing common edges meet but do not overlap. This characteristic, which I discussed at length in Chapter 38, is not a trivial matter; it allows polygons to fit together without fear of overlapping or missed pixels. In general, Listing 40.1 guarantees that polygons are filled such that common boundaries and vertices are drawn once and only once. This has the side-effect for any individual polygon of not drawing pixels that lie exactly on the bottom or right boundaries or at vertices that terminate bottom or right boundaries.</p>
<p>By the way, I have not seen polygon boundary filling handled precisely this way elsewhere. The boundary filling approach in Foley and van Dam is similar, but seems to me to not draw all boundary and vertex pixels once and only once.</p>
<section id="more-on-active-edges" class="level4">
<h4><a href="#more-on-active-edges">More on Active Edges</a></h4>
<p>Edges of zero height—horizontal edges and edges defined by two vertices at the same location—never even make it into the GET in Listing 40.1. A polygon edge of zero height can never be an active edge, because it can never intersect a scan line; it can only run along the scan line, and the span it runs along is defined not by that edge but by the edges that connect to its endpoints.</p>
</section>
<section id="performance-considerations" class="level4">
<h4><a href="#performance-considerations">Performance Considerations</a></h4>
<p>How fast is Listing 40.1? When drawing triangles on a 20-MHz 386, it’s less than one-fifth the speed of the fast convex polygon fill code. However, most of that time is spent drawing individual pixels; when Listing 40.2 is replaced with the fast assembly line segment drawing code in Listing 40.5, performance improves by two and one-half times, to about half as fast as the fast convex fill code. Even after conversion to assembly in Listing 40.5, <code>DrawHorizontalLineSeg</code> still takes more than half of the total execution time, and the remaining time is spread out fairly evenly over the various subroutines in Listing 40.1. Consequently, there’s no single place in which it’s possible to greatly improve performance, and the maximum additional improvement that’s possible looks to be a good deal less than two times; for that reason, and because of space limitations, I’m not going to convert the rest of the code to assembly. However, when filling a polygon with a great many edges, and especially one with a great many active edges at one time, relatively more time would be spent traversing the linked lists. In such a case, conversion to assembly (which does a very good job with linked list processing) could pay off reasonably well.</p>
<p><strong>LISTING 40.5 L40-5.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Draws all pixels in the horizontal line segment passed in, from</span>
<span class="co">;  (LeftX,Y) to (RightX,Y), in the specified color in mode 13h, the</span>
<span class="co">;  VGA&#39;s 320x200 256-color mode. No drawing will take place if</span>
<span class="co">;  LeftX &gt; RightX. Tested with TASM</span>
<span class="co">; C near-callable as:</span>
<span class="co">;       void DrawHorizontalLineSeg(Y, LeftX, RightX, Color);</span>

SCREEN_WIDTH    <span class="dt">equ</span>     <span class="dv">320</span>
SCREEN_SEGMENT  <span class="dt">equ</span><span class="bn">     0a000h</span>

Parms   <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup(?)<span class="co">;return address &amp; pushed BP</span>
Y       <span class="dt">dw</span>      ?       <span class="co">;Y coordinate of line segment to draw</span>
LeftX   <span class="dt">dw</span>      ?       <span class="co">;left endpoint of the line segment</span>
RightX  <span class="dt">dw</span>      ?       <span class="co">;right endpoint of the line segment</span>
Color   <span class="dt">dw</span>      ?       <span class="co">;color in which to draw the line segment</span>
Parms   ends

       .model small
       .code
       public _DrawHorizontalLineSeg
       <span class="kw">align</span>   <span class="dv">2</span>
_DrawHorizontalLineSeg  proc
       <span class="kw">push</span>    <span class="kw">bp</span>              <span class="co">;preserve caller&#39;s stack frame</span>
       <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>           <span class="co">;point to our stack frame</span>
       <span class="kw">push</span>    <span class="kw">di</span>              <span class="co">;preserve caller&#39;s register variable</span>
       <span class="kw">cld</span>                     <span class="co">;make string instructions inc pointers</span>
       <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEGMENT
       <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>           <span class="co">;point ES to display memory</span>
       <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+LeftX]
       <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+RightX]
       <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">di</span>           <span class="co">;width of line</span>
       <span class="kw">jl</span>      DrawDone        <span class="co">;RightX &lt; LeftX; no drawing to do</span>
       <span class="kw">inc</span>     <span class="kw">cx</span>              <span class="co">;include both endpoints</span>
       <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_WIDTH
       <span class="kw">mul</span>     [<span class="kw">bp</span>+Y]          <span class="co">;offset of scan line on which to draw</span>
       <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>           <span class="co">;ES:DI points to start of line seg</span>
       <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Color] <span class="co">;color in which to draw</span>
       <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">al</span>           <span class="co">;put color in AH for STOSW</span>
       <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>            <span class="co">;# of words to fill</span>
       rep     <span class="kw">stosw</span>           <span class="co">;fill a word at a time</span>
       <span class="kw">adc</span>     <span class="kw">cx</span>,<span class="kw">cx</span>
       rep     <span class="kw">stosb</span>           <span class="co">;draw the odd byte, if any</span>
<span class="fu">DrawDone:</span>
       <span class="kw">pop</span>     <span class="kw">di</span>              <span class="co">;restore caller&#39;s register variable</span>
       <span class="kw">pop</span>     <span class="kw">bp</span>              <span class="co">;restore caller&#39;s stack frame</span>
       <span class="kw">ret</span>
_DrawHorizontalLineSeg  endp
       end</code></pre>
<p>The algorithm used to X-sort the AET is an interesting performance consideration. Listing 40.1 uses a bubble sort, usually a poor choice for performance. However, bubble sorts perform well when the data are already almost sorted, and because of the X coherence of edges from one scan line to the next, that’s generally the case with the AET. An insertion sort might be somewhat faster, depending on the state of the AET when any particular sort occurs, but a bubble sort will generally do just fine.</p>
<p>An insertion sort that scans backward through the AET from the current edge rather than forward from the start of the AET could be quite a bit faster, because edges rarely move more than one or two positions through the AET. However, scanning backward requires a doubly linked list, rather than the singly linked list used in Listing 40.1. I’ve chosen to use a singly linked list partly to minimize memory requirements (double-linking requires an extra pointer field) and partly because supporting back links would complicate the code a good bit. The main reason, though, is that the potential rewards for the complications of back links and insertion sorting aren’t great enough; profiling a variety of polygons reveals that less than ten percent of total time is spent sorting the AET.</p>
<blockquote>
<p><img src="images/i.jpg" /> The potential 1 to 5 percent speedup gained by optimizing AET sorting just isn’t worth it in any but the most demanding application—a good example of the need to keep an overall perspective when comparing the theoretical characteristics of various approaches.</p>
</blockquote>
</section>
</section>
<section id="nonconvex-polygons" class="level3">
<h3><a href="#nonconvex-polygons">Nonconvex Polygons</a></h3>
<p>Nonconvex polygons can be filled somewhat faster than complex polygons. Because edges never cross or switch positions with other edges once they’re in the AET, the AET for a nonconvex polygon needs to be sorted only when new edges are added. In order for this to work, though, edges must be added to the AET in strict left-to-right order. Complications arise when dealing with two edges that start at the same point, because slopes must be compared to determine which edge is leftmost. This is certainly doable, but because of space limitations and limited performance returns, I haven’t implemented this in Listing 40.1.</p>
<section id="details-details" class="level4">
<h4><a href="#details-details">Details, Details</a></h4>
<p>Every so often, a programming demon that I’d thought I’d forever laid to rest arises to haunt me once again. A minor example of this—an imp, if you will—is the use of &quot; = &quot; when I mean &quot; == ,&quot; which I’ve done all too often in the past, and am sure I’ll do again. That’s minor deviltry, though, compared to the considerably greater evils of one of my personal scourges, of which I was recently reminded anew: too-close attention to detail. Not seeing the forest for the trees. Looking low when I should have looked high. Missing the big picture, if you catch my drift.</p>
<p>Thoreau said it best: “Our life is frittered away by detail….Simplify, simplify.” That quote sprang to mind when I received a letter a while back from Anton Treuenfels of Fridley, Minnesota, thanking me for clarifying the principles of filling adjacent convex polygons in my ongoing writings on graphics programming. (You’ll find this material in the previous two chapters.) Anton then went on to describe his own method for filling convex polygons.</p>
<p>Anton’s approach had its virtues and drawbacks, foremost among the virtues being a simplicity Thoreau would have admired. For instance, in writing my polygon-filling code, I had spent quite some time trying to figure out the best way to identify which edge was the left edge and which the right, finally settling on comparing the slopes of the edges if the top of the polygon wasn’t flat, and comparing the starting points of the edges if the top was flat. Anton simplified this tremendously by not bothering to figure out ahead of time which was the right edge of the polygon and which the left, instead scanning out the two edges in whatever order he found them and letting the low-level drawing code test, and if necessary swap, the endpoints of each horizontal line of the fill, so that filling started at the leftmost edge. This is a little slower than my approach (although the difference is almost surely negligible), but it also makes quite a bit of code go away.</p>
<p>What that example, and others like it in Anton’s letter, did was kick my mind into a mode that it hadn’t—but should have—been in when I wrote the code, a mode in which I began to wonder, “How else can I simplify this code?”; what you might call Occam’s Razor mode. You see, I created the convex polygon-drawing code by first writing pseudocode, then writing C code, and finally writing assembly code, and once the pseudocode was finished, I stopped thinking about the interactions of the various portions of the program.</p>
<p>In other words, I became so absorbed in individual details that I forgot to consider the code as a whole. That was a mistake, and an embarrassing one for someone who constantly preaches that programmers should look at their code from a variety of perspectives; the next chapter shows just how much difference thinking about the big picture can make. May my embarrassment be your enlightenment.</p>
<p>The point is not whether, in the final analysis, my code or Anton’s code is better; both have their advantages. The point is that I was programming with half a deck because I was so fixated on the details of a single type of implementation; I ended up with relatively hard-to-write, complex code, and missed out on many potentially useful optimizations by being so focused. It’s a big world out there, and there are many subtle approaches to any problem, so relax and keep the big picture in mind as you implement your programs. Your code will likely be not only better, but also simpler. And whenever you see me walking across hot coals in this book or elsewhere when there’s an easier way to go, please, let me know!</p>
<p>Thanks, Anton.</p>
</section>
</section>
</section>
<section id="chapter-41-those-way-down-polygon-nomenclature-blues" class="level2">
<h2><a href="#chapter-41-those-way-down-polygon-nomenclature-blues">Chapter 41 – Those Way-Down Polygon Nomenclature Blues</a></h2>
<section id="names-do-matter-when-you-conceptualize-a-data-structure" class="level3">
<h3><a href="#names-do-matter-when-you-conceptualize-a-data-structure">Names Do Matter when You Conceptualize a Data Structure</a></h3>
<p>After I wrote the columns on polygons in <em>Dr. Dobb’s Journal</em> that became Chapters 38-40, long-time reader Bill Huber wrote to take me to task—and a well-deserved kick in the fanny it was, I might add—for my use of non-standard polygon terminology in those columns. Unix’s X-Window System (XWS) defines three categories of polygons: complex, nonconvex, and convex. These three categories, each a specialized subset of the preceding category, not-so-coincidentally map quite nicely to three increasingly fast polygon filling techniques. Therefore, I used the XWS names to describe the sorts of polygons that can be drawn with each of the polygon filling techniques.</p>
<p>The problem is that those names don’t accurately describe all the sorts of polygons that the techniques are capable of drawing. Convex polygons are those for which no interior angle is greater than 180 degrees. The “convex” drawing approach described in the previous few chapters actually handles a number of polygons that are not convex; in fact, it can draw any polygon through which no horizontal line can be drawn that intersects the boundary more than twice. (In other words, the boundary reverses the Y direction exactly twice, disregarding polygons that have degenerated into horizontal lines, which I’m going to ignore.)</p>
<p>Bill was kind enough to send me the pages out of <em>Computational Geometry, An Introduction</em> (Springer-Verlag, 1988) that describe the correct terminology; such polygons are, in fact, “monotone with respect to a vertical line” (which unfortunately makes a rather long <code>#define</code> variable). Actually, to be a tad more precise, I’d call them “monotone with respect to a vertical line and simple,” where “simple” means “not self-intersecting.” Similarly, the polygon type I called “nonconvex” is actually “simple,” and I suppose what I called “complex” should be referred to as “nonsimple,” or maybe just “none of the above.”</p>
<blockquote>
<p><img src="images/i.jpg" /> This may seem like nit-picking, but actually, it isn’t; what it’s really about is the tremendous importance of having a shared language. In one of his books, Richard Feynman describes having developed his own mathematical framework, complete with his own notation and terminology, in high school. When he got to college and started working with other people who were at his level, he suddenly understood that people can’t share ideas effectively unless they speak the same language; otherwise, they waste a great deal of time on misunderstandings and explanation.</p>
</blockquote>
<p>Or, as Bill Huber put it, “You are free to adopt your own terminology when it suits your purposes well. But you risk losing or confusing those who could be among your most astute readers—those who already have been trained in the same or a related field.” Ditto. Likewise. <em>D’accord</em>. And <em>mea culpa</em> ; I shall endeavor to watch my language in the future.</p>
</section>
<section id="nomenclature-in-action" class="level3">
<h3><a href="#nomenclature-in-action">Nomenclature in Action</a></h3>
<p>Just to show you how much difference proper description and interchange of ideas can make, consider the case of identifying convex polygons. When I was writing about polygons in my column in <em>DDJ</em>, a nonfunctional method for identifying such polygons—checking for exactly two X direction changes and two Y direction changes around the perimeter of the polygon—crept into the column by accident. That method, as I noted in a later column, does not work. (That’s why you won’t find it in this book.) Still, a fast method of checking for convex polygons would be highly desirable, because such polygons can be drawn with the fast code from Chapter 39, rather than the relatively slow, general-purpose code from Chapter 40.</p>
<p>Now consider Bill’s point that we’re not limited to drawing convex polygons in our “convex fill” code, but can actually handle any simple polygon that’s monotone with respect to a vertical line. Additionally, consider Anton Treuenfels’s point, made back in Chapter 40, that life gets simpler if we stop worrying about which edge of a polygon is the left edge and which is the right, and instead just scan out each raster line starting at whichever edge is left-most. Now, what do we have?</p>
<p>What we have is an approach passed along by Jim Kent, of Autodesk Animator fame. If we modify the low-level code to check which edge is left-most on each scan line and start drawing there, as just described, then we can handle any polygon that’s monotone with respect to a vertical line regardless of whether the edges cross. (I’ll call this “monotone-vertical” from now on; if anyone wants to correct that terminology, jump right in.) In other words, we can then handle nonsimple polygons that are monotone-vertical; self-intersection is no longer a problem. We just scan around the polygon’s perimeter looking for exactly two direction reversals along the Y axis only, and if that proves to be the case, we can handle the polygon at high speed. Figure 41.1 shows polygons that can be drawn by a monotone-vertical capable filler; Figure 41.2 shows some that cannot. Listing 41.1 shows code to test whether a polygon is appropriately monotone.</p>
<p><strong>LISTING 41.1 L41-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Returns 1 if polygon described by passed-in vertex list is monotone with</span>
<span class="co">respect to a vertical line, 0 otherwise. Doesn&#39;t matter if polygon is simple </span>
<span class="co">(non-self-intersecting) or not. Tested with Borland C++ in small model. */</span>

<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="ot">#define SIGNUM(a) ((a&gt;0)?1:((a&lt;0)?-1:0))</span>

<span class="dt">int</span> PolygonIsMonotoneVertical(<span class="kw">struct</span> PointListHeader * VertexList)
{
   <span class="dt">int</span> i, Length, DeltaYSign, PreviousDeltaYSign;
   <span class="dt">int</span> NumYReversals = <span class="dv">0</span>;
   <span class="kw">struct</span> Point *VertexPtr = VertexList-&gt;PointPtr;

   <span class="co">/* Three or fewer points can&#39;t make a non-vertical-monotone polygon */</span>
   <span class="kw">if</span> ((Length=VertexList-&gt;Length) &lt; <span class="dv">4</span>) <span class="kw">return</span>(<span class="dv">1</span>);

   <span class="co">/* Scan to the first non-horizontal edge */</span>
   PreviousDeltaYSign = SIGNUM(VertexPtr[Length<span class="dv">-1</span>].Y - VertexPtr[<span class="dv">0</span>].Y);
   i = <span class="dv">0</span>;
   <span class="kw">while</span> ((PreviousDeltaYSign == <span class="dv">0</span>) &amp;&amp; (i &lt; (Length<span class="dv">-1</span>))) {
      PreviousDeltaYSign = SIGNUM(VertexPtr[i].Y - VertexPtr[i<span class="dv">+1</span>].Y);
      i++;
   }

   <span class="kw">if</span> (i == (Length<span class="dv">-1</span>)) <span class="kw">return</span>(<span class="dv">1</span>);  <span class="co">/* polygon is a flat line */</span>

   <span class="co">/* Now count Y reversals. Might miss one reversal, at the last vertex, but </span>
<span class="co">      because reversal counts must be even, being off by one isn&#39;t a problem */</span>
   <span class="kw">do</span> {
      <span class="kw">if</span> ((DeltaYSign = SIGNUM(VertexPtr[i].Y - VertexPtr[i<span class="dv">+1</span>].Y))
            != <span class="dv">0</span>) {
         <span class="kw">if</span> (DeltaYSign != PreviousDeltaYSign) {
            <span class="co">/* Switched Y direction; not vertical-monotone if</span>
<span class="co">               reversed Y direction as many as three times */</span>
            <span class="kw">if</span> (++NumYReversals &gt; <span class="dv">2</span>) <span class="kw">return</span>(<span class="dv">0</span>);
            PreviousDeltaYSign = DeltaYSign;
         }
      }
   } <span class="kw">while</span> (i++ &lt; (Length<span class="dv">-1</span>));
   <span class="kw">return</span>(<span class="dv">1</span>);  <span class="co">/* it&#39;s a vertical-monotone polygon */</span>
}</code></pre>
<p>Listings 41.2 and 41.3 are variants of the fast convex polygon fill code from Chapter 39, modified to be able to handle all monotone-vertical polygons, including nonsimple ones; the edge-scanning code (Listing 39.4 from Chapter 39) remains the same, and so is not shown again here.</p>
<figure>
<img src="images/41-01.jpg" alt="Figure 41.1  Monotone-vertical polygons." /><figcaption><strong>Figure 41.1</strong>  <em>Monotone-vertical polygons.</em></figcaption>
</figure>
<figure>
<img src="images/41-02.jpg" alt="Figure 41.2  Non-monotone-vertical polygons." /><figcaption><strong>Figure 41.2</strong>  <em>Non-monotone-vertical polygons.</em></figcaption>
</figure>
<p><strong>LISTING 41.2 L41-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Color-fills a convex polygon. All vertices are offset by (XOffset, YOffset).</span>
<span class="co">&quot;Convex&quot; means &quot;monotone with respect to a vertical line&quot;; that is, every </span>
<span class="co">horizontal line drawn through the polygon at any point would cross exactly two </span>
<span class="co">active edges (neither horizontal lines nor zero-length edges count as active </span>
<span class="co">edges; both are acceptable anywhere in the polygon). Right &amp; left edges may </span>
<span class="co">cross (polygons may be nonsimple). Polygons that are not convex according to </span>
<span class="co">this definition won&#39;t be drawn properly. (Yes, &quot;convex&quot; is a lousy name for </span>
<span class="co">this type of polygon, but it&#39;s convenient; use &quot;monotone-vertical&quot; if it makes </span>
<span class="co">you happier!)</span>
<span class="co">*******************************************************************</span>
<span class="co">NOTE: the low-level drawing routine, DrawHorizontalLineList, must be able to</span>
<span class="co">reverse the edges, if necessary to make the correct edge left edge. It must </span>
<span class="co">also expect right edge to be specified in +1 format (the X coordinate is 1 past</span>
<span class="co">highest coordinate to draw). In both respects, this differs from low-level </span>
<span class="co">drawing routines presented in earlier columns; changes are necessary to make it</span>
<span class="co">possible to draw nonsimple monotone-vertical polygons; that in turn makes it </span>
<span class="co">possible to use Jim Kent&#39;s test for monotone-vertical polygons.</span>
<span class="co">*******************************************************************</span>
<span class="co">Returns 1 for success, 0 if memory allocation failed */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="co">/* Advances the index by one vertex forward through the vertex list,</span>
<span class="co">wrapping at the end of the list */</span>
<span class="ot">#define INDEX_FORWARD(Index) \</span>
   Index = (Index + <span class="dv">1</span>) % VertexList-&gt;Length;

<span class="co">/* Advances the index by one vertex backward through the vertex list,</span>
<span class="co">wrapping at the start of the list */</span>
<span class="ot">#define INDEX_BACKWARD(Index) \</span>
   Index = (Index - <span class="dv">1</span> + VertexList-&gt;Length) % VertexList-&gt;Length;

<span class="co">/* Advances the index by one vertex either forward or backward through</span>
<span class="co">the vertex list, wrapping at either end of the list */</span>
<span class="ot">#define INDEX_MOVE(Index,Direction)                                  \</span>
   <span class="kw">if</span> (Direction &gt; <span class="dv">0</span>)                                                \
      Index = (Index + <span class="dv">1</span>) % VertexList-&gt;Length;                      \
   <span class="kw">else</span>                                                              \
      Index = (Index - <span class="dv">1</span> + VertexList-&gt;Length) % VertexList-&gt;Length;

<span class="kw">extern</span> <span class="dt">void</span> ScanEdge(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="kw">struct</span> HLine **);
<span class="kw">extern</span> <span class="dt">void</span> DrawHorizontalLineList(<span class="kw">struct</span> HLineList *, <span class="dt">int</span>);

<span class="dt">int</span> FillMonotoneVerticalPolygon(<span class="kw">struct</span> PointListHeader * VertexList,
      <span class="dt">int</span> Color, <span class="dt">int</span> XOffset, <span class="dt">int</span> YOffset)
{
   <span class="dt">int</span> i, MinIndex, MaxIndex, MinPoint_Y, MaxPoint_Y;
   <span class="dt">int</span> NextIndex, CurrentIndex, PreviousIndex;
   <span class="kw">struct</span> HLineList WorkingHLineList;
   <span class="kw">struct</span> HLine *EdgePointPtr;
   <span class="kw">struct</span> Point *VertexPtr;

   <span class="co">/* Point to the vertex list */</span>
   VertexPtr = VertexList-&gt;PointPtr;

   <span class="co">/* Scan the list to find the top and bottom of the polygon */</span>
   <span class="kw">if</span> (VertexList-&gt;Length == <span class="dv">0</span>)
      <span class="kw">return</span>(<span class="dv">1</span>);  <span class="co">/* reject null polygons */</span>
   MaxPoint_Y = MinPoint_Y = VertexPtr[MinIndex = MaxIndex = <span class="dv">0</span>].Y;
   <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt; VertexList-&gt;Length; i++) {
      <span class="kw">if</span> (VertexPtr[i].Y &lt; MinPoint_Y)
         MinPoint_Y = VertexPtr[MinIndex = i].Y; <span class="co">/* new top */</span>
      <span class="kw">else</span> <span class="kw">if</span> (VertexPtr[i].Y &gt; MaxPoint_Y)
         MaxPoint_Y = VertexPtr[MaxIndex = i].Y; <span class="co">/* new bottom */</span>
   }

   <span class="co">/* Set the # of scan lines in the polygon, skipping the bottom edge */</span>
   <span class="kw">if</span> ((WorkingHLineList.Length = MaxPoint_Y - MinPoint_Y) &lt;= <span class="dv">0</span>)
      <span class="kw">return</span>(<span class="dv">1</span>);  <span class="co">/* there&#39;s nothing to draw, so we&#39;re done */</span>
   WorkingHLineList.YStart = YOffset + MinPoint_Y;

   <span class="co">/* Get memory in which to store the line list we generate */</span>
   <span class="kw">if</span> ((WorkingHLineList.HLinePtr =
         (<span class="kw">struct</span> HLine *) (malloc(<span class="kw">sizeof</span>(<span class="kw">struct</span> HLine) *
         WorkingHLineList.Length))) == NULL)
      <span class="kw">return</span>(<span class="dv">0</span>);  <span class="co">/* couldn&#39;t get memory for the line list */</span>

   <span class="co">/* Scan the first edge and store the boundary points in the list */</span>
   <span class="co">/* Initial pointer for storing scan converted first-edge coords */</span>
   EdgePointPtr = WorkingHLineList.HLinePtr;
   <span class="co">/* Start from the top of the first edge */</span>
   PreviousIndex = CurrentIndex = MinIndex;
   <span class="co">/* Scan convert each line in the first edge from top to bottom */</span>
   <span class="kw">do</span> {
      INDEX_BACKWARD(CurrentIndex);
      ScanEdge(VertexPtr[PreviousIndex].X + XOffset,
            VertexPtr[PreviousIndex].Y,
            VertexPtr[CurrentIndex].X + XOffset,
            VertexPtr[CurrentIndex].Y, <span class="dv">1</span>, <span class="dv">0</span>, &amp;EdgePointPtr);
      PreviousIndex = CurrentIndex;
   } <span class="kw">while</span> (CurrentIndex != MaxIndex);

   <span class="co">/* Scan the second edge and store the boundary points in the list */</span>
   EdgePointPtr = WorkingHLineList.HLinePtr;
   PreviousIndex = CurrentIndex = MinIndex;
   <span class="co">/* Scan convert the second edge, top to bottom */</span>
   <span class="kw">do</span> {
      INDEX_FORWARD(CurrentIndex);
      ScanEdge(VertexPtr[PreviousIndex].X + XOffset,
            VertexPtr[PreviousIndex].Y,
            VertexPtr[CurrentIndex].X + XOffset,
            VertexPtr[CurrentIndex].Y, <span class="dv">0</span>, <span class="dv">0</span>, &amp;EdgePointPtr);
      PreviousIndex = CurrentIndex;
   } <span class="kw">while</span> (CurrentIndex != MaxIndex);

   <span class="co">/* Draw the line list representing the scan converted polygon */</span>
   DrawHorizontalLineList(&amp;WorkingHLineList, Color);

   <span class="co">/* Release the line list&#39;s memory and we&#39;re successfully done */</span>
   free(WorkingHLineList.HLinePtr);
   <span class="kw">return</span>(<span class="dv">1</span>);
}</code></pre>
<p><strong>LISTING 41.3 L41-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Draws all pixels in list of horizontal lines passed in, in mode 13h, VGA&#39;s </span>
<span class="co">; 320x200 256-color mode. Uses REP STOS to fill each line.</span>
<span class="co">; ******************************************************************</span>
<span class="co">; NOTE: is able to reverse the X coords for a scan line, if necessary, to make </span>
<span class="co">; XStart &lt; XEnd. Expects whichever edge is rightmost on any scan line to be in</span>
<span class="co">; +1 format; that is, XEnd is 1 greater than rightmost pixel to draw. If </span>
<span class="co">; XStart == XEnd, nothing is drawn on that scan line.</span>
<span class="co">; ******************************************************************</span>
<span class="co">; C near-callable as:</span>
<span class="co">;     void DrawHorizontalLineList(struct HLineList * HLineListPtr, int Color);</span>
<span class="co">; All assembly code tested with TASM and MASM</span>

SCREEN_WIDTH    <span class="dt">equ</span>     <span class="dv">320</span>
SCREEN_SEGMENT  <span class="dt">equ</span><span class="bn">     0a000h</span>

HLine   <span class="kw">struc</span>
XStart  <span class="dt">dw</span>      ?       <span class="co">;X coordinate of leftmost pixel in line</span>
XEnd    <span class="dt">dw</span>      ?       <span class="co">;X coordinate of rightmost pixel in line</span>
HLine   ends

HLineList <span class="kw">struc</span>
Lngth    <span class="dt">dw</span>      ?      <span class="co">;# of horizontal lines</span>
YStart   <span class="dt">dw</span>      ?      <span class="co">;Y coordinate of topmost line</span>
HLinePtr <span class="dt">dw</span>      ?       <span class="co">;pointer to list of horz lines</span>
HLineList ends

Parms   <span class="kw">struc</span>
                <span class="dt">dw</span>      <span class="dv">2</span> dup(?) <span class="co">;return address &amp; pushed BP</span>
HLineListPtr    <span class="dt">dw</span>      ?       <span class="co">;pointer to HLineList structure</span>
Color           <span class="dt">dw</span>      ?       <span class="co">;color with which to fill</span>
Parms   ends
        .model small
        .code
        public _DrawHorizontalLineList
        <span class="kw">align</span>   <span class="dv">2</span>
_DrawHorizontalLineList proc
        <span class="kw">push</span>    <span class="kw">bp</span>              <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>           <span class="co">;point to our stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>              <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">cld</span>                     <span class="co">;make string instructions inc pointers</span>

        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>   <span class="co">;point ES to display memory for REP STOS</span>

        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+HLineListPtr] <span class="co">;point to the line list</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_WIDTH <span class="co">;point to the start of the first scan</span>
        <span class="kw">mul</span>     [<span class="kw">si</span>+YStart]     <span class="co">; line in which to draw</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="kw">ax</span>           <span class="co">;ES:DX points to first scan line to draw</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">si</span>+HLinePtr] <span class="co">;point to the XStart/XEnd descriptor</span>
                                <span class="co">; for the first (top) horizontal line</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">si</span>+Lngth]   <span class="co">;# of scan lines to draw</span>
        <span class="kw">and</span>     <span class="kw">si</span>,<span class="kw">si</span>           <span class="co">;are there any lines to draw?</span>
        <span class="kw">jz</span>      FillDone        <span class="co">;no, so we&#39;re done</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Color] <span class="co">;color with which to fill</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">al</span>           <span class="co">;duplicate color for STOSW</span>
<span class="fu">FillLoop:</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bx</span>+XStart]  <span class="co">;left edge of fill on this line</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bx</span>+XEnd]    <span class="co">;right edge of fill</span>
        <span class="kw">cmp</span>     <span class="kw">di</span>,<span class="kw">cx</span>           <span class="co">;is XStart &gt; XEnd?</span>
        <span class="kw">jle</span>     NoSwap          <span class="co">;no, we&#39;re all set</span>
        <span class="kw">xchg</span>    <span class="kw">di</span>,<span class="kw">cx</span>           <span class="co">;yes, so swap edges</span>
<span class="fu">NoSwap:</span>
        <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">di</span>           <span class="co">;width of fill on this line</span>
        <span class="kw">jz</span>      LineFillDone    <span class="co">;skip if zero width</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">dx</span>           <span class="co">;offset of left edge of fill</span>
        <span class="kw">test</span>    <span class="kw">di</span>,<span class="dv">1</span>            <span class="co">;does fill start at an odd address?</span>
        <span class="kw">jz</span>      MainFill        <span class="co">;no</span>
        <span class="kw">stosb</span>                   <span class="co">;yes, draw the odd leading byte to</span>
                                <span class="co">; word-align the rest of the fill</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>              <span class="co">;count off the odd leading byte</span>
        <span class="kw">jz</span>      LineFillDone    <span class="co">;done if that was the only byte</span>
<span class="fu">MainFill:</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>            <span class="co">;# of words in fill</span>
        rep     <span class="kw">stosw</span>           <span class="co">;fill as many words as possible</span>
        <span class="kw">adc</span>     <span class="kw">cx</span>,<span class="kw">cx</span>           <span class="co">;1 if there&#39;s an odd trailing byte to</span>
                                <span class="co">; do, 0 otherwise</span>
        rep     <span class="kw">stosb</span>           <span class="co">;fill any odd trailing byte</span>
<span class="fu">LineFillDone:</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,size HLine   <span class="co">;point to the next line descriptor</span>
        <span class="kw">add</span>     <span class="kw">dx</span>,SCREEN_WIDTH <span class="co">;point to the next scan line</span>
        <span class="kw">dec</span>     <span class="kw">si</span>              <span class="co">;count off lines to fill</span>
        <span class="kw">jnz</span>     FillLoop
<span class="fu">FillDone:</span>
        <span class="kw">pop</span>     <span class="kw">di</span>              <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>              <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_DrawHorizontalLineList endp
        end</code></pre>
<p>Listing 41.4 is almost identical to Listing 40.1 from Chapter 40. I’ve modified Listing 40.1 to employ the vertical-monotone detection test we’ve been talking about and use the fast vertical-monotone drawing code whenever possible; that’s what Listing 41.4 is. Note well that Listing 40.5 from Chapter 40 is also required in order for this code to link. Listing 41.5 is an appropriately updated version of the POLYGON.H header file.</p>
<p><strong>LISTING 41.4 L41-4.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Color-fills an arbitrarily-shaped polygon described by VertexList.</span>
<span class="co">If the first and last points in VertexList are not the same, the path</span>
<span class="co">around the polygon is automatically closed. All vertices are offset</span>
<span class="co">by (XOffset, YOffset). Returns 1 for success, 0 if memory allocation</span>
<span class="co">failed. All C code tested with Borland C++.</span>

<span class="co">If the polygon shape is known in advance, speedier processing may be</span>
<span class="co">enabled by specifying the shape as follows: &quot;convex&quot; - a rubber band</span>
<span class="co">stretched around the polygon would touch every vertex in order;</span>
<span class="co">&quot;nonconvex&quot; - the polygon is not self-intersecting, but need not be</span>
<span class="co">convex; &quot;complex&quot; - the polygon may be self-intersecting, or, indeed,</span>
<span class="co">any sort of polygon at all. Complex will work for all polygons; convex</span>
<span class="co">is fastest. Undefined results will occur if convex is specified for a</span>
<span class="co">nonconvex or complex polygon.</span>

<span class="co">Define CONVEX_CODE_LINKED if the fast convex polygon filling code from</span>
<span class="co">the February 1991 column is linked in. Otherwise, convex polygons are</span>
<span class="co">handled by the complex polygon filling code.</span>
<span class="co">Nonconvex is handled as complex in this implementation. See text for a</span>
<span class="co">discussion of faster nonconvex handling. */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#ifdef __TURBOC__</span>
<span class="ot">#include &lt;alloc.h&gt;</span>
<span class="ot">#else    </span><span class="co">/* MSC */</span>
<span class="ot">#include &lt;malloc.h&gt;</span>
<span class="ot">#endif</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="ot">#define SWAP(a,b) {temp = a; a = b; b = temp;}</span>

<span class="kw">struct</span> EdgeState {
   <span class="kw">struct</span> EdgeState *NextEdge;
   <span class="dt">int</span> X;
   <span class="dt">int</span> StartY;
   <span class="dt">int</span> WholePixelXMove;
   <span class="dt">int</span> XDirection;
   <span class="dt">int</span> ErrorTerm;
   <span class="dt">int</span> ErrorTermAdjUp;
   <span class="dt">int</span> ErrorTermAdjDown;
   <span class="dt">int</span> Count;
};

<span class="kw">extern</span> <span class="dt">void</span> DrawHorizontalLineSeg(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">int</span> FillMonotoneVerticalPolygon(<span class="kw">struct</span> PointListHeader *,
   <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">int</span> PolygonIsMonotoneVertical(<span class="kw">struct</span> PointListHeader *);
<span class="dt">static</span> <span class="dt">void</span> BuildGET(<span class="kw">struct</span> PointListHeader *, <span class="kw">struct</span> EdgeState *,
   <span class="dt">int</span>, <span class="dt">int</span>);
<span class="dt">static</span> <span class="dt">void</span> MoveXSortedToAET(<span class="dt">int</span>);
<span class="dt">static</span> <span class="dt">void</span> ScanOutAET(<span class="dt">int</span>, <span class="dt">int</span>);
<span class="dt">static</span> <span class="dt">void</span> AdvanceAET(<span class="dt">void</span>);
<span class="dt">static</span> <span class="dt">void</span> XSortAET(<span class="dt">void</span>);

<span class="co">/* Pointers to global edge table (GET) and active edge table (AET) */</span>
<span class="dt">static</span> <span class="kw">struct</span> EdgeState *GETPtr, *AETPtr;

<span class="dt">int</span> FillPolygon(<span class="kw">struct</span> PointListHeader * VertexList, <span class="dt">int</span> Color,
      <span class="dt">int</span> PolygonShape, <span class="dt">int</span> XOffset, <span class="dt">int</span> YOffset)
{
   <span class="kw">struct</span> EdgeState *EdgeTableBuffer;
   <span class="dt">int</span> CurrentY;

<span class="ot">#ifdef CONVEX_CODE_LINKED</span>
   <span class="co">/* Pass convex polygons through to fast convex polygon filler */</span>
   <span class="kw">if</span> ((PolygonShape == CONVEX) ||
         PolygonIsMonotoneVertical(VertexList))
      <span class="kw">return</span>(FillMonotoneVerticalPolygon(VertexList, Color, XOffset,
            YOffset));
<span class="ot">#endif</span>

   <span class="co">/* It takes a minimum of 3 vertices to cause any pixels to be</span>
<span class="co">      drawn; reject polygons that are guaranteed to be invisible */</span>
   <span class="kw">if</span> (VertexList-&gt;Length &lt; <span class="dv">3</span>)
      <span class="kw">return</span>(<span class="dv">1</span>);
   <span class="co">/* Get enough memory to store the entire edge table */</span>
   <span class="kw">if</span> ((EdgeTableBuffer =
         (<span class="kw">struct</span> EdgeState *) (malloc(<span class="kw">sizeof</span>(<span class="kw">struct</span> EdgeState) *
         VertexList-&gt;Length))) == NULL)
      <span class="kw">return</span>(<span class="dv">0</span>);  <span class="co">/* couldn&#39;t get memory for the edge table */</span>
   <span class="co">/* Build the global edge table */</span>
   BuildGET(VertexList, EdgeTableBuffer, XOffset, YOffset);
   <span class="co">/* Scan down through the polygon edges, one scan line at a time,</span>
<span class="co">      so long as at least one edge remains in either the GET or AET */</span>
   AETPtr = NULL;    <span class="co">/* initialize the active edge table to empty */</span>
   CurrentY = GETPtr-&gt;StartY; <span class="co">/* start at the top polygon vertex */</span>
   <span class="kw">while</span> ((GETPtr != NULL) || (AETPtr != NULL)) {
      MoveXSortedToAET(CurrentY);  <span class="co">/* update AET for this scan line */</span>
      ScanOutAET(CurrentY, Color); <span class="co">/* draw this scan line from AET */</span>
      AdvanceAET();                <span class="co">/* advance AET edges 1 scan line */</span>
      XSortAET();                  <span class="co">/* resort on X */</span>
      CurrentY++;                  <span class="co">/* advance to the next scan line */</span>
   }
   <span class="co">/* Release the memory we&#39;ve allocated and we&#39;re done */</span>
   free(EdgeTableBuffer);
   <span class="kw">return</span>(<span class="dv">1</span>);
}

<span class="co">/* Creates a GET in the buffer pointed to by NextFreeEdgeStruc from</span>
<span class="co">   the vertex list. Edge endpoints are flipped, if necessary, to</span>
<span class="co">   guarantee all edges go top to bottom. The GET is sorted primarily</span>
<span class="co">   by ascending Y start coordinate, and secondarily by ascending X</span>
<span class="co">   start coordinate within edges with common Y coordinates. */</span>
<span class="dt">static</span> <span class="dt">void</span> BuildGET(<span class="kw">struct</span> PointListHeader * VertexList,
      <span class="kw">struct</span> EdgeState * NextFreeEdgeStruc, <span class="dt">int</span> XOffset, <span class="dt">int</span> YOffset)
{
   <span class="dt">int</span> i, StartX, StartY, EndX, EndY, DeltaY, DeltaX, Width, temp;
   <span class="kw">struct</span> EdgeState *NewEdgePtr;
   <span class="kw">struct</span> EdgeState *FollowingEdge, **FollowingEdgeLink;
   <span class="kw">struct</span> Point *VertexPtr;

   <span class="co">/* Scan through the vertex list and put all non-0-height edges into</span>
<span class="co">      the GET, sorted by increasing Y start coordinate */</span>
   VertexPtr = VertexList-&gt;PointPtr;   <span class="co">/* point to the vertex list */</span>
   GETPtr = NULL;    <span class="co">/* initialize the global edge table to empty */</span>
   <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; VertexList-&gt;Length; i++) {
      <span class="co">/* Calculate the edge height and width */</span>
      StartX = VertexPtr[i].X + XOffset;
      StartY = VertexPtr[i].Y + YOffset;
      <span class="co">/* The edge runs from the current point to the previous one */</span>
      <span class="kw">if</span> (i == <span class="dv">0</span>) {
         <span class="co">/* Wrap back around to the end of the list */</span>
         EndX = VertexPtr[VertexList-&gt;Length<span class="dv">-1</span>].X + XOffset;
         EndY = VertexPtr[VertexList-&gt;Length<span class="dv">-1</span>].Y + YOffset;
      } <span class="kw">else</span> {
         EndX = VertexPtr[i<span class="dv">-1</span>].X + XOffset;
         EndY = VertexPtr[i<span class="dv">-1</span>].Y + YOffset;
      }
      <span class="co">/* Make sure the edge runs top to bottom */</span>
      <span class="kw">if</span> (StartY &gt; EndY) {
         SWAP(StartX, EndX);
         SWAP(StartY, EndY);
      }
      <span class="co">/* Skip if this can&#39;t ever be an active edge (has 0 height) */</span>
      <span class="kw">if</span> ((DeltaY = EndY - StartY) != <span class="dv">0</span>) {
         <span class="co">/* Allocate space for this edge&#39;s info, and fill in the</span>
<span class="co">            structure */</span>
         NewEdgePtr = NextFreeEdgeStruc++;
         NewEdgePtr-&gt;XDirection =   <span class="co">/* direction in which X moves */</span>
               ((DeltaX = EndX - StartX) &gt; <span class="dv">0</span>) ? <span class="dv">1</span> : -<span class="dv">1</span>;
         Width = abs(DeltaX);
         NewEdgePtr-&gt;X = StartX;
         NewEdgePtr-&gt;StartY = StartY;
         NewEdgePtr-&gt;Count = DeltaY;
         NewEdgePtr-&gt;ErrorTermAdjDown = DeltaY;
         <span class="kw">if</span> (DeltaX &gt;= <span class="dv">0</span>)  <span class="co">/* initial error term going L-&gt;R */</span>
            NewEdgePtr-&gt;ErrorTerm = <span class="dv">0</span>;
         <span class="kw">else</span>              <span class="co">/* initial error term going R-&gt;L */</span>
            NewEdgePtr-&gt;ErrorTerm = -DeltaY + <span class="dv">1</span>;
         <span class="kw">if</span> (DeltaY &gt;= Width) {     <span class="co">/* Y-major edge */</span>
            NewEdgePtr-&gt;WholePixelXMove = <span class="dv">0</span>;
            NewEdgePtr-&gt;ErrorTermAdjUp = Width;
         } <span class="kw">else</span> {                   <span class="co">/* X-major edge */</span>
            NewEdgePtr-&gt;WholePixelXMove =
                  (Width / DeltaY) * NewEdgePtr-&gt;XDirection;
            NewEdgePtr-&gt;ErrorTermAdjUp = Width % DeltaY;
         }
         <span class="co">/* Link the new edge into the GET so that the edge list is</span>
<span class="co">            still sorted by Y coordinate, and by X coordinate for all</span>
<span class="co">            edges with the same Y coordinate */</span>
         FollowingEdgeLink = &amp;GETPtr;
         <span class="kw">for</span> (;;) {
            FollowingEdge = *FollowingEdgeLink;
            <span class="kw">if</span> ((FollowingEdge == NULL) ||
                  (FollowingEdge-&gt;StartY &gt; StartY) ||
                  ((FollowingEdge-&gt;StartY == StartY) &amp;&amp;
                  (FollowingEdge-&gt;X &gt;= StartX))) {
               NewEdgePtr-&gt;NextEdge = FollowingEdge;
               *FollowingEdgeLink = NewEdgePtr;
               <span class="kw">break</span>;
            }
            FollowingEdgeLink = &amp;FollowingEdge-&gt;NextEdge;
         }
      }
   }
}

<span class="co">/* Sorts all edges currently in the active edge table into ascending</span>
<span class="co">   order of current X coordinates */</span>
<span class="dt">static</span> <span class="dt">void</span> XSortAET() {
   <span class="kw">struct</span> EdgeState *CurrentEdge, **CurrentEdgePtr, *TempEdge;
   <span class="dt">int</span> SwapOccurred;

   <span class="co">/* Scan through the AET and swap any adjacent edges for which the</span>
<span class="co">      second edge is at a lower current X coord than the first edge.</span>
<span class="co">      Repeat until no further swapping is needed */</span>
   <span class="kw">if</span> (AETPtr != NULL) {
      <span class="kw">do</span> {
         SwapOccurred = <span class="dv">0</span>;
         CurrentEdgePtr = &amp;AETPtr;
         <span class="kw">while</span> ((CurrentEdge = *CurrentEdgePtr)-&gt;NextEdge != NULL) {
            <span class="kw">if</span> (CurrentEdge-&gt;X &gt; CurrentEdge-&gt;NextEdge-&gt;X) {
               <span class="co">/* The second edge has a lower X than the first;</span>
<span class="co">                  swap them in the AET */</span>
               TempEdge = CurrentEdge-&gt;NextEdge-&gt;NextEdge;
               *CurrentEdgePtr = CurrentEdge-&gt;NextEdge;
               CurrentEdge-&gt;NextEdge-&gt;NextEdge = CurrentEdge;
               CurrentEdge-&gt;NextEdge = TempEdge;
               SwapOccurred = <span class="dv">1</span>;
            }
            CurrentEdgePtr = &amp;(*CurrentEdgePtr)-&gt;NextEdge;
         }
      } <span class="kw">while</span> (SwapOccurred != <span class="dv">0</span>);
   }
}

<span class="co">/* Advances each edge in the AET by one scan line.</span>
<span class="co">   Removes edges that have been fully scanned. */</span>
<span class="dt">static</span> <span class="dt">void</span> AdvanceAET() {
   <span class="kw">struct</span> EdgeState *CurrentEdge, **CurrentEdgePtr;

   <span class="co">/* Count down and remove or advance each edge in the AET */</span>
   CurrentEdgePtr = &amp;AETPtr;
   <span class="kw">while</span> ((CurrentEdge = *CurrentEdgePtr) != NULL) {
      <span class="co">/* Count off one scan line for this edge */</span>
      <span class="kw">if</span> ((--(CurrentEdge-&gt;Count)) == <span class="dv">0</span>) {
         <span class="co">/* This edge is finished, so remove it from the AET */</span>
         *CurrentEdgePtr = CurrentEdge-&gt;NextEdge;
      } <span class="kw">else</span> {
         <span class="co">/* Advance the edge&#39;s X coordinate by minimum move */</span>
         CurrentEdge-&gt;X += CurrentEdge-&gt;WholePixelXMove;
         <span class="co">/* Determine whether it&#39;s time for X to advance one extra */</span>
         <span class="kw">if</span> ((CurrentEdge-&gt;ErrorTerm +=
               CurrentEdge-&gt;ErrorTermAdjUp) &gt; <span class="dv">0</span>) {
            CurrentEdge-&gt;X += CurrentEdge-&gt;XDirection;
            CurrentEdge-&gt;ErrorTerm -= CurrentEdge-&gt;ErrorTermAdjDown;
         }
         CurrentEdgePtr = &amp;CurrentEdge-&gt;NextEdge;
      }
   }
}

<span class="co">/* Moves all edges that start at the specified Y coordinate from the</span>
<span class="co">   GET to the AET, maintaining the X sorting of the AET. */</span>
<span class="dt">static</span> <span class="dt">void</span> MoveXSortedToAET(<span class="dt">int</span> YToMove) {
   <span class="kw">struct</span> EdgeState *AETEdge, **AETEdgePtr, *TempEdge;
   <span class="dt">int</span> CurrentX;

   <span class="co">/* The GET is Y sorted. Any edges that start at the desired Y</span>
<span class="co">      coordinate will be first in the GET, so we&#39;ll move edges from</span>
<span class="co">      the GET to AET until the first edge left in the GET is no longer</span>
<span class="co">      at the desired Y coordinate. Also, the GET is X sorted within</span>
<span class="co">      each Y coordinate, so each successive edge we add to the AET is</span>
<span class="co">      guaranteed to belong later in the AET than the one just added. */</span>
   AETEdgePtr = &amp;AETPtr;
   <span class="kw">while</span> ((GETPtr != NULL) &amp;&amp; (GETPtr-&gt;StartY == YToMove)) {
      CurrentX = GETPtr-&gt;X;
      <span class="co">/* Link the new edge into the AET so that the AET is still</span>
<span class="co">         sorted by X coordinate */</span>
      <span class="kw">for</span> (;;) {
         AETEdge = *AETEdgePtr;
         <span class="kw">if</span> ((AETEdge == NULL) || (AETEdge-&gt;X &gt;= CurrentX)) {
            TempEdge = GETPtr-&gt;NextEdge;
            *AETEdgePtr = GETPtr;  <span class="co">/* link the edge into the AET */</span>
            GETPtr-&gt;NextEdge = AETEdge;
            AETEdgePtr = &amp;GETPtr-&gt;NextEdge;
            GETPtr = TempEdge;   <span class="co">/* unlink the edge from the GET */</span>
            <span class="kw">break</span>;
         } <span class="kw">else</span> {
            AETEdgePtr = &amp;AETEdge-&gt;NextEdge;
         }
      }
   }
}

<span class="co">/* Fills the scan line described by the current AET at the specified Y</span>
<span class="co">   coordinate in the specified color, using the odd/even fill rule */</span>
<span class="dt">static</span> <span class="dt">void</span> ScanOutAET(<span class="dt">int</span> YToScan, <span class="dt">int</span> Color) {
   <span class="dt">int</span> LeftX;
   <span class="kw">struct</span> EdgeState *CurrentEdge;

   <span class="co">/* Scan through the AET, drawing line segments as each pair of edge</span>
<span class="co">      crossings is encountered. The nearest pixel on or to the right</span>
<span class="co">      of left edges is drawn, and the nearest pixel to the left of but</span>
<span class="co">      not on right edges is drawn */</span>
   CurrentEdge = AETPtr;
   <span class="kw">while</span> (CurrentEdge != NULL) {
      LeftX = CurrentEdge-&gt;X;
      CurrentEdge = CurrentEdge-&gt;NextEdge;
      DrawHorizontalLineSeg(YToScan, LeftX, CurrentEdge-&gt;X<span class="dv">-1</span>, Color);
      CurrentEdge = CurrentEdge-&gt;NextEdge;
   }
}</code></pre>
<p><strong>LISTING 41.5 POLYGON.H</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Header file for polygon-filling code */</span>

<span class="ot">#define CONVEX    0</span>
<span class="ot">#define NONCONVEX 1</span>
<span class="ot">#define COMPLEX   2</span>

<span class="co">/* Describes a single point (used for a single vertex) */</span>
<span class="kw">struct</span> Point {
   <span class="dt">int</span> X;   <span class="co">/* X coordinate */</span>
   <span class="dt">int</span> Y;   <span class="co">/* Y coordinate */</span>
};

<span class="co">/* Describes series of points (used to store a list of vertices that describe </span>
<span class="co">a polygon; each vertex is assumed to connect to the two adjacent vertices, and </span>
<span class="co">last vertex is assumed to connect to the first) */</span>
<span class="kw">struct</span> PointListHeader {
   <span class="dt">int</span> Length;                <span class="co">/* # of points */</span>
   <span class="kw">struct</span> Point * PointPtr;   <span class="co">/* pointer to list of points */</span>
};

<span class="co">/* Describes beginning and ending X coordinates of a single horizontal line */</span>
<span class="kw">struct</span> HLine {
   <span class="dt">int</span> XStart; <span class="co">/* X coordinate of leftmost pixel in line */</span>
   <span class="dt">int</span> XEnd;   <span class="co">/* X coordinate of rightmost pixel in line */</span>
};

<span class="co">/* Describes a Length-long series of horizontal lines, all assumed to be on </span>
<span class="co">contiguous scan lines starting at YStart and proceeding downward (used to </span>
<span class="co">describe scan-converted polygon to low-level hardware-dependent drawing code) */</span>
<span class="kw">struct</span> HLineList {
   <span class="dt">int</span> Length;                <span class="co">/* # of horizontal lines */</span>
   <span class="dt">int</span> YStart;                <span class="co">/* Y coordinate of topmost line */</span>
   <span class="kw">struct</span> HLine * HLinePtr;   <span class="co">/* pointer to list of horz lines */</span>
};

<span class="co">/* Describes a color as an RGB triple, plus one byte for other info */</span>
<span class="kw">struct</span> RGB { <span class="dt">unsigned</span> <span class="dt">char</span> Red, Green, Blue, Spare; };</code></pre>
<p>Is monotone-vertical polygon detection worth all this trouble? Under the right circumstances, you bet. In a situation where a great many polygons are being drawn, and the application either doesn’t know whether they’re monotone-vertical or has no way to tell the polygon filler that they are, performance can be increased considerably if most polygons are, in fact, monotone-vertical. This potential performance advantage is helped along by the surprising fact that Jim’s test for monotone-vertical status is simpler and faster than my original, nonfunctional test for convexity.</p>
<p>See what accurate terminology and effective communication can do?</p>
</section>
</section>
<section id="chapter-42-wued-in-haste-fried-stewed-at-leisure" class="level2">
<h2><a href="#chapter-42-wued-in-haste-fried-stewed-at-leisure">Chapter 42 – Wu’ed in Haste; Fried, Stewed at Leisure</a></h2>
<section id="fast-antialiased-lines-using-wus-algorithm" class="level3">
<h3><a href="#fast-antialiased-lines-using-wus-algorithm">Fast Antialiased Lines Using Wu’s Algorithm</a></h3>
<p>The thought first popped into my head as I unenthusiastically picked through the salad bar at a local “family” restaurant, trying to decide whether the meatballs, the fried clams, or the lasagna was likely to shorten my life the least. I decided on the chicken in mystery sauce.</p>
<p>The thought recurred when my daughter asked, “Dad, is that fried chicken?”</p>
<p>“I don’t think so,” I said. “I think it’s stewed chicken.”</p>
<p>“It looks like fried chicken.”</p>
<p>“Maybe it’s fried, stewed chicken,” my wife volunteered hopefully. I took a bite. It was, indeed, fried, stewed chicken. I can now, unhesitatingly and without reservation, recommend that you avoid fried, stewed chicken at all costs.</p>
<p>The thought I had was as follows: <em>This is not good food</em>. Not a profound thought, but it raises an interesting question: Why was I eating in this restaurant? The answer, to borrow a phrase from E.F. Schumacher, is <em>appropriate technology</em>. For a family on a budget, with a small child, tired of staring at each other over the kitchen table, this was a perfect place to eat. It was cheap, it had greasy food and ice cream, no one cared if children dropped things or talked loudly or walked around, and, most important of all, it wasn’t home. So what if the food was lousy? Good food was a luxury, a bonus; everything on the above list was necessary. A family restaurant was the appropriate dining-out technology, given the parameters within which we had to work.</p>
<p>When I read through SIGGRAPH proceedings and other state-of-the-art computer-graphics material, all too often I feel like I’m dining at a four-star restaurant with two-year-old triplets and an empty wallet. We’re talking incredibly inappropriate technology for PC graphics here. Sure, I say to myself as I read about an antialiasing technique, that sounds wonderful—if I had 24-bpp color, and dedicated hardware to do the processing, and all day to wait to generate one image. Yes, I think, that is a good way to do hidden surface removal—in a system with hardware z-buffering. Most of the stuff in the journal <em>Computer Graphics</em> is riveting, but, alas, pretty much useless on PCs. When an x86 has to do all the work, speed becomes the overriding parameter, especially for real-time graphics.</p>
<p>Literature that’s applicable to fast PC graphics is hard enough to find, but what we’d really like is above-average image quality combined with terrific speed, and there’s almost no literature of that sort around. There is some, however, and you folks are right on top of it. For example, alert reader Michael Chaplin, of San Diego, wrote to suggest that I might enjoy the line-antialiasing algorithm presented in Xiaolin Wu’s article, “An Efficient Antialiasing Technique,” in the July 1991 issue of <em>Computer Graphics</em>. Michael was dead-on right. This is a great algorithm, combining excellent antialiased line quality with speed that’s close to that of non-antialiased Bresenham’s line drawing. This is the sort of algorithm that makes you want to go out and write a wire-frame animation program, just so you can see how good those smooth lines look in motion. Wu antialiasing is a wonderful example of what can be accomplished on inexpensive, mass-market hardware with the proper programming perspective. In short, it’s a splendid example of appropriate technology for PCs.</p>
</section>
<section id="wu-antialiasing" class="level3">
<h3><a href="#wu-antialiasing">Wu Antialiasing</a></h3>
<p>Antialiasing, as we’ve been discussing for the past few chapters, is the process of smoothing lines and edges so that they appear less jagged. Antialiasing is partly an aesthetic issue, because it makes images more attractive. It’s also partly an accuracy issue, because it makes it possible to position and draw images with effectively more precision than the resolution of the display. Finally, it’s partly a flat-out necessity, to avoid the horrible, crawling, jagged edges of temporal aliasing when performing animation.</p>
<p>The basic premise of Wu antialiasing is almost ridiculously simple: As the algorithm steps one pixel unit at a time along the major (longer) axis of a line, it draws the two pixels bracketing the line along the minor axis at each point. Each of the two bracketing pixels is drawn with a weighted fraction of the full intensity of the drawing color, with the weighting for each pixel equal to one minus the pixel’s distance along the minor axis from the ideal line. Yes, it’s a mouthful, but Figure 42.1 illustrates the concept.</p>
<p>The intensities of the two pixels that bracket the line are selected so that they always sum to exactly 1; that is, to the intensity of one fully illuminated pixel of the drawing color. The presence of aggregate full-pixel intensity means that at each step, the line has the same brightness it would have if a single pixel were drawn at precisely the correct location. Moreover, thanks to the distribution of the intensity weighting, that brightness is centered at the ideal line. Not coincidentally, a line drawn with pixel pairs of aggregate single-pixel intensity, centered on the ideal line, is perceived by the eye not as a jagged collection of pixel pairs, but as a smooth line centered on the ideal line. Thus, by weighting the bracketing pixels properly at each step, we can readily produce what looks like a smooth line at precisely the right location, rather than the jagged pattern of line segments that non-antialiased line-drawing algorithms such as Bresenham’s (see Chapters 35, 36, and 37) trace out.</p>
<figure>
<img src="images/42-01.jpg" alt="Figure 42.1  The basic concept of Wu antialiasing." /><figcaption><strong>Figure 42.1</strong>  <em>The basic concept of Wu antialiasing.</em></figcaption>
</figure>
<p>You might expect that the implementation of Wu antialiasing would fall into two distinct areas: tracing out the line (that is, finding the appropriate pixel pairs to draw) and calculating the appropriate weightings for each pixel pair. Not so, however. The weighting calculations involve only a few shifts, XORs, and adds; for all practical purposes, tracing and weighting are rolled into one step—and a very fast step it is. How fast is it? On a 33-MHz 486 with a fast VGA, a good but not maxed-out assembly implementation of Wu antialiasing draws a more than respectable 5,000 150-pixel-long vectors per second. That’s especially impressive considering that about 1,500,000 actual pixels are drawn per second, meaning that Wu antialiasing is drawing at around 50 percent of the maximum memory bandwidth—half the fastest theoretically possible drawing speed—of an AT-bus VGA. In short, Wu antialiasing is about as fast an antialiased line approach as you could ever hope to find for the VGA.</p>
</section>
<section id="tracing-and-intensity-in-one" class="level3">
<h3><a href="#tracing-and-intensity-in-one">Tracing and Intensity in One</a></h3>
<p>Horizontal, vertical, and diagonal lines do not require Wu antialiasing because they pass through the center of every pixel they meet; such lines can be drawn with fast, special-case code. For all other cases, Wu lines are traced out one step at a time along the major axis by means of a simple, fixed-point algorithm. The move along the minor axis with respect to a one-pixel move along the major axis (the line slope for lines with slopes less than 1, 1/slope for lines with slopes greater than 1) is calculated with a single integer divide. This value, called the “error adjust,” is stored as a fixed-point fraction, in 0.16 format (that is, all bits are fractional, and the decimal point is just to the left of bit 15). An error accumulator, also in 0.16 format, is initialized to 0. Then the first pixel is drawn; no weighting is needed, because the line intersects its endpoints exactly.</p>
<p>Now the error adjust is added to the error accumulator. The error accumulator indicates how far between pixels the line has progressed along the minor axis at any given step; when the error accumulator turns over, it’s time to advance one pixel along the minor axis. At each step along the line, the major-axis coordinate advances by one pixel. The two bracketing pixels to draw are simply the two pixels nearest the line along the minor axis. For instance, if X is the current major-axis coordinate and Y is the current minor-axis coordinate, the two pixels to be drawn are (X,Y) and (X,Y+1). In short, the derivation of the pixels at which to draw involves nothing more complicated than advancing one pixel along the major axis, adding the error adjust to the error accumulator, and advancing one pixel along the minor axis when the error accumulator turns over.</p>
<p>So far, nothing special; but now we come to the true wonder of Wu antialiasing. We know which pair of pixels to draw at each step along the line, but we also need to generate the two proper intensities, which must be inversely proportional to distance from the ideal line and sum to 1, and that’s a potentially time-consuming operation. Let’s assume, however, that the number of possible intensity levels to be used for weighting is the value NumLevels = 2<sup>n</sup> for some integer n, with the minimum weighting (0 percent intensity) being the value 2<sup>n</sup> -1, and the maximum weighting (100 percent intensity) being the value 0. Given that, lo and behold, the most significant n bits of the error accumulator select the proper intensity value for one element of the pixel pair, as shown in Figure 42.2. Better yet, 2<sup>n</sup>-1 minus the intensity of the first pixel selects the intensity of the other pixel in the pair, because the intensities of the two pixels must sum to 1; as it happens, this result can be obtained simply by flipping the n least-significant bits of the first pixel’s value. All this works because what the error accumulator accumulates is precisely the ideal line’s current distance between the two bracketing pixels.</p>
<figure>
<img src="images/42-02.jpg" alt="Figure 42.2  Wu intensity calculations." /><figcaption><strong>Figure 42.2</strong>  <em>Wu intensity calculations.</em></figcaption>
</figure>
<p>The intensity calculations take longer to describe than they do to perform. All that’s involved is a shift of the error accumulator to right-justify the desired intensity weighting bits, and then an XOR to flip the least-significant n bits of the first pixel’s value in order to generate the second pixel’s value. Listing 42.1 illustrates just how efficient Wu antialiasing is; the intensity calculations take only three statements, and the entire Wu line-drawing loop is only nine statements long. Of course, a single C statement can hide a great deal of complexity, but Listing 42.6, an assembly implementation, shows that only 15 instructions are required per step along the major axis—and the number of instructions could be reduced to ten by special-casing and loop unrolling. Make no mistake about it, Wu antialiasing is fast.</p>
<p><strong>LISTING 42.1 L42-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Function to draw an antialiased line from (X0,Y0) to (X1,Y1), using an</span>
<span class="co"> * antialiasing approach published by Xiaolin Wu in the July 1991 issue of</span>
<span class="co"> * Computer Graphics. Requires that the palette be set up so that there</span>
<span class="co"> * are NumLevels intensity levels of the desired drawing color, starting at</span>
<span class="co"> * color BaseColor (100% intensity) and followed by (NumLevels-1) levels of</span>
<span class="co"> * evenly decreasing intensity, with color (BaseColor+NumLevels-1) being 0%</span>
<span class="co"> * intensity of the desired drawing color (black). This code is suitable for</span>
<span class="co"> * use at screen resolutions, with lines typically no more than 1K long; for</span>
<span class="co"> * longer lines, 32-bit error arithmetic must be used to avoid problems with</span>
<span class="co"> * fixed-point inaccuracy. No clipping is performed in DrawWuLine; it must be</span>
<span class="co"> * performed either at a higher level or in the DrawPixel function.</span>
<span class="co"> * Tested with Borland C++ in C compilation mode and the small model.</span>
<span class="co"> */</span>
<span class="kw">extern</span> <span class="dt">void</span> DrawPixel(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);

<span class="co">/* Wu antialiased line drawer.</span>
<span class="co"> * (X0,Y0),(X1,Y1) = line to draw</span>
<span class="co"> * BaseColor = color # of first color in block used for antialiasing, the</span>
<span class="co"> *          100% intensity version of the drawing color</span>
<span class="co"> * NumLevels = size of color block, with BaseColor+NumLevels-1 being the</span>
<span class="co"> *          0% intensity version of the drawing color</span>
<span class="co"> * IntensityBits = log base 2 of NumLevels; the # of bits used to describe</span>
<span class="co"> *          the intensity of the drawing color. 2**IntensityBits==NumLevels</span>
<span class="co"> */</span>
<span class="dt">void</span> DrawWuLine(<span class="dt">int</span> X0, <span class="dt">int</span> Y0, <span class="dt">int</span> X1, <span class="dt">int</span> Y1, <span class="dt">int</span> BaseColor, <span class="dt">int</span> NumLevels,
   <span class="dt">unsigned</span> <span class="dt">int</span> IntensityBits)
{
   <span class="dt">unsigned</span> <span class="dt">int</span> IntensityShift, ErrorAdj, ErrorAcc;
   <span class="dt">unsigned</span> <span class="dt">int</span> ErrorAccTemp, Weighting, WeightingComplementMask;
   <span class="dt">int</span> DeltaX, DeltaY, Temp, XDir;

   <span class="co">/* Make sure the line runs top to bottom */</span>
   <span class="kw">if</span> (Y0 &gt; Y1) {
      Temp = Y0; Y0 = Y1; Y1 = Temp;
      Temp = X0; X0 = X1; X1 = Temp;
   }
   <span class="co">/* Draw the initial pixel, which is always exactly intersected by</span>
<span class="co">      the line and so needs no weighting */</span>
   DrawPixel(X0, Y0, BaseColor);

   <span class="kw">if</span> ((DeltaX = X1 - X0) &gt;= <span class="dv">0</span>) {
      XDir = <span class="dv">1</span>;
   } <span class="kw">else</span> {
      XDir = -<span class="dv">1</span>;
      DeltaX = -DeltaX; <span class="co">/* make DeltaX positive */</span>
   }
   <span class="co">/* Special-case horizontal, vertical, and diagonal lines, which</span>
<span class="co">      require no weighting because they go right through the center of</span>
<span class="co">      every pixel */</span>
   <span class="kw">if</span> ((DeltaY = Y1 - Y0) == <span class="dv">0</span>) {
      <span class="co">/* Horizontal line */</span>
      <span class="kw">while</span> (DeltaX-- != <span class="dv">0</span>) {
         X0 += XDir;
         DrawPixel(X0, Y0, BaseColor);
      }
      <span class="kw">return</span>;
   }
   <span class="kw">if</span> (DeltaX == <span class="dv">0</span>) {
      <span class="co">/* Vertical line */</span>
      <span class="kw">do</span> {
         Y0++;
         DrawPixel(X0, Y0, BaseColor);
      } <span class="kw">while</span> (--DeltaY != <span class="dv">0</span>);
      <span class="kw">return</span>;
   }
   <span class="kw">if</span> (DeltaX == DeltaY) {
      <span class="co">/* Diagonal line */</span>
      <span class="kw">do</span> {
         X0 += XDir;
         Y0++;
         DrawPixel(X0, Y0, BaseColor);
      } <span class="kw">while</span> (--DeltaY != <span class="dv">0</span>);
      <span class="kw">return</span>;
   }
   <span class="co">/* line is not horizontal, diagonal, or vertical */</span>
   ErrorAcc = <span class="dv">0</span>;  <span class="co">/* initialize the line error accumulator to 0 */</span>
   <span class="co">/* # of bits by which to shift ErrorAcc to get intensity level */</span>
   IntensityShift = <span class="dv">16</span> - IntensityBits;
   <span class="co">/* Mask used to flip all bits in an intensity weighting, producing the</span>
<span class="co">      result (1 - intensity weighting) */</span>
   WeightingComplementMask = NumLevels - <span class="dv">1</span>;
   <span class="co">/* Is this an X-major or Y-major line? */</span>
   <span class="kw">if</span> (DeltaY &gt; DeltaX) {
      <span class="co">/* Y-major line; calculate 16-bit fixed-point fractional part of a</span>
<span class="co">         pixel that X advances each time Y advances 1 pixel, truncating the</span>
<span class="co">         result so that we won&#39;t overrun the endpoint along the X axis */</span>
      ErrorAdj = ((<span class="dt">unsigned</span> <span class="dt">long</span>) DeltaX &lt;&lt; <span class="dv">16</span>) / (<span class="dt">unsigned</span> <span class="dt">long</span>) DeltaY;
      <span class="co">/* Draw all pixels other than the first and last */</span>
      <span class="kw">while</span> (--DeltaY) {
         ErrorAccTemp = ErrorAcc;   <span class="co">/* remember currrent accumulated error */</span>
         ErrorAcc += ErrorAdj;      <span class="co">/* calculate error for next pixel */</span>
         <span class="kw">if</span> (ErrorAcc &lt;= ErrorAccTemp) {
            <span class="co">/* The error accumulator turned over, so advance the X coord */</span>
            X0 += XDir;
         }
         Y0++; <span class="co">/* Y-major, so always advance Y */</span>
         <span class="co">/* The IntensityBits most significant bits of ErrorAcc give us the</span>
<span class="co">            intensity weighting for this pixel, and the complement of the</span>
<span class="co">            weighting for the paired pixel */</span>
         Weighting = ErrorAcc &gt;&gt; IntensityShift;
         DrawPixel(X0, Y0, BaseColor + Weighting);
         DrawPixel(X0 + XDir, Y0,
               BaseColor + (Weighting ^ WeightingComplementMask));
      }
      <span class="co">/* Draw the final pixel, which is always exactly intersected by the line</span>
<span class="co">         and so needs no weighting */</span>
      DrawPixel(X1, Y1, BaseColor);
      <span class="kw">return</span>;
   }
   <span class="co">/* It&#39;s an X-major line; calculate 16-bit fixed-point fractional part of a</span>
<span class="co">      pixel that Y advances each time X advances 1 pixel, truncating the</span>
<span class="co">      result to avoid overrunning the endpoint along the X axis */</span>
   ErrorAdj = ((<span class="dt">unsigned</span> <span class="dt">long</span>) DeltaY &lt;&lt; <span class="dv">16</span>) / (<span class="dt">unsigned</span> <span class="dt">long</span>) DeltaX;
   <span class="co">/* Draw all pixels other than the first and last */</span>
   <span class="kw">while</span> (--DeltaX) {
      ErrorAccTemp = ErrorAcc;   <span class="co">/* remember currrent accumulated error */</span>
      ErrorAcc += ErrorAdj;      <span class="co">/* calculate error for next pixel */</span>
      <span class="kw">if</span> (ErrorAcc &lt;= ErrorAccTemp) {
         <span class="co">/* The error accumulator turned over, so advance the Y coord */</span>
         Y0++;
      }
      X0 += XDir; <span class="co">/* X-major, so always advance X */</span>
      <span class="co">/* The IntensityBits most significant bits of ErrorAcc give us the</span>
<span class="co">         intensity weighting for this pixel, and the complement of the</span>
<span class="co">         weighting for the paired pixel */</span>
      Weighting = ErrorAcc &gt;&gt; IntensityShift;
      DrawPixel(X0, Y0, BaseColor + Weighting);
      DrawPixel(X0, Y0 + <span class="dv">1</span>,
            BaseColor + (Weighting ^ WeightingComplementMask));
   }
   <span class="co">/* Draw the final pixel, which is always exactly intersected by the line</span>
<span class="co">      and so needs no weighting */</span>
   DrawPixel(X1, Y1, BaseColor);
}</code></pre>
</section>
<section id="sample-wu-antialiasing" class="level3">
<h3><a href="#sample-wu-antialiasing">Sample Wu Antialiasing</a></h3>
<p>The true test of any antialiasing technique is how good it looks, so let’s have a look at Wu antialiasing in action. Listing 42.1 is a C implementation of Wu antialiasing. Listing 42.2 is a sample program that draws a variety of Wu-antialiased lines, followed by non-antialiased lines, for comparison. Listing 42.3 contains <code>DrawPixel()</code> and <code>SetMode()</code> functions for mode 13H, the VGA’s 320x200 256-color mode. Finally, Listing 42.4 is a simple, non-antialiased line-drawing routine. Link these four listings together and run the resulting program to see both Wu-antialiased and non-antialiased lines.</p>
<p><strong>LISTING 42.2 L42-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Sample line-drawing program to demonstrate Wu antialiasing. Also draws</span>
<span class="co"> * non-antialiased lines for comparison.</span>
<span class="co"> * Tested with Borland C++ in C compilation mode and the small model.</span>
<span class="co"> */</span>
<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &lt;conio.h&gt;</span>

<span class="dt">void</span> SetPalette(<span class="kw">struct</span> WuColor *);
<span class="kw">extern</span> <span class="dt">void</span> DrawWuLine(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">unsigned</span> <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> DrawLine(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> SetMode(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">int</span> ScreenWidthInPixels;  <span class="co">/* screen dimension globals */</span>
<span class="kw">extern</span> <span class="dt">int</span> ScreenHeightInPixels;

<span class="ot">#define NUM_WU_COLORS 2 </span><span class="co">/* # of colors we&#39;ll do antialiased drawing with */</span>
<span class="kw">struct</span> WuColor {        <span class="co">/* describes one color used for antialiasing */</span>
   <span class="dt">int</span> BaseColor;       <span class="co">/* # of start of palette intensity block in DAC */</span>
   <span class="dt">int</span> NumLevels;       <span class="co">/* # of intensity levels */</span>
   <span class="dt">int</span> IntensityBits;   <span class="co">/* IntensityBits == log2 NumLevels */</span>
   <span class="dt">int</span> MaxRed;          <span class="co">/* red component of color at full intensity */</span>
   <span class="dt">int</span> MaxGreen;        <span class="co">/* green component of color at full intensity */</span>
   <span class="dt">int</span> MaxBlue;         <span class="co">/* blue component of color at full intensity */</span>
};
<span class="kw">enum</span> {WU_BLUE=<span class="dv">0</span>, WU_WHITE=<span class="dv">1</span>};             <span class="co">/* drawing colors */</span>
<span class="kw">struct</span> WuColor WuColors[NUM_WU_COLORS] =  <span class="co">/* blue and white */</span>
    {{<span class="dv">192</span>, <span class="dv">32</span>, <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="bn">0x3F</span>}, {<span class="dv">224</span>, <span class="dv">32</span>, <span class="dv">5</span>, <span class="bn">0x3F</span>, <span class="bn">0x3F</span>, <span class="bn">0x3F</span>}};

<span class="dt">void</span> main()
{
   <span class="dt">int</span> CurrentColor, i;
   <span class="kw">union</span> REGS regset;

   <span class="co">/* Draw Wu-antialiased lines in all directions */</span>
   SetMode();
   SetPalette(WuColors);
   <span class="kw">for</span> (i=<span class="dv">5</span>; i&lt;ScreenWidthInPixels; i += <span class="dv">10</span>) {
      DrawWuLine(ScreenWidthInPixels/<span class="dv">2</span>-ScreenWidthInPixels/<span class="dv">10</span>+i/<span class="dv">5</span>,
            ScreenHeightInPixels/<span class="dv">5</span>, i, ScreenHeightInPixels<span class="dv">-1</span>,
            WuColors[WU_BLUE].BaseColor, WuColors[WU_BLUE].NumLevels,
            WuColors[WU_BLUE].IntensityBits);
   }
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;ScreenHeightInPixels; i += <span class="dv">10</span>) {
      DrawWuLine(ScreenWidthInPixels/<span class="dv">2</span>-ScreenWidthInPixels/<span class="dv">10</span>, i/<span class="dv">5</span>, <span class="dv">0</span>, i,
            WuColors[WU_BLUE].BaseColor, WuColors[WU_BLUE].NumLevels,
            WuColors[WU_BLUE].IntensityBits);
   }
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;ScreenHeightInPixels; i += <span class="dv">10</span>) {
      DrawWuLine(ScreenWidthInPixels/<span class="dv">2</span>+ScreenWidthInPixels/<span class="dv">10</span>, i/<span class="dv">5</span>,
            ScreenWidthInPixels<span class="dv">-1</span>, i, WuColors[WU_BLUE].BaseColor,
            WuColors[WU_BLUE].NumLevels, WuColors[WU_BLUE].IntensityBits);
   }
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;ScreenWidthInPixels; i += <span class="dv">10</span>) {
      DrawWuLine(ScreenWidthInPixels/<span class="dv">2</span>-ScreenWidthInPixels/<span class="dv">10</span>+i/<span class="dv">5</span>,
            ScreenHeightInPixels, i, <span class="dv">0</span>, WuColors[WU_WHITE].BaseColor,
            WuColors[WU_WHITE].NumLevels,
            WuColors[WU_WHITE].IntensityBits);
   }
   getch();                <span class="co">/* wait for a key press */</span>

   <span class="co">/* Now clear the screen and draw non-antialiased lines */</span>
   SetMode();
   SetPalette(WuColors);
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;ScreenWidthInPixels; i += <span class="dv">10</span>) {
      DrawLine(ScreenWidthInPixels/<span class="dv">2</span>-ScreenWidthInPixels/<span class="dv">10</span>+i/<span class="dv">5</span>,
            ScreenHeightInPixels/<span class="dv">5</span>, i, ScreenHeightInPixels<span class="dv">-1</span>,
            WuColors[WU_BLUE].BaseColor);
   }
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;ScreenHeightInPixels; i += <span class="dv">10</span>) {
      DrawLine(ScreenWidthInPixels/<span class="dv">2</span>-ScreenWidthInPixels/<span class="dv">10</span>, i/<span class="dv">5</span>, <span class="dv">0</span>, i,
            WuColors[WU_BLUE].BaseColor);
   }
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;ScreenHeightInPixels; i += <span class="dv">10</span>) {
      DrawLine(ScreenWidthInPixels/<span class="dv">2</span>+ScreenWidthInPixels/<span class="dv">10</span>, i/<span class="dv">5</span>,
            ScreenWidthInPixels<span class="dv">-1</span>, i, WuColors[WU_BLUE].BaseColor);
   }
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;ScreenWidthInPixels; i += <span class="dv">10</span>) {
      DrawLine(ScreenWidthInPixels/<span class="dv">2</span>-ScreenWidthInPixels/<span class="dv">10</span>+i/<span class="dv">5</span>,
            ScreenHeightInPixels, i, <span class="dv">0</span>, WuColors[WU_WHITE].BaseColor);
   }
   getch();                <span class="co">/* wait for a key press */</span>

   regset.x.ax = <span class="bn">0x0003</span>;   <span class="co">/* AL = 3 selects 80x25 text mode */</span>
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);   <span class="co">/* return to text mode */</span>
}

<span class="co">/* Sets up the palette for antialiasing with the specified colors.</span>
<span class="co"> * Intensity steps for each color are scaled from the full desired intensity</span>
<span class="co"> * of the red, green, and blue components for that color down to 0%</span>
<span class="co"> * intensity; each step is rounded to the nearest integer. Colors are</span>
<span class="co"> * corrected for a gamma of 2.3. The values that the palette is programmed</span>
<span class="co"> * with are hardwired for the VGA&#39;s 6 bit per color DAC.</span>
<span class="co"> */</span>
<span class="dt">void</span> SetPalette(<span class="kw">struct</span> WuColor * WColors)
{
   <span class="dt">int</span> i, j;
   <span class="kw">union</span> REGS regset;
   <span class="kw">struct</span> SREGS sregset;
   <span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">char</span> PaletteBlock[<span class="dv">256</span>][<span class="dv">3</span>];   <span class="co">/* 256 RGB entries */</span>
   <span class="co">/* Gamma-corrected DAC color components for 64 linear levels from 0% to</span>
<span class="co">      100% intensity */</span>
   <span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">char</span> GammaTable[] = {
      <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">14</span>, <span class="dv">17</span>, <span class="dv">19</span>, <span class="dv">21</span>, <span class="dv">23</span>, <span class="dv">24</span>, <span class="dv">26</span>, <span class="dv">27</span>, <span class="dv">28</span>, <span class="dv">29</span>, <span class="dv">31</span>, <span class="dv">32</span>, <span class="dv">33</span>, <span class="dv">34</span>,
      <span class="dv">35</span>, <span class="dv">36</span>, <span class="dv">37</span>, <span class="dv">37</span>, <span class="dv">38</span>, <span class="dv">39</span>, <span class="dv">40</span>, <span class="dv">41</span>, <span class="dv">41</span>, <span class="dv">42</span>, <span class="dv">43</span>, <span class="dv">44</span>, <span class="dv">44</span>, <span class="dv">45</span>, <span class="dv">46</span>, <span class="dv">46</span>,
      <span class="dv">47</span>, <span class="dv">48</span>, <span class="dv">48</span>, <span class="dv">49</span>, <span class="dv">49</span>, <span class="dv">50</span>, <span class="dv">51</span>, <span class="dv">51</span>, <span class="dv">52</span>, <span class="dv">52</span>, <span class="dv">53</span>, <span class="dv">53</span>, <span class="dv">54</span>, <span class="dv">54</span>, <span class="dv">55</span>, <span class="dv">55</span>,
      <span class="dv">56</span>, <span class="dv">56</span>, <span class="dv">57</span>, <span class="dv">57</span>, <span class="dv">58</span>, <span class="dv">58</span>, <span class="dv">59</span>, <span class="dv">59</span>, <span class="dv">60</span>, <span class="dv">60</span>, <span class="dv">61</span>, <span class="dv">61</span>, <span class="dv">62</span>, <span class="dv">62</span>, <span class="dv">63</span>, <span class="dv">63</span>};

   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NUM_WU_COLORS; i++) {
      <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;WColors[i].NumLevels; j++) {
         PaletteBlock[j][<span class="dv">0</span>] = GammaTable[((<span class="dt">double</span>)WColors[i].MaxRed * (<span class="fl">1.0</span> -
               (<span class="dt">double</span>)j / (<span class="dt">double</span>)(WColors[i].NumLevels - <span class="dv">1</span>))) + <span class="fl">0.5</span>];
         PaletteBlock[j][<span class="dv">1</span>] = GammaTable[((<span class="dt">double</span>)WColors[i].MaxGreen * (<span class="fl">1.0</span> -
               (<span class="dt">double</span>)j / (<span class="dt">double</span>)(WColors[i].NumLevels - <span class="dv">1</span>))) + <span class="fl">0.5</span>];
         PaletteBlock[j][<span class="dv">2</span>] = GammaTable[((<span class="dt">double</span>)WColors[i].MaxBlue * (<span class="fl">1.0</span> -
               (<span class="dt">double</span>)j / (<span class="dt">double</span>)(WColors[i].NumLevels - <span class="dv">1</span>))) + <span class="fl">0.5</span>];
      }
      <span class="co">/* Now set up the palette to do Wu antialiasing for this color */</span>
      regset.x.ax = <span class="bn">0x1012</span>;   <span class="co">/* set block of DAC registers function */</span>
      regset.x.bx = WColors[i].BaseColor;   <span class="co">/* first DAC location to load */</span>
      regset.x.cx = WColors[i].NumLevels;   <span class="co">/* # of DAC locations to load */</span>
      regset.x.dx = (<span class="dt">unsigned</span> <span class="dt">int</span>)PaletteBlock; <span class="co">/* offset of array from which</span>
<span class="co">                                                   to load RGB settings */</span>
      sregset.es = _DS; <span class="co">/* segment of array from which to load settings */</span>
      int86x(<span class="bn">0x10</span>, &amp;regset, &amp;regset, &amp;sregset); <span class="co">/* load the palette block */</span>
   }
}</code></pre>
<p><strong>LISTING 42.3 L42-3.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* VGA mode 13h pixel-drawing and mode set functions.</span>
<span class="co"> * Tested with Borland C++ in C compilation mode and the small model.</span>
<span class="co"> */</span>
<span class="ot">#include &lt;dos.h&gt;</span>

<span class="co">/* Screen dimension globals, used in main program to scale. */</span>
<span class="dt">int</span> ScreenWidthInPixels = <span class="dv">320</span>;
<span class="dt">int</span> ScreenHeightInPixels = <span class="dv">200</span>;

<span class="co">/* Mode 13h draw pixel function. */</span>
<span class="dt">void</span> DrawPixel(<span class="dt">int</span> X, <span class="dt">int</span> Y, <span class="dt">int</span> Color)
{
<span class="ot">#define SCREEN_SEGMENT  0xA000</span>
   <span class="dt">unsigned</span> <span class="dt">char</span> far *ScreenPtr;

   FP_SEG(ScreenPtr) = SCREEN_SEGMENT;
   FP_OFF(ScreenPtr) = (<span class="dt">unsigned</span> <span class="dt">int</span>) Y * ScreenWidthInPixels + X;
   *ScreenPtr = Color;
}

<span class="co">/* Mode 13h mode-set function. */</span>
<span class="dt">void</span> SetMode()
{
   <span class="kw">union</span> REGS regset;

   <span class="co">/* Set to 320x200 256-color graphics mode */</span>
   regset.x.ax = <span class="bn">0x0013</span>;
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}</code></pre>
<p><strong>LISTING 42.4 L42-4.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Function to draw a non-antialiased line from (X0,Y0) to (X1,Y1), using a</span>
<span class="co"> * simple fixed-point error accumulation approach.</span>
<span class="co"> * Tested with Borland C++ in C compilation mode and the small model.</span>
<span class="co"> */</span>
<span class="kw">extern</span> <span class="dt">void</span> DrawPixel(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);

<span class="co">/* Non-antialiased line drawer.</span>
<span class="co"> * (X0,Y0),(X1,Y1) = line to draw, Color = color in which to draw</span>
<span class="co"> */</span>
<span class="dt">void</span> DrawLine(<span class="dt">int</span> X0, <span class="dt">int</span> Y0, <span class="dt">int</span> X1, <span class="dt">int</span> Y1, <span class="dt">int</span> Color)
{
   <span class="dt">unsigned</span> <span class="dt">long</span> ErrorAcc, ErrorAdj;
   <span class="dt">int</span> DeltaX, DeltaY, XDir, Temp;

   <span class="co">/* Make sure the line runs top to bottom */</span>
   <span class="kw">if</span> (Y0 &gt; Y1) {
      Temp = Y0; Y0 = Y1; Y1 = Temp;
      Temp = X0; X0 = X1; X1 = Temp;
   }
   DrawPixel(X0, Y0, Color);  <span class="co">/* draw the initial pixel */</span>
   <span class="kw">if</span> ((DeltaX = X1 - X0) &gt;= <span class="dv">0</span>) {
      XDir = <span class="dv">1</span>;
   } <span class="kw">else</span> {
      XDir = -<span class="dv">1</span>;
      DeltaX = -DeltaX; <span class="co">/* make DeltaX positive */</span>
   }
   <span class="kw">if</span> ((DeltaY = Y1 - Y0) == <span class="dv">0</span>)  <span class="co">/* done if only one point in the line */</span>
      <span class="kw">if</span> (DeltaX == <span class="dv">0</span>) <span class="kw">return</span>;

   ErrorAcc = <span class="bn">0x8000</span>;   <span class="co">/* initialize line error accumulator to .5, so we can</span>
<span class="co">                           advance when we get halfway to the next pixel */</span>
   <span class="co">/* Is this an X-major or Y-major line? */</span>
   <span class="kw">if</span> (DeltaY &gt; DeltaX) {
      <span class="co">/* Y-major line; calculate 16-bit fixed-point fractional part of a</span>
<span class="co">         pixel that X advances each time Y advances 1 pixel */</span>
      ErrorAdj = ((((<span class="dt">unsigned</span> <span class="dt">long</span>)DeltaX &lt;&lt; <span class="dv">17</span>) / (<span class="dt">unsigned</span> <span class="dt">long</span>)DeltaY) +
            <span class="dv">1</span>) &gt;&gt; <span class="dv">1</span>;
      <span class="co">/* Draw all pixels between the first and last */</span>
      <span class="kw">do</span> {
         ErrorAcc += ErrorAdj;      <span class="co">/* calculate error for this pixel */</span>
         <span class="kw">if</span> (ErrorAcc &amp; ~0xFFFFL) {
            <span class="co">/* The error accumulator turned over, so advance the X coord */</span>
            X0 += XDir;
            ErrorAcc &amp;= 0xFFFFL;    <span class="co">/* clear integer part of result */</span>
         }
         Y0++;                      <span class="co">/* Y-major, so always advance Y */</span>
         DrawPixel(X0, Y0, Color);
      } <span class="kw">while</span> (--DeltaY);
      <span class="kw">return</span>;
   }
   <span class="co">/* It&#39;s an X-major line; calculate 16-bit fixed-point fractional part of a</span>
<span class="co">      pixel that Y advances each time X advances 1 pixel */</span>
   ErrorAdj = ((((<span class="dt">unsigned</span> <span class="dt">long</span>)DeltaY &lt;&lt; <span class="dv">17</span>) / (<span class="dt">unsigned</span> <span class="dt">long</span>)DeltaX) +
         <span class="dv">1</span>) &gt;&gt; <span class="dv">1</span>;
   <span class="co">/* Draw all remaining pixels */</span>
   <span class="kw">do</span> {
      ErrorAcc += ErrorAdj;      <span class="co">/* calculate error for this pixel */</span>
      <span class="kw">if</span> (ErrorAcc &amp; ~0xFFFFL) {
         <span class="co">/* The error accumulator turned over, so advance the Y coord */</span>
         Y0++;
         ErrorAcc &amp;= 0xFFFFL;    <span class="co">/* clear integer part of result */</span>
      }
      X0 += XDir;                <span class="co">/* X-major, so always advance X */</span>
      DrawPixel(X0, Y0, Color);
   } <span class="kw">while</span> (--DeltaX);
}</code></pre>
<p>Listing 42.1 isn’t particularly fast, because it calls <code>DrawPixel()</code> for each pixel. On the other hand, <code>DrawPixel()</code> makes it easy to try out Wu antialiasing in a variety of modes; just adapt the code in Listing 42.3 for the 256-color mode you want to support. For example, Listing 42.5 shows code to draw Wu-antialiased lines in 640x480 256-color mode on SuperVGAs built around the Tseng Labs ET4000 chip with at least 512K of display memory installed. It’s well worth checking out Wu antialiasing at 640x480. Although antialiased lines look much smoother than normal lines at 320x200 resolution, they’re far from perfect, because the pixels are so big that the eye can’t blend them properly. At 640x480, however, Wu-antialiased lines look fabulous; from a couple of feet away, they look as straight and smooth as if they were drawn with a ruler.</p>
<p><strong>LISTING 42.5 L42-5.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Mode set and pixel-drawing functions for the 640x480 256-color mode of</span>
<span class="co"> * Tseng Labs ET4000-based SuperVGAs.</span>
<span class="co"> * Tested with Borland C++ in C compilation mode and the small model.</span>
<span class="co"> */</span>
<span class="ot">#include &lt;dos.h&gt;</span>

<span class="co">/* Screen dimension globals, used in main program to scale */</span>
<span class="dt">int</span> ScreenWidthInPixels = <span class="dv">640</span>;
<span class="dt">int</span> ScreenHeightInPixels = <span class="dv">480</span>;

<span class="co">/* ET4000 640x480 256-color draw pixel function. */</span>
<span class="dt">void</span> DrawPixel(<span class="dt">int</span> X, <span class="dt">int</span> Y, <span class="dt">int</span> Color)
{
<span class="ot">#define SCREEN_SEGMENT        0xA000</span>
<span class="ot">#define GC_SEGMENT_SELECT     0x3CD </span><span class="co">/* ET4000 segment (bank) select reg */</span>
   <span class="dt">unsigned</span> <span class="dt">char</span> far *ScreenPtr;
   <span class="dt">unsigned</span> <span class="dt">int</span> Bank;
   <span class="dt">unsigned</span> <span class="dt">long</span> BitmapAddress;

   <span class="co">/* full bitmap address of pixel, as measured from address 0 to 0xFFFFF */</span>
   BitmapAddress = (<span class="dt">unsigned</span> <span class="dt">long</span>) Y * ScreenWidthInPixels + X;
   <span class="co">/* Bank # is upper word of bitmap addr */</span>
   Bank = BitmapAddress &gt;&gt; <span class="dv">16</span>;
   <span class="co">/* Upper nibble is read bank #, lower nibble is write bank # */</span>
   outp(GC_SEGMENT_SELECT, (Bank &lt;&lt; <span class="dv">4</span>) | Bank);
   <span class="co">/* Draw into the bank */</span>
   FP_SEG(ScreenPtr) = SCREEN_SEGMENT;
   FP_OFF(ScreenPtr) = (<span class="dt">unsigned</span> <span class="dt">int</span>) BitmapAddress;
   *ScreenPtr = Color;
}

<span class="co">/* ET4000 640x480 256-color mode-set function. */</span>
<span class="dt">void</span> SetMode()
{
   <span class="kw">union</span> REGS regset;

   <span class="co">/* Set to 640x480 256-color graphics mode */</span>
   regset.x.ax = <span class="bn">0x002E</span>;
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}</code></pre>
<p>Listing 42.1 requires that the DAC palette be set up so that a <code>NumLevel</code>-long block of palette entries contains linearly decreasing intensities of the drawing color. The size of the block is programmable, but must be a power of two. The more intensity levels, the better. Wu says that 32 intensities are enough; on my system, eight and even four levels looked pretty good. I found that gamma correction, which gives linearly spaced intensity steps, improved antialiasing quality significantly. Fortunately, we can program the palette with gamma-corrected values, so our drawing code doesn’t have to do any extra work.</p>
<p>Listing 42.1 isn’t very fast, so I implemented Wu antialiasing in assembly, hard-coded for mode 13H. The implementation is shown in full in Listing 42.6. High-speed graphics code and fast VGAs go together like peanut butter and jelly, which is to say very well indeed; the assembly implementation ran more than twice as fast as the C code on my 486. Enough said!</p>
<p><strong>LISTING 42.6 L42-6.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; C near-callable function to draw an antialiased line from</span>
<span class="co">; (X0,Y0) to (X1,Y1), in mode 13h, the VGA&#39;s standard 320x200 256-color</span>
<span class="co">; mode. Uses an antialiasing approach published by Xiaolin Wu in the July</span>
<span class="co">; 1991 issue of Computer Graphics. Requires that the palette be set up so</span>
<span class="co">; that there are NumLevels intensity levels of the desired drawing color,</span>
<span class="co">; starting at color BaseColor (100% intensity) and followed by (NumLevels-1)</span>
<span class="co">; levels of evenly decreasing intensity, with color (BaseColor+NumLevels-1)</span>
<span class="co">; being 0% intensity of the desired drawing color (black). No clipping is</span>
<span class="co">; performed in DrawWuLine. Handles a maximum of 256 intensity levels per</span>
<span class="co">; antialiased color. This code is suitable for use at screen resolutions,</span>
<span class="co">; with lines typically no more than 1K long; for longer lines, 32-bit error</span>
<span class="co">; arithmetic must be used to avoid problems with fixed-point inaccuracy.</span>
<span class="co">; Tested with TASM.</span>
<span class="co">;</span>
<span class="co">; C near-callable as:</span>
<span class="co">;   void DrawWuLine(int X0, int Y0, int X1, int Y1, int BaseColor,</span>
<span class="co">;      int NumLevels, unsigned int IntensityBits);</span>

SCREEN_WIDTH_IN_BYTES <span class="dt">equ</span> <span class="dv">320</span><span class="co">;# of bytes from the start of one scan line</span>
<span class="co">; to the start of the next</span>
SCREEN_SEGMENT   <span class="dt">equ</span>   0a000h<span class="co">;segment in which screen memory resides</span>

<span class="co">; Parameters passed in stack frame.</span>
parms   <span class="kw">struc</span>
     <span class="dt">dw</span>    <span class="dv">2</span> dup (?) <span class="co">;pushed BP and return address</span>
X0   <span class="dt">dw</span>    ?         <span class="co">;X coordinate of line start point</span>
Y0   <span class="dt">dw</span>    ?         <span class="co">;Y coordinate of line start point</span>
X1   <span class="dt">dw</span>    ?         <span class="co">;X coordinate of line end point</span>
Y1   <span class="dt">dw</span>    ?         <span class="co">;Y coordinate of line end point</span>
BaseColor <span class="dt">dw</span>     ?       <span class="co">;color # of first color in block used for</span>
                     <span class="co">;antialiasing, the 100% intensity version of the</span>
                     <span class="co">;drawing color</span>
NumLevels <span class="dt">dw</span>     ?       <span class="co">;size of color block, with BaseColor+NumLevels-1</span>
                     <span class="co">; being the 0% intensity version of the drawing color</span>
                     <span class="co">; (maximum NumLevels = 256)</span>
IntensityBits <span class="dt">dw</span> ?       <span class="co">;log base 2 of NumLevels; the # of bits used to</span>
                     <span class="co">; describe the intensity of the drawing color.</span>
                     <span class="co">; 2**IntensityBits==NumLevels</span>
                     <span class="co">; (maximum IntensityBits = 8)</span>
parms ends

.model  small
.code
<span class="co">; Screen dimension globals, used in main program to scale.</span>
_ScreenWidthInPixels    <span class="dt">dw</span>      <span class="dv">320</span>
_ScreenHeightInPixels   <span class="dt">dw</span>      <span class="dv">200</span>

        .code
        public   _DrawWuLine
_DrawWuLine proc near
        <span class="kw">push</span>    <span class="kw">bp</span>      <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>   <span class="co">;point to local stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>      <span class="co">;preserve C&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">push</span>    <span class="kw">ds</span>      <span class="co">;preserve C&#39;s default data segment</span>
        <span class="kw">cld</span>             <span class="co">;make string instructions increment their pointers</span>

<span class="co">; Make sure the line runs top to bottom.</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>].X0
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>].Y0
        <span class="kw">cmp</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>].Y1   <span class="co">;swap endpoints if necessary to ensure that</span>
        <span class="kw">jna</span>     NoSwap       <span class="co">; Y0 &lt;= Y1</span>
        <span class="kw">xchg</span>    [<span class="kw">bp</span>].Y1,<span class="kw">ax</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>].Y0,<span class="kw">ax</span>
        <span class="kw">xchg</span>    [<span class="kw">bp</span>].X1,<span class="kw">si</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>].X0,<span class="kw">si</span>
<span class="fu">NoSwap:</span>

<span class="co">; Draw the initial pixel, which is always exactly intersected by the line</span>
<span class="co">; and so needs no weighting.</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SCREEN_SEGMENT
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">dx</span>           <span class="co">;point DS to the screen segment</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SCREEN_WIDTH_IN_BYTES
        <span class="kw">mul</span>     <span class="kw">dx</span>              <span class="co">;Y0 * SCREEN_WIDTH_IN_BYTES yields the offset</span>
                                <span class="co">; of the start of the row start the initial</span>
                                <span class="co">; pixel is on</span>
        <span class="kw">add</span>     <span class="kw">si</span>,<span class="kw">ax</span>           <span class="co">;point DS:SI to the initial pixel</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BaseColor <span class="co">;color with which to draw</span>
        <span class="kw">mov</span>     [<span class="kw">si</span>],<span class="kw">al</span>         <span class="co">;draw the initial pixel</span>

        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="dv">1</span>            <span class="co">;XDir = 1; assume DeltaX &gt;= 0</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>].X1
        <span class="kw">sub</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>].X0      <span class="co">;DeltaX; is it &gt;= 1?</span>
        <span class="kw">jns</span>     DeltaXSet       <span class="co">;yes, move left-&gt;right, all set</span>
                                <span class="co">;no, move right-&gt;left</span>
        <span class="kw">neg</span>     <span class="kw">cx</span>              <span class="co">;make DeltaX positive</span>
        <span class="kw">neg</span>     <span class="kw">bx</span>              <span class="co">;XDir = -1</span>
<span class="fu">DeltaXSet:</span>

<span class="co">; Special-case horizontal, vertical, and diagonal lines, which require no</span>
<span class="co">; weighting because they go right through the center of every pixel.</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bp</span>].Y1
        <span class="kw">sub</span>     <span class="kw">dx</span>,[<span class="kw">bp</span>].Y0      <span class="co">;DeltaY; is it 0?</span>
        <span class="kw">jnz</span>     NotHorz         <span class="co">;no, not horizontal</span>
                                <span class="co">;yes, is horizontal, special case</span>
        <span class="kw">and</span>     <span class="kw">bx</span>,<span class="kw">bx</span>           <span class="co">;draw from left-&gt;right?</span>
        <span class="kw">jns</span>     DoHorz          <span class="co">;yes, all set</span>
        <span class="kw">std</span>                     <span class="co">;no, draw right-&gt;left</span>
<span class="fu">DoHorz:</span>
        <span class="kw">lea</span>     <span class="kw">di</span>,[<span class="kw">bx</span>+<span class="kw">si</span>]      <span class="co">;point DI to next pixel to draw</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">ds</span>
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>           <span class="co">;point ES:DI to next pixel to draw</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BaseColor <span class="co">;color with which to draw</span>
                                <span class="co">;CX = DeltaX at this point</span>
        rep     <span class="kw">stosb</span>           <span class="co">;draw the rest of the horizontal line</span>
        <span class="kw">cld</span>                             <span class="co">;restore default direction flag</span>
        <span class="kw">jmp</span>     Done                    <span class="co">;and we&#39;re done</span>

        align2
<span class="fu">NotHorz:</span>
        <span class="kw">and</span>     <span class="kw">cx</span>,<span class="kw">cx</span>                   <span class="co">;is DeltaX 0?</span>
        <span class="kw">jnz</span>     NotVert                 <span class="co">;no, not a vertical line</span>
                                        <span class="co">;yes, is vertical, special case</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BaseColor  <span class="co">;color with which to draw</span>
<span class="fu">VertLoop:</span>
        <span class="kw">add</span>     <span class="kw">si</span>,SCREEN_WIDTH_IN_BYTES    <span class="co">;point to next pixel to draw</span>
        <span class="kw">mov</span>     [<span class="kw">si</span>],<span class="kw">al</span>                 <span class="co">;draw the next pixel</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>                      <span class="co">;--DeltaY</span>
        <span class="kw">jnz</span>     VertLoop
        <span class="kw">jmp</span>     Done                    <span class="co">;and we&#39;re done</span>
        
        align2
<span class="fu">NotVert:</span>
        <span class="kw">cmp</span>     <span class="kw">cx</span>,<span class="kw">dx</span>                   <span class="co">;DeltaX == DeltaY?</span>
        <span class="kw">jnz</span>     NotDiag                 <span class="co">;no, not diagonal</span>
                                        <span class="co">;yes, is diagonal, special case</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].BaseColor  <span class="co">;color with which to draw</span>
<span class="fu">DiagLoop:</span>
        <span class="kw">lea</span>     <span class="kw">si</span>,[<span class="kw">si</span>+SCREEN_WIDTH_IN_BYTES+<span class="kw">bx</span>]
                                        <span class="co">;advance to next pixel to draw by</span>
                                        <span class="co">; incrementing Y and adding XDir to X</span>
        <span class="kw">mov</span>     [<span class="kw">si</span>],<span class="kw">al</span>                 <span class="co">;draw the next pixel</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>                      <span class="co">;--DeltaY</span>
        <span class="kw">jnz</span>     DiagLoop
        <span class="kw">jmp</span>     Done                    <span class="co">;and we&#39;re done</span>

<span class="co">; Line is not horizontal, diagonal, or vertical.</span>
        align2
<span class="fu">NotDiag:</span>
<span class="co">; Is this an X-major or Y-major line?</span>
        <span class="kw">cmp</span>     <span class="kw">dx</span>,<span class="kw">cx</span>
        <span class="kw">jb</span>X     Ma<span class="kw">jo</span>r                   <span class="co">;it&#39;s X-major</span>

<span class="co">; It&#39;s a Y-major line. Calculate the 16-bit fixed-point fractional part of a</span>
<span class="co">; pixel that X advances each time Y advances 1 pixel, truncating the result</span>
<span class="co">; to avoid overrunning the endpoint along the X axis.</span>
        <span class="kw">xchg</span>    <span class="kw">dx</span>,<span class="kw">cx</span>           <span class="co">;DX = DeltaX, CX = DeltaY</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>           <span class="co">;make DeltaX 16.16 fixed-point value in DX:AX</span>
        <span class="kw">div</span>     <span class="kw">cx</span>              <span class="co">;AX = (DeltaX &lt;&lt; 16) / DeltaY. Won&#39;t overflow</span>
                                <span class="co">; because DeltaX &lt; DeltaY</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">cx</span>           <span class="co">;DI = DeltaY (loop count)</span>
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">bx</span>           <span class="co">;back up the start X by 1, as explained below</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,-<span class="dv">1</span>           <span class="co">;initialize the line error accumulator to -1,</span>
                                <span class="co">; so that it will turn over immediately and</span>
                                <span class="co">; advance X to the start X. This is necessary</span>
                                <span class="co">; properly to bias error sums of 0 to mean</span>
                                <span class="co">; &quot;advance next time&quot; rather than &quot;advance</span>
                                <span class="co">; this time,&quot; so that the final error sum can</span>
                                <span class="co">; never cause drawing to overrun the final X</span>
                                <span class="co">; coordinate (works in conjunction with</span>
                                <span class="co">; truncating ErrorAdj, to make sure X can&#39;t</span>
                                <span class="co">; overrun)</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">8</span>            <span class="co">;CL = # of bits by which to shift</span>
        <span class="kw">sub</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>].IntensityBits  <span class="co">; ErrorAcc to get intensity level (8</span>
                                <span class="co">; instead of 16 because we work only</span>
                                <span class="co">; with the high byte of ErrorAcc)</span>
        <span class="kw">mov</span>     <span class="kw">ch</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].NumLevels  <span class="co">;mask used to flip all bits in an</span>
        <span class="kw">dec</span>     <span class="kw">ch</span>              <span class="co">; intensity weighting, producing</span>
                                <span class="co">; result (1 - intensity weighting)</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,BaseColor[<span class="kw">bp</span>]  <span class="co">;***stack frame not available***</span>
                                <span class="co">;***from now on              ***</span>
        <span class="kw">xchg</span>    <span class="kw">bp</span>,<span class="kw">ax</span>           <span class="co">;BP = ErrorAdj, AL = BaseColor,</span>
                                <span class="co">; AH = scratch register</span>

<span class="co">; Draw all remaining pixels.</span>
<span class="fu">YMajorLoop:</span>
        <span class="kw">add</span>     <span class="kw">dx</span>,<span class="kw">bp</span>           <span class="co">;calculate error for next pixel</span>
        <span class="kw">jnc</span>     NoXAdvance      <span class="co">;not time to step in X yet</span>
                                <span class="co">;the error accumulator turned over,</span>
                                <span class="co">;so advance the X coord</span>
        <span class="kw">add</span>     <span class="kw">si</span>,<span class="kw">bx</span>           <span class="co">;add XDir to the pixel pointer</span>
<span class="fu">NoXAdvance:</span>
        <span class="kw">add</span>     <span class="kw">si</span>,SCREEN_WIDTH_IN_BYTES <span class="co">;Y-major, so always advance Y</span>

<span class="co">; The IntensityBits most significant bits of ErrorAcc give us the intensity</span>
<span class="co">; weighting for this pixel, and the complement of the weighting for the</span>
<span class="co">; paired pixel.</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">dh</span>           <span class="co">;msb of ErrorAcc</span>
        <span class="kw">shr</span>     <span class="kw">ah</span>,<span class="kw">cl</span>           <span class="co">;Weighting = ErrorAcc &gt;&gt; IntensityShift;</span>
        <span class="kw">add</span>     <span class="kw">ah</span>,<span class="kw">al</span>           <span class="co">;BaseColor + Weighting</span>
        <span class="kw">mov</span>     [<span class="kw">si</span>],<span class="kw">ah</span>         <span class="co">;DrawPixel(X, Y, BaseColor + Weighting);</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">dh</span>           <span class="co">;msb of ErrorAcc</span>
        <span class="kw">shr</span>     <span class="kw">ah</span>,<span class="kw">cl</span>           <span class="co">;Weighting = ErrorAcc &gt;&gt; IntensityShift;</span>
        <span class="kw">xor</span>     <span class="kw">ah</span>,<span class="kw">ch</span>           <span class="co">;Weighting ^ WeightingComplementMask</span>
        <span class="kw">add</span>     <span class="kw">ah</span>,<span class="kw">al</span>           <span class="co">;BaseColor + (Weighting ^ WeightingComplementMask)</span>
        <span class="kw">mov</span>     [<span class="kw">si</span>+<span class="kw">bx</span>],<span class="kw">ah</span>      <span class="co">;DrawPixel(X+XDir, Y,</span>
                                <span class="co">; BaseColor + (Weighting ^ WeightingComplementMask));</span>
        <span class="kw">dec</span>     <span class="kw">di</span>              <span class="co">;--DeltaY</span>
        <span class="kw">jnz</span>     YMa<span class="kw">jo</span>rLoop
        <span class="kw">jmp</span>     Done            <span class="co">;we&#39;re done with this line</span>

<span class="co">; It&#39;s an X-major line.</span>
        align2
<span class="fu">XMajor:</span>
<span class="co">; Calculate the 16-bit fixed-point fractional part of a pixel that Y advances</span>
<span class="co">; each time X advances 1 pixel, truncating the result to avoid overrunning</span>
<span class="co">; the endpoint along the X axis.</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>           <span class="co">;make DeltaY 16.16 fixed-point value in DX:AX</span>
        <span class="kw">div</span>     <span class="kw">cx</span>              <span class="co">;AX = (DeltaY &lt;&lt; 16) / Deltax. Won&#39;t overflow</span>
                                <span class="co">; because DeltaY &lt; DeltaX</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">cx</span>           <span class="co">;DI = DeltaX (loop count)</span>
        <span class="kw">sub</span>     <span class="kw">si</span>,SCREEN_WIDTH_IN_BYTES <span class="co">;back up the start X by 1, as</span>
                                <span class="co">; explained below</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,-<span class="dv">1</span>           <span class="co">;initialize the line error accumulator to -1,</span>
                                <span class="co">; so that it will turn over immediately and</span>
                                <span class="co">; advance Y to the start Y. This is necessary</span>
                                <span class="co">; properly to bias error sums of 0 to mean</span>
                                <span class="co">; &quot;advance next time&quot; rather than &quot;advance</span>
                                <span class="co">; this time,&quot; so that the final error sum can</span>
                                <span class="co">; never cause drawing to overrun the final Y</span>
                                <span class="co">; coordinate (works in conjunction with</span>
                                <span class="co">; truncating ErrorAdj, to make sure Y can&#39;t</span>
                                <span class="co">; overrun)</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">8</span>            <span class="co">;CL = # of bits by which to shift</span>
        <span class="kw">sub</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>].IntensityBits <span class="co">; ErrorAcc to get intensity level (8</span>
                                <span class="co">; instead of 16 because we work only</span>
                                <span class="co">; with the high byte of ErrorAcc)</span>
        <span class="kw">mov</span>     <span class="kw">ch</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].NumLevels  <span class="co">;mask used to flip all bits in an</span>
        <span class="kw">dec</span>     <span class="kw">ch</span>              <span class="co">; intensity weighting, producing</span>
                                <span class="co">; result (1 - intensity weighting)</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,BaseColor[<span class="kw">bp</span>]<span class="co">;***stack frame not available***</span>
                                <span class="co">;***from now on              ***</span>
        <span class="kw">xchg</span>    <span class="kw">bp</span>,<span class="kw">ax</span>           <span class="co">;BP = ErrorAdj, AL = BaseColor,</span>
                                <span class="co">; AH = scratch register</span>
                                <span class="co">; Draw all remaining pixels.</span>
<span class="fu">XMajorLoop:</span>
        <span class="kw">add</span>     <span class="kw">dx</span>,<span class="kw">bp</span>           <span class="co">;calculate error for next pixel</span>
        <span class="kw">jnc</span>     NoYAdvance      <span class="co">;not time to step in Y yet</span>
                                <span class="co">;the error accumulator turned over,</span>
                                <span class="co">; so advance the Y coord</span>
        <span class="kw">add</span>     <span class="kw">si</span>,SCREEN_WIDTH_IN_BYTES <span class="co">;advance Y</span>
<span class="fu">NoYAdvance:</span>
        <span class="kw">add</span>     <span class="kw">si</span>,<span class="kw">bx</span>           <span class="co">;X-major, so add XDir to the pixel pointer</span>

<span class="co">; The IntensityBits most significant bits of ErrorAcc give us the intensity</span>
<span class="co">; weighting for this pixel, and the complement of the weighting for the</span>
<span class="co">; paired pixel.</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">dh</span>           <span class="co">;msb of ErrorAcc</span>
        <span class="kw">shr</span>     <span class="kw">ah</span>,<span class="kw">cl</span>           <span class="co">;Weighting = ErrorAcc &gt;&gt; IntensityShift;</span>
        <span class="kw">add</span>     <span class="kw">ah</span>,<span class="kw">al</span>           <span class="co">;BaseColor + Weighting</span>
        <span class="kw">mov</span>     [<span class="kw">si</span>],<span class="kw">ah</span>         <span class="co">;DrawPixel(X, Y, BaseColor + Weighting);</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">dh</span>           <span class="co">;msb of ErrorAcc</span>
        <span class="kw">shr</span>     <span class="kw">ah</span>,<span class="kw">cl</span>           <span class="co">;Weighting = ErrorAcc &gt;&gt; IntensityShift;</span>
        <span class="kw">xor</span>     <span class="kw">ah</span>,<span class="kw">ch</span>           <span class="co">;Weighting ^ WeightingComplementMask</span>
        <span class="kw">add</span>     <span class="kw">ah</span>,<span class="kw">al</span>           <span class="co">;BaseColor + (Weighting ^ WeightingComplementMask)</span>
        <span class="kw">mov</span>     [<span class="kw">si</span>+SCREEN_WIDTH_IN_BYTES],<span class="kw">ah</span>
 <span class="co">;DrawPixel(X, Y+SCREEN_WIDTH_IN_BYTES,</span>
 <span class="co">; BaseColor + (Weighting ^ WeightingComplementMask));</span>
        <span class="kw">dec</span>     <span class="kw">di</span>              <span class="co">;--DeltaX</span>
        <span class="kw">jnz</span>     XMa<span class="kw">jo</span>rLoop
        
<span class="fu">Done:</span>                           <span class="co">;we&#39;re done with this line</span>
        <span class="kw">pop</span>     <span class="kw">ds</span>              <span class="co">;restore C&#39;s default data segment</span>
        <span class="kw">pop</span>     <span class="kw">di</span>              <span class="co">;restore C&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>              <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>                     <span class="co">;done</span>
_DrawWuLine endp
        end</code></pre>
<section id="notes-on-wu-antialiasing" class="level4">
<h4><a href="#notes-on-wu-antialiasing">Notes on Wu Antialiasing</a></h4>
<p>Wu antialiasing can be applied to any curve for which it’s possible to calculate at each step the positions and intensities of two bracketing pixels, although the implementation will generally be nowhere near as efficient as it is for lines. However, Wu’s article in <em>Computer Graphics</em> does describe an efficient algorithm for drawing antialiased circles. Wu also describes a technique for antialiasing solids, such as filled circles and polygons. Wu’s approach biases the edges of filled objects outward. Although this is no good for adjacent polygons of the sort used in rendering, it’s certainly possible to design a more accurate polygon-antialiasing approach around Wu’s basic weighting technique. The results would not be quite so good as more sophisticated antialiasing techniques, but they would be much faster.</p>
<blockquote>
<p><img src="images/i.jpg" /> In general, the results obtained by Wu antialiasing are only so-so, by theoretical measures. Wu antialiasing amounts to a simple box filter placed over a fixed-point step approximation of a line, and that process introduces a good deal of deviation from the ideal. On the other hand, Wu notes that even a 10 percent error in intensity doesn’t lead to noticeable loss of image quality, and for Wu-antialiased lines up to 1K pixels in length, the error is under 10 percent. If it looks good, it is good—and it looks good.</p>
</blockquote>
<p>With a 16-bit error accumulator, fixed-point inaccuracy becomes a problem for Wu-antialiased lines longer than 1K. For such lines, you should switch to using 32-bit error values, which would let you handle lines of any practical length.</p>
<p>In the listings, I have chosen to truncate, rather than round, the error-adjust value. This increases the intensity error of the line but guarantees that fixed-point inaccuracy won’t cause the minor axis to advance past the endpoint. Overrunning the endpoint would result in the drawing of pixels outside the line’s bounding box, and potentially even in an attempt to access pixels off the edge of the bitmap.</p>
<p>Finally, I should mention that, as published, Wu’s algorithm draws lines symmetrically, from both ends at once. I haven’t done this for a number of reasons, not least of which is that symmetric drawing is an inefficient way to draw lines that span banks on banked Super-VGAs. Banking aside, however, symmetric drawing is potentially faster, because it eliminates half of all calculations; in so doing, it cuts cumulative error in half, as well.</p>
<p>With or without symmetrical processing, Wu antialiasing beats fried, stewed chicken hands-down. Trust me on this one.</p>
</section>
</section>
</section>
<section id="chapter-43-bit-plane-animation" class="level2">
<h2><a href="#chapter-43-bit-plane-animation">Chapter 43 – Bit-Plane Animation</a></h2>
<section id="a-simple-and-extremely-fast-animation-method-for-limited-color" class="level3">
<h3><a href="#a-simple-and-extremely-fast-animation-method-for-limited-color">A Simple and Extremely Fast Animation Method for Limited Color</a></h3>
<p>When it comes to computers, my first love is animation. There’s nothing quite like the satisfaction of fooling the eye and creating a miniature reality simply by rearranging a few bytes of display memory. What makes animation particularly interesting is that it has to happen fast (as measured in human time), and without blinking and flickering, or else you risk destroying the illusion of motion and solidity. Those constraints make animation the toughest graphics challenge—and also the most rewarding.</p>
<p>It pains me to hear industry pundits rag on the PC when it comes to animation. Okay, I’ll grant you that the PC isn’t a Silicon Graphics workstation and never will be, but then neither is anything else on the market. The VGA offers good resolution and color, and while the hardware wasn’t <em>designed</em> for animation, that doesn’t mean we can’t put it to work in that capacity. One lesson that any good PC graphics or assembly programmer learns quickly is that it’s what the PC’s hardware <em>can</em> do—not what it was intended to do—that’s important. (By the way, if I were to pick one aspect of the PC to dump on, it would be sound, not animation. The PC’s sound circuity really is lousy, and it’s hard to understand why that should be, given that a cheap sound chip—which even the almost-forgotten PC<em>jr</em>had—would have changed everything. I guess IBM figured “serious” computer users would be put off by a computer that could make fun noises.)</p>
<p>Anyway, my point is that the PC’s animation capabilities are pretty good. There’s a trick, though: You can only push the VGA to its animation limits by stretching your mind a bit and using some unorthodox approaches to animation. In fact, stretching your mind is the key to producing good code for <em>any</em> task on the PC—that’s the topic of the first part of this book. For most software, however, it’s not fatal if your code isn’t excellent—there’s slow but functional software all over the place. When it comes to VGA animation, though, you won’t get to first base without a clever approach.</p>
<p>So, what clever approaches do I have in mind? All sorts. The resources of the VGA (or even its now-ancient predecessor, the EGA) are many and varied, and can be applied and combined in hundreds of ways to produce effective animation. For example, refer back to Chapter 23 for an example of page flipping. Or look at the July 1986 issue of <em>PC Tech Journal</em>, which describes the basic block-move animation technique, or the August 1987 issue of <em>PC Tech Journal</em>, which shows a software-sprite scheme built around the EGA’s vertical interrupt and the AND-OR image drawing technique. Or look over the rest of this book, which contains dozens of tips and tricks that can be applied to animation, including Mode X-based techniques starting in Chapter 47 that are the basis for many commercial games.</p>
<p>This chapter adds yet another sort of animation to the list. We’re going to take advantage of the bit-plane architecture and color palette of the VGA to develop an animation architecture that can handle several overlapping images with terrific speed and with virtually perfect visual quality. This technique produces no overlap effects or flicker and allows us to use the fastest possible method to draw images—the <code>REP MOVS</code> instruction. It has its limitations, but unlike Mode X and some other animation techniques, the techniques I’ll show you in this chapter will also work on the EGA, which may be important in some applications.</p>
<p>As with any technique on the PC, there are tradeoffs involved with bit-plane animation. While bit-plane animation is extremely attractive as far as performance and visual quality are concerned, it is somewhat limited. Bit-plane animation supports only four colors plus the background color at any one time, each image must consist of only one of the four colors, and it’s preferable that images of the same color not intersect.</p>
<p>It doesn’t much matter if bit-plane animation isn’t perfect for all applications, though. The real point of showing you bit-plane animation is to bring home the reality that the VGA is a complex adapter with many resources, and that you can do remarkable things if you understand those resources and come up with creative ways to put them to work at specific tasks.</p>
</section>
<section id="bit-planes-the-basics" class="level3">
<h3><a href="#bit-planes-the-basics">Bit-Planes: The Basics</a></h3>
<p>The underlying principle of bit-plane animation is extremely simple. The VGA has four separate bit planes in modes 0DH, 0EH, 10H, and 12H. Plane 0 normally contains data for the blue component of pixel color, plane 1 normally contains green pixel data, plane 2 red pixel data, and plane 3 intensity pixel data—but we’re going to mix that up a bit in a moment, so we’ll simply refer to them as planes 0, 1, 2, and 3 from now on.</p>
<p>Each bit plane can be written to independently. The contents of the four bit planes are used to generate pixels, with the four bits that control the color of each pixel coming from the four planes. However, the bits from the planes go through a look-up stage on the way to becoming pixels—they’re used to look up a 6-bit color from one of the sixteen palette registers. Figure 43.1 shows how the bits from the four planes feed into the palette registers to select the color of each pixel. (On the VGA specifically, the output of the palette registers goes to the DAC for an additional look-up stage, as described in Chapters 33 and 34 and also Chapter A on the companion CD-ROM.)</p>
<p>Take a good look at Figure 43.1. Any light bulbs going on over your head yet? If not, consider this. The general problem with VGA animation is that it’s complex and time-consuming to manipulate images that span the four planes (as most do), and that it’s hard to avoid interference problems when images intersect, since those images share the same bits in display memory. Since the four bit planes can be written to and read from independently, it should be apparent that if we could come up with a way to display images from each plane independently of whatever images are stored in the other planes, we would have four sets of images that we could manipulate very easily. There would be no interference effects between images in different planes, because images in one plane wouldn’t share bits with images in another plane. What’s more, since all the bits for a given image would reside in a single plane, we could do away with the cumbersome programming of the VGA’s complex hardware that is needed to manipulate images that span multiple planes.</p>
<figure>
<img src="images/43-01.jpg" alt="Figure 43.1  How 4 bits of video data become 6 bits of color." /><figcaption><strong>Figure 43.1</strong>  <em>How 4 bits of video data become 6 bits of color.</em></figcaption>
</figure>
<p>All in all, it would be a good deal if we could store each image in a single plane, as shown in Figure 43.2. However, a problem arises when images in different planes overlap, as shown in Figure 43.3. The combined bits from overlapping images generate new colors, so the overlapping parts of the images don’t look like they belong to either of the two images. What we really want, of course, is for one of the images to appear to be in front of the other. It would be better yet if the rearward image showed through any transparent (that is, background-colored) parts of the forward image. Can we do that?</p>
<p>You bet.</p>
<figure>
<img src="images/43-02.jpg" alt="Figure 43.2  Storing images in separate planes." /><figcaption><strong>Figure 43.2</strong>  <em>Storing images in separate planes.</em></figcaption>
</figure>
<figure>
<img src="images/43-03.jpg" alt="Figure 43.3  The problem of overlapping colors." /><figcaption><strong>Figure 43.3</strong>  <em>The problem of overlapping colors.</em></figcaption>
</figure>
<section id="stacking-the-palette-registers" class="level4">
<h4><a href="#stacking-the-palette-registers">Stacking the Palette Registers</a></h4>
<p>Suppose that instead of viewing the four bits per pixel coming out of display memory as selecting one of sixteen colors,we view those bits as selecting one of <em>four</em> colors. If the bit from plane 0 is 1, that would select color 0 (say, red). The bit from plane 1 would select color 1 (say, green), the bit from plane 2 would select color 2 (say, blue), and the bit from plane 3 would select color 3 (say, white). Whenever more than 1 bit is 1, the 1 bit from the lowest-numbered plane would determine the color, and 1 bits from all other planes would be ignored. Finally, the absence of any 1 bits at all would select the background color (say, black).</p>
<p>That would give us four colors and the background color. It would also give us nifty image precedence, with images in plane 0 appearing to be in front of images from the other planes, images in plane 1 appearing to be in front of images from planes 2 and 3, and so on. It would even give us transparency, where rearward images would show through holes within and around the edges of images in forward planes. Finally, and most importantly, it would meet all the criteria needed to allow us to store each image in a single plane, letting us manipulate the images very quickly and with no reprogramming of the VGA’s hardware other than the few <code>OUT</code> instructions required to select the plane we want to write to.</p>
<p>Which leaves only one question: How do we get this magical pixel-precedence scheme to work? As it turns out, all we need to do is reprogram the palette registers so that the 1 bit from the plane with the highest precedence determines the color. The palette RAM settings for the colors described above are summarized in Table 43.1.</p>
<p>Remember that the 4-bit values coming from display memory select which palette register provides the actual pixel color. Given that, it’s easy to see that the rightmost 1-bit of the four bits coming from display memory in Table 43.1 selects the pixel color. If the bit from plane 0 is 1, then the color is red, no matter what the other bits are, as shown in Figure 43.4. If the bit from plane 0 is 0, then if the bit from plane 1 is 1 the color is green, and so on for planes 2 and 3. In other words, with the palette register settings we instantly have exactly what we want, which is an approach that keeps images in one plane from interfering with images in other planes while providing precedence and transparency.</p>
<table>
<caption>Table 43.1 Palette RAM settings for bit-plane animation.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Bit Value For Plane<br /> 3 2 1 0</th>
<th style="text-align: left;">Palette Register</th>
<th style="text-align: left;">Register setting</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0 0 0 0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">00H (black)</td>
</tr>
<tr class="even">
<td style="text-align: left;">0 0 0 1</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">3CH (red)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">0 0 1 0</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">3AH (green)</td>
</tr>
<tr class="even">
<td style="text-align: left;">0 0 1 1</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">3CH (red)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">0 1 0 0</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">39H (blue)</td>
</tr>
<tr class="even">
<td style="text-align: left;">0 1 0 1</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">3CH (red)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">0 1 1 0</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">3AH (green)</td>
</tr>
<tr class="even">
<td style="text-align: left;">0 1 1 1</td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">3CH (red)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1 0 0 0</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">3FH (white)</td>
</tr>
<tr class="even">
<td style="text-align: left;">1 0 0 1</td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">3CH (red)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1 0 1 0</td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">3AH (green)</td>
</tr>
<tr class="even">
<td style="text-align: left;">1 0 1 1</td>
<td style="text-align: left;">11</td>
<td style="text-align: left;">3CH (red)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1 1 0 0</td>
<td style="text-align: left;">12</td>
<td style="text-align: left;">39H (blue)</td>
</tr>
<tr class="even">
<td style="text-align: left;">1 1 0 1</td>
<td style="text-align: left;">13</td>
<td style="text-align: left;">3CH (red)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1 1 1 0</td>
<td style="text-align: left;">14</td>
<td style="text-align: left;">3AH (green)</td>
</tr>
<tr class="even">
<td style="text-align: left;">1 1 1 1</td>
<td style="text-align: left;">15</td>
<td style="text-align: left;">3CH (red)</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/43-04.jpg" alt="Figure 43.4  How pixel precedence works." /><figcaption><strong>Figure 43.4</strong>  <em>How pixel precedence works.</em></figcaption>
</figure>
<p>Seems almost too easy, doesn’t it? Nonetheless, it works beautifully, as we’ll see very shortly. First, though, I’d like to point out that there’s nothing sacred about plane 0 having precedence. We could rearrange the palette register settings so that any plane had the highest precedence, followed by the other planes in any order. I’ve chosen to make plane 0 the highest precedence only because it seems simplest to think of plane 0 as appearing in front of plane 1, which is in front of plane 2, which is in front of plane 3.</p>
</section>
</section>
<section id="bit-plane-animation-in-action" class="level3">
<h3><a href="#bit-plane-animation-in-action">Bit-Plane Animation in Action</a></h3>
<p>Without further ado, Listing 43.1 shows bit-plane animation in action. Listing 43.1 animates 13 rather large images (each 32 pixels on a side) over a complex background at a good clip <em>even on a primordial 8088-based PC</em>. Five of the images move very quickly, while the other 8 bounce back and forth at a steady pace.</p>
<p><strong>LISTING 43.1 L43-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Program to demonstrate bit-plane animation. Performs</span>
<span class="co">; flicker-free animation with image transparency and</span>
<span class="co">; image precedence across four distinct planes, with</span>
<span class="co">; 13 32x32 images kept in motion at once.</span>
<span class="co">;</span>
<span class="co">;</span>
<span class="co">; Set to higher values to slow down on faster computers.</span>
<span class="co">; 0 is fine for a PC. 500 is a reasonable setting for an AT.</span>
<span class="co">; Slowing animation further allows a good look at</span>
<span class="co">; transparency and the lack of flicker and color effects</span>
<span class="co">; when images cross.</span>
<span class="co">;</span>
SLOWDOWN        <span class="dt">equ</span>     <span class="dv">10000</span>
<span class="co">;</span>
<span class="co">; Plane selects for the four colors we&#39;re using.</span>
<span class="co">;</span>
RED     <span class="dt">equ</span><span class="bn">     01h</span>
GREEN   <span class="dt">equ</span><span class="bn">     02h</span>
BLUE    <span class="dt">equ</span><span class="bn">     04h</span>
WHITE   <span class="dt">equ</span><span class="bn">     08h</span>
<span class="co">;</span>
VGA_SEGMENT     <span class="dt">equ</span><span class="bn">     0a000h  </span><span class="co">;mode 10h display memory</span>
                                <span class="co">; segment</span>
SC_INDEX        <span class="dt">equ</span><span class="bn">     3c4h    </span><span class="co">;Sequence Controller Index</span>
                                <span class="co">; register</span>
MAP_MASK        <span class="dt">equ</span>     <span class="dv">2</span>       <span class="co">;Map Mask register index in</span>
                                <span class="co">; Sequence Controller</span>
SCREEN_WIDTH    <span class="dt">equ</span>     <span class="dv">80</span>      <span class="co">;# of bytes across screen</span>
SCREEN_HEIGHT   <span class="dt">equ</span>     <span class="dv">350</span>     <span class="co">;# of scan lines on screen</span>
WORD_OUTS_OK    <span class="dt">equ</span>     <span class="dv">1</span>       <span class="co">;set to 0 to assemble for</span>
                                <span class="co">; computers that can&#39;t</span>
                                <span class="co">; handle word outs to</span>
                                <span class="co">; indexed VGA regs</span>
                                <span class="co">;</span>
stack <span class="kw">segment</span> para stack ‘STACK<span class="st">&#39;</span>
        <span class="dt">db</span>      <span class="dv">512</span> dup (?)
stack ends
<span class="co">;</span>
<span class="co">; Complete info about one object that we&#39;re animating.</span>
<span class="co">;</span>
Ob<span class="kw">je</span>ctStructure         <span class="kw">struc</span>
Delay   <span class="dt">dw</span>      ?       <span class="co">;used to delay for n passes</span>
                        <span class="co">; throught the loop to</span>
                        <span class="co">; control animation speed</span>
BaseDelay <span class="dt">dw</span>    ?       <span class="co">;reset value for Delay</span>
Image   <span class="dt">dw</span>      ?       <span class="co">;pointer to drawing info</span>
                        <span class="co">; for object</span>
XCoord  <span class="dt">dw</span>      ?       <span class="co">;object X location in pixels</span>
XInc    <span class="dt">dw</span>      ?       <span class="co">;# of pixels to increment</span>
                        <span class="co">; location by in the X</span>
                        <span class="co">; direction on each move</span>
XLeftLimit <span class="dt">dw</span>   ?       <span class="co">;left limit of X motion</span>
XRightLimit <span class="dt">dw</span>  ?       <span class="co">;right limit of X motion</span>
YCoord  <span class="dt">dw</span>      ?       <span class="co">;object Y location in pixels</span>
YInc    <span class="dt">dw</span>      ?       <span class="co">;# of pixels to increment</span>
                        <span class="co">; location by in the Y</span>
                        <span class="co">; direction on each move</span>
YTopLimit <span class="dt">dw</span>    ?       <span class="co">;top limit of Y motion</span>
YBottomLimit <span class="dt">dw</span> ?       <span class="co">;bottom limit of Y motion</span>
PlaneSelect <span class="dt">db</span>  ?       <span class="co">;mask to select plane to</span>
                        <span class="co">; which object is drawn</span>
          <span class="dt">db</span>    ?       <span class="co">;to make an even # of words</span>
                        <span class="co">; long, for better 286</span>
                        <span class="co">; performance (keeps the</span>
                        <span class="co">; following structure</span>
                        <span class="co">; word-aligned)</span>
Ob<span class="kw">je</span>ctStructure ends
<span class="co">;</span>
Data <span class="kw">segment</span>    <span class="dt">word</span> ‘DATA<span class="st">&#39;</span>
<span class="co">;</span>
<span class="co">; Palette settings to give plane 0 precedence, followed by</span>
<span class="co">; planes 1, 2, and 3. Plane 3 has the lowest precedence (is</span>
<span class="co">; obscured by any other plane), while plane 0 has the</span>
<span class="co">; highest precedence (displays in front of any other plane).</span>
<span class="co">;</span>
Colors  <span class="dt">db</span><span class="bn">      000h    </span><span class="co">;background color=black</span>
        <span class="dt">db</span><span class="bn">      03ch    </span><span class="co">;plane 0 only=red</span>
        <span class="dt">db</span><span class="bn">      03ah    </span><span class="co">;plane 1 only=green</span>
        <span class="dt">db</span><span class="bn">      03ch    </span><span class="co">;planes 0&amp;1=red (plane 0 priority)</span>
        <span class="dt">db</span><span class="bn">      039h    </span><span class="co">;plane 2 only=blue</span>
        <span class="dt">db</span><span class="bn">      03ch    </span><span class="co">;planes 0&amp;2=red (plane 0 priority)</span>
        <span class="dt">db</span><span class="bn">      03ah    </span><span class="co">;planes 1&amp;2=green (plane 1 priority)</span>
        <span class="dt">db</span><span class="bn">      03ch    </span><span class="co">;planes 0&amp;1&amp;2=red (plane 0 priority)</span>
        <span class="dt">db</span><span class="bn">      03fh    </span><span class="co">;plane 3 only=white</span>
        <span class="dt">db</span><span class="bn">      03ch    </span><span class="co">;planes 0&amp;3=red (plane 0 priority)</span>
        <span class="dt">db</span><span class="bn">      03ah    </span><span class="co">;planes 1&amp;3=green (plane 1 priority)</span>
        <span class="dt">db</span><span class="bn">      03ch    </span><span class="co">;planes 0&amp;1&amp;3=red (plane 0 priority)</span>
        <span class="dt">db</span><span class="bn">      039h    </span><span class="co">;planes 2&amp;3=blue (plane 2 priority)</span>
        <span class="dt">db</span><span class="bn">      03ch    </span><span class="co">;planes 0&amp;2&amp;3=red (plane 0 priority)</span>
        <span class="dt">db</span><span class="bn">      03ah    </span><span class="co">;planes 1&amp;2&amp;3=green (plane 1 priority)</span>
        <span class="dt">db</span><span class="bn">      03ch    </span><span class="co">;planes 0&amp;1&amp;2&amp;3=red (plane 0 priority)</span>
        <span class="dt">db</span><span class="bn">      000h    </span><span class="co">;border color=black</span>
<span class="co">;</span>
<span class="co">; Image of a hollow square.</span>
<span class="co">; There&#39;s an 8-pixel-wide blank border around all edges</span>
<span class="co">; so that the image erases the old version of itself as</span>
<span class="co">; it&#39;s moved and redrawn.</span>
<span class="co">;</span>
Square  label   <span class="dt">byte</span>
        <span class="dt">dw</span> <span class="dv">48</span>,<span class="dv">6</span>    <span class="co">;height in pixels, width in bytes</span>
        rept    <span class="dv">8</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span><span class="co">;top blank border</span>
        endm
        .radix  <span class="dv">2</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">00000000</span>,<span class="dv">00000000</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">11111111</span>,<span class="dv">0</span>
        .radix  <span class="dv">10</span>
        rept    <span class="dv">8</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span><span class="co">;bottom blank border</span>
        endm
<span class="co">;</span>
<span class="co">; Image of a hollow diamond with a smaller diamond in the</span>
<span class="co">; middle.</span>
<span class="co">; There&#39;s an 8-pixel-wide blank border around all edges</span>
<span class="co">; so that the image erases the old version of itself as</span>
<span class="co">; it&#39;s moved and redrawn.</span>
<span class="co">;</span>
Diamond label <span class="dt">byte</span>
        <span class="dt">dw</span>      <span class="dv">48</span>,<span class="dv">6</span>    <span class="co">;height in pixels, width in bytes</span>
        rept    <span class="dv">8</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span><span class="co">;top blank border</span>
        endm
        .radix  <span class="dv">2</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">00000001</span>,<span class="dv">10000000</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">00000011</span>,<span class="dv">11000000</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">00000111</span>,<span class="dv">11100000</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">00001111</span>,<span class="dv">11110000</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">00011111</span>,<span class="dv">11111000</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">00111110</span>,<span class="dv">01111100</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">01111100</span>,<span class="dv">00111110</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">11111000</span>,<span class="dv">00011111</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000001</span>,<span class="dv">11110000</span>,<span class="dv">00001111</span>,<span class="dv">10000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000011</span>,<span class="dv">11100000</span>,<span class="dv">00000111</span>,<span class="dv">11000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000111</span>,<span class="dv">11000000</span>,<span class="dv">00000011</span>,<span class="dv">11100000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00001111</span>,<span class="dv">10000001</span>,<span class="dv">10000001</span>,<span class="dv">11110000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00011111</span>,<span class="dv">00000011</span>,<span class="dv">11000000</span>,<span class="dv">11111000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00111110</span>,<span class="dv">00000111</span>,<span class="dv">11100000</span>,<span class="dv">01111100</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">01111100</span>,<span class="dv">00001111</span>,<span class="dv">11110000</span>,<span class="dv">00111110</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111000</span>,<span class="dv">00011111</span>,<span class="dv">11111000</span>,<span class="dv">00011111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">11111000</span>,<span class="dv">00011111</span>,<span class="dv">11111000</span>,<span class="dv">00011111</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">01111100</span>,<span class="dv">00001111</span>,<span class="dv">11110000</span>,<span class="dv">00111110</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00111110</span>,<span class="dv">00000111</span>,<span class="dv">11100000</span>,<span class="dv">01111100</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00011111</span>,<span class="dv">00000011</span>,<span class="dv">11000000</span>,<span class="dv">11111000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00001111</span>,<span class="dv">10000001</span>,<span class="dv">10000001</span>,<span class="dv">11110000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000111</span>,<span class="dv">11000000</span>,<span class="dv">00000011</span>,<span class="dv">11100000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000011</span>,<span class="dv">11100000</span>,<span class="dv">00000111</span>,<span class="dv">11000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000001</span>,<span class="dv">11110000</span>,<span class="dv">00001111</span>,<span class="dv">10000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">11111000</span>,<span class="dv">00011111</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">01111100</span>,<span class="dv">00111110</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">00111110</span>,<span class="dv">01111100</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">00011111</span>,<span class="dv">11111000</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">00001111</span>,<span class="dv">11110000</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">00000111</span>,<span class="dv">11100000</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">00000011</span>,<span class="dv">11000000</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">00000000</span>,<span class="dv">00000001</span>,<span class="dv">10000000</span>,<span class="dv">00000000</span>,<span class="dv">0</span>
        .radix  <span class="dv">10</span>
        rept    <span class="dv">8</span>
        <span class="dt">db</span>      <span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span><span class="co">;    bottom blank border</span>
        endm
<span class="co">;</span>
<span class="co">; List of objects to animate.</span>
<span class="co">;</span>
even<span class="co">;word-align for better 286 performance</span>
<span class="co">;</span>
Ob<span class="kw">je</span>ctListlabelOb<span class="kw">je</span>ctStructure
 Ob<span class="kw">je</span>ctStructure &lt;<span class="dv">1</span>,<span class="dv">21</span>,Diamond,<span class="dv">88</span>,<span class="dv">8</span>,<span class="dv">80</span>,<span class="dv">512</span>,<span class="dv">16</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">350</span>,RED&gt;
 Ob<span class="kw">je</span>ctStructure &lt;<span class="dv">1</span>,<span class="dv">15</span>,Square,<span class="dv">296</span>,<span class="dv">8</span>,<span class="dv">112</span>,<span class="dv">480</span>,<span class="dv">144</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">350</span>,RED&gt;
 Ob<span class="kw">je</span>ctStructure &lt;<span class="dv">1</span>,<span class="dv">23</span>,Diamond,<span class="dv">88</span>,<span class="dv">8</span>,<span class="dv">80</span>,<span class="dv">512</span>,<span class="dv">256</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">350</span>,RED&gt;
 Ob<span class="kw">je</span>ctStructure &lt;<span class="dv">1</span>,<span class="dv">13</span>,Square,<span class="dv">120</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">640</span>,<span class="dv">144</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">280</span>,BLUE&gt;
 Ob<span class="kw">je</span>ctStructure &lt;<span class="dv">1</span>,<span class="dv">11</span>,Diamond,<span class="dv">208</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">640</span>,<span class="dv">144</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">280</span>,BLUE&gt;
 Ob<span class="kw">je</span>ctStructure &lt;<span class="dv">1</span>,<span class="dv">8</span>,Square,<span class="dv">296</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">640</span>,<span class="dv">144</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">288</span>,BLUE&gt;
 Ob<span class="kw">je</span>ctStructure &lt;<span class="dv">1</span>,<span class="dv">9</span>,Diamond,<span class="dv">384</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">640</span>,<span class="dv">144</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">288</span>,BLUE&gt;
 Ob<span class="kw">je</span>ctStructure &lt;<span class="dv">1</span>,<span class="dv">14</span>,Square,<span class="dv">472</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">640</span>,<span class="dv">144</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">280</span>,BLUE&gt;
 Ob<span class="kw">je</span>ctStructure &lt;<span class="dv">1</span>,<span class="dv">8</span>,Diamond,<span class="dv">200</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">576</span>,<span class="dv">48</span>,<span class="dv">6</span>,<span class="dv">0</span>,<span class="dv">280</span>,GREEN&gt;
 Ob<span class="kw">je</span>ctStructure &lt;<span class="dv">1</span>,<span class="dv">8</span>,Square,<span class="dv">248</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">576</span>,<span class="dv">96</span>,<span class="dv">6</span>,<span class="dv">0</span>,<span class="dv">280</span>,GREEN&gt;
 Ob<span class="kw">je</span>ctStructure &lt;<span class="dv">1</span>,<span class="dv">8</span>,Diamond,<span class="dv">296</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">576</span>,<span class="dv">144</span>,<span class="dv">6</span>,<span class="dv">0</span>,<span class="dv">280</span>,GREEN&gt;
 Ob<span class="kw">je</span>ctStructure &lt;<span class="dv">1</span>,<span class="dv">8</span>,Square,<span class="dv">344</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">576</span>,<span class="dv">192</span>,<span class="dv">6</span>,<span class="dv">0</span>,<span class="dv">280</span>,GREEN&gt;
 Ob<span class="kw">je</span>ctStructure &lt;<span class="dv">1</span>,<span class="dv">8</span>,Diamond,<span class="dv">392</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">576</span>,<span class="dv">240</span>,<span class="dv">6</span>,<span class="dv">0</span>,<span class="dv">280</span>,GREEN&gt;
Ob<span class="kw">je</span>ctListEndlabelOb<span class="kw">je</span>ctStructure
<span class="co">;</span>
Dataends
<span class="co">;</span>
<span class="co">; Macro to output a word value to a port.</span>
<span class="co">;</span>
OUT_WORDmacro
if WORD_OUTS_OK
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>
else
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>
        <span class="kw">xchg</span>    <span class="kw">ah</span>,<span class="kw">al</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">xchg</span>    <span class="kw">ah</span>,<span class="kw">al</span>
endif
        endm
<span class="co">;</span>
<span class="co">; Macro to output a constant value to an indexed VGA</span>
<span class="co">; register.</span>
<span class="co">;</span>
CONSTANT_TO_INDEXED_REGISTERmacro ADDRESS, INDEX, VALUE
        movdx,  ADDRESS
        movax,  (VALUE <span class="kw">shl</span> <span class="dv">8</span>) + INDEX
        OUT_WORD
        endm
<span class="co">;</span>
Code    <span class="kw">segment</span>
        assume  <span class="kw">cs</span>:Code, <span class="kw">ds</span>:Data
Start   proc    near
        <span class="kw">cld</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>, Data
        <span class="kw">mov</span>     <span class="kw">ds</span>, <span class="kw">ax</span>
<span class="co">;</span>
<span class="co">; Set 640x350 16-color mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0010h        </span><span class="co">;AH=0 means select mode</span>
                                <span class="co">;AL=10h means select</span>
                                <span class="co">; mode 10h</span>
        <span class="kw">int</span><span class="bn">     10h             </span><span class="co">;BIOS video interrupt</span>
<span class="co">;</span>
<span class="co">; Set the palette up to provide bit-plane precedence. If</span>
<span class="co">; planes 0 &amp; 1 overlap, the plane 0 color will be shown;</span>
<span class="co">; if planes 1 &amp; 2 overlap, the plane 1 color will be</span>
<span class="co">; shown; and so on.</span>
<span class="co">;</span>
        <span class="kw">mov</span>  <span class="kw">ax</span>,(10h <span class="kw">shl</span> <span class="dv">8</span>) + <span class="dv">2</span>      <span class="co">;AH = 10h means</span>
                                     <span class="co">; set palette</span>
                                     <span class="co">; registers fn</span>
                                     <span class="co">;AL = 2 means set</span>
                                     <span class="co">; all palette</span>
                                     <span class="co">; registers</span>
        <span class="kw">push</span>    <span class="kw">ds</span>                   <span class="co">;ES:DX points to</span>
        <span class="kw">pop</span>     <span class="kw">es</span>                   <span class="co">; the palette</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,offset Colors     <span class="co">; settings</span>
        <span class="kw">int</span><span class="bn">     10h                  </span><span class="co">;call the BIOS to</span>
                                     <span class="co">; set the palette                       </span>
<span class="co">;</span>
<span class="co">; Draw the static backdrop in plane 3. All the moving images</span>
<span class="co">; will appear to be in front of this backdrop, since plane 3</span>
<span class="co">; has the lowest precedence the way the palette is set up.</span>
<span class="co">;</span>
        CONSTANT_TO_INDEXED_REGISTER SC_INDEX, MAP_MASK<span class="bn">, 08h</span>
                                        <span class="co">;allow data to go to</span>
                                        <span class="co">; plane 3 only</span>
<span class="co">;</span>
<span class="co">; Point ES to display memory for the rest of the program.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,VGA_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
<span class="co">;</span>
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,SCREEN_HEIGHT/<span class="dv">16</span>     <span class="co">;fill in the screen</span>
                                        <span class="co">; 16 lines at a time</span>
<span class="fu">BackdropBlockLoop:</span>
        <span class="kw">call</span>    DrawGridCross           <span class="co">;draw a cross piece</span>
        <span class="kw">call</span>    DrawGridVert            <span class="co">;draw the rest of a</span>
                                        <span class="co">; 15-high block</span>
        <span class="kw">dec</span>     <span class="kw">bp</span>
        <span class="kw">jnz</span>     BackdropBlockLoop
        <span class="kw">call</span>    DrawGridCross           <span class="co">;bottom line of grid</span>
<span class="co">;</span>
<span class="co">; Start animating!</span>
<span class="co">;</span>
<span class="fu">AnimationLoop:</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,offset Ob<span class="kw">je</span>ctList    <span class="co">;point to the first</span>
                                        <span class="co">; object in the list</span>
<span class="co">;</span>
<span class="co">; For each object, see if it&#39;s time to move and draw that</span>
<span class="co">; object.</span>
<span class="co">;</span>
<span class="fu">ObjectLoop:</span>
<span class="co">;</span>
<span class="co">; See if it&#39;s time to move this object.</span>
<span class="co">;</span>
        <span class="kw">dec</span>  [<span class="kw">bx</span>+Delay]            <span class="co">;count down delay</span>
        <span class="kw">jnz</span>  DoNextOb<span class="kw">je</span>ct          <span class="co">;still delaying-don&#39;t move</span>
        <span class="kw">mov</span>  <span class="kw">ax</span>,[<span class="kw">bx</span>+BaseDelay]
        <span class="kw">mov</span>  [<span class="kw">bx</span>+Delay],<span class="kw">ax</span>         <span class="co">;reset delay for next time</span>
<span class="co">;</span>
<span class="co">; Select the plane that this object will be drawn in.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">ah</span>,[<span class="kw">bx</span>+PlaneSelect]
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK
        OUT_WORD
<span class="co">;</span>
<span class="co">; Advance the X coordinate, reversing direction if either</span>
<span class="co">; of the X margins has been reached.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bx</span>+XCoord]          <span class="co">;current X location</span>
        <span class="kw">cmp</span>     <span class="kw">cx</span>,[<span class="kw">bx</span>+XLeftLimit]      <span class="co">;at left limit?</span>
        <span class="kw">ja</span>      CheckXRightLimit        <span class="co">;no</span>
        <span class="kw">neg</span>     [<span class="kw">bx</span>+XInc]               <span class="co">;yes-reverse</span>
<span class="fu">CheckXRightLimit:</span>
        <span class="kw">cmp</span>     <span class="kw">cx</span>,[<span class="kw">bx</span>+XRightLimit]     <span class="co">;at right limit?</span>
        <span class="kw">jb</span>      SetNewX                 <span class="co">;no</span>
        <span class="kw">neg</span>     [<span class="kw">bx</span>+XInc]               <span class="co">;yes-reverse</span>
<span class="fu">SetNewX:</span>
        <span class="kw">add</span>     <span class="kw">cx</span>,[<span class="kw">bx</span>+XInc]            <span class="co">;move the X coord</span>
        <span class="kw">mov</span>     [<span class="kw">bx</span>+XCoord],<span class="kw">cx</span>          <span class="co">; &amp; save it</span>
<span class="co">;</span>
<span class="co">; Advance the Y coordinate, reversing direction if either</span>
<span class="co">; of the Y margins has been reached.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bx</span>+YCoord]    <span class="co">;current Y location</span>
        <span class="kw">cmp</span>     <span class="kw">dx</span>,[<span class="kw">bx</span>+YTopLimit]   <span class="co">;at top limit?</span>
        <span class="kw">ja</span>      CheckYBottomLimit   <span class="co">;no</span>
        <span class="kw">neg</span>     [<span class="kw">bx</span>+YInc]    <span class="co">;yes-reverse</span>
<span class="fu">CheckYBottomLimit:</span>
        <span class="kw">cmp</span>     <span class="kw">dx</span>,[<span class="kw">bx</span>+YBottomLimit]    <span class="co">;at bottom limit?</span>
        <span class="kw">jb</span>      SetNewY    <span class="co">;no</span>
        <span class="kw">neg</span>     [<span class="kw">bx</span>+YInc]    <span class="co">;yes-reverse</span>
<span class="fu">SetNewY:</span>
        <span class="kw">add</span>     <span class="kw">dx</span>,[<span class="kw">bx</span>+YInc]    <span class="co">;move the Y coord</span>
        <span class="kw">mov</span>     [<span class="kw">bx</span>+YCoord],<span class="kw">dx</span>    <span class="co">; &amp; save it</span>
<span class="co">;</span>
<span class="co">; Draw at the new location. Because of the plane select</span>
<span class="co">; above, only one plane will be affected.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bx</span>+Image]   <span class="co">;point to the</span>
                                <span class="co">; object&#39;s image</span>
                                <span class="co">; info</span>
        <span class="kw">call</span>    DrawOb<span class="kw">je</span>ct
<span class="co">;</span>
<span class="co">; Point to the next object in the list until we run out of</span>
<span class="co">; objects.</span>
<span class="co">;</span>
<span class="fu">DoNextObject:</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,size Ob<span class="kw">je</span>ctStructure
        <span class="kw">cmp</span>     <span class="kw">bx</span>,offset Ob<span class="kw">je</span>ctListEnd
        <span class="kw">jb</span>      Ob<span class="kw">je</span>ctLoop
<span class="co">;</span>
<span class="co">; Delay as specified to slow things down.</span>
<span class="co">;</span>
if SLOWDOWN
        <span class="kw">mov</span>     <span class="kw">cx</span>,SLOWDOWN
<span class="fu">DelayLoop:</span>
        <span class="kw">loop</span>    DelayLoop
endif
<span class="co">;</span>
<span class="co">; If a key&#39;s been pressed, we&#39;re done, otherwise animate</span>
<span class="co">; again.</span>
<span class="co">;</span>
<span class="fu">CheckKey:</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dv">1</span>
        <span class="kw">int</span><span class="bn">     16h             </span><span class="co">;is a key waiting?</span>
        <span class="kw">jz</span>      AnimationLoop   <span class="co">;no</span>
        <span class="kw">sub</span>     <span class="kw">ah</span>,<span class="kw">ah</span>
        <span class="kw">int</span><span class="bn">     16h             </span><span class="co">;yes-clear the key &amp; done</span>
<span class="co">;</span>
<span class="co">; Back to text mode.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0003h        </span><span class="co">;AL=03h means select</span>
                                <span class="co">; mode 03h</span>
        <span class="kw">int</span><span class="bn">     10h</span>
<span class="co">;</span>
<span class="co">; Back to DOS.</span>
<span class="co">;</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,4ch          </span><span class="co">;DOS terminate function</span>
        <span class="kw">int</span><span class="bn">     21h             </span><span class="co">;done</span>
<span class="co">;</span>
Start endp
<span class="co">;</span>
<span class="co">; Draws a single grid cross-element at the display memory</span>
<span class="co">; location pointed to by ES:DI. 1 horizontal line is drawn</span>
<span class="co">; across the screen.</span>
<span class="co">;</span>
<span class="co">; Input: ES:DI points to the address at which to draw</span>
<span class="co">;</span>
<span class="co">; Output: ES:DI points to the address following the</span>
<span class="co">;       line drawn</span>
<span class="co">;</span>
<span class="co">; Registers altered: AX, CX, DI</span>
<span class="co">;</span>
DrawGridCross   proc    near
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0ffffh       </span><span class="co">;draw a solid line</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,SCREEN_WIDTH/<span class="dv">2-1</span>
        rep     <span class="kw">stosw</span>           <span class="co">;draw all but the rightmost</span>
                                <span class="co">; edge</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0080h</span>
        <span class="kw">stosw</span>                   <span class="co">;draw the right edge of the</span>
                                <span class="co">; grid</span>
        <span class="kw">ret</span>
DrawGridCross   endp
<span class="co">;</span>
<span class="co">; Draws the non-cross part of the grid at the display memory</span>
<span class="co">; location pointed to by ES:DI. 15 scan lines are filled.</span>
<span class="co">;</span>
<span class="co">; Input: ES:DI points to the address at which to draw</span>
<span class="co">;</span>
<span class="co">; Output: ES:DI points to the address following the</span>
<span class="co">;       part of the grid drawn</span>
<span class="co">;</span>
<span class="co">; Registers altered: AX, CX, DX, DI</span>
<span class="co">;</span>
DrawGridVert    proc    near
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0080h        </span><span class="co">;pattern for a vertical line</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dv">15</span>           <span class="co">;draw 15 scan lines (all of</span>
                                <span class="co">; a grid block except the</span>
                                <span class="co">; solid cross line)</span>
<span class="fu">BackdropRowLoop:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,SCREEN_WIDTH/<span class="dv">2</span>
        rep     <span class="kw">stosw</span>           <span class="co">;draw this scan line&#39;s bit</span>
                                <span class="co">; of all the vertical lines</span>
                                <span class="co">; on the screen</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">jnz</span>     BackdropRowLoop
        <span class="kw">ret</span>
        DrawGridVert    endp
<span class="co">;</span>
<span class="co">; Draw the specified image at the specified location.</span>
<span class="co">; Images are drawn on byte boundaries horizontally, pixel</span>
<span class="co">; boundaries vertically.</span>
<span class="co">; The Map Mask register must already have been set to enable</span>
<span class="co">; access to the desired plane.</span>
<span class="co">;</span>
<span class="co">; Input:</span>
<span class="co">;       CX - X coordinate of upper left corner</span>
<span class="co">;       DX - Y coordinate of upper left corner</span>
<span class="co">;       DS:SI - pointer to draw info for image</span>
<span class="co">;       ES - display memory segment</span>
<span class="co">;</span>
<span class="co">; Output: none</span>
<span class="co">;</span>
<span class="co">; Registers altered: AX, CX, DX, SI, DI, BP</span>
<span class="co">;</span>
DrawOb<span class="kw">je</span>ct      proc    near
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_WIDTH
        <span class="kw">mul</span>     <span class="kw">dx</span>              <span class="co">;calculate the start offset in</span>
                                <span class="co">; display memory of the row the</span>
                                <span class="co">; image will be drawn at</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>            <span class="co">;divide the X coordinate in pixels</span>
                                <span class="co">; by 8 to get the X coordinate in</span>
                                <span class="co">; bytes</span>
        <span class="kw">add</span>     <span class="kw">ax</span>,<span class="kw">cx</span>           <span class="co">;destination offset in display</span>
                                <span class="co">; memory for the image</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,<span class="kw">ax</span>           <span class="co">;point ES:DI to the address to</span>
                                <span class="co">; which the image will be copied</span>
                                <span class="co">; in display memory</span>
        <span class="kw">lodsw</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="kw">ax</span>           <span class="co">;# of lines in the image</span>
        <span class="kw">lodsw</span>                   <span class="co">;# of bytes across the image</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,SCREEN_WIDTH
        subbp,<span class="kw">ax</span>                <span class="co">;# of bytes to add to the display</span>
                                <span class="co">; memory offset after copying a line</span>
                                <span class="co">; of the image to display memory in</span>
                                <span class="co">; order to point to the address</span>
                                <span class="co">; where the next line of the image</span>
                                <span class="co">; will go in display memory</span>
<span class="fu">DrawLoop:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">ax</span>           <span class="co">;width of the image</span>
        rep     <span class="kw">movsb</span>           <span class="co">;copy the next line of the image</span>
                                <span class="co">; into display memory</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">bp</span>           <span class="co">;point to the address at which the</span>
                                <span class="co">; next line will go in display</span>
                                <span class="co">; memory</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>              <span class="co">;count down the lines of the image</span>
        <span class="kw">jnz</span>DrawLoop
        <span class="kw">ret</span>
DrawOb<span class="kw">je</span>ctendp
<span class="co">;</span>
Code    ends
        end     Start</code></pre>
<p>For those of you who haven’t experienced the frustrations of animation programming on a PC, there’s a <em>whole</em> lot of animation going on in Listing 43.1. What’s more, the animation is virtually flicker-free, partly thanks to bit-plane animation and partly because images are never really erased but rather are simply overwritten. (The principle behind the animation is that of redrawing each image with a blank fringe around it when it moves, so that the blank fringe erases the part of the old image that the new image doesn’t overwrite. For details on this sort of animation, see the above-mentioned <em>PC Tech Journal</em> July 1986 article.) Better yet, the red images take precedence over the green images, which take precedence over the blue images, which take precedence over the white backdrop, and all obscured images show through holes in and around the edges of images in front of them.</p>
<p>In short, Listing 43.1 accomplishes everything we wished for earlier in an animation technique.</p>
<p>If you possibly can, run Listing 43.1. The animation may be a revelation to those of you who are used to weak, slow animation on PCs with EGA or VGA adapters. Bit-plane animation makes the PC look an awful lot like—dare I say it?—a games machine.</p>
<p>Listing 43.1 was designed to run at the absolute fastest speed, and as I mentioned it puts in a pretty amazing performance on the slowest PCs of all. Assuming you’ll be running Listing 43.1 on an faster computer, you’ll have to crank up the <code>DELAY</code> equate at the start of Listing 43.1 to slow things down to a reasonable pace. (It’s not a very good game where all the pieces are a continual blur!) Even on something as modest as a 286-based AT, Listing 43.1 runs much too fast without a substantial delay (although it does look rather interesting at warp speed). We should all have such problems, eh? In fact, we could easily increase the number of animated images past 20 on that old AT, and well into the hundreds on a cutting-edge local-bus 486 or Pentium.</p>
<p>I’m not going to discuss Listing 43.1 in detail; the code is very thoroughly commented and should speak for itself, and most of the individual components of Listing 43.1—the Map Mask register, mode sets, word versus byte <code>OUT</code> instructions to the VGA—have been covered in earlier chapters. Do notice, however, that Listing 43.1 sets the palette exactly as I described earlier. This is accomplished by passing a pointer to a 17-byte array (1 byte for each of the 16 palette registers, and 1 byte for the border color) to the BIOS video interrupt (<code>INT</code> 10H), function 10H, subfunction 2.</p>
<p>Bit-plane animation does have inherent limitations, which we’ll get to in a second. One limitation that is <em>not</em> inherent to bit-plane animation but simply a shortcoming of Listing 43.1 is somewhat choppy horizontal motion. In the interests of both clarity and keeping Listing 43.1 to a reasonable length, I decided to byte-align all images horizontally. This saved the many tables needed to define the 7 non-byte-aligned rotations of the images, as well as the code needed to support rotation. Unfortunately, it also meant that the smallest possible horizontal movement was 8 pixels (1 byte of display memory), which is far enough to be noticeable at certain speeds. The situation is, however, easily correctable with the additional rotations and code. We’ll see an implementation of fully rotated images (in this case for Mode X, but the principles generalize nicely) in Chapter 49. Vertically, where there is no byte-alignment issue, the images move 4 or 6 pixels at a times, resulting in considerably smoother animation.</p>
<p>The addition of code to support rotated images would also open the door to support for internal animation, where the appearance of a given image changes over time to suggest that the image is an active entity. For example, propellers could whirl, jaws could snap, and jets could flare. Bit-plane animation with bit-aligned images and internal animation can look truly spectacular. It’s a sight worth seeing, particularly for those who doubt the PC’s worth when it comes to animation.</p>
</section>
<section id="limitations-of-bit-plane-animation" class="level3">
<h3><a href="#limitations-of-bit-plane-animation">Limitations of Bit-Plane Animation</a></h3>
<p>As I’ve said, bit-plane animation is not perfect. For starters, bit-plane animation can only be used in the VGA’s planar modes, modes 0DH, 0EH, 10H, and 12H. Also, the reprogramming of the palette registers that provides image precedence also reduces the available color set from the normal 16 colors to just 5 (one color per plane plus the background color). Worse still, each image must consist entirely of only one of the four colors. Mixing colors within an image is not allowed, since the bits for each image are limited to a single plane and can therefore select only one color. Finally, all images of the same precedence must be the same color.</p>
<p>It is possible to work around the color limitations to some extent by using only one or two planes for bit-plane animation, while reserving the other planes for multi-color drawing. For example, you could use plane 3 for bit-plane animation while using planes 0-2 for normal 8-color drawing. The images in plane 3 would then appear to be in front of the 8-color images. If we wanted the plane 3 images to be yellow, we could set up the palette registers as shown in Table 43.2.</p>
<p>As you can see, the color yellow is displayed whenever a pixel’s bit from plane 3 is 1. This gives the images from plane 3 precedence, while leaving us with the 8 normal low-intensity colors for images drawn across the other 3 planes, as shown in Figure 43.5. Of course, this approach provides only 1 rather than 3 high-precedence planes, but that might be a good tradeoff for being able to draw multi-colored images as a backdrop to the high-precedence images. For the right application, high-speed flicker-free plane 3 images moving in front of an 8-color backdrop could be a potent combination indeed.</p>
<p>Another limitation of bit-plane animation is that it’s best if images stored in the same plane never cross each other. Why? Because when images do cross, the blank fringe</p>
<table>
<caption>Table 43.2 Palette RAM settings for two-plane animation.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Palette Register</th>
<th style="text-align: left;">Register Setting</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">00H (black)</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">01H (blue)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;">02H (green)</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: left;">03H (cyan)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;">04H (red)</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td style="text-align: left;">05H (magenta)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">6</td>
<td style="text-align: left;">14H (brown)</td>
</tr>
<tr class="even">
<td style="text-align: left;">7</td>
<td style="text-align: left;">07H (light gray)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">8</td>
<td style="text-align: left;">3EH (yellow)</td>
</tr>
<tr class="even">
<td style="text-align: left;">9</td>
<td style="text-align: left;">3EH (yellow)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">10</td>
<td style="text-align: left;">3EH (yellow)</td>
</tr>
<tr class="even">
<td style="text-align: left;">11</td>
<td style="text-align: left;">13EH (yellow)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">12</td>
<td style="text-align: left;">3EH (yellow)</td>
</tr>
<tr class="even">
<td style="text-align: left;">13</td>
<td style="text-align: left;">3EH (yellow)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">14</td>
<td style="text-align: left;">3EH (yellow)</td>
</tr>
<tr class="even">
<td style="text-align: left;">15</td>
<td style="text-align: left;">3EH (yellow)</td>
</tr>
</tbody>
</table>
<p>around each image can temporarily erase the overlapped parts of the other image or images, resulting in momentary flicker. While that’s not fatal, it certainly detracts from the rock-solid animation effect of bit-plane animation.</p>
<p>Not allowing images in the same plane to overlap is actually less of a limitation than it seems. Run Listing 43.1 again. Unless you were looking for it, you’d never notice that images of the same color almost never overlap—there’s plenty of action to distract the eye, and the trajectories of images of the same color are arranged so that they have a full range of motion without running into each other. The only exception is the chain of green images, which occasionally doubles back on itself when it bounces directly into a corner and reverses direction. Here, however, the images are moving so quickly that the brief moment during which one image’s fringe blanks a portion of another image is noticeable only upon close inspection, and not particularly unaesthetic even then.</p>
<figure>
<img src="images/43-05.jpg" alt="Figure 43.5  Pixel precedence for plane 3 only." /><figcaption><strong>Figure 43.5</strong>  <em>Pixel precedence for plane 3 only.</em></figcaption>
</figure>
<p>When a technique has such tremendous visual and performance advantages as does bit-plane animation, it behooves you to design your animation software so that the limitations of the animation technique don’t get in the way. For example, you might design a shooting gallery game with all the images in a given plane marching along in step in a continuous band. The images could never overlap, so bit-plane animation would produce very high image quality.</p>
</section>
<section id="shearing-and-page-flipping" class="level3">
<h3><a href="#shearing-and-page-flipping">Shearing and Page Flipping</a></h3>
<p>As Listing 43.1 runs, you may occasionally see an image shear, with the top and bottom parts of the image briefly offset. This is a consequence of drawing an image directly into memory as that memory is being scanned for video data. Occasionally the CRT controller scans a given area of display memory for pixel data just as the program is changing that same memory. If the CRT controller scans memory faster than the CPU can modify that memory, then the CRT controller can scan out the bytes of display memory that have been already been changed, pass the point in the image that the CPU is currently drawing, and start scanning out bytes that haven’t yet been changed. The result: Mismatched upper and lower portions of the image.</p>
<p>If the CRT controller scans more slowly than the CPU can modify memory (likely with a 386, a fast VGA, and narrow images), then the CPU can rip right past the CRT controller, with the same net result of mismatched top and bottom parts of the image, as the CRT controller scans out first unchanged bytes and then changed bytes. Basically, shear will occasionally occur unless the CPU and CRT proceed at exactly the same rate, which is most unlikely. Shear is more noticeable when there are fewer but larger images, since it’s more apparent when a larger screen area is sheared, and because it’s easier to spot one out of three large images momentarily shearing than one out of twenty small images.</p>
<p>Image shear isn’t terrible—I’ve written and sold several games in which images occasionally shear, and I’ve never heard anyone complain—but neither is it ideal. One solution is page flipping, in which drawing is done to a non-displayed page of display memory while another page of display memory is shown on the screen. (We saw page flipping back in Chapter 23, we’ll see it again in the next chapter, and we’ll use it heavily starting in Chapter 47.) When the drawing is finished, the newly-drawn part of display memory is made the displayed page, so that the new screen becomes visible all at once, with no shearing or flicker. The other page is then drawn to, and when the drawing is complete the display is switched back to that page.</p>
<p>Page flipping can be used in conjunction with bit-plane animation, although page flipping does diminish some of the unique advantages of bit-plane animation. Page flipping produces animation of the highest visual quality whether bit-plane animation is used or not. There are a few drawbacks to page flipping, however.</p>
<p>Page flipping requires two display memory buffers, one to draw in and one to display at any given time. Unfortunately, in mode 12H there just isn’t enough memory for two buffers, so page flipping is not an option in that mode.</p>
<p>Also, page flipping requires that you keep the contents of both buffers up to date, which can require a good deal of extra drawing.</p>
<p>Finally, page flipping requires that you wait until you’re sure the page has flipped before you start drawing to the other page. Otherwise, you could end up modifying a page while it’s still being displayed, defeating the whole purpose of page flipping. Waiting for pages to flip takes time and can slow overall performance significantly. What’s more, it’s sometimes difficult to be sure when the page has flipped, since not all VGA clones implement the display adapter status bits and page flip timing identically.</p>
<p>To sum up, bit-plane animation by itself is very fast and looks good. In conjunction with page flipping, bit-plane animation looks a little better but is slower, and the overall animation scheme is more difficult to implement and perhaps a bit less reliable on some computers.</p>
</section>
<section id="beating-the-odds-in-the-jaw-dropping-contest" class="level3">
<h3><a href="#beating-the-odds-in-the-jaw-dropping-contest">Beating the Odds in the Jaw-Dropping Contest</a></h3>
<p>Bit-plane animation is neat stuff. Heck, good animation of <em>any</em> sort is fun, and the PC is as good a place as any (well, almost any) to make people’s jaws drop. (Certainly it’s the place to go if you want to make a <em>lot</em> of jaws drop.) Don’t let anyone tell you that you can’t do good animation on the PC. You can—<em>if</em> you stretch your mind to find ways to bring the full power of the VGA to bear on your applications. Bit-plane animation isn’t for every task; neither are page flipping, exclusive-ORing, pixel panning, or any of the many other animation techniques you have available. One or more tricks from that grab-bag should give you what you need, though, and the bigger your grab-bag, the better your programs.</p>
</section>
</section>
<section id="chapter-44-split-screens-save-the-page-flipped-day" class="level2">
<h2><a href="#chapter-44-split-screens-save-the-page-flipped-day">Chapter 44 – Split Screens Save the Page Flipped Day</a></h2>
<section id="x480-page-flipped-animation-in-64kalmost" class="level3">
<h3><a href="#x480-page-flipped-animation-in-64kalmost">640x480 Page Flipped Animation in 64K…Almost</a></h3>
<p>Almost doesn’t count, they say—at least in horseshoes and maybe a few other things. This is especially true in digital circles, where if you need 12 MB of hard disk to install something and you only have 10 MB left (a situation that seems to be some sort of eternal law) you’re stuck.</p>
<p>And that’s only infuriating until you dredge up the gumption to go in there and free up some space. How would you feel if you were up against an “almost-but-not-quite” kind of a wall that couldn’t be breached by freeing up something elsewhere? Suppose you were within a few KB of implementing a wonderful VGA animation scheme that provided lots of screen space, square pixels, smooth motion and more than adequate speed—but all the memory you have is all there is? What would you do?</p>
<p>Scream a little. Or throw something that won’t break easily. Then you sit down and let your right brain do what it was designed to do. Sure enough, there’s a way, and in this chapter I’ll explain how a little VGA secret called <em>page splitting</em> can save the day for page flipped animation in 640x480 mode. But to do that, I have to lay a little groundwork first. Or maybe a lot of groundwork.</p>
<p>No horseshoes here.</p>
<section id="a-plethora-of-challenges" class="level4">
<h4><a href="#a-plethora-of-challenges">A Plethora of Challenges</a></h4>
<p>In its simplest terms, computer animation consists of rapidly redrawing similar images at slightly differing locations, so that the eye interprets the successive images as a single object in motion over time. The fact that the world is an analog realm and the images displayed on a computer screen consist of discrete pixels updated at a maximum rate of about 70 Hz is irrelevant; your eye can interpret both real-world images and pixel patterns on the screen as objects in motion, and that’s that.</p>
<p>One of the key problems of computer animation is that it takes time to redraw a screen, time during which the bitmap controlling the screen is in an intermediate state, with, quite possibly, many objects erased and others half-drawn. Even when only briefly displayed, a partially-updated screen can cause flicker at best, and at worst can destroy the illusion of motion entirely.</p>
<p>Another problem of animation is that the screen must update often enough so that motion appears continuous. A moving object that moves just once every second, shifting by hundreds of pixels each time it does move, will appear to jump, not to move smoothly. Therefore, there are two overriding requirements for smooth animation: 1) the bitmap must be updated quickly (once per frame—60 to 70 Hz—is ideal, although 30 Hz will do fine), and, 2) the process of redrawing the screen must be invisible to the user; only the end result should ever be seen. Both of these requirements are met by the program presented in Listings 44.1 and 44.2.</p>
</section>
<section id="a-page-flipping-animation-demonstration" class="level4">
<h4><a href="#a-page-flipping-animation-demonstration">A Page Flipping Animation Demonstration</a></h4>
<p>The listings taken together form a sample animation program, in which a single object bounces endlessly off other objects, with instructions and a count of bounces displayed at the bottom of the screen. I’ll discuss various aspects of Listings 44.1 and 44.2 during the balance of this article. The listings are too complex and involve too much VGA and animation knowledge for for me to discuss it all in exhaustive detail (and I’ve covered a lot of this stuff earlier in the book); instead, I’ll cover the major elements, leaving it to you to explore the finer points—and, hope, to experiment with and expand on the code I’ll provide.</p>
<p><strong>LISTING 44.1 L44-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Split screen VGA animation program. Performs page flipping in the</span>
<span class="co">top portion of the screen while displaying non-page flipped</span>
<span class="co">information in the split screen at the bottom of the screen.</span>
<span class="co">Compiled with Borland C++ in C compilation mode. */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>

<span class="ot">#define SCREEN-SEG         0xA000</span>
<span class="ot">#define SCREEN-PIXWIDTH    640   </span><span class="co">/* in pixels */</span>
<span class="ot">#define SCREEN-WIDTH       80    </span><span class="co">/* in bytes */</span>
<span class="ot">#define SPLIT-START-LINE   339</span>
<span class="ot">#define SPLIT-LINES        141</span>
<span class="ot">#define NONSPLIT-LINES     339</span>
<span class="ot">#define SPLIT-START-OFFSET 0</span>
<span class="ot">#define PAGE0-START-OFFSET (SPLIT-LINES*SCREEN-WIDTH)</span>
<span class="ot">#define PAGE1-START-OFFSET ((SPLIT-LINES+NONSPLIT-LINES)*SCREEN-WIDTH)</span>
<span class="ot">#define CRTC-INDEX   0x3D4 </span><span class="co">/* CRT Controller Index register */</span>
<span class="ot">#define CRTC-DATA    0x3D5 </span><span class="co">/* CRT Controller Data register */</span>
<span class="ot">#define OVERFLOW     0x07  </span><span class="co">/* index of CRTC reg holding bit 8 of the</span>
<span class="co">                              line the split screen starts after */</span>
<span class="ot">#define MAX-SCAN     0x09  </span><span class="co">/* index of CRTC reg holding bit 9 of the</span>
<span class="co">                              line the split screen starts after */</span>
<span class="ot">#define LINE-COMPARE 0x18  </span><span class="co">/* index of CRTC reg holding lower 8 bits</span>
<span class="co">                              of line split screen starts after */</span>
<span class="ot">#define NUM-BUMPERS  (sizeof(Bumpers)/sizeof(bumper))</span>
<span class="ot">#define BOUNCER-COLOR 15</span>
<span class="ot">#define BACK-COLOR   1     </span><span class="co">/* playfield background color */</span>

<span class="kw">typedef</span> <span class="kw">struct</span> {  <span class="co">/* one solid bumper to be bounced off of */</span>
   <span class="dt">int</span> LeftX,TopY,RightX,BottomY;
   <span class="dt">int</span> Color;
} bumper;

<span class="kw">typedef</span> <span class="kw">struct</span> {     <span class="co">/* one bit pattern to be used for drawing */</span>
   <span class="dt">int</span> WidthInBytes;
   <span class="dt">int</span> Height;
   <span class="dt">unsigned</span> <span class="dt">char</span> *BitPattern;
} image;

<span class="kw">typedef</span> <span class="kw">struct</span> {  <span class="co">/* one bouncing object to move around the screen */</span>
   <span class="dt">int</span> LeftX,TopY;         <span class="co">/* location */</span>
   <span class="dt">int</span> Width,Height;       <span class="co">/* size in pixels */</span>
   <span class="dt">int</span> DirX,DirY;          <span class="co">/* motion vectors */</span>
   <span class="dt">int</span> CurrentX[<span class="dv">2</span>],CurrentY[<span class="dv">2</span>]; <span class="co">/* current location in each page */</span>
   <span class="dt">int</span> Color;              <span class="co">/* color in which to be drawn */</span>
   image *Rotation0;       <span class="co">/* rotations for handling the 8 possible */</span>
   image *Rotation1;       <span class="co">/* intrabyte start address at which the */</span>
   image *Rotation2;       <span class="co">/* left edge can be */</span>
   image *Rotation3;
   image *Rotation4;
   image *Rotation5;
   image *Rotation6;
   image *Rotation7;
} bouncer;

<span class="dt">void</span> main(<span class="dt">void</span>);
<span class="dt">void</span> DrawBumperList(bumper *, <span class="dt">int</span>, <span class="dt">unsigned</span> <span class="dt">int</span>);
<span class="dt">void</span> DrawSplitScreen(<span class="dt">void</span>);
<span class="dt">void</span> EnableSplitScreen(<span class="dt">void</span>);
<span class="dt">void</span> MoveBouncer(bouncer *, bumper *, <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> DrawRect(<span class="dt">int</span>,<span class="dt">int</span>,<span class="dt">int</span>,<span class="dt">int</span>,<span class="dt">int</span>,<span class="dt">unsigned</span> <span class="dt">int</span>,<span class="dt">unsigned</span> <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> ShowPage(<span class="dt">unsigned</span> <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> DrawImage(<span class="dt">int</span>,<span class="dt">int</span>,image **,<span class="dt">int</span>,<span class="dt">unsigned</span> <span class="dt">int</span>,<span class="dt">unsigned</span> <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> ShowBounceCount(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">void</span> TextUp(<span class="dt">char</span> *,<span class="dt">int</span>,<span class="dt">int</span>,<span class="dt">unsigned</span> <span class="dt">int</span>,<span class="dt">unsigned</span> <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> SetBIOS8x8Font(<span class="dt">void</span>);

<span class="co">/* All bumpers in the playfield */</span>
bumper Bumpers[] = {
   {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">19</span>,<span class="dv">339</span>,<span class="dv">2</span>}, {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">639</span>,<span class="dv">19</span>,<span class="dv">2</span>}, {<span class="dv">620</span>,<span class="dv">0</span>,<span class="dv">639</span>,<span class="dv">339</span>,<span class="dv">2</span>},
   {<span class="dv">0</span>,<span class="dv">320</span>,<span class="dv">639</span>,<span class="dv">339</span>,<span class="dv">2</span>}, {<span class="dv">60</span>,<span class="dv">48</span>,<span class="dv">79</span>,<span class="dv">67</span>,<span class="dv">12</span>}, {<span class="dv">60</span>,<span class="dv">108</span>,<span class="dv">79</span>,<span class="dv">127</span>,<span class="dv">12</span>},
   {<span class="dv">60</span>,<span class="dv">168</span>,<span class="dv">79</span>,<span class="dv">187</span>,<span class="dv">12</span>}, {<span class="dv">60</span>,<span class="dv">228</span>,<span class="dv">79</span>,<span class="dv">247</span>,<span class="dv">12</span>}, {<span class="dv">120</span>,<span class="dv">68</span>,<span class="dv">131</span>,<span class="dv">131</span>,<span class="dv">13</span>},
   {<span class="dv">120</span>,<span class="dv">188</span>,<span class="dv">131</span>,<span class="dv">271</span>,<span class="dv">13</span>}, {<span class="dv">240</span>,<span class="dv">128</span>,<span class="dv">259</span>,<span class="dv">147</span>,<span class="dv">14</span>}, {<span class="dv">240</span>,<span class="dv">192</span>,<span class="dv">259</span>,<span class="dv">211</span>,<span class="dv">14</span>},
   {<span class="dv">208</span>,<span class="dv">160</span>,<span class="dv">227</span>,<span class="dv">179</span>,<span class="dv">14</span>}, {<span class="dv">272</span>,<span class="dv">160</span>,<span class="dv">291</span>,<span class="dv">179</span>,<span class="dv">14</span>}, {<span class="dv">228</span>,<span class="dv">272</span>,<span class="dv">231</span>,<span class="dv">319</span>,<span class="dv">11</span>},
   {<span class="dv">192</span>,<span class="dv">52</span>,<span class="dv">211</span>,<span class="dv">55</span>,<span class="dv">11</span>}, {<span class="dv">302</span>,<span class="dv">80</span>,<span class="dv">351</span>,<span class="dv">99</span>,<span class="dv">12</span>}, {<span class="dv">320</span>,<span class="dv">260</span>,<span class="dv">379</span>,<span class="dv">267</span>,<span class="dv">13</span>},
   {<span class="dv">380</span>,<span class="dv">120</span>,<span class="dv">387</span>,<span class="dv">267</span>,<span class="dv">13</span>}, {<span class="dv">420</span>,<span class="dv">60</span>,<span class="dv">579</span>,<span class="dv">63</span>,<span class="dv">11</span>}, {<span class="dv">428</span>,<span class="dv">110</span>,<span class="dv">571</span>,<span class="dv">113</span>,<span class="dv">11</span>},
   {<span class="dv">420</span>,<span class="dv">160</span>,<span class="dv">579</span>,<span class="dv">163</span>,<span class="dv">11</span>}, {<span class="dv">428</span>,<span class="dv">210</span>,<span class="dv">571</span>,<span class="dv">213</span>,<span class="dv">11</span>}, {<span class="dv">420</span>,<span class="dv">260</span>,<span class="dv">579</span>,<span class="dv">263</span>,<span class="dv">11</span>} };

<span class="co">/* Image for bouncing object when left edge is aligned with bit 7 */</span>
<span class="dt">unsigned</span> <span class="dt">char</span> -BouncerRotation0[] = {
   <span class="bn">0xFF</span>,<span class="bn">0x0F</span>,<span class="bn">0xF0</span>, <span class="bn">0xFE</span>,<span class="bn">0x07</span>,<span class="bn">0xF0</span>, <span class="bn">0xFC</span>,<span class="bn">0x03</span>,<span class="bn">0xF0</span>, <span class="bn">0xFC</span>,<span class="bn">0x03</span>,<span class="bn">0xF0</span>,
   <span class="bn">0xFE</span>,<span class="bn">0x07</span>,<span class="bn">0xF0</span>, <span class="bn">0xFF</span>,<span class="bn">0xFF</span>,<span class="bn">0xF0</span>, <span class="bn">0xCF</span>,<span class="bn">0xFF</span>,<span class="bn">0x30</span>, <span class="bn">0x87</span>,<span class="bn">0xFE</span>,<span class="bn">0x10</span>,
   <span class="bn">0x07</span>,<span class="bn">0x0E</span>,<span class="bn">0x00</span>, <span class="bn">0x07</span>,<span class="bn">0x0E</span>,<span class="bn">0x00</span>, <span class="bn">0x07</span>,<span class="bn">0x0E</span>,<span class="bn">0x00</span>, <span class="bn">0x07</span>,<span class="bn">0x0E</span>,<span class="bn">0x00</span>,
   <span class="bn">0x87</span>,<span class="bn">0xFE</span>,<span class="bn">0x10</span>, <span class="bn">0xCF</span>,<span class="bn">0xFF</span>,<span class="bn">0x30</span>, <span class="bn">0xFF</span>,<span class="bn">0xFF</span>,<span class="bn">0xF0</span>, <span class="bn">0xFE</span>,<span class="bn">0x07</span>,<span class="bn">0xF0</span>,
   <span class="bn">0xFC</span>,<span class="bn">0x03</span>,<span class="bn">0xF0</span>, <span class="bn">0xFC</span>,<span class="bn">0x03</span>,<span class="bn">0xF0</span>, <span class="bn">0xFE</span>,<span class="bn">0x07</span>,<span class="bn">0xF0</span>, <span class="bn">0xFF</span>,<span class="bn">0x0F</span>,<span class="bn">0xF0</span>};
image BouncerRotation0 = {<span class="dv">3</span>, <span class="dv">20</span>, -BouncerRotation0};

<span class="co">/* Image for bouncing object when left edge is aligned with bit 3 */</span>
<span class="dt">unsigned</span> <span class="dt">char</span> -BouncerRotation4[] = {
   <span class="bn">0x0F</span>,<span class="bn">0xF0</span>,<span class="bn">0xFF</span>, <span class="bn">0x0F</span>,<span class="bn">0xE0</span>,<span class="bn">0x7F</span>, <span class="bn">0x0F</span>,<span class="bn">0xC0</span>,<span class="bn">0x3F</span>, <span class="bn">0x0F</span>,<span class="bn">0xC0</span>,<span class="bn">0x3F</span>,
   <span class="bn">0x0F</span>,<span class="bn">0xE0</span>,<span class="bn">0x7F</span>, <span class="bn">0x0F</span>,<span class="bn">0xFF</span>,<span class="bn">0xFF</span>, <span class="bn">0x0C</span>,<span class="bn">0xFF</span>,<span class="bn">0xF3</span>, <span class="bn">0x08</span>,<span class="bn">0x7F</span>,<span class="bn">0xE1</span>,
   <span class="bn">0x00</span>,<span class="bn">0x70</span>,<span class="bn">0xE0</span>, <span class="bn">0x00</span>,<span class="bn">0x70</span>,<span class="bn">0xE0</span>, <span class="bn">0x00</span>,<span class="bn">0x70</span>,<span class="bn">0xE0</span>, <span class="bn">0x00</span>,<span class="bn">0x70</span>,<span class="bn">0xE0</span>,
   <span class="bn">0x08</span>,<span class="bn">0x7F</span>,<span class="bn">0xE1</span>, <span class="bn">0x0C</span>,<span class="bn">0xFF</span>,<span class="bn">0xF3</span>, <span class="bn">0x0F</span>,<span class="bn">0xFF</span>,<span class="bn">0xFF</span>, <span class="bn">0x0F</span>,<span class="bn">0xE0</span>,<span class="bn">0x7F</span>,
   <span class="bn">0x0F</span>,<span class="bn">0xC0</span>,<span class="bn">0x3F</span>, <span class="bn">0x0F</span>,<span class="bn">0xC0</span>,<span class="bn">0x3F</span>, <span class="bn">0x0F</span>,<span class="bn">0xE0</span>,<span class="bn">0x7F</span>, <span class="bn">0x0F</span>,<span class="bn">0xF0</span>,<span class="bn">0xFF</span>};
image BouncerRotation4 = {<span class="dv">3</span>, <span class="dv">20</span>, -BouncerRotation4};

<span class="co">/* Initial settings for bouncing object. Only 2 rotations are needed</span>
<span class="co">   because the object moves 4 pixels horizontally at a time */</span>
bouncer Bouncer = {<span class="dv">156</span>,<span class="dv">60</span>,<span class="dv">20</span>,<span class="dv">20</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">156</span>,<span class="dv">156</span>,<span class="dv">60</span>,<span class="dv">60</span>,BOUNCER-COLOR,
   &amp;BouncerRotation0,NULL,NULL,NULL,&amp;BouncerRotation4,NULL,NULL,NULL};
<span class="dt">unsigned</span> <span class="dt">int</span> PageStartOffsets[<span class="dv">2</span>] =
   {PAGE0-START-OFFSET,PAGE1-START-OFFSET};
<span class="dt">unsigned</span> <span class="dt">int</span> BounceCount;

<span class="dt">void</span> main() {
   <span class="dt">int</span> DisplayedPage, NonDisplayedPage, Done, i;
   <span class="kw">union</span> REGS regset;

   regset.x.ax = <span class="bn">0x0012</span>; <span class="co">/* set display to 640x480 16-color mode */</span>
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
   SetBIOS8x8Font();    <span class="co">/* set the pointer to the BIOS 8x8 font */</span>
   EnableSplitScreen(); <span class="co">/* turn on the split screen */</span>

   <span class="co">/* Display page 0 above the split screen */</span>
   ShowPage(PageStartOffsets[DisplayedPage = <span class="dv">0</span>]);

   <span class="co">/* Clear both pages to background and draw bumpers in each page */</span>
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">2</span>; i++) {
      DrawRect(<span class="dv">0</span>,<span class="dv">0</span>,SCREEN-PIXWIDTH<span class="dv">-1</span>,NONSPLIT-LINES<span class="dv">-1</span>,BACK-COLOR,
            PageStartOffsets[i],SCREEN-SEG);
      DrawBumperList(Bumpers,NUM-BUMPERS,PageStartOffsets[i]);
   }

   DrawSplitScreen();   <span class="co">/* draw the static split screen info */</span>
   BounceCount = <span class="dv">0</span>;
   ShowBounceCount();   <span class="co">/* put up the initial zero count */</span>

   <span class="co">/* Draw the bouncing object at its initial location */</span>
   DrawImage(Bouncer.LeftX,Bouncer.TopY,&amp;Bouncer.Rotation0,
         Bouncer.Color,PageStartOffsets[DisplayedPage],SCREEN-SEG);

   <span class="co">/* Move the object, draw it in the nondisplayed page, and flip the</span>
<span class="co">      page until Esc is pressed */</span>
   Done = <span class="dv">0</span>;
   <span class="kw">do</span> {
      NonDisplayedPage = DisplayedPage ^ <span class="dv">1</span>;
      <span class="co">/* Erase at current location in the nondisplayed page */</span>
      DrawRect(Bouncer.CurrentX[NonDisplayedPage],
            Bouncer.CurrentY[NonDisplayedPage],
            Bouncer.CurrentX[NonDisplayedPage]+Bouncer.Width<span class="dv">-1</span>,
            Bouncer.CurrentY[NonDisplayedPage]+Bouncer.Height<span class="dv">-1</span>,
            BACK-COLOR,PageStartOffsets[NonDisplayedPage],SCREEN-SEG);
      <span class="co">/* Move the bouncer */</span>
      MoveBouncer(&amp;Bouncer, Bumpers, NUM-BUMPERS);
      <span class="co">/* Draw at the new location in the nondisplayed page */</span>
      DrawImage(Bouncer.LeftX,Bouncer.TopY,&amp;Bouncer.Rotation0,
            Bouncer.Color,PageStartOffsets[NonDisplayedPage],
            SCREEN-SEG);
      <span class="co">/* Remember where the bouncer is in the nondisplayed page */</span>
      Bouncer.CurrentX[NonDisplayedPage] = Bouncer.LeftX;
      Bouncer.CurrentY[NonDisplayedPage] = Bouncer.TopY;
      <span class="co">/* Flip to the page we just drew into */</span>
      ShowPage(PageStartOffsets[DisplayedPage = NonDisplayedPage]);
      <span class="co">/* Respond to any keystroke */</span>
      <span class="kw">if</span> (kbhit()) {
         <span class="kw">switch</span> (getch()) {
            <span class="kw">case</span> <span class="bn">0x1B</span>:           <span class="co">/* Esc to end */</span>
               Done = <span class="dv">1</span>; <span class="kw">break</span>;
            <span class="kw">case</span> <span class="dv">0</span>:              <span class="co">/* branch on the extended code */</span>
               <span class="kw">switch</span> (getch()) {
                  <span class="kw">case</span> <span class="bn">0x48</span>:  <span class="co">/* nudge up */</span>
                     Bouncer.DirY = -abs(Bouncer.DirY); <span class="kw">break</span>;
                  <span class="kw">case</span> <span class="bn">0x4B</span>:  <span class="co">/* nudge left */</span>
                     Bouncer.DirX = -abs(Bouncer.DirX); <span class="kw">break</span>;
                  <span class="kw">case</span> <span class="bn">0x4D</span>:  <span class="co">/* nudge right */</span>
                     Bouncer.DirX = abs(Bouncer.DirX); <span class="kw">break</span>;
                  <span class="kw">case</span> <span class="bn">0x50</span>:  <span class="co">/* nudge down */</span>
                     Bouncer.DirY = abs(Bouncer.DirY); <span class="kw">break</span>;
               }
               <span class="kw">break</span>;
            <span class="kw">default</span>:
               <span class="kw">break</span>;
         }
      }
   } <span class="kw">while</span> (!Done);

   <span class="co">/* Restore text mode and done */</span>
   regset.x.ax = <span class="bn">0x0003</span>;
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}

<span class="co">/* Draws the specified list of bumpers into the specified page */</span>
<span class="dt">void</span> DrawBumperList(bumper * Bumpers, <span class="dt">int</span> NumBumpers,
      <span class="dt">unsigned</span> <span class="dt">int</span> PageStartOffset)
{
   <span class="dt">int</span> i;

   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NumBumpers; i++,Bumpers++) {
      DrawRect(Bumpers-&gt;LeftX,Bumpers-&gt;TopY,Bumpers-&gt;RightX,
            Bumpers-&gt;BottomY,Bumpers-&gt;Color,PageStartOffset,
            SCREEN-SEG);
   }
}

<span class="co">/* Displays the current bounce count */</span>
<span class="dt">void</span> ShowBounceCount() {
   <span class="dt">char</span> CountASCII[<span class="dv">7</span>];

   itoa(BounceCount,CountASCII,<span class="dv">10</span>); <span class="co">/* convert the count to ASCII*/</span>
   TextUp(CountASCII,<span class="dv">344</span>,<span class="dv">64</span>,SPLIT-START-OFFSET,SCREEN-SEG);
}

<span class="co">/* Frames the split screen and fills it with various text */</span>
<span class="dt">void</span> DrawSplitScreen() {
   DrawRect(<span class="dv">0</span>,<span class="dv">0</span>,SCREEN-PIXWIDTH<span class="dv">-1</span>,SPLIT-LINES<span class="dv">-1</span>,<span class="dv">0</span>,SPLIT-START-OFFSET,
         SCREEN-SEG);
   DrawRect(<span class="dv">0</span>,<span class="dv">1</span>,SCREEN-PIXWIDTH<span class="dv">-1</span>,<span class="dv">4</span>,<span class="dv">15</span>,SPLIT-START-OFFSET,
         SCREEN-SEG);
   DrawRect(<span class="dv">0</span>,SPLIT-LINES<span class="dv">-4</span>,SCREEN-PIXWIDTH<span class="dv">-1</span>,SPLIT-LINES<span class="dv">-1</span>,<span class="dv">15</span>,
         SPLIT-START-OFFSET,SCREEN-SEG);
   DrawRect(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">3</span>,SPLIT-LINES<span class="dv">-1</span>,<span class="dv">15</span>,SPLIT-START-OFFSET,SCREEN-SEG);
   DrawRect(SCREEN-PIXWIDTH<span class="dv">-4</span>,<span class="dv">1</span>,SCREEN-PIXWIDTH<span class="dv">-1</span>,SPLIT-LINES<span class="dv">-1</span>,<span class="dv">15</span>,
         SPLIT-START-OFFSET,SCREEN-SEG);
   TextUp(<span class="st">&quot;This is the split screen area...&quot;</span>,<span class="dv">8</span>,<span class="dv">8</span>,SPLIT-START-OFFSET,
         SCREEN-SEG);
   TextUp(<span class="st">&quot;Bounces: &quot;</span>,<span class="dv">272</span>,<span class="dv">64</span>,SPLIT-START-OFFSET,SCREEN-SEG);
   TextUp(<span class="st">&quot;</span><span class="ch">\033</span><span class="st">: nudge left&quot;</span>,<span class="dv">520</span>,<span class="dv">78</span>,SPLIT-START-OFFSET,SCREEN-SEG);
   TextUp(<span class="st">&quot;</span><span class="ch">\032</span><span class="st">: nudge right&quot;</span>,<span class="dv">520</span>,<span class="dv">90</span>,SPLIT-START-OFFSET,SCREEN-SEG);
   TextUp(<span class="st">&quot;</span><span class="ch">\031</span><span class="st">: nudge down&quot;</span>,<span class="dv">520</span>,<span class="dv">102</span>,SPLIT-START-OFFSET,SCREEN-SEG);
   TextUp(<span class="st">&quot;</span><span class="ch">\030</span><span class="st">: nudge up&quot;</span>,<span class="dv">520</span>,<span class="dv">114</span>,SPLIT-START-OFFSET,SCREEN-SEG);
   TextUp(<span class="st">&quot;Esc to end&quot;</span>,<span class="dv">520</span>,<span class="dv">126</span>,SPLIT-START-OFFSET,SCREEN-SEG);
}

<span class="co">/* Turn on the split screen at the desired line (minus 1 because the</span>
<span class="co">   split screen starts *after* the line specified by the LINE-COMPARE</span>
<span class="co">   register) (bit 8 of the split screen start line is stored in the</span>
<span class="co">   Overflow register, and bit 9 is in the Maximum Scan Line reg) */</span>
<span class="dt">void</span> EnableSplitScreen() {
   outp(CRTC-INDEX, LINE-COMPARE);
   outp(CRTC-DATA, (SPLIT-START-LINE - <span class="dv">1</span>) &amp; <span class="bn">0xFF</span>);
   outp(CRTC-INDEX, OVERFLOW);
   outp(CRTC-DATA, (((((SPLIT-START-LINE - <span class="dv">1</span>) &amp; <span class="bn">0x100</span>) &gt;&gt; <span class="dv">8</span>) &lt;&lt; <span class="dv">4</span>) |
         (inp(CRTC-DATA) &amp; ~<span class="bn">0x10</span>)));
   outp(CRTC-INDEX, MAX-SCAN);
   outp(CRTC-DATA, (((((SPLIT-START-LINE - <span class="dv">1</span>) &amp; <span class="bn">0x200</span>) &gt;&gt; <span class="dv">9</span>) &lt;&lt; <span class="dv">6</span>) |
         (inp(CRTC-DATA) &amp; ~<span class="bn">0x40</span>)));
}

<span class="co">/* Moves the bouncer, bouncing if bumpers are hit */</span>
<span class="dt">void</span> MoveBouncer(bouncer *Bouncer, bumper *BumperPtr, <span class="dt">int</span> NumBumpers) {
   <span class="dt">int</span> NewLeftX, NewTopY, NewRightX, NewBottomY, i;

   <span class="co">/* Move to new location, bouncing if necessary */</span>
   NewLeftX = Bouncer-&gt;LeftX + Bouncer-&gt;DirX;   <span class="co">/* new coords */</span>
   NewTopY = Bouncer-&gt;TopY + Bouncer-&gt;DirY;
   NewRightX = NewLeftX + Bouncer-&gt;Width - <span class="dv">1</span>;
   NewBottomY = NewTopY + Bouncer-&gt;Height - <span class="dv">1</span>;
   <span class="co">/* Compare the new location to all bumpers, checking for bounce */</span>
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NumBumpers; i++,BumperPtr++) {
      <span class="co">/* If moving puts the bouncer inside this bumper, bounce */</span>
      <span class="kw">if</span> (  (NewLeftX &lt;= BumperPtr-&gt;RightX) &amp;&amp;
            (NewRightX &gt;= BumperPtr-&gt;LeftX) &amp;&amp;
            (NewTopY &lt;= BumperPtr-&gt;BottomY) &amp;&amp;
            (NewBottomY &gt;= BumperPtr-&gt;TopY) ) {
         <span class="co">/* The bouncer has tried to move into this bumper; figure</span>
<span class="co">            out which edge(s) it crossed, and bounce accordingly */</span>
         <span class="kw">if</span> (((Bouncer-&gt;LeftX &gt; BumperPtr-&gt;RightX) &amp;&amp;
               (NewLeftX &lt;= BumperPtr-&gt;RightX)) ||
               (((Bouncer-&gt;LeftX + Bouncer-&gt;Width - <span class="dv">1</span>) &lt;
               BumperPtr-&gt;LeftX) &amp;&amp;
               (NewRightX &gt;= BumperPtr-&gt;LeftX))) {
            Bouncer-&gt;DirX = -Bouncer-&gt;DirX;  <span class="co">/* bounce horizontally */</span>
            NewLeftX = Bouncer-&gt;LeftX + Bouncer-&gt;DirX;
         }
         <span class="kw">if</span> (((Bouncer-&gt;TopY &gt; BumperPtr-&gt;BottomY) &amp;&amp;
               (NewTopY &lt;= BumperPtr-&gt;BottomY)) ||
               (((Bouncer-&gt;TopY + Bouncer-&gt;Height - <span class="dv">1</span>) &lt;
               BumperPtr-&gt;TopY) &amp;&amp;
               (NewBottomY &gt;= BumperPtr-&gt;TopY))) {
            Bouncer-&gt;DirY = -Bouncer-&gt;DirY; <span class="co">/* bounce vertically */</span>
            NewTopY = Bouncer-&gt;TopY + Bouncer-&gt;DirY;
         }
         <span class="co">/* Update the bounce count display; turn over at 10000 */</span>
         <span class="kw">if</span> (++BounceCount &gt;= <span class="dv">10000</span>) {
            TextUp(<span class="st">&quot;0    &quot;</span>,<span class="dv">344</span>,<span class="dv">64</span>,SPLIT-START-OFFSET,SCREEN-SEG);
            BounceCount = <span class="dv">0</span>;
         } <span class="kw">else</span> {
            ShowBounceCount();
         }
      }
   }
   Bouncer-&gt;LeftX = NewLeftX; <span class="co">/* set the final new coordinates */</span>
   Bouncer-&gt;TopY = NewTopY;
}</code></pre>
<p><strong>LISTING 44.2 L44-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Low-level animation routines.</span>
<span class="co">; Tested with TASM</span>

SCREEN-WIDTH       <span class="dt">equ</span>     <span class="dv">80</span>      <span class="co">;screen width in bytes</span>
INPUT-STATUS<span class="dv">-1</span>     <span class="dt">equ</span><span class="bn">     03dah   </span><span class="co">;Input Status 1 register</span>
CRTC-INDEX         <span class="dt">equ</span><span class="bn">     03d4h   </span><span class="co">;CRT Controller Index reg</span>
START-ADDRESS-HIGH <span class="dt">equ</span><span class="bn">     0ch     </span><span class="co">;bitmap start address high byte</span>
START-ADDRESS-LOW  <span class="dt">equ</span><span class="bn">     0dh     </span><span class="co">;bitmap start address low byte</span>
GC-INDEX           <span class="dt">equ</span><span class="bn">     03ceh   </span><span class="co">;Graphics Controller Index reg</span>
SET-RESET          <span class="dt">equ</span>     <span class="dv">0</span>       <span class="co">;GC index of Set/Reset reg</span>
G-MODE             <span class="dt">equ</span>     <span class="dv">5</span>       <span class="co">;GC index of Mode register</span>

        .model  small
        .data
BIOS8x8Ptr <span class="dt">dd</span>   ?       <span class="co">;points to BIOS 8x8 font</span>
<span class="co">; Tables used to look up left and right clip masks.</span>
LeftMask d<span class="bn">    0ffh, </span>07fh<span class="bn">, 03fh, </span>01fh<span class="bn">, 00fh, </span>007h<span class="bn">, 003h, </span>001h
RightMask d<span class="bn">   080h, </span>0c0h<span class="bn">, 0e0h, </span>0f0h<span class="bn">, 0f8h, </span>0fch<span class="bn">, 0feh, </span>0ffh

        .code
<span class="co">; Draws the specified filled rectangle in the specified color.</span>
<span class="co">; Assumes the display is in mode 12h. Does not clip and assumes</span>
<span class="co">; rectangle coordinates are valid.</span>
<span class="co">;</span>
<span class="co">; C near-callable as: void DrawRect(int LeftX, int TopY, int RightX,</span>
<span class="co">;       int BottomY, int Color, unsigned int ScrnOffset,</span>
<span class="co">;       unsigned int ScrnSegment);</span>

DrawRectParms   <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup (?) <span class="co">;pushed BP and return address</span>
LeftX   <span class="dt">dw</span>      ?               <span class="co">;X coordinate of left side of rectangle</span>
TopY    <span class="dt">dw</span>      ?               <span class="co">;Y coordinate of top side of rectangle</span>
RightX  <span class="dt">dw</span>      ?               <span class="co">;X coordinate of right side of rectangle</span>
BottomY <span class="dt">dw</span>      ?               <span class="co">;Y coordinate of bottom side of rectangle</span>
Color   <span class="dt">dw</span>      ?               <span class="co">;color in which to draw rectangle (only the</span>
                                <span class="co">; lower 4 bits matter)</span>
ScrnOffset  <span class="dt">dw</span>  ?               <span class="co">;offset of base of bitmap in which to draw</span>
ScrnSegment <span class="dt">dw</span>  ?               <span class="co">;segment of base of bitmap in which to draw</span>
DrawRectParms   ends

        public  -DrawRect
-DrawRect       proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>              <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>           <span class="co">;point to local stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>              <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">cld</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC-INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,SET-RESET
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> Color[<span class="kw">bp</span>]
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>           <span class="co">;set the color in which to draw</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,G-MODE + (0300h)
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>           <span class="co">;set to write mode 3</span>
        <span class="kw">les</span>     <span class="kw">di</span>,<span class="dt">dword</span> <span class="dt">ptr</span> ScrnOffset[<span class="kw">bp</span>] <span class="co">;point to bitmap start</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN-WIDTH
        <span class="kw">mul</span>     TopY[<span class="kw">bp</span>]         <span class="co">;point to the start of the top scan</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>            <span class="co">; line to fill</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,LeftX[<span class="kw">bp</span>]
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">ax</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>             <span class="co">;/8 = byte offset from left of screen</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>            <span class="co">;point to the upper-left corner of fill area</span>
        <span class="kw">and</span>     <span class="kw">bx</span>,<span class="dv">7</span>             <span class="co">;isolate intrapixel address</span>
        <span class="kw">mov</span>     <span class="kw">dl</span>,LeftMask[<span class="kw">bx</span>]  <span class="co">;set the left-edge clip mask</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,RightX[<span class="kw">bp</span>]
        <span class="kw">mov</span>     <span class="kw">si</span>,<span class="kw">bx</span>
        <span class="kw">and</span>     <span class="kw">bx</span>,<span class="dv">7</span>             <span class="co">;isolate intrapixel address of right edge</span>
        <span class="kw">mov</span>     <span class="kw">dh</span>,RightMask[<span class="kw">bx</span>] <span class="co">;set the right-edge clip mask</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,LeftX[<span class="kw">bp</span>]
        <span class="kw">and</span>     <span class="kw">bx</span>,<span class="kw">NOT</span> <span class="dv">7</span>         <span class="co">;intrapixel address of left edge</span>
        su    <span class="kw">si</span>,<span class="kw">bx</span>
        <span class="kw">shr</span>     <span class="kw">si</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">si</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">si</span>,<span class="dv">1</span>             <span class="co">;# of bytes across spanned by rectangle - 1</span>
        <span class="kw">jnz</span>     MasksSet         <span class="co">;if there&#39;s only one byte across,</span>
        <span class="kw">and</span>     <span class="kw">dl</span>,<span class="kw">dh</span>            <span class="co">; combine the masks</span>
<span class="fu">MasksSet:</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,BottomY[<span class="kw">bp</span>]
        su    <span class="kw">bx</span>,TopY[<span class="kw">bp</span>]        <span class="co">;# of scan lines to fill - 1</span>
<span class="fu">FillLoop:</span>
        <span class="kw">push</span>    <span class="kw">di</span>               <span class="co">;remember line start offset</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">dl</span>            <span class="co">;left edge clip mask</span>
        <span class="kw">xchg</span>    <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">al</span>       <span class="co">;draw the left edge</span>
        <span class="kw">inc</span>     <span class="kw">di</span>               <span class="co">;point to the next byte</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">si</span>            <span class="co">;# of bytes left to do</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>               <span class="co">;# of bytes left to do - 1</span>
        <span class="kw">js</span>      LineDone         <span class="co">;that&#39;s it if there&#39;s only 1 byte across</span>
        <span class="kw">jz</span>      DrawRightEdge    <span class="co">;no middle bytes if only 2 bytes across</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ffh          </span><span class="co">;non-edge bytes are solid</span>
        rep     <span class="kw">stos</span>             <span class="co">;draw the solid bytes across the middle</span>
<span class="fu">DrawRightEdge:</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">dh</span>            <span class="co">;right-edge clip mask</span>
        <span class="kw">xchg</span>    <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">al</span>       <span class="co">;draw the right edge</span>
<span class="fu">LineDone:</span>
        <span class="kw">pop</span>     <span class="kw">di</span>               <span class="co">;retrieve line start offset</span>
        <span class="kw">add</span>     <span class="kw">di</span>,SCREEN-WIDTH  <span class="co">;point to the next line</span>
        <span class="kw">dec</span>     <span class="kw">bx</span>               <span class="co">;count off scan lines</span>
        <span class="kw">jns</span>     FillLoop

        <span class="kw">pop</span>     <span class="kw">di</span>               <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>               <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
-DrawRect       endp

<span class="co">; Shows the page at the specified offset in the bitmap. Page is</span>
<span class="co">; displayed when this routine returns.</span>
<span class="co">;</span>
<span class="co">; C near-callable as: void ShowPage(unsigned int StartOffset);</span>

ShowPageParms   <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup (?)         <span class="co">;pushed BP and return address</span>
StartOffset <span class="dt">dw</span>  ?           <span class="co">;offset in bitmap of page to display</span>
ShowPageParms   ends

        public  -ShowPage
-ShowPage       proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>                <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>             <span class="co">;point to local stack frame</span>
<span class="co">; Wait for display enable to be active (status is active low), to be</span>
<span class="co">; sure both halves of the start address will take in the same frame.</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,START-ADDRESS-LOW        <span class="co">;preload for fastest</span>
        <span class="kw">mov</span>     <span class="kw">bh</span>,<span class="dt">byte</span> <span class="dt">ptr</span> StartOffset[<span class="kw">bp</span>] <span class="co">; flipping once display</span>
        <span class="kw">mov</span>     <span class="kw">cl</span>,START-ADDRESS-HIGH       <span class="co">; enable is detected</span>
        <span class="kw">mov</span>     <span class="kw">ch</span>,<span class="dt">byte</span> <span class="dt">ptr</span> StartOffset<span class="dv">+1</span>[<span class="kw">bp</span>]
        <span class="kw">mov</span>     <span class="kw">dx</span>,INPUT-STATUS<span class="dv">-1</span>
<span class="fu">WaitDE:</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">test</span>    <span class="kw">al</span><span class="bn">,01h</span>
        <span class="kw">jnz</span>     WaitDE            <span class="co">;display enable is active low (0 = active)</span>
<span class="co">; Set the start offset in display memory of the page to display.</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,CRTC-INDEX
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">bx</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>             <span class="co">;start address low</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">cx</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>             <span class="co">;start address high</span>
<span class="co">; Now wait for vertical sync, so the other page will be invisible when</span>
<span class="co">; we start drawing to it.</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,INPUT-STATUS<span class="dv">-1</span>
<span class="fu">WaitVS:</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">test</span>    <span class="kw">al</span><span class="bn">,08h</span>
        <span class="kw">jz</span>      WaitVS            <span class="co">;vertical sync is active high (1 = active)</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>                <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
-ShowPage       endp

<span class="co">; Displays the specified image at the specified location in the</span>
<span class="co">; specified bitmap, in the desired color.</span>
<span class="co">;</span>
<span class="co">; C near-callable as: void DrawImage(int LeftX, int TopY,</span>
<span class="co">;       image **RotationTable, int Color, unsigned int ScrnOffset,</span>
<span class="co">;       unsigned int ScrnSegment);</span>

DrawImageParms  <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup (?) <span class="co">;pushed BP and return address</span>
DILeftX       <span class="dt">dw</span>   ?            <span class="co">;X coordinate of left side of image</span>
DITopY        <span class="dt">dw</span>   ?            <span class="co">;Y coordinate of top side of image</span>
RotationTable <span class="dt">dw</span>   ?            <span class="co">;pointer to table of pointers to image</span>
                                <span class="co">; rotations</span>
DIColor       <span class="dt">dw</span>   ?            <span class="co">;color in which to draw image (only the</span>
                                <span class="co">; lower 4 bits matter)</span>
DIScrnOffset  <span class="dt">dw</span>   ?            <span class="co">;offset of base of bitmap in which to draw</span>
DIScrnSegment <span class="dt">dw</span>   ?            <span class="co">;segment of base of bitmap in which to draw</span>
DrawImageParms  ends

image <span class="kw">struc</span>
WidthInBytes    <span class="dt">dw</span>      ?
Height          <span class="dt">dw</span>      ?
BitPattern      <span class="dt">dw</span>      ?
image ends

        public  -DrawImage
-DrawImage      proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>              <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>           <span class="co">;point to local stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>              <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">cld</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC-INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,SET-RESET
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> DIColor[<span class="kw">bp</span>]
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>           <span class="co">;set the color in which to draw</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,G-MODE + (0300h)
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>           <span class="co">;set to write mode 3</span>
        <span class="kw">les</span>     <span class="kw">di</span>,<span class="dt">dword</span> <span class="dt">ptr</span> DIScrnOffset[<span class="kw">bp</span>] <span class="co">;point to bitmap start</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN-WIDTH
        <span class="kw">mul</span>     DITopY[<span class="kw">bp</span>]      <span class="co">;point to the start of the top scan</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>           <span class="co">; line on which to draw</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,DILeftX[<span class="kw">bp</span>]
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">ax</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>            <span class="co">;/8 = byte offset from left of screen</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>           <span class="co">;point to the upper-left corner of draw area</span>
        <span class="kw">and</span>     <span class="kw">bx</span>,<span class="dv">7</span>            <span class="co">;isolate intrapixel address</span>
        <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>            <span class="co">;*2 for word look-up</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,RotationTable[<span class="kw">bp</span>] <span class="co">;point to the image structure for</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bx</span>]              <span class="co">; the intrabyte rotation</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bx</span>].WidthInBytes <span class="co">;image width</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bx</span>].BitPattern   <span class="co">;pointer to image pattern bytes</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bx</span>].Height       <span class="co">;image height</span>
<span class="fu">DrawImageLoop:</span>
        <span class="kw">push</span>    <span class="kw">di</span>                   <span class="co">;remember line start offset</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">dx</span>                <span class="co">;# of bytes across</span>
<span class="fu">DrawImageLineLoop:</span>
        <span class="kw">lods</span>                         <span class="co">;get the next image byte</span>
        <span class="kw">xchg</span>    <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">al</span>           <span class="co">;draw the next image byte</span>
        <span class="kw">inc</span>     <span class="kw">di</span>                   <span class="co">;point to the following screen byte</span>
        <span class="kw">loop</span>    DrawImageLineLoop
        <span class="kw">pop</span>     <span class="kw">di</span>                   <span class="co">;retrieve line start offset</span>
        <span class="kw">add</span>     <span class="kw">di</span>,SCREEN-WIDTH      <span class="co">;point to the next line</span>
        <span class="kw">dec</span>     <span class="kw">bx</span>                   <span class="co">;count off scan lines</span>
        <span class="kw">jnz</span>     DrawImageLoop

        <span class="kw">pop</span>     <span class="kw">di</span>                   <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>                   <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
-DrawImage      endp

<span class="co">; Draws a 0-terminated text string at the specified location in the</span>
<span class="co">; specified bitmap in white, using the 8x8 BIOS font. Must be at an X</span>
<span class="co">; coordinate that&#39;s a multiple of 8.</span>
<span class="co">;</span>
<span class="co">; C near-callable as: void TextUp(char *Text, int LeftX, int TopY,</span>
<span class="co">;       unsigned int ScrnOffset, unsigned int ScrnSegment);</span>

TextUpParms     <span class="kw">struc</span>
                 <span class="dt">dw</span>    <span class="dv">2</span> dup (?) <span class="co">;pushed BP and return address</span>
Text             <span class="dt">dw</span>    ?            <span class="co">;pointer to text to draw</span>
TULeftX          <span class="dt">dw</span>    ?            <span class="co">;X coordinate of left side of rectangle</span>
                                    <span class="co">; (must be a multiple of 8)</span>
TUTopY           <span class="dt">dw</span>    ?            <span class="co">;Y coordinate of top side of rectangle</span>
TUScrnOffset     <span class="dt">dw</span>    ?            <span class="co">;offset of base of bitmap in which to draw</span>
TUScrnSegment    <span class="dt">dw</span>    ?            <span class="co">;segment of base of bitmap in which to draw</span>
TextUpParms     ends

        public  -TextUp
-TextUp proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>                  <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>               <span class="co">;point to local stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>                  <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">cld</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC-INDEX
        <span class="kw">mov</span>     <span class="kw">ax</span>,G-MODE + (0000h)
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>   <span class="co">;set to write mode 0</span>
        <span class="kw">les</span>     <span class="kw">di</span>,<span class="dt">dword</span> <span class="dt">ptr</span> TUScrnOffset[<span class="kw">bp</span>] <span class="co">;point to bitmap start</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN-WIDTH
        <span class="kw">mul</span>     TUTopY[<span class="kw">bp</span>]           <span class="co">;point to the start of the top scan</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>                <span class="co">; line the text starts on</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,TULeftX[<span class="kw">bp</span>]
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">ax</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>                 <span class="co">;/8 = byte offset from left of screen</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>                <span class="co">;point to the upper-left corner of first char</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,Text[<span class="kw">bp</span>]          <span class="co">;point to text to draw</span>
<span class="fu">TextUpLoop:</span>
        <span class="kw">lods</span>                         <span class="co">;get the next character to draw</span>
        <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">al</span>
        <span class="kw">jz</span>      TextUpDone           <span class="co">;done if null byte</span>
        <span class="kw">push</span>    <span class="kw">si</span>                   <span class="co">;preserve text string pointer</span>
        <span class="kw">push</span>    <span class="kw">di</span>                   <span class="co">;preserve character&#39;s screen offset</span>
        <span class="kw">push</span>    <span class="kw">ds</span>                   <span class="co">;preserve default data segment</span>
        <span class="kw">call</span>    CharUp               <span class="co">;draw this character</span>
        <span class="kw">pop</span>     <span class="kw">ds</span>                   <span class="co">;restore default data segment</span>
        <span class="kw">pop</span>     <span class="kw">di</span>                   <span class="co">;retrieve character&#39;s screen offset</span>
        <span class="kw">pop</span>     <span class="kw">si</span>                   <span class="co">;retrieve text string pointer</span>
        <span class="kw">inc</span>     <span class="kw">di</span>                   <span class="co">;point to next character&#39;s start location</span>
        <span class="kw">jmp</span>     TextUpLoop

<span class="fu">TextUpDone:</span>
        <span class="kw">pop</span>     <span class="kw">di</span>                   <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>                   <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>

<span class="fu">CharUp:</span>                              <span class="co">;draws the character in AL at ES:DI</span>
        <span class="kw">lds</span>     <span class="kw">si</span>,[BIOS8x8Ptr]      <span class="co">;point to the 8x8 font start</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,<span class="kw">al</span>
        su    <span class="kw">bh</span>,<span class="kw">bh</span>
        <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>
        <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>
        <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">1</span>                 <span class="co">;*8 to look up character offset in font</span>
        <span class="kw">add</span>     <span class="kw">si</span>,<span class="kw">bx</span>                <span class="co">;point DS:Sito character data in font</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">8</span>                 <span class="co">;characters are 8 high</span>
<span class="fu">CharUpLoop:</span>
        <span class="kw">movs</span>                         <span class="co">;copy the next character pattern byte</span>
        <span class="kw">add</span>     <span class="kw">di</span>,SCREEN-WIDTH<span class="dv">-1</span>    <span class="co">;point to the next dest byte</span>
        <span class="kw">loop</span>    CharUpLoop
        <span class="kw">ret</span>
-TextUp endp

<span class="co">; Sets the pointer to the BIOS 8x8 font.</span>
<span class="co">;</span>
<span class="co">; C near-callable as: extern void SetBIOS8x8Font(void);</span>

        public  -SetBIOS8x8Font
-SetBIOS8x8Font proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>                  <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>                  <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>                  <span class="co">; and data segment (don&#39;t assume BIOS</span>
        <span class="kw">push</span>    <span class="kw">ds</span>                  <span class="co">; preserves anything)</span>
        <span class="kw">mov</span>     <span class="kw">ah</span><span class="bn">,11h              </span><span class="co">;BIOS character generator function</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,30h              </span><span class="co">;BIOS information subfunction</span>
        <span class="kw">mov</span>     <span class="kw">bh</span>,<span class="dv">3</span>                <span class="co">;request 8x8 font pointer</span>
        <span class="kw">int</span><span class="bn">     10h                 </span><span class="co">;invoke BIOS video services</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [BIOS8x8Ptr],<span class="kw">bp</span>  <span class="co">;store the pointer</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [BIOS8x8Ptr<span class="dv">+2</span>],<span class="kw">es</span>
        <span class="kw">pop</span>     <span class="kw">ds</span>
        <span class="kw">pop</span>     <span class="kw">di</span>                  <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>                  <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
-SetBIOS8x8Font endp
        end</code></pre>
<p>Listing 44.1 is written in C. It could equally well have been written in assembly language, and would then have been somewhat faster. However, wanted to make the point (as I’ve made again and again) that assembly language, and, indeed, optimization in general, is needed only in the most critical portions of any program, and then only when the program would otherwise be too slow. Only in a highly performance-sensitive situation would the performance boost resulting from converting Listing 44.1 to assembly justify the time spent in coding and the bugs that would likely creep in—and the sample program already updates the screen at the maximum possible rate of once per frame even on a 1985-vintage 8-MHz AT. In this case, faster performance would result only in a longer wait for the page to flip.</p>
</section>
<section id="write-mode-3" class="level4">
<h4><a href="#write-mode-3">Write Mode 3</a></h4>
<p>It’s possible to update the bitmap very efficiently on the VGA, because the VGA can draw up to 8 pixels at once, and because the VGA provides a number of hardware features to speed up drawing. This article makes considerable use of one particularly unusual hardware feature, write mode 3. We discussed write mode 3 back in Chapter 26, but we’ve covered a lot of ground since then—so I’m going to run through a quick refresher on write mode 3.</p>
<p>Some background: In the standard VGA’s high-resolution mode, mode 12H (640x480 with 16 colors, the mode in which this chapter’s sample program runs), each byte of display memory controls 8 adjacent pixels on the screen. (The color of each pixel is, in turn, controlled by 4 bits spread across the four VGA memory planes, but we need not concern ourselves with that here.) Now, there will often be times when we want to change some but not all of the pixels controlled by a particular byte of display memory. This is not easily done, for there is no way to write half a byte, or two bits, or such to memory; it’s the whole byte or none of it at all.</p>
<p>You might think that using AND and OR to manipulate individual bits could solve the problem. Alas, not so. ANDing and ORing would work if the VGA had only one plane of memory (like the original monochrome Hercules Graphics Adapter) but the VGA has four planes, and ANDing and ORing would work only if we selected and manipulated each plane separately, a process that would be hideously slow. No, with the VGA you must use the hardware assist features, or you might as well forget about real-time screen updates altogether. Write mode 3 will do the trick for our present needs.</p>
<p>Write mode 3 is useful when you want to set some but not all of the pixels in a single byte of display memory <em>to the same color.</em> That is, if you want to draw a number of pixels within a byte in a single color, write mode 3 is a good way to do it.</p>
<p>Write mode 3 works like this. First, set the Graphics Controller Mode register to write mode 3. (Look at Listing 44.2 for code that does everything described here.) Next, set the Set/Reset register to the color with which you wish to draw, in the range 0-15. (It is not necessary to explicitly enable set/reset via the Enable Set/Reset register; write mode 3 does that automatically.) Then, to draw individual pixels within a single byte, simply read display memory, and then write a byte to display memory with 1-bits where you want the color to be drawn and 0-bits where you want the current bitmap contents to be preserved. (Note well that <em>the data actually read by the CPU doesn’t matter;</em> the read operation latches all four planes’ data, as described way back in Chapter 24.) So, for example, if write mode 3 is enabled and the Set/Reset register is set to 1 (blue), then the following sequence of operations:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>   <span class="kw">dx</span><span class="bn">,0a000h</span>
<span class="kw">mov</span>   <span class="kw">es</span>,<span class="kw">dx</span>
<span class="kw">mov</span>   <span class="kw">al</span>,<span class="kw">es</span>:[<span class="dv">0</span>]
<span class="kw">mov</span>   <span class="dt">byte</span> <span class="dt">ptr</span> <span class="kw">es</span>:[<span class="dv">0</span>]<span class="bn">,0f0h</span></code></pre>
<p>will change the first 4 pixels on the screen (the left nibble of the byte at offset 0 in display memory) to blue, and will leave the next 4 pixels (the right nibble of the byte at offset 0) unchanged.</p>
<p>Using one <code>MOV</code> to read from display memory and another to write to display memory is not particularly efficient on some processors. In Listing 44.2, I instead use <code>XCHG</code>, which reads and then writes a memory location in a single operation, as in:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>    <span class="kw">dx</span><span class="bn">,0a000h</span>
<span class="kw">mov</span>    <span class="kw">es</span>,<span class="kw">dx</span>
<span class="kw">mov</span>    <span class="kw">al</span><span class="bn">,0f0h</span>
<span class="kw">xchg</span>   <span class="kw">es</span>:[<span class="dv">0</span>],<span class="kw">al</span></code></pre>
<p>Again, the actual value that’s read is irrelevant. In general, the <code>XCHG</code> approach is more compact than two <code>MOV</code>s, and is faster on 386 and earlier processors, but slower on 486s and Pentiums.</p>
<p>If all pixels in a byte of display memory are to be drawn in a single color, it’s not necessary to read before writing, because none of the information in display memory at that byte needs to be preserved; a simple write of 0FFH (to draw all bits) will set all 8 pixels to the set/reset color:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span>   <span class="kw">dx</span><span class="bn">,0a000h</span>
<span class="kw">mov</span>   <span class="kw">es</span>,<span class="kw">dx</span>
<span class="kw">mov</span>   <span class="dt">byte</span> <span class="dt">ptr</span> <span class="kw">es</span>:[<span class="kw">di</span>]<span class="bn">,0ffh</span></code></pre>
<blockquote>
<p><img src="images/i.jpg" /> If you’re familiar with VGA programming, you’re no doubt aware that everything that can be done with write mode 3 can also be accomplished in write mode 0 or write mode 2 by using the Bit Mask register. However, setting the Bit Mask register requires at least one <code>OUT</code> per byte written, in addition to the read and write of display memory, and <code>OUT</code>s are often slower than display memory accesses, especially on 386s and 486s. One of the great virtues of write mode 3 is that it requires virtually no <code>OUT</code>s and is therefore substantially faster for masking than the other write modes.</p>
</blockquote>
<p>In short, write mode 3 is a good choice for single-color drawing that modifies individual pixels within display memory bytes. Not coincidentally, the sample application draws only single-color objects within the animation area; this allows write mode 3 to be used for all drawing, in keeping with our desire for speedy screen updates.</p>
</section>
<section id="drawing-text" class="level4">
<h4><a href="#drawing-text">Drawing Text</a></h4>
<p>We’ll need text in the sample application; is that also a good use for write mode 3? Sometimes it is, but not in this particular case.</p>
<p>Each character in a font is represented by a pattern of bits, with 1-bits representing character pixels and 0-bits representing background pixels. Since we’ll be using the 8x8 font stored in the BIOS ROM (a pointer to which can be obtained by calling a BIOS service, as illustrated by Listing 44.2), each character is exactly 8 bits, or 1 byte wide. We’ll further insist that characters be placed on byte boundaries (that is, with their left edges only at pixels with X coordinates that are multiples of 8); this means that the character bytes in the font are automatically aligned with display memory, and no rotation or clipping of characters is needed. Finally, we’ll draw all text in white.</p>
<p>Given the above assumptions, drawing text is easy; we simply copy each byte of each character to the appropriate location in display memory, and <em>voila</em>, we’re done. Text copying is done in write mode 0, in which the byte written to display memory is copied to all four planes at once; hence, 1-bits turn into white (color value 0FH, with 1-bits in all four planes), and 0-bits turn into black (color value 0). This is faster than using write mode 3 because write mode 3 requires a read/write of display memory (or at least preloading the latches with the background color), while the write mode 0 approach requires only a write to display memory.</p>
<blockquote>
<p><img src="images/i.jpg" /> Is write mode 0 always the best way to do text? Not at all. The write mode 0 approach described above draws both foreground and background pixels within the character box, forcing the background pixels to black at the same time that it forces the foreground pixels to white. If you want to draw transparent text (that is, draw only the character pixels, not the surrounding background box), write mode 3 is ideal. Also, matters get far more complicated if characters that aren’t 8 pixels wide are drawn, or if characters are drawn starting at arbitrary pixel locations, without the multiple-of-8 column restriction, so that rotation and masking are required. Lastly, the Map Mask register can be used to draw text in colors other than white—but only if the background is black. Otherwise, the data remaining in the planes protected by the Map Mask will remain and can interfere with the colors of the text being drawn.</p>
</blockquote>
<p>I’m not going to delve any deeper into the considerable issues of drawing VGA text; I just want to sensitize you to the existence of approaches other than the ones used in Listings 44.1 and 44.2. On the VGA, the rule is: If there’s something you want to do, there probably are 10 ways to do it, each with unique strengths and weaknesses. Your mission, should you decide to accept it, is to figure out which one is best for your particular application.</p>
</section>
<section id="page-flipping-1" class="level4">
<h4><a href="#page-flipping-1">Page Flipping</a></h4>
<p>Now that we know how to update the screen reasonably quickly, it’s time to get on to the fun stuff. Page flipping answers the second requirement for animation, by keeping bitmap changes off the screen until they’re complete. In other words, page flipping guarantees that partially updated bitmaps are never seen.</p>
<p>How is it possible to update a bitmap without seeing the changes as they’re made? Easy—with page flipping, there are <em>two</em> bitmaps; the program shows you one bitmap while it updates the other. Conceptually, it’s that simple. In practice, unfortunately, it’s not so simple, because of the design of the VGA. To understand why that is, we must look at how the VGA turns bytes in display memory into pixels on the screen.</p>
<p>The VGA bitmap is a linear 64 K block of memory. (True, most adapters nowadays are SuperVGAs with more than 256 K of display memory, but every make of SuperVGA has its own way of letting you access that extra memory, so going beyond standard VGA is a daunting and difficult task. Also, it’s hard to manipulate the large frame buffers of SuperVGA modes fast enough for real-time animation.) Normally, the VGA picks up the first byte of memory (the byte at offset 0) and displays the corresponding 8 pixels on the screen, then picks up the byte at offset 1 and displays the next 8 pixels, and so on to the end of the screen. However, the offset of the first byte of display memory picked up during each frame is not fixed at 0, but is rather programmable by way of the Start Address High and Low registers, which together store the 16-bit offset in display memory at which the bitmap to be displayed during the next frame starts. So, for example, in mode 10H (640x350, 16 colors), a large enough bitmap to store a complete screen of information can be stored at display memory offsets 0 through 27,999, and <em>another</em> full bitmap could be stored at offsets 28,000 through 55,999, as shown in Figure 44.1. (I’m discussing 640x350 mode at the moment for good reason; we’ll get to 640x480 shortly.) When the Start Address registers are set to 0, the first bitmap (or page) is displayed; when they are set to 28,000, the second bitmap is displayed. Page flipped animation can be performed by displaying page 0 and drawing to page 1, then setting the start address to page 1 to display that page and drawing to page 0, and so on <em>ad infinitum.</em></p>
<figure>
<img src="images/44-01.jpg" alt="Figure 44.1  Memory allocation for mode 10h page flipping." /><figcaption><strong>Figure 44.1</strong>  <em>Memory allocation for mode 10h page flipping.</em></figcaption>
</figure>
</section>
<section id="knowing-when-to-flip" class="level4">
<h4><a href="#knowing-when-to-flip">Knowing When to Flip</a></h4>
<p>There’s a hitch, though, and that hitch is knowing exactly when it is that the page has flipped. The page doesn’t flip the instant that you set the Start Address registers. The VGA loads the starting offset from the Start Address registers once before starting each frame, then pays those registers no nevermind until the next frame comes around. This means that you can set the Start Address registers whenever you want—but the page actually being displayed doesn’t change until after the VGA loads that new offset in preparation for the next frame.</p>
<p>The potential problem should be obvious. Suppose that page 1 is being displayed, and you’re updating page 0. You finish drawing to page 0, set the Start Address registers to 0 to switch to displaying page 0, and start updating page 1, which is no longer displayed. Or is it? If the VGA was in the middle of the current frame, displaying page 1, when you set the Start Address registers, then page 1 is going to be displayed for the rest of the frame, no matter what you do with the Start Address registers. If you start updating page 1 right away, any changes you make may well show up on the screen, because page 0 hasn’t yet flipped to being displayed in place of page 1—and that defeats the whole purpose of page flipping.</p>
<p>To avoid this problem, it is mandatory that you wait until you’re sure the page has flipped. The Start Address registers are, according to my tests, loaded at the start of the Vertical Sync signal, although that may not be the case with all VGA clones. The Vertical Sync status is provided as bit 3 of the Input Status 1 register, so it would seem that all you need to do to flip a page is set the new Start Address registers, wait for the start of the Vertical Sync pulse that indicates that the page has flipped, and be on your merry way.</p>
<p>Almost—but not quite. (Do I hear teeth gnashing in the background?) The problem is this: Suppose that, by coincidence, you set one of the Start Address registers just before the start of Vertical Sync, and the other right after the start of Vertical Sync. Why, then, for one frame the Start Address High value for one page would be mixed with the Start Address Low value for the other page, and, depending on the start address values, the whole screen could appear to shift any number of pixels for a single, horrible frame. <em>This must never happen!</em> The solution is to set the Start Address registers when you’re certain Vertical Sync is not about to start. The easiest way to know that is to check for the Display Enable status (bit 0 of the Input Status 1 register) being active; that means that bitmap-controlled pixels are being scanned onto the screen, and, since Vertical Sync happens in the middle of the vertical non-display portion of the frame, Vertical Sync can never be anywhere nearby if Display Enable is active. (Note that one good alternative is to set up both pages with a start address that’s a multiple of 256, and just change the Start Address High register and wait for Vertical Sync, with no Display Enable wait required.)</p>
<p>So, to flip pages, you must complete all drawing to the non-displayed page, wait for Display Enable to be active, set the new start address, and wait for Vertical Sync to be active. At that point, you can be fully confident that the page that you just flipped off the screen is not displayed and can safely (invisibly) be updated. A side benefit of page flipping is that your program will automatically have a constant time base, with the rate at which new screens are drawn synchronized to the frame rate of the display (typically 60 or 70 Hz). However, complex updates may take more than one frame to complete, especially on slower processors; this can be compensated for by maintaining a count of new screens drawn and cross-referencing that to the BIOS timer count periodically, accelerating the overall pace of the animation (moving farther each time and the like) if updates are happening too slowly.</p>
</section>
<section id="enter-the-split-screen" class="level4">
<h4><a href="#enter-the-split-screen">Enter the Split Screen</a></h4>
<p>So far, I’ve discussed page flipping in 640x350 mode. There’s a reason for that: 640x350 is the highest-resolution standard mode in which there’s enough display memory for two full pages on a standard VGA. It’s possible to program the VGA to a non-standard 640x400 mode and still have two full pages, but that’s pretty much the limit. One 640x480 page takes 38,400 bytes of display memory, and clearly there isn’t enough room in 64 K of display memory for two of <em>those</em> monster pages.</p>
<p>And yet, 640x480 is a wonderful mode in many ways. It offers a 1:1 aspect ratio (square pixels), and it provides by far the best resolution of any 16-color mode. Surely there’s <em>some</em> way to bring the visual appeal of page flipping to this mode?</p>
<p>Surely there is—but it’s an odd solution indeed. The VGA has a feature, known as the <em>split screen,</em> that allows you to force the offset from which the VGA fetches video data back to 0 after any desired scan line. For example, you can program the VGA to scan through display memory as usual until it finishes scan line number 338, and then get the first byte of information for scan line number 339 from offset 0 in display memory.</p>
<p>That, in turn, allows us to divvy up display memory into three areas, as shown in Figure 44.2. The area from 0 to 11,279 is reserved for the split screen, the area from 11,280 to 38,399 is used for page 0, and the area from 38,400 to 65,519 is used for page 1. This allows page flipping to be performed in the top 339 scan lines (about 70 percent) of the screen, and leaves the bottom 141 scan lines for non-animation purposes, such as showing scores, instructions, statuses, and suchlike. (Note that the allocation of display memory and number of scan lines are dictated by the desire to have as many page-flipped scan lines as possible; you may, if you wish, have fewer page-flipped lines and reserve part of the bitmap for other uses, such as off-screen storage for images.)</p>
<figure>
<img src="images/44-02.jpg" alt="Figure 44.2  Memory allocation for mode 12h page flipping." /><figcaption><strong>Figure 44.2</strong>  <em>Memory allocation for mode 12h page flipping.</em></figcaption>
</figure>
<p>The sample program for this chapter uses the split screen and page flipping exactly as described above. The playfield through which the object bounces is the page-flipped portion of the screen, and the rectangle at the bottom containing the bounce count and the instructions is the split (that is, not animatable) portion of the screen. Of course, to the user it all looks like one screen. There are no visible boundaries between the two unless you choose to create them.</p>
<p>Very few animation applications use the entire screen for animation. If you can get by with 339 scan lines of animation, split-screen page flipping gives you the best combination of square pixels and high resolution possible on a standard VGA.</p>
<p>So. Is VGA animation worth all the fuss? <em>Mais oui.</em> Run the sample program; if you’ve never seen aggressive VGA animation before, you’ll be amazed at how smooth it can be. Not every square millimeter of every animated screen must be in constant motion. Most graphics screens need a little quiet space to display scores, coordinates, file names, or (if all else fails) company logos. If you don’t tell the user he’s/she’s only getting 339 scan lines of animation, he’ll/she’ll probably never know.</p>
</section>
</section>
</section>
<section id="chapter-45-dog-hair-and-dirty-rectangles" class="level2">
<h2><a href="#chapter-45-dog-hair-and-dirty-rectangles">Chapter 45 – Dog Hair and Dirty Rectangles</a></h2>
<section id="different-angles-on-animation" class="level3">
<h3><a href="#different-angles-on-animation">Different Angles on Animation</a></h3>
<p>We brought our pets with us when we moved to Seattle. At about the same time, our Golden Retriever, Sam, observed his third birthday. Sam is relatively intelligent, in the sense that he is clearly smarter than a banana slug, although if he were in the same room with Jeff Duntemann’s dog Mr. Byte, there’s a reasonable chance that he would mistake Mr. Byte for something edible (a category that includes rocks, socks, and a surprising number of things too disgusting to mention), and Jeff would have to find a new source of things to write about.</p>
<p>But that’s not important now. What is important is that—and I am not making this up—this morning I managed to find the one pair of socks Sam hadn’t chewed holes in. And what’s even more important is that after we moved and Sam turned three, he calmed down amazingly. We had been waiting for this magic transformation since Sam turned one, the age at which most puppies turn into normal dogs who lie around a lot, waking up to eat their Science Diet (motto, “The dog food that costs more than the average neurosurgeon makes in a year”) before licking themselves in embarrassing places and going back to sleep. When Sam turned one and remained hopelessly out of control we said, “Goldens take two years to calm down,” as if we had a clue. When he turned two and remained undeniably Sam we said, “Any day now.” By the time he turned three, we were reduced to figuring that it was only about seven more years until he expired, at which point we might be able to take all the fur he had shed in his lifetime and weave ourselves some clothes without holes in them, or quite possibly a house.</p>
<p>But miracle of miracles, we moved, and Sam instantly turned into the dog we thought we’d gotten when we forked over $500—calm, sweet, and obedient. Weeks went by, and Sam was, if anything, better than ever. Clearly, the change was permanent.</p>
<p>And then we took Sam to the vet for his annual check-up and found that he had an ear infection. Thanks to the wonders of modern animal medicine, a $5 bottle of liquid restored his health in just two days. And with his health, we got, as a bonus, the old Sam. You see, Sam hadn’t changed. He was just tired from being sick. Now he once again joyously knocks down any stranger who makes the mistake of glancing in his direction, and will, quite possibly, be booked any day now on suspicion of homicide by licking.</p>
</section>
<section id="plus-ça-change" class="level3">
<h3><a href="#plus-ça-change">Plus ça Change</a></h3>
<p>Okay, you give up. What exactly does this have to do with graphics? I’m glad you asked. The lesson to be learned from Sam, The Dog With A Brain The Size Of A Walnut, is that while things may <em>look</em> like they’ve changed, in fact they often haven’t. Take VGA performance. If you buy a 486 with a SuperVGA, you’ll get performance that knocks your socks off, especially if you run Windows. Things are liable to be so fast that you’ll figure the SuperVGA has to deserve some of the credit. Well, maybe it does if it’s a local-bus VGA. But maybe it doesn’t, even if it is local bus—and it certainly doesn’t if it’s an ISA bus VGA, because no ISA bus VGA can run faster than about 300 nanoseconds per access, and VGAs capable of that speed have been common for at least a couple of years now.</p>
<p>Your 486 VGA system is fast almost entirely because it has a 486 in it. (486 systems with graphics accelerators such as the ATI Ultra or Diamond Stealth are another story altogether.) Underneath it all, the VGA is still painfully slow—and if you have an old VGA or IBM’s original PS/2 motherboard VGA, it’s incredibly slow. The fastest ISA-bus VGA around is two to twenty times slower than system memory, and the slowest VGA around is as much as 100 times slower. In the old days, the rule was, “Display memory is slow, and should be avoided.” Nowadays, the rule is, “Display memory is not quite so slow, but should still be avoided.”</p>
<p>So, as I say, sometimes things don’t change. Of course, sometimes they do change. For example, in just 49 dog years, I fully expect to own at least one pair of underwear without a single hole in it. Which brings us, deus ex machina and the creek don’t rise, to yet another animation method: dirty-rectangle animation.</p>
</section>
<section id="vga-access-times" class="level3">
<h3><a href="#vga-access-times">VGA Access Times</a></h3>
<p>Actually, before we get to dirty rectangles, I’d like to take you through a quick refresher on VGA memory and I/O access times. I want to do this partly because the slow access times of the VGA make dirty-rectangle animation particularly attractive, and partly as a public service, because even I was shocked by the results of some I/O performance tests I recently ran.</p>
<p>Table 45.1 shows the results of the aforementioned I/O performance tests, as run on two 486/33 SuperVGA systems under the Phar Lap 386|DOS-Extender. (The systems and VGAs are unnamed because this is a not-very-scientific spot test, and I don’t want to unfairly malign, say, a VGA whose only sin is being plugged into a lousy motherboard, or vice versa.) Under Phar Lap, 32-bit protected-mode apps run with full I/O privileges, meaning that the <code>OUT</code> instructions I measured had the best official cycle times possible on the 486: 10 cycles. <code>OUT</code> officially takes 16 cycles in real mode on a 486, and officially takes a mind-boggling 30 cycles in protected mode if running <em>without</em> full I/O privileges (as is normally the case for protected-mode applications). Basically, I/O is just plain slow on a 486.</p>
<p>As slow as 30 or even 10 cycles is for an <code>OUT</code>, one could only wish that VGA I/O were actually that fast. The fastest measured <code>OUT</code> to a VGA in Table 45.1 is 26 cycles, and the slowest is 126—this for an operation that’s <em>supposed</em> to take 10 cycles. To put this in context, <code>MUL</code> takes only 13 to 42 cycles, and a normal <code>MOV</code> to or from system memory takes exactly one cycle on the 486. In short, <code>OUT</code>s to VGAs are as much as 100 times slower than normal memory accesses, and are generally two to four times slower than even display memory accesses, although there are exceptions.</p>
<p>Of course, VGA display memory has its own performance problems. The fastest ISA bus VGA can, at best, support sustained write times of about 10 cycles per word-sized write on a 486/33; 15 or 20 cycles is more common, even for relatively fast SuperVGAs; the worst case I’ve seen is 65 cycles per byte. However, intermittent writes, mixed with a lot of register and cache-only code, can effectively execute in one cycle, thanks to the caching design of many VGAs and the 486’s 4-deep write buffer, which stores pending writes while the CPU continues executing instructions. Display memory reads tend to take longer, because coprocessing isn’t possible—one microsecond is a reasonable rule of thumb for VGA reads, although there’s considerable variation. So VGA memory tends not to be as bad as VGA I/O, but lord knows it isn’t <em>good</em>.</p>
<p><strong>OUT Time in Microseconds and Cycles</strong></p>
<table>
<caption>Table 45.1 Results of I/O performance tests run under the Phar Lap386|DOS-Extender.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">OUT Instruction</th>
<th style="text-align: left;">Official Time</th>
<th style="text-align: left;">486 #1/16-bit VGA #1</th>
<th style="text-align: left;">486 #2/16-bit VGA #2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OUT DX,AL repeated 1,000 times nonstop (maximum byte access)</td>
<td style="text-align: left;">0.300s 10 cycles</td>
<td style="text-align: left;">2.546s 84 cycles</td>
<td style="text-align: left;">0.813s 27 cycles</td>
</tr>
<tr class="even">
<td style="text-align: left;">OUT DX,AX repeated 1,000 times nonstop (maximum word access)</td>
<td style="text-align: left;">0.300s 10 cycles</td>
<td style="text-align: left;">3.820s 126 cycles</td>
<td style="text-align: left;">1.066s 35 cycles</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OUT DX,AL repeated 1,000 times, but interspersed with MULs (random byte access)</td>
<td style="text-align: left;">0.300s 10 cycles</td>
<td style="text-align: left;">1.610s 53 cycles</td>
<td style="text-align: left;">0.780s 26 cycles</td>
</tr>
<tr class="even">
<td style="text-align: left;">OUT DX,AX repeated 1,000 times, but interspersed with MULs (random word access)</td>
<td style="text-align: left;">0.300s 10 cycles</td>
<td style="text-align: left;">2.830s 93 cycles</td>
<td style="text-align: left;">1.010s 33 cycles</td>
</tr>
</tbody>
</table>
<blockquote>
<p><img src="images/i.jpg" /> <code>OUT</code>s, in general, are lousy on the 486 (and to think they only took three cycles on the 286!). <code>OUT</code>s to VGAs are particularly lousy. Display memory performance is pretty poor, especially for reads. The conclusions are obvious, I would hope. Structure your graphics code, and, in general, all 486 code, to avoid <code>OUT</code>s.</p>
</blockquote>
<p>For graphics, this especially means using write mode 3 rather than the bit-mask register. When you must use the bit mask, arrange drawing so that you can set the bit mask once, then do a lot of drawing with that mask. For example, draw a whole edge at once, then the middle, then the other edge, rather than setting the bit mask several times on each scan line to draw the edge and middle bytes together. Don’t read from display memory if you don’t have to. Write each pixel once and only once.</p>
<p>It is indeed a strange concept: The key to fast graphics is staying away from the graphics adapter as much as possible.</p>
</section>
<section id="dirty-rectangle-animation" class="level3">
<h3><a href="#dirty-rectangle-animation">Dirty-Rectangle Animation</a></h3>
<p>The relative slowness of VGA hardware is part of the appeal of the technique that I call “dirty-rectangle” animation, in which a complete copy of the contents of display memory is maintained in offscreen system (nondisplay) memory. All drawing is done to this system buffer. As offscreen drawing is done, a list is maintained of the bounding rectangles for the drawn-to areas; these are the <em>dirty rectangles</em>, “dirty” in the sense that that have been altered and no longer match the contents of the screen. After all drawing for a frame is completed, all the dirty rectangles for that frame are copied to the screen in a burst, and then the cycle of off-screen drawing begins again.</p>
<p>Why, exactly, would we want to go through all this complication, rather than simply drawing to the screen in the first place? The reason is visual quality. If we were to do all our drawing directly to the screen, there’d be a lot of flicker as objects were erased and then redrawn. Similarly, overlapped drawing done with the painter’s algorithm (in which farther objects are drawn first, so that nearer objects obscure them) would flicker as farther objects were visible for short periods. With dirty-rectangle animation, only the finished pixels for any given frame ever appear on the screen; intermediate results are never visible. Figure 45.1 illustrates the visual problems associated with drawing directly to the screen; Figure 45.2 shows how dirty-rectangle animation solves these problems.</p>
<figure>
<img src="images/45-01.jpg" alt="Figure 45.1  Drawing directly to the screen." /><figcaption><strong>Figure 45.1</strong>  <em>Drawing directly to the screen.</em></figcaption>
</figure>
<figure>
<img src="images/45-02.jpg" alt="Figure 45.2  Dirty rectangle animation." /><figcaption><strong>Figure 45.2</strong>  <em>Dirty rectangle animation.</em></figcaption>
</figure>
<section id="so-why-not-use-page-flipping" class="level4">
<h4><a href="#so-why-not-use-page-flipping">So Why Not Use Page Flipping?</a></h4>
<p>Well, then, if we want good visual quality, why not use page flipping? For one thing, not all adapters and all modes support page flipping. The CGA and MCGA don’t, and neither do the VGA’s 640x480 16-color or 320x200 256-color modes, or many SuperVGA modes. In contrast, <em>all</em> adapters support dirty-rectangle animation. Another advantage of dirty-rectangle animation is that it’s generally faster. While it may seem strange that it would be faster to draw off-screen and then copy the result to the screen, that is often the case, because dirty-rectangle animation usually reduces the number of times the VGA’s hardware needs to be touched, especially in 256-color modes.</p>
<p>This reduction comes about because when dirty rectangles are erased, it’s done in system memory, not in display memory, and since most objects move a good deal less than their full width (that is, the new and old positions overlap), display memory is written to fewer times than with page flipping. (In 16-color modes, this is not necessarily the case, because of the parallelism obtained from the VGA’s planar hardware.) Also, read/modify/write operations are performed in fast system memory rather than slow display memory, so display memory rarely needs to be read. This is particularly good because display memory is generally even slower for reads than for writes.</p>
<p>Also, page flipping wastes a good deal of time waiting for the page to flip at the end of the frame. Dirty-rectangle animation never needs to wait for anything because partially drawn images are never present in display memory. Actually, in one sense, partially drawn images are sometimes present because it’s possible for a rectangle to be partially drawn when the scanning raster beam reaches that part of the screen. This causes the rectangle to appear partially drawn for one frame, producing a phenomenon I call “shearing.” Fortunately, shearing tends not to be particularly distracting, especially for fairly small images, but it can be a problem when copying large areas. This is one area in which dirty-rectangle animation falls short of page flipping, because page flipping has perfect display quality, never showing anything other than a completely finished frame. Similarly, dirty-rectangle copying may take two or more frame times to finish, so even if shearing doesn’t happen, it’s still possible to have the images in the various dirty rectangles show up non-simultaneously. In my experience, this latter phenomenon is not a serious problem, but do be aware of it.</p>
</section>
</section>
<section id="dirty-rectangles-in-action" class="level3">
<h3><a href="#dirty-rectangles-in-action">Dirty Rectangles in Action</a></h3>
<p>Listing 45.1 demonstrates dirty-rectangle animation. This is a very simple implementation, in several respects. For one thing, it’s written entirely in C, and animation fairly cries out for assembly language. For another thing, it uses far pointers, which C often handles with less than optimal efficiency, especially because I haven’t used library functions to copy and fill memory. (I did this so the code would work in any memory model.) Also, Listing 45.1 doesn’t attempt to coalesce rectangles so as to perform a minimum number of display-memory accesses; instead, it copies each dirty rectangle to the screen, even if it overlaps with another rectangle, so some pixels are copied multiple times. Listing 45.1 runs pretty well, considering all of its failings; on my 486/33, 10 11x11 images animate at a very respectable clip.</p>
<p><strong>LISTING 45.1 L45-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Sample simple dirty-rectangle animation program. Doesn&#39;t attempt to coalesce</span>
<span class="co">   rectangles to minimize display memory accesses. Not even vaguely optimized!</span>
<span class="co">   Tested with Borland C++ in the small model. */</span>

<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;alloc.h&gt;</span>
<span class="ot">#include &lt;memory.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>

<span class="ot">#define SCREEN_WIDTH  320</span>
<span class="ot">#define SCREEN_HEIGHT 200</span>
<span class="ot">#define SCREEN_SEGMENT 0xA000</span>

<span class="co">/* Describes a rectangle */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
   <span class="dt">int</span> Top;
   <span class="dt">int</span> Left;
   <span class="dt">int</span> Right;
   <span class="dt">int</span> Bottom;
} Rectangle;

<span class="co">/* Describes an animated object */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
   <span class="dt">int</span> X;            <span class="co">/* upper left corner in virtual bitmap */</span>
   <span class="dt">int</span> Y;
   <span class="dt">int</span> XDirection;   <span class="co">/* direction and distance of movement */</span>
   <span class="dt">int</span> YDirection;
} Entity;

<span class="co">/* Storage used for dirty rectangles */</span>
<span class="ot">#define MAX_DIRTY_RECTANGLES  100</span>
<span class="dt">int</span> NumDirtyRectangles;
Rectangle DirtyRectangles[MAX_DIRTY_RECTANGLES];

<span class="co">/* If set to 1, ignore dirty rectangle list and copy the whole screen. */</span>
<span class="dt">int</span> DrawWholeScreen = <span class="dv">0</span>;

<span class="co">/* Pixels for image we&#39;ll animate */</span>
<span class="ot">#define IMAGE_WIDTH  11</span>
<span class="ot">#define IMAGE_HEIGHT 11</span>
<span class="dt">char</span> ImagePixels[] = {
  <span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>,
  <span class="dv">15</span>,<span class="dv">15</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">15</span>,<span class="dv">15</span>,
  <span class="dv">15</span>, <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">15</span>,
   <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>,
   <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>,
   <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>,
   <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>,
   <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>,
  <span class="dv">15</span>, <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">15</span>,
  <span class="dv">15</span>,<span class="dv">15</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">15</span>,<span class="dv">15</span>,
  <span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>,
};
<span class="co">/* animated entities */</span>
<span class="ot">#define NUM_ENTITIES 10</span>
Entity Entities[NUM_ENTITIES];

<span class="co">/* pointer to system buffer into which we&#39;ll draw */</span>
<span class="dt">char</span> far *SystemBufferPtr;

<span class="co">/* pointer to screen */</span>
<span class="dt">char</span> far *ScreenPtr;

<span class="dt">void</span> EraseEntities(<span class="dt">void</span>);
<span class="dt">void</span> CopyDirtyRectanglesToScreen(<span class="dt">void</span>);
<span class="dt">void</span> DrawEntities(<span class="dt">void</span>);

<span class="dt">void</span> main()
{
   <span class="dt">int</span> i, XTemp, YTemp;
   <span class="dt">unsigned</span> <span class="dt">int</span> TempCount;
   <span class="dt">char</span> far *TempPtr;
   <span class="kw">union</span> REGS regs;
   <span class="co">/* Allocate memory for the system buffer into which we&#39;ll draw */</span>
   <span class="kw">if</span> (!(SystemBufferPtr = farmalloc((<span class="dt">unsigned</span> <span class="dt">int</span>)SCREEN_WIDTH*
         SCREEN_HEIGHT))) {
      printf(<span class="st">&quot;Couldn&#39;t get memory</span><span class="ch">\n</span><span class="st">&quot;</span>);
      exit(<span class="dv">1</span>);
   }
   <span class="co">/* Clear the system buffer */</span>
   TempPtr = SystemBufferPtr;
   <span class="kw">for</span> (TempCount = ((<span class="dt">unsigned</span>)SCREEN_WIDTH*SCREEN_HEIGHT); TempCount--; ) {
      *TempPtr++ = <span class="dv">0</span>;
   }
   <span class="co">/* Point to the screen */</span>
   ScreenPtr = MK_FP(SCREEN_SEGMENT, <span class="dv">0</span>);

   <span class="co">/* Set up the entities we&#39;ll animate, at random locations */</span>
   randomize();
   <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; NUM_ENTITIES; i++) {
      Entities[i].X = random(SCREEN_WIDTH - IMAGE_WIDTH);
      Entities[i].Y = random(SCREEN_HEIGHT - IMAGE_HEIGHT);
      Entities[i].XDirection = <span class="dv">1</span>;
      Entities[i].YDirection = -<span class="dv">1</span>;
   }
   <span class="co">/* Set 320x200 256-color graphics mode */</span>
   regs.x.ax = <span class="bn">0x0013</span>;
   int86(<span class="bn">0x10</span>, &amp;regs, &amp;regs);

   <span class="co">/* Loop and draw until a key is pressed */</span>
   <span class="kw">do</span> {
      <span class="co">/* Draw the entities to the system buffer at their current locations,</span>
<span class="co">         updating the dirty rectangle list */</span>
      DrawEntities();

      <span class="co">/* Draw the dirty rectangles, or the whole system buffer if</span>
<span class="co">         appropriate */</span>
      CopyDirtyRectanglesToScreen();

      <span class="co">/* Reset the dirty rectangle list to empty */</span>
      NumDirtyRectangles = <span class="dv">0</span>;

      <span class="co">/* Erase the entities in the system buffer at their old locations,</span>
<span class="co">         updating the dirty rectangle list */</span>
      EraseEntities();

      <span class="co">/* Move the entities, bouncing off the edges of the screen */</span>
      <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; NUM_ENTITIES; i++) {
         XTemp = Entities[i].X + Entities[i].XDirection;
         YTemp = Entities[i].Y + Entities[i].YDirection;
         <span class="kw">if</span> ((XTemp &lt; <span class="dv">0</span>) || ((XTemp + IMAGE_WIDTH) &gt; SCREEN_WIDTH)) {
            Entities[i].XDirection = -Entities[i].XDirection;
            XTemp = Entities[i].X + Entities[i].XDirection;
         }
         <span class="kw">if</span> ((YTemp &lt; <span class="dv">0</span>) || ((YTemp + IMAGE_HEIGHT) &gt; SCREEN_HEIGHT)) {
            Entities[i].YDirection = -Entities[i].YDirection;
            YTemp = Entities[i].Y + Entities[i].YDirection;
         }
         Entities[i].X = XTemp;
         Entities[i].Y = YTemp;
      }

   } <span class="kw">while</span> (!kbhit());
   getch();    <span class="co">/* clear the keypress */</span>
   <span class="co">/* Back to text mode */</span>
   regs.x.ax = <span class="bn">0x0003</span>;
   int86(<span class="bn">0x10</span>, &amp;regs, &amp;regs);
}
<span class="co">/* Draw entities at current locations, updating dirty rectangle list. */</span>
<span class="dt">void</span> DrawEntities()
{
   <span class="dt">int</span> i, j, k;
   <span class="dt">char</span> far *RowPtrBuffer;
   <span class="dt">char</span> far *TempPtrBuffer;
   <span class="dt">char</span> far *TempPtrImage;
   <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; NUM_ENTITIES; i++) {
      <span class="co">/* Remember the dirty rectangle info for this entity */</span>
      <span class="kw">if</span> (NumDirtyRectangles &gt;= MAX_DIRTY_RECTANGLES) {
         <span class="co">/* Too many dirty rectangles; just redraw the whole screen */</span>
         DrawWholeScreen = <span class="dv">1</span>;
      } <span class="kw">else</span> {
         <span class="co">/* Remember this dirty rectangle */</span>
         DirtyRectangles[NumDirtyRectangles].Left = Entities[i].X;
         DirtyRectangles[NumDirtyRectangles].Top = Entities[i].Y;
         DirtyRectangles[NumDirtyRectangles].Right =
               Entities[i].X + IMAGE_WIDTH;
         DirtyRectangles[NumDirtyRectangles++].Bottom =
               Entities[i].Y + IMAGE_HEIGHT;
      }
      <span class="co">/* Point to the destination in the system buffer */</span>
      RowPtrBuffer = SystemBufferPtr + (Entities[i].Y * SCREEN_WIDTH) +
            Entities[i].X;
      <span class="co">/* Point to the image to draw */</span>
      TempPtrImage = ImagePixels;
      <span class="co">/* Copy the image to the system buffer */</span>
      <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; IMAGE_HEIGHT; j++) {
         <span class="co">/* Copy a row */</span>
         <span class="kw">for</span> (k = <span class="dv">0</span>, TempPtrBuffer = RowPtrBuffer; k &lt; IMAGE_WIDTH; k++) {
            *TempPtrBuffer++ = *TempPtrImage++;
         }
         <span class="co">/* Point to the next system buffer row */</span>
         RowPtrBuffer += SCREEN_WIDTH;
      }
   }
}
<span class="co">/* Copy the dirty rectangles, or the whole system buffer if appropriate,</span>
<span class="co">   to the screen. */</span>
<span class="dt">void</span> CopyDirtyRectanglesToScreen()
{
   <span class="dt">int</span> i, j, k, RectWidth, RectHeight;
   <span class="dt">unsigned</span> <span class="dt">int</span> TempCount;
   <span class="dt">unsigned</span> <span class="dt">int</span> Offset;
   <span class="dt">char</span> far *TempPtrScreen;
   <span class="dt">char</span> far *TempPtrBuffer;

   <span class="kw">if</span> (DrawWholeScreen) {
      <span class="co">/* Just copy the whole buffer to the screen */</span>
      DrawWholeScreen = <span class="dv">0</span>;
      TempPtrScreen = ScreenPtr;
      TempPtrBuffer = SystemBufferPtr;
      <span class="kw">for</span> (TempCount = ((<span class="dt">unsigned</span>)SCREEN_WIDTH*SCREEN_HEIGHT); TempCount--; ) {
         *TempPtrScreen++ = *TempPtrBuffer++;
      }
   } <span class="kw">else</span> {
      <span class="co">/* Copy only the dirty rectangles */</span>
      <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; NumDirtyRectangles; i++) {
         <span class="co">/* Offset in both system buffer and screen of image */</span>
         Offset = (<span class="dt">unsigned</span> <span class="dt">int</span>) (DirtyRectangles[i].Top * SCREEN_WIDTH) +
               DirtyRectangles[i].Left;
         <span class="co">/* Dimensions of dirty rectangle */</span>
         RectWidth = DirtyRectangles[i].Right - DirtyRectangles[i].Left;
         RectHeight = DirtyRectangles[i].Bottom - DirtyRectangles[i].Top;
         <span class="co">/* Copy a dirty rectangle */</span>
         <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; RectHeight; j++) {

            <span class="co">/* Point to the start of row on screen */</span>
            TempPtrScreen = ScreenPtr + Offset;

            <span class="co">/* Point to the start of row in system buffer */</span>
            TempPtrBuffer = SystemBufferPtr + Offset;

            <span class="co">/* Copy a row */</span>
            <span class="kw">for</span> (k = <span class="dv">0</span>; k &lt; RectWidth; k++) {
               *TempPtrScreen++ = *TempPtrBuffer++;
            }
            <span class="co">/* Point to the next row */</span>
            Offset += SCREEN_WIDTH;
         }
      }
   }
}
<span class="co">/* Erase the entities in the system buffer at their current locations,</span>
<span class="co">   updating the dirty rectangle list. */</span>
<span class="dt">void</span> EraseEntities()
{
   <span class="dt">int</span> i, j, k;
   <span class="dt">char</span> far *RowPtr;
   <span class="dt">char</span> far *TempPtr;

   <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; NUM_ENTITIES; i++) {
      <span class="co">/* Remember the dirty rectangle info for this entity */</span>
      <span class="kw">if</span> (NumDirtyRectangles &gt;= MAX_DIRTY_RECTANGLES) {
         <span class="co">/* Too many dirty rectangles; just redraw the whole screen */</span>
         DrawWholeScreen = <span class="dv">1</span>;
      } <span class="kw">else</span> {
         <span class="co">/* Remember this dirty rectangle */</span>
         DirtyRectangles[NumDirtyRectangles].Left = Entities[i].X;
         DirtyRectangles[NumDirtyRectangles].Top = Entities[i].Y;
         DirtyRectangles[NumDirtyRectangles].Right =
               Entities[i].X + IMAGE_WIDTH;
         DirtyRectangles[NumDirtyRectangles++].Bottom =
               Entities[i].Y + IMAGE_HEIGHT;
      }
      <span class="co">/* Point to the destination in the system buffer */</span>
      RowPtr = SystemBufferPtr + (Entities[i].Y*SCREEN_WIDTH) + Entities[i].X;

      <span class="co">/* Clear the entity&#39;s rectangle */</span>
      <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; IMAGE_HEIGHT; j++) {
         <span class="co">/* Clear a row */</span>
         <span class="kw">for</span> (k = <span class="dv">0</span>, TempPtr = RowPtr; k &lt; IMAGE_WIDTH; k++) {
            *TempPtr++ = <span class="dv">0</span>;
         }
         <span class="co">/* Point to the next row */</span>
         RowPtr += SCREEN_WIDTH;
      }
   }
}</code></pre>
<p>One point I’d like to make is that although the system-memory buffer in Listing 45.1 has exactly the same dimensions as the screen bitmap, that’s not a requirement, and there are some good reasons not to make the two the same size. For example, if the system buffer is bigger than the area displayed on the screen, it’s possible to pan the visible area around the system buffer. Or, alternatively, the system buffer can be just the size of a desired window, representing a window into a larger, virtual buffer. We could then draw the desired portion of the virtual bitmap into the system-memory buffer, then copy the buffer to the screen, and the effect will be of having panned the window to the new location.</p>
<blockquote>
<p><img src="images/i.jpg" /> Another argument in favor of a small viewing window is that it restricts the amount of display memory actually drawn to. Restricting the display memory used for animation reduces the total number of display-memory accesses, which in turn boosts overall performance; it also improves the performance and appearance of panning, in which the whole window has to be redrawn or copied.</p>
</blockquote>
<p>If you keep a close watch, you’ll notice that many high-performance animation games similarly restrict their full-featured animation area to a relatively small region. Often, it’s hard to tell that this is the case, because the animation region is surrounded by flashy digitized graphics and by items such as scoreboards and status screens, but look closely and see if the animation region in your favorite game isn’t smaller than you thought.</p>
</section>
<section id="hi-res-vga-page-flipping" class="level3">
<h3><a href="#hi-res-vga-page-flipping">Hi-Res VGA Page Flipping</a></h3>
<p>On a standard VGA, hi-res mode is mode 12H, which offers 640x480 resolution with 16 colors. That’s a nice mode, with plenty of pixels, and square ones at that, but it lacks one thing—page flipping. The problem is that the mode 12H bitmap is 150 K in size, and the standard VGA has only 256 K total, too little memory for two of those monster mode 12H pages. With only one page, flipping is obviously out of the question, and without page flipping, top-flight, hi-res animation can’t be implemented. The standard fallback is to use the EGA’s hi-res mode, mode 10H (640x350, 16 colors) for page flipping, but this mode is less than ideal for a couple of reasons: It offers sharply lower vertical resolution, and it’s lousy for handling scaled-up CGA graphics, because the vertical resolution is a fractional multiple—1.75 times, to be exact—of that of the CGA. CGA resolution may not seem important these days, but many images were originally created for the CGA, as were many graphics packages and games, and it’s at least convenient to be able to handle CGA graphics easily. Then, too, 640x350 is also a poor multiple of the 200 scan lines of the popular 320x200 256-color mode 13H of the VGA.</p>
<p>There are a couple of interesting, if imperfect, solutions to the problem of hi-res page flipping. One is to use the split screen to enable page flipping only in the top two-thirds of the screen; see the previous chapter for details, and for details on the mechanics of page flipping generally. This doesn’t address the CGA problem, but it does yield square pixels and a full 640x480 screen resolution, although not all those pixels are flippable and thus animatable.</p>
<p>A second solution is to program the screen to a 640x400 mode. Such a mode uses almost every byte of display memory (64,000 bytes, actually; you could add another few lines, if you really wanted to), and thereby provides the highest resolution possible on the VGA for a fully page-flipped display. It maps well to CGA and mode 13H resolutions, being either identical or double in both dimensions. As an added benefit, it offers an easy-on-the-eyes 70-Hz frame rate, as opposed to the 60 Hz that is the best that mode 12H can offer, due to the design of standard VGA monitors. Best of all, perhaps, is that 640x400 16-color mode is easy to set up.</p>
<p>The key to 640x400 mode is understanding that on a VGA, mode 10H (640x350) is, at heart, a 400-scan-line mode. What I mean by that is that in mode 10H, the Vertical Total register, which controls the total number of scan lines, both displayed and nondisplayed, is set to 447, exactly the same as in the VGA’s text modes, which do in fact support 400 scan lines. A properly sized and centered display is achieved in mode 10H by setting the polarity of the sync pulses to tell the monitor to scan vertically at a faster rate (to make fewer lines fill the screen), by starting the overscan after 350 lines, and by setting the vertical sync and blanking pulses appropriately for the faster vertical scanning rate. Changing those settings is all that’s required to turn mode 10H into a 640x400 mode, and that’s easy to do, as illustrated by Listing 45.2, which provides mode set code for 640x400 mode.</p>
<p><strong>LISTING 45.2 L45-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Mode set routine for VGA 640x400 16-color mode. Tested with</span>
<span class="co">   Borland C++ in C compilation mode. */</span>

<span class="ot">#include &lt;dos.h&gt;</span>

<span class="dt">void</span> Set640x400()
{
   <span class="kw">union</span> REGS regset;

   <span class="co">/* First, set to standard 640x350 mode (mode 10h) */</span>
   regset.x.ax = <span class="bn">0x0010</span>;
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);

   <span class="co">/* Modify the sync polarity bits (bits 7 &amp; 6) of the</span>
<span class="co">      Miscellaneous Output register (readable at 0x3CC, writable at</span>
<span class="co">      0x3C2) to select the 400-scan-line vertical scanning rate */</span>
   outp(<span class="bn">0x3C2</span>, ((inp(<span class="bn">0x3CC</span>) &amp; <span class="bn">0x3F</span>) | <span class="bn">0x40</span>));

   <span class="co">/* Now, tweak the registers needed to convert the vertical</span>
<span class="co">      timings from 350 to 400 scan lines */</span>
   outpw(<span class="bn">0x3D4</span>, <span class="bn">0x9C10</span>);   <span class="co">/* adjust the Vertical Sync Start register</span>
<span class="co">                              for 400 scan lines */</span>
   outpw(<span class="bn">0x3D4</span>, <span class="bn">0x8E11</span>);   <span class="co">/* adjust the Vertical Sync End register</span>
<span class="co">                              for 400 scan lines */</span>
   outpw(<span class="bn">0x3D4</span>, <span class="bn">0x8F12</span>);   <span class="co">/* adjust the Vertical Display End</span>
<span class="co">                              register for 400 scan lines */</span>
   outpw(<span class="bn">0x3D4</span>, <span class="bn">0x9615</span>);   <span class="co">/* adjust the Vertical Blank Start</span>
<span class="co">                              register for 400 scan lines */</span>
   outpw(<span class="bn">0x3D4</span>, <span class="bn">0xB916</span>);   <span class="co">/* adjust the Vertical Blank End register</span>
<span class="co">                              for 400 scan lines */</span>
}</code></pre>
<p>In 640x400, 16-color mode, page 0 runs from offset 0 to offset 31,999 (7CFFH), and page 1 runs from offset 32,000 (7D00H) to 63,999 (0F9FFH). Page 1 is selected by programming the Start Address registers (CRTC registers 0CH, the high 8 bits, and 0DH, the low 8 bits) to 7D00H. Actually, because the low byte of the start address is 0 for both pages, you can page flip simply by writing 0 or 7DH to the Start Address High register (CRTC register 0CH); this has the benefit of eliminating a nasty class of potential synchronization bugs that can arise when both registers must be set. Listing 45.3 illustrates simple 640x400 page flipping.</p>
<p><strong>LISTING 45.3 L45-3.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Sample program to exercise VGA 640x400 16-color mode page flipping, by</span>
<span class="co">   drawing a horizontal line at the top of page 0 and another at bottom of page 1,</span>
<span class="co">   then flipping between them once every 30 frames. Tested with Borland C++,</span>
<span class="co">   in C compilation mode. */</span>

<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &lt;conio.h&gt;</span>

<span class="ot">#define SCREEN_SEGMENT  0xA000</span>
<span class="ot">#define SCREEN_HEIGHT   400</span>
<span class="ot">#define SCREEN_WIDTH_IN_BYTES 80</span>
<span class="ot">#define INPUT_STATUS_1  0x3DA </span><span class="co">/* color-mode address of Input Status 1</span>
<span class="co">                                 register */</span>
<span class="co">/* The page start addresses must be even multiples of 256, because page</span>
<span class="co">   flipping is performed by changing only the upper start address byte */</span>
<span class="ot">#define PAGE_0_START 0</span>
<span class="ot">#define PAGE_1_START (400*SCREEN_WIDTH_IN_BYTES)</span>

<span class="dt">void</span> main(<span class="dt">void</span>);
<span class="dt">void</span> Wait30Frames(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">void</span> Set640x400(<span class="dt">void</span>);

<span class="dt">void</span> main()
{
   <span class="dt">int</span> i;
   <span class="dt">unsigned</span> <span class="dt">int</span> far *ScreenPtr;
   <span class="kw">union</span> REGS regset;

   Set640x400();  <span class="co">/* set to 640x400 16-color mode */</span>

   <span class="co">/* Point to first line of page 0 and draw a horizontal line across screen */</span>
   FP_SEG(ScreenPtr) = SCREEN_SEGMENT;
   FP_OFF(ScreenPtr) = PAGE_0_START;
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;(SCREEN_WIDTH_IN_BYTES/<span class="dv">2</span>); i++) *ScreenPtr++ = <span class="bn">0xFFFF</span>;

   <span class="co">/* Point to last line of page 1 and draw a horizontal line across screen */</span>
   FP_OFF(ScreenPtr) =
         PAGE_1_START + ((SCREEN_HEIGHT<span class="dv">-1</span>)*SCREEN_WIDTH_IN_BYTES);
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;(SCREEN_WIDTH_IN_BYTES/<span class="dv">2</span>); i++) *ScreenPtr++ = <span class="bn">0xFFFF</span>;

   <span class="co">/* Now flip pages once every 30 frames until a key is pressed */</span>
   <span class="kw">do</span> {
      Wait30Frames();

      <span class="co">/* Flip to page 1 */</span>
      outpw(<span class="bn">0x3D4</span>, <span class="bn">0x0C</span> | ((PAGE_1_START &gt;&gt; <span class="dv">8</span>) &lt;&lt; <span class="dv">8</span>));

      Wait30Frames();

      <span class="co">/* Flip to page 0 */</span>
      outpw(<span class="bn">0x3D4</span>, <span class="bn">0x0C</span> | ((PAGE_0_START &gt;&gt; <span class="dv">8</span>) &lt;&lt; <span class="dv">8</span>));
   } <span class="kw">while</span> (kbhit() == <span class="dv">0</span>);

   getch(); <span class="co">/* clear the key press */</span>

   <span class="co">/* Return to text mode and exit */</span>
   regset.x.ax = <span class="bn">0x0003</span>;   <span class="co">/* AL = 3 selects 80x25 text mode */</span>
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}

<span class="dt">void</span> Wait30Frames()
{
   <span class="dt">int</span> i;

   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">30</span>; i++) {
      <span class="co">/* Wait until we&#39;re not in vertical sync, so we can catch leading edge */</span>
      <span class="kw">while</span> ((inp(INPUT_STATUS_1) &amp; <span class="bn">0x08</span>) != <span class="dv">0</span>) ;
      <span class="co">/* Wait until we are in vertical sync */</span>
      <span class="kw">while</span> ((inp(INPUT_STATUS_1) &amp; <span class="bn">0x08</span>) == <span class="dv">0</span>) ;
   }
}</code></pre>
<p>After I described 640x400 mode in a magazine article, Bill Lindley, of Mesa, Arizona, wrote me to suggest that when programming the VGA to a nonstandard mode of this sort, it’s a good idea to tell the BIOS about the new screen size, for a couple of reasons. For one thing, pop-up utilities often use the BIOS variables; Bill’s memory-resident screen printer, EGAD Screen Print, determines the number of scan lines to print by multiplying the BIOS “number of text rows” variable times the “character height” variable. For another, the BIOS itself may do a poor job of displaying text if not given proper information; the active text area may not match the screen dimensions, or an inappropriate graphics font may be used. (Of course, the BIOS isn’t going to be able to display text anyway in highly nonstandard modes such as Mode X, but it will do fine in slightly nonstandard modes such as 640x400 16-color mode.) In the case of the 640x400 16-color model described a little earlier, Bill suggests that the code in Listing 45.4 be called immediately after putting the VGA into that mode to tell the BIOS that we’re working with 25 rows of 16-pixel-high text. I think this is an excellent suggestion; it can’t hurt, and may save you from getting aggravating tech support calls down the road.</p>
<p><strong>LISTING 45.4 L45-4.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Function to tell the BIOS to set up properly sized characters for 25 rows of</span>
<span class="co">   16 pixel high text in 640x400 graphics mode. Call immediately after mode set.</span>
<span class="co">   Based on a contribution by Bill Lindley. */</span>

<span class="ot">#include &lt;dos.h&gt;</span>

<span class="dt">void</span> Set640x400()
{
   <span class="kw">union</span> REGS regs;

   regs.h.ah = <span class="bn">0x11</span>;                    <span class="co">/* character generator function */</span>
   regs.h.al = <span class="bn">0x24</span>;                    <span class="co">/* use ROM 8x6 character set for graphics */</span>
   regs.h.bl = <span class="dv">2</span>;                       <span class="co">/* 25 rows */</span>
   int86(<span class="bn">0x10</span>, &amp;regs, &amp;regs);           <span class="co">/* invoke the BIOS video interrupt</span>
<span class="co">                                           to set up the text */</span>
}</code></pre>
<p>The 640x400 mode I’ve described here isn’t exactly earthshaking, but it can come in handy for page flipping and CGA emulation, and I’m sure that some of you will find it useful at one time or another.</p>
</section>
<section id="another-interesting-twist-on-page-flipping" class="level3">
<h3><a href="#another-interesting-twist-on-page-flipping">Another Interesting Twist on Page Flipping</a></h3>
<p>I’ve spent a fair amount of time exploring various ways to do animation. I thought I had pegged all the possible ways to do animation: exclusive-ORing; simply drawing and erasing objects; drawing objects with a blank fringe to erase them at their old locations as they’re drawn; page flipping; and, finally, drawing to local memory and copying the dirty (modified) rectangles to the screen, as I’ve discussed in this chapter.</p>
<p>To my surprise, someone threw me an interesting and useful twist on animation not long ago, which turned out to be a cross between page flipping and dirty-rectangle animation. That someone was Serge Mathieu of Concepteva Inc., in Rosemere, Quebec, who informed me that he designs everything “from a game <em>point de vue</em>.”</p>
<p>In normal page flipping, you display one page while you update the other page. Then you display the new page while you update the other. This works fine, but the need to keep two pages current can make for a lot of bookkeeping and possibly extra drawing, especially in applications where only some of the objects are redrawn each time.</p>
<p>Serge didn’t care to do all that bookkeeping in his animation applications, so he came up with the following approach, which I’ve reworded, amplified, and slightly modified in the summary here:</p>
<ol type="1">
<li><p>Set the start address to display page 0.</p></li>
<li><p>Draw to page 1.</p></li>
<li><p>Set the start address to display page 1 (the newly drawn page), then wait for the leading edge of vertical sync, at which point the page has flipped and it’s safe to modify page 0.</p></li>
<li><p>Copy, via the latches, from page 1 to page 0 the areas that changed from the previous screen to the current one.</p></li>
<li><p>Set the start address to display page 0, which is now identical to page 1, then wait for the leading edge of vertical sync, at which point the page has flipped and it’s safe to modify page 1.</p></li>
<li><p>Go to step 2.</p></li>
</ol>
<p>The great benefit of Serge’s approach is that the only page that is ever actually drawn to (as opposed to being block-copied to) is page 1. Only one page needs to be maintained, and the complications of maintaining two separate pages vanish entirely. The performance of Serge’s approach may be better or worse than standard page flipping, depending on whether a lot of extra work is required to maintain two pages or not. My guess is that Serge’s approach will usually be slower, owing to the considerable amount of display-memory copying involved, and also to the double page-flip per frame. There’s no doubt, however, that Serge’s approach is simpler, and the resultant display quality is every bit as good as standard page flipping. Given page flipping’s fair degree of complication, this approach is a valuable tool, especially for less-experienced animation programmers.</p>
<p>An interesting variation on Serge’s approach doesn’t page flip nor wait for vertical sync:</p>
<ol type="1">
<li><p>Set the start address to display page 0.</p></li>
<li><p>Draw to page 1.</p></li>
<li><p>Copy, via the latches, the areas that changed from the last screen to the current one from page 1 to page 0.</p></li>
<li><p>Go to step 2.</p></li>
</ol>
<p>This approach totally eliminates page flipping, which can consume a great deal of time. The downside is that images may shear for one frame if they’re only partially copied when the raster beam reaches them. This approach is basically a standard dirty-rectangle approach, except that the drawing buffer is stored in display memory, rather than in system memory. Whether this technique is faster than drawing to system memory depends on whether the benefit you get from the VGA’s hardware, such as the Bit Mask, the ALUs, and especially the latches (for copying the dirty rectangles) is sufficient to outweigh the extra display-memory accesses involved in drawing and copying, since display memory is notoriously slow.</p>
<p>Finally, I’d like to point out that in any scheme that involves changing the display-memory start address, a clever trick can potentially reduce the time spent waiting for pages to flip. Normally, it’s necessary to wait for display enable to be active, then set the two start address registers, and finally wait for vertical sync to be active, so that you know the new start address has taken effect. The start-address registers must never be set around the time vertical sync is active (the new start address is accepted at either the start or end of vertical sync on the EGAs and VGAs I’m familiar with), because it would then be possible to load a half-changed start address (one register loaded, the other not yet loaded), and the screen would jump for a frame. Avoiding this condition is the motivation for waiting for display enable, because display enable is active only when vertical sync is not active and will not become active for a long while.</p>
<p>Suppose, however, that you arrange your page start addresses so that they both have a low-byte value of 0 (page 0 starts at 0000H, and page 1 starts at 8000H, for example). Page flipping can then be done simply by setting the new high byte of the start address, then waiting for the leading edge of vertical sync. This eliminates the need to wait for display enable (the two bytes of the start address can never be mismatched); page flipping will often involve less waiting, because display enable becomes inactive long before vertical sync becomes active. Using the above approach reclaims all the time between the end of display enable and the start of vertical sync for doing useful work. (The steps I’ve given for Serge’s animation approach assume that the single-byte approach is in use; that’s why display enable is never waited for.)</p>
<p>In the next chapter, I’ll return to the original dirty-rectangle algorithm presented in this chapter, and goose it a little with some assembly, so that we can see what dirty-rectangle animation is really made of. (Probably not dog hair….)</p>
</section>
</section>
<section id="chapter-46-who-was-that-masked-image" class="level2">
<h2><a href="#chapter-46-who-was-that-masked-image">Chapter 46 – Who Was that Masked Image?</a></h2>
<section id="optimizing-dirty-rectangle-animation" class="level3">
<h3><a href="#optimizing-dirty-rectangle-animation">Optimizing Dirty-Rectangle Animation</a></h3>
<p>Programming is, by and large, a linear process. One statement or instruction follows another, in predictable sequences, with tiny building blocks strung together to make thinking, which is, of course, A Good Thing. Still, it’s important to keep in mind that there’s a large chunk of the human mind that doesn’t work in a linear fashion.</p>
<p>I’ve written elsewhere about the virtues of nonlinear/right-brain/lateral/what-have-you thinking in solving tough programming problems, such as debugging or optimization, but it bears repeating. The mind can be an awesome pattern-matching and extrapolation tool, if you let it. For example, the other day was grinding my way through a particularly difficult bit of debugging. The code had been written by someone else, and, to my mind, there’s nothing worse than debugging someone else’s code; there’s always the nasty feeling that you don’t quite know what’s going on. The overall operation of this code wouldn’t come clear in my head, no matter how long stared at it, leaving me with a rising sense of frustration and a determination not to quit until got this bug.</p>
<p>In the midst of this, a coworker poked his head through the door and told me he had something had to listen to. Reluctantly, went to his office, whereupon he played a tape of what is surely one of the most bizarre 911 calls in history. No doubt some of you have heard this tape, which will briefly describe as involving a deer destroying the interior of a car and biting a man in the neck. Perhaps you found it funny, perhaps not—but as for me, it hit me exactly right. started laughing helplessly, tears rolling down my face. When went back to work—presto!—the pieces of the debugging puzzle had come together in my head, and the work went quickly and easily.</p>
<p>Obviously, my mind needed a break from linear, left-brain, push-it-out thinking, so it could do the sort of integrating work it does so well—but that it’s rarely willing to do under conscious control. It was exactly this sort of thinking had in mind when titled my 1989 optimization book of <em>Zen of Assembly Language.</em> (Although must admit that few people seem to have gotten the connection, and I’ve had to field a lot of questions about whether I’m a Zen disciple. I’m not—actually, I’m more of a Dave Barry disciple. If you don’t know who Dave Barry is, you should; he’s good for your right brain.) Give your mind a break once in a while, and I’ll bet you’ll find you’re more productive.</p>
<p>We’re strange thinking machines, but we’re the best ones yet invented, and it’s worth learning how to tap our full potential. And with that, it’s back to dirty-rectangle animation.</p>
<section id="dirty-rectangle-animation-continued" class="level4">
<h4><a href="#dirty-rectangle-animation-continued">Dirty-Rectangle Animation, Continued</a></h4>
<p>In the last chapter, Introduced the idea of dirty-rectangle animation. This technique is an alternative to page flipping that’s capable of producing animation of very high visual quality, without any help at all from video hardware, and without the need for any extra, nondisplayed video memory. This makes dirty-rectangle animation more widely usable than page flipping, because many adapters don’t support page flipping. Dirty-rectangle animation also tends to be simpler to implement than page flipping, because there’s only one bitmap to keep track of. A final advantage of dirty-rectangle animation is that it’s potentially somewhat faster than page flipping, because display-memory accesses can theoretically be reduced to exactly one access for each pixel that changes from one frame to the next.</p>
<p>The speed advantage of dirty-rectangle animation was entirely theoretical in the previous chapter, because the implementation was completely in C, and because no attempt was made to minimize display memory accesses. The visual quality of Chapter 45’s animation was also less than ideal, for reasons we’ll explore shortly. The code in Listings 46.1 and 46.2 addresses the shortcomings of Chapter 45’s code.</p>
<p>Listing 46.2 implements the low-level drawing routines in assembly language, which boosts performance a good deal. For maximum performance, it would be worthwhile to convert more of Listing 46.1 into assembly, so a call isn’t required for each animated image, and overall performance could be improved by streamlining the C code, but Listing 46.2 goes a long way toward boosting animation speed. This program now supports snappy animation of 15 images (as opposed to 10 for the software presented in the last chapter), and the images are now two pixels wider. That level of performance is all the more impressive considering that for this chapter I’ve converted the code from using rectangular images to using masked images.</p>
<p><strong>LISTING 46.1 L46-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Sample simple dirty-rectangle animation program, partially optimized and</span>
<span class="co">   featuring internal animation, masked images (sprites), and nonoverlapping dirty</span>
<span class="co">   rectangle copying. Tested with Borland C++ in the small model. */</span>

<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;alloc.h&gt;</span>
<span class="ot">#include &lt;memory.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>

<span class="co">/* Comment out to disable overlap elimination in the dirty rectangle list. */</span>
<span class="ot">#define CHECK-OVERLAP 1</span>
<span class="ot">#define SCREEN-WIDTH  320</span>
<span class="ot">#define SCREEN-HEIGHT 200</span>
<span class="ot">#define SCREEN-SEGMENT 0xA000</span>

<span class="co">/* Describes a dirty rectangle */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
   <span class="dt">void</span> *Next;    <span class="co">/* pointer to next node in linked dirty rect list */</span>
   <span class="dt">int</span> Top;
   <span class="dt">int</span> Left;
   <span class="dt">int</span> Right;
   <span class="dt">int</span> Bottom;
} DirtyRectangle;
<span class="co">/* Describes an animated object */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
   <span class="dt">int</span> X;            <span class="co">/* upper left corner in virtual bitmap */</span>
   <span class="dt">int</span> Y;
   <span class="dt">int</span> XDirection;   <span class="co">/* direction and distance of movement */</span>
   <span class="dt">int</span> YDirection;
   <span class="dt">int</span> InternalAnimateCount; <span class="co">/* tracking internal animation state */</span>
   <span class="dt">int</span> InternalAnimateMax;   <span class="co">/* maximum internal animation state */</span>
} Entity;
<span class="co">/* storage used for dirty rectangles */</span>
<span class="ot">#define MAX-DIRTY-RECTANGLES  100</span>
<span class="dt">int</span> NumDirtyRectangles;
DirtyRectangle DirtyRectangles[MAX-DIRTY-RECTANGLES];
<span class="co">/* head/tail of dirty rectangle list */</span>
DirtyRectangle DirtyHead;
<span class="co">/* If set to 1, ignore dirty rectangle list and copy the whole screen. */</span>
<span class="dt">int</span> DrawWholeScreen = <span class="dv">0</span>;
<span class="co">/* pixels and masks for the two internally animated versions of the image</span>
<span class="co">   we&#39;ll animate */</span>
<span class="ot">#define IMAGE-WIDTH  13</span>
<span class="ot">#define IMAGE-HEIGHT 11</span>
<span class="dt">char</span> ImagePixels0[] = {
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
};
<span class="dt">char</span> ImageMask0[] = {
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
};
<span class="dt">char</span> ImagePixels1[] = {
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">9</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>,
   <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>,
   <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">14</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>,
};
<span class="dt">char</span> ImageMask1[] = {
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,
   <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>,
};
<span class="co">/* Pointers to pixel and mask data for various internally animated</span>
<span class="co">   versions of our animated image. */</span>
<span class="dt">char</span> * ImagePixelArray[] = {ImagePixels0, ImagePixels1};
<span class="dt">char</span> * ImageMaskArray[] = {ImageMask0, ImageMask1};
<span class="co">/* Animated entities */</span>
<span class="ot">#define NUM-ENTITIES 15</span>
Entity Entities[NUM-ENTITIES];
<span class="co">/* pointer to system buffer into which we&#39;ll draw */</span>
<span class="dt">char</span> far *SystemBufferPtr;
<span class="co">/* pointer to screen */</span>
<span class="dt">char</span> far *ScreenPtr;
<span class="dt">void</span> EraseEntities(<span class="dt">void</span>);
<span class="dt">void</span> CopyDirtyRectanglesToScreen(<span class="dt">void</span>);
<span class="dt">void</span> DrawEntities(<span class="dt">void</span>);
<span class="dt">void</span> AddDirtyRect(Entity *, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="dt">void</span> DrawMasked(<span class="dt">char</span> far *, <span class="dt">char</span> *, <span class="dt">char</span> *, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="dt">void</span> FillRect(<span class="dt">char</span> far *, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="dt">void</span> CopyRect(<span class="dt">char</span> far *, <span class="dt">char</span> far *, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);

<span class="dt">void</span> main()
{
   <span class="dt">int</span> i, XTemp, YTemp;
   <span class="dt">unsigned</span> <span class="dt">int</span> TempCount;
   <span class="dt">char</span> far *TempPtr;
   <span class="kw">union</span> REGS regs;
   <span class="co">/* Allocate memory for the system buffer into which we&#39;ll draw */</span>
   <span class="kw">if</span> (!(SystemBufferPtr = farmalloc((<span class="dt">unsigned</span> <span class="dt">int</span>)SCREEN-WIDTH*
         SCREEN-HEIGHT))) {
      printf(<span class="st">&quot;Couldn&#39;t get memory</span><span class="ch">\n</span><span class="st">&quot;</span>);
      exit(<span class="dv">1</span>);
   }
   <span class="co">/* Clear the system buffer */</span>
   TempPtr = SystemBufferPtr;
   <span class="kw">for</span> (TempCount = ((<span class="dt">unsigned</span>)SCREEN-WIDTH*SCREEN-HEIGHT); TempCount--; ) {
      *TempPtr++ = <span class="dv">0</span>;
   }
   <span class="co">/* Point to the screen */</span>
   ScreenPtr = MK-FP(SCREEN-SEGMENT, <span class="dv">0</span>);
   <span class="co">/* Set up the entities we&#39;ll animate, at random locations */</span>
   randomize();
   <span class="kw">for</span> (= <span class="dv">0</span>; &lt; NUM-ENTITIES; i++) {
      Entities[i].X = random(SCREEN-WIDTH - IMAGE-WIDTH);
      Entities[i].Y = random(SCREEN-HEIGHT - IMAGE-HEIGHT);
      Entities[i].XDirection = <span class="dv">1</span>;
      Entities[i].YDirection = -<span class="dv">1</span>;
      Entities[i].InternalAnimateCount = &amp; <span class="dv">1</span>;
      Entities[i].InternalAnimateMax = <span class="dv">2</span>;
   }
   <span class="co">/* Set the dirty rectangle list to empty, and set up the head/tail node</span>
<span class="co">      as a sentinel */</span>
   NumDirtyRectangles = <span class="dv">0</span>;
   DirtyHead.Next = &amp;DirtyHead;
   DirtyHead.Top = <span class="bn">0x7FFF</span>;
   DirtyHead.Left= <span class="bn">0x7FFF</span>;
   DirtyHead.Bottom = <span class="bn">0x7FFF</span>;
   DirtyHead.Right = <span class="bn">0x7FFF</span>;
   <span class="co">/* Set 320x200 256-color graphics mode */</span>
   regs.x.ax = <span class="bn">0x0013</span>;
   int86(<span class="bn">0x10</span>, &amp;regs, &amp;regs);
   <span class="co">/* Loop and draw until a key is pressed */</span>
   <span class="kw">do</span> {
      <span class="co">/* Draw the entities to the system buffer at their current locations,</span>
<span class="co">         updating the dirty rectangle list */</span>
      DrawEntities();
      <span class="co">/* Draw the dirty rectangles, or the whole system buffer if</span>
<span class="co">         appropriate */</span>
      CopyDirtyRectanglesToScreen();
      <span class="co">/* Reset the dirty rectangle list to empty */</span>
      NumDirtyRectangles = <span class="dv">0</span>;
      DirtyHead.Next = &amp;DirtyHead;
      <span class="co">/* Erase the entities in the system buffer at their old locations,</span>
<span class="co">         updating the dirty rectangle list */</span>
      EraseEntities();
      <span class="co">/* Move the entities, bouncing off the edges of the screen */</span>
      <span class="kw">for</span> (= <span class="dv">0</span>; &lt; NUM-ENTITIES; i++) {
         XTemp = Entities[i].X + Entities[i].XDirection;
         YTemp = Entities[i].Y + Entities[i].YDirection;
         <span class="kw">if</span> ((XTemp &lt; <span class="dv">0</span>) || ((XTemp + IMAGE-WIDTH) &gt; SCREEN-WIDTH)) {
            Entities[i].XDirection = -Entities[i].XDirection;
            XTemp = Entities[i].X + Entities[i].XDirection;
         }
         <span class="kw">if</span> ((YTemp &lt; <span class="dv">0</span>) || ((YTemp + IMAGE-HEIGHT) &gt; SCREEN-HEIGHT)) {
            Entities[i].YDirection = -Entities[i].YDirection;
            YTemp = Entities[i].Y + Entities[i].YDirection;
         }
         Entities[i].X = XTemp;
         Entities[i].Y = YTemp;
      }
   } <span class="kw">while</span> (!kbhit());
   getch();    <span class="co">/* clear the keypress */</span>

   <span class="co">/* Return back to text mode */</span>
   regs.x.ax = <span class="bn">0x0003</span>;
   int86(<span class="bn">0x10</span>, &amp;regs, &amp;regs);
}
<span class="co">/* Draw entities at their current locations, updating dirty rectangle list. */</span>
<span class="dt">void</span> DrawEntities()
{
   <span class="dt">int</span> i;
   <span class="dt">char</span> far *RowPtrBuffer;
   <span class="dt">char</span> *TempPtrImage;
   <span class="dt">char</span> *TempPtrMask;
   Entity *EntityPtr;

   <span class="kw">for</span> (= <span class="dv">0</span>, EntityPtr = Entities; &lt; NUM-ENTITIES; i++, EntityPtr++) {
      <span class="co">/* Remember the dirty rectangle info for this entity */</span>
      AddDirtyRect(EntityPtr, IMAGE-HEIGHT, IMAGE-WIDTH);
      <span class="co">/* Point to the destination in the system buffer */</span>
      RowPtrBuffer = SystemBufferPtr + (EntityPtr-&gt;Y * SCREEN-WIDTH) +
            EntityPtr-&gt;X;
      <span class="co">/* Advance the image animation pointer */</span>
      <span class="kw">if</span> (++EntityPtr-&gt;InternalAnimateCount &gt;=
            EntityPtr-&gt;InternalAnimateMax) {
         EntityPtr-&gt;InternalAnimateCount = <span class="dv">0</span>;
      }
      <span class="co">/* Point to the image and mask to draw */</span>
      TempPtrImage = ImagePixelArray[EntityPtr-&gt;InternalAnimateCount];
      TempPtrMask = ImageMaskArray[EntityPtr-&gt;InternalAnimateCount];
      DrawMasked(RowPtrBuffer, TempPtrImage, TempPtrMask, IMAGE-HEIGHT,
               IMAGE-WIDTH, SCREEN-WIDTH);
   }
}
<span class="co">/* Copy the dirty rectangles, or the whole system buffer if appropriate,</span>
<span class="co">   to the screen. */</span>
<span class="dt">void</span> CopyDirtyRectanglesToScreen()
{
   <span class="dt">int</span> i, RectWidth, RectHeight;
   <span class="dt">unsigned</span> <span class="dt">int</span> Offset;
   DirtyRectangle * DirtyPtr;
   <span class="kw">if</span> (DrawWholeScreen) {
      <span class="co">/* Just copy the whole buffer to the screen */</span>
      DrawWholeScreen = <span class="dv">0</span>;
      CopyRect(ScreenPtr, SystemBufferPtr, SCREEN-HEIGHT, SCREEN-WIDTH,
               SCREEN-WIDTH, SCREEN-WIDTH);
   } <span class="kw">else</span> {
      <span class="co">/* Copy only the dirty rectangles, in the YX-sorted order in which</span>
<span class="co">         they&#39;re linked */</span>
      DirtyPtr = DirtyHead.Next;
      <span class="kw">for</span> (= <span class="dv">0</span>; &lt; NumDirtyRectangles; i++) {
         <span class="co">/* Offset in both system buffer and screen of image */</span>
         Offset = (<span class="dt">unsigned</span> <span class="dt">int</span>) (DirtyPtr-&gt;Top * SCREEN-WIDTH) +
               DirtyPtr-&gt;Left;
         <span class="co">/* Dimensions of dirty rectangle */</span>
         RectWidth = DirtyPtr-&gt;Right - DirtyPtr-&gt;Left;
         RectHeight = DirtyPtr-&gt;Bottom - DirtyPtr-&gt;Top;
         <span class="co">/* Copy a dirty rectangle */</span>
         CopyRect(ScreenPtr + Offset, SystemBufferPtr + Offset,
               RectHeight, RectWidth, SCREEN-WIDTH, SCREEN-WIDTH);
         <span class="co">/* Point to the next dirty rectangle */</span>
         DirtyPtr = DirtyPtr-&gt;Next;
      }
   }
}
<span class="co">/* Erase the entities in the system buffer at their current locations,</span>
<span class="co">   updating the dirty rectangle list. */</span>
<span class="dt">void</span> EraseEntities()
{
   <span class="dt">int</span> i;
   <span class="dt">char</span> far *RowPtr;
   
   <span class="kw">for</span> (= <span class="dv">0</span>; &lt; NUM-ENTITIES; i++) {
      <span class="co">/* Remember the dirty rectangle info for this entity */</span>
      AddDirtyRect(&amp;Entities[i], IMAGE-HEIGHT, IMAGE-WIDTH);
      <span class="co">/* Point to the destination in the system buffer */</span>
      RowPtr = SystemBufferPtr + (Entities[i].Y * SCREEN-WIDTH) +
            Entities[i].X;
      <span class="co">/* Clear the rectangle */</span>
      FillRect(RowPtr, IMAGE-HEIGHT, IMAGE-WIDTH, SCREEN-WIDTH, <span class="dv">0</span>);
   }
}
<span class="co">/* Add a dirty rectangle to the list. The list is maintained in top-to-bottom,</span>
<span class="co">   left-to-right (YX sorted) order, with no pixel ever included twice, to minimize</span>
<span class="co">   the number of display memory accesses and to avoid screen artifacts resulting </span>
<span class="co">   from a large time interval between erasure and redraw for a given object or for</span>
<span class="co">   adjacent objects. The technique used is to check for overlap between the </span>
<span class="co">   rectangle and all rectangles already in the list. If no overlap is found, the </span>
<span class="co">   rectangle is added to the list. If overlap is found, the rectangle is broken </span>
<span class="co">   into nonoverlapping pieces, and the pieces are added to the list by recursive </span>
<span class="co">   calls to this function. */</span>
   <span class="dt">void</span> AddDirtyRect(Entity * pEntity, <span class="dt">int</span> ImageHeight, <span class="dt">int</span> ImageWidth)
{
   DirtyRectangle * DirtyPtr;
   DirtyRectangle * TempPtr;
   Entity TempEntity;
   <span class="dt">int</span> i;
   <span class="kw">if</span> (NumDirtyRectangles &gt;= MAX-DIRTY-RECTANGLES) {
      <span class="co">/* Too many dirty rectangles; just redraw the whole screen */</span>
      DrawWholeScreen = <span class="dv">1</span>;
      <span class="kw">return</span>;
   }
   <span class="co">/* Remember this dirty rectangle. Break up if necessary to avoid</span>
<span class="co">      overlap with rectangles already in the list, then add whatever</span>
<span class="co">      rectangles are left, in YX sorted order */</span>
<span class="ot">#ifdef CHECK-OVERLAP</span>
   <span class="co">/* Check for overlap with existing rectangles */</span>
   TempPtr = DirtyHead.Next;
   <span class="kw">for</span> (= <span class="dv">0</span>; &lt; NumDirtyRectangles; i++, TempPtr = TempPtr-&gt;Next) {
      <span class="kw">if</span> ((TempPtr-&gt;Left &lt; (pEntity-&gt;X + ImageWidth)) &amp;&amp;
          (TempPtr-&gt;Right &gt; pEntity-&gt;X) &amp;&amp;
          (TempPtr-&gt;Top &lt; (pEntity-&gt;Y + ImageHeight)) &amp;&amp;
          (TempPtr-&gt;Bottom &gt; pEntity-&gt;Y)) {

         <span class="co">/* We&#39;ve found an overlapping rectangle. Calculate the</span>
<span class="co">            rectangles, if any, remaining after subtracting out the</span>
<span class="co">            overlapped areas, and add them to the dirty list */</span>
         <span class="co">/* Check for a nonoverlapped left portion */</span>
         <span class="kw">if</span> (TempPtr-&gt;Left &gt; pEntity-&gt;X) {
            <span class="co">/* There&#39;s definitely a nonoverlapped portion at the left; add</span>
<span class="co">               it, but only to at most the top and bottom of the overlapping</span>
<span class="co">               rect; top and bottom strips are taken care of below */</span>
            TempEntity.X = pEntity-&gt;X;
            TempEntity.Y = max(pEntity-&gt;Y, TempPtr-&gt;Top);
            AddDirtyRect(&amp;TempEntity,
                  min(pEntity-&gt;Y + ImageHeight, TempPtr-&gt;Bottom) -
                  TempEntity.Y,
                        TempPtr-&gt;Left - pEntity-&gt;X);
         }
         <span class="co">/* Check for a nonoverlapped right portion */</span>
         <span class="kw">if</span> (TempPtr-&gt;Right &lt; (pEntity-&gt;X + ImageWidth)) {
            <span class="co">/* There&#39;s definitely a nonoverlapped portion at the right; add</span>
<span class="co">               it, but only to at most the top and bottom of the overlapping</span>
<span class="co">               rect; top and bottom strips are taken care of below */</span>
            TempEntity.X = TempPtr-&gt;Right;
            TempEntity.Y = max(pEntity-&gt;Y, TempPtr-&gt;Top);
            AddDirtyRect(&amp;TempEntity,
                  min(pEntity-&gt;Y + ImageHeight, TempPtr-&gt;Bottom) -
                  TempEntity.Y,
                  (pEntity-&gt;X + ImageWidth) - TempPtr-&gt;Right);
         }
         <span class="co">/* Check for a nonoverlapped top portion */</span>
         <span class="kw">if</span> (TempPtr-&gt;Top &gt; pEntity-&gt;Y) {
            <span class="co">/* There&#39;s a top portion that&#39;s not overlapped */</span>
            TempEntity.X = pEntity-&gt;X;
            TempEntity.Y = pEntity-&gt;Y;
            AddDirtyRect(&amp;TempEntity, TempPtr-&gt;Top - pEntity-&gt;Y, ImageWidth);
         }
         <span class="co">/* Check for a nonoverlapped bottom portion */</span>
         <span class="kw">if</span> (TempPtr-&gt;Bottom &lt; (pEntity-&gt;Y + ImageHeight)) {
            <span class="co">/* There&#39;s a bottom portion that&#39;s not overlapped */</span>
            TempEntity.X = pEntity-&gt;X;
            TempEntity.Y = TempPtr-&gt;Bottom;
            AddDirtyRect(&amp;TempEntity,
                  (pEntity-&gt;Y + ImageHeight) - TempPtr-&gt;Bottom, ImageWidth);
         }
         <span class="co">/* We&#39;ve added all non-overlapped portions to the dirty list */</span>
         <span class="kw">return</span>;
      }
   }
<span class="ot">#endif </span><span class="co">/* CHECK-OVERLAP */</span>
   <span class="co">/* There&#39;s no overlap with any existing rectangle, so we can just</span>
<span class="co">      add this rectangle as-is */</span>
   <span class="co">/* Find the YX-sorted insertion point. Searches will always terminate,</span>
<span class="co">      because the head/tail rectangle is set to the maximum values */</span>
   TempPtr = &amp;DirtyHead;
   <span class="kw">while</span> (((DirtyRectangle *)TempPtr-&gt;Next)-&gt;Top &lt; pEntity-&gt;Y) {
      TempPtr = TempPtr-&gt;Next;
   }
   <span class="kw">while</span> ((((DirtyRectangle *)TempPtr-&gt;Next)-&gt;Top == pEntity-&gt;Y) &amp;&amp;
           (((DirtyRectangle *)TempPtr-&gt;Next)-&gt;Left &lt; pEntity-&gt;X)) {
      TempPtr = TempPtr-&gt;Next;
   }
   <span class="co">/* Set the rectangle and actually add it to the dirty list */</span>
   DirtyPtr = &amp;DirtyRectangles[NumDirtyRectangles++];
   DirtyPtr-&gt;Left = pEntity-&gt;X;
   DirtyPtr-&gt;Top = pEntity-&gt;Y;
   DirtyPtr-&gt;Right = pEntity-&gt;X + ImageWidth;
   DirtyPtr-&gt;Bottom = pEntity-&gt;Y + ImageHeight;
   DirtyPtr-&gt;Next = TempPtr-&gt;Next;
   TempPtr-&gt;Next = DirtyPtr;
}</code></pre>
<p><strong>LISTING 46.2 L46-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Assembly language helper routines for dirty rectangle animation. Tested with</span>
<span class="co">; TASM. </span>
<span class="co">; Fills a rectangle in the specified buffer. </span>
<span class="co">; C-callable as:  </span>
<span class="co">;  void FillRect(char far * BufferPtr, int RectHeight, int RectWidth,</span>
<span class="co">;                   int BufferWidth, int Color);</span>
<span class="co">;</span>
        .model  small
        .code
parms   <span class="kw">struc</span>
                <span class="dt">dw</span>      ?       <span class="co">;pushed BP</span>
                <span class="dt">dw</span>      ?       <span class="co">;pushed return address</span>
BufferPtr       <span class="dt">dd</span>      ?       <span class="co">;far pointer to buffer in which to fill</span>
RectHeight      <span class="dt">dw</span>      ?       <span class="co">;height of rectangle to fill</span>
RectWidth       <span class="dt">dw</span>      ?       <span class="co">;width of rectangle to fill</span>
BufferWidth     <span class="dt">dw</span>      ?       <span class="co">;width of buffer in which to fill</span>
Color           <span class="dt">dw</span>      ?       <span class="co">;color with which to fill</span>
parms   ends
        public  -FillRect
-FillRectproc  near
        <span class="kw">cld</span>
        <span class="kw">push</span>    <span class="kw">bp</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">les</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+BufferPtr]
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bp</span>+RectHeight]
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+BufferWidth]
        su    <span class="kw">bx</span>,[<span class="kw">bp</span>+RectWidth]         <span class="co">;distance from end of one dest scan</span>
                                        <span class="co">; to start of next</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Color]
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="kw">al</span>                   <span class="co">;double the color for REP STOSW</span>
<span class="fu">RowLoop:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+RectWidth]
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>
        rep     <span class="kw">stosw</span>
        <span class="kw">adc</span>     <span class="kw">cx</span>,<span class="kw">cx</span>
        rep     <span class="kw">stosb</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">bx</span>                   <span class="co">;point to next scan to fill</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>                      <span class="co">;count down rows to fill</span>
        <span class="kw">jnz</span>     RowLoop

        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>
        <span class="kw">ret</span>
-FillRect   endp

<span class="co">; Draws a masked image (a sprite) to the specified buffer. C-callable as:</span>
<span class="co">;     void DrawMasked(char far * BufferPtr, char * Pixels, char * Mask,</span>
<span class="co">;                   int ImageHeight, int ImageWidth, int BufferWidth);</span>
parms2  <span class="kw">struc</span>
                <span class="dt">dw</span>      ?       <span class="co">;pushed BP</span>
                <span class="dt">dw</span>      ?       <span class="co">;pushed return address</span>
BufferPtr2      <span class="dt">dd</span>      ?       <span class="co">;far pointer to buffer in which to draw</span>
Pixels          <span class="dt">dw</span>      ?       <span class="co">;pointer to image pixels</span>
Mask            <span class="dt">dw</span>      ?       <span class="co">;pointer to image mask</span>
ImageHeight     <span class="dt">dw</span>      ?       <span class="co">;height of image to draw</span>
ImageWidth      <span class="dt">dw</span>      ?       <span class="co">;width of image to draw</span>
BufferWidth2    <span class="dt">dw</span>      ?       <span class="co">;width of buffer in which to draw</span>
parms2  ends
        public  -DrawMasked
-DrawMasked     proc    near
        <span class="kw">cld</span>
        <span class="kw">push</span>    <span class="kw">bp</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>
        <span class="kw">push</span>    <span class="kw">si</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">les</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+BufferPtr2]
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+Mask]
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+Pixels]
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bp</span>+ImageHeight]
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+BufferWidth2]
        su    <span class="kw">ax</span>,[<span class="kw">bp</span>+ImageWidth]        <span class="co">;distance from end of one dest scan</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+BufferWidth2],<span class="kw">ax</span>    <span class="co">; to start of next</span>
<span class="fu">RowLoop2:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+ImageWidth]
<span class="fu">ColumnLoop:</span>
        <span class="kw">lods</span>                            <span class="co">;get the next mask byte</span>
        <span class="kw">and</span>     <span class="kw">al</span>,<span class="kw">al</span>                   <span class="co">;draw this pixel?</span>
        <span class="kw">jz</span>      SkipPixel               <span class="co">;no</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,[<span class="kw">bx</span>]                 <span class="co">;yes, draw the pixel</span>
        <span class="kw">mov</span>     <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">al</span>
<span class="fu">SkipPixel:</span>
        <span class="kw">inc</span>     <span class="kw">bx</span>                      <span class="co">;point to next source pixel</span>
        <span class="kw">inc</span>     d                       <span class="co">;point to next dest pixel</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>
        <span class="kw">jnz</span>     ColumnLoop
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+BufferWidth2]    <span class="co">;point to next scan to fill</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>                      <span class="co">;count down rows to fill</span>
        <span class="kw">jnz</span>     RowLoop2

        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>
        <span class="kw">ret</span>
-DrawMasked     endp

<span class="co">; Copies a rectangle from one buffer to another. C-callable as:</span>
<span class="co">;     void CopyRect(DestBufferPtr, SrcBufferPtr, CopyHeight, CopyWidth,</span>
<span class="co">;                   DestBufferWidth, SrcBufferWidth);</span>

parms3  <span class="kw">struc</span>
                <span class="dt">dw</span>      ?       <span class="co">;pushed BP</span>
                <span class="dt">dw</span>      ?       <span class="co">;pushed return address</span>
DestBufferPtr   <span class="dt">dd</span>      ?       <span class="co">;far pointer to buffer to which to copy</span>
SrcBufferPtr    <span class="dt">dd</span>      ?       <span class="co">;far pointer to buffer from which to copy</span>
CopyHeight      <span class="dt">dw</span>      ?       <span class="co">;height of rect to copy</span>
CopyWidth       <span class="dt">dw</span>      ?       <span class="co">;width of rect to copy</span>
DestBufferWidth <span class="dt">dw</span>      ?       <span class="co">;width of buffer to which to copy</span>
SrcBufferWidth  <span class="dt">dw</span>      ?       <span class="co">;width of buffer from which to copy</span>
parms3  ends
        public  -CopyRect
-CopyRect       proc    near
        <span class="kw">cld</span>
        <span class="kw">push</span>    <span class="kw">bp</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>
        <span class="kw">push</span>    <span class="kw">si</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">push</span>    <span class="kw">ds</span>

        <span class="kw">les</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+DestBufferPtr]
        <span class="kw">lds</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+SrcBufferPtr]
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bp</span>+CopyHeight]
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+DestBufferWidth] <span class="co">;distance from end of one dest scan</span>
        su    <span class="kw">bx</span>,[<span class="kw">bp</span>+CopyWidth]         <span class="co">; of copy to the next</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SrcBufferWidth]  <span class="co">;distance from end of one source scan</span>
        su    <span class="kw">ax</span>,[<span class="kw">bp</span>+CopyWidth]         <span class="co">; of copy to the next</span>
<span class="fu">RowLoop3:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+CopyWidth]       <span class="co">;# of bytes to copy</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>
        rep     <span class="kw">movsw</span>                   <span class="co">;copy as many words as possible</span>
        <span class="kw">adc</span>     <span class="kw">cx</span>,<span class="kw">cx</span>
        rep     <span class="kw">movs</span>                    <span class="co">;copy odd byte, if any</span>
        <span class="kw">add</span>     <span class="kw">si</span>,<span class="kw">ax</span>                   <span class="co">;point to next source scan line</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">bx</span>                   <span class="co">;point to next dest scan line</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>                      <span class="co">;count down rows to fill</span>
        <span class="kw">jnz</span>     RowLoop3

        <span class="kw">pop</span>     <span class="kw">ds</span>
        <span class="kw">pop</span>     <span class="kw">di</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>
        <span class="kw">ret</span>
-CopyRect       endp
        end</code></pre>
</section>
<section id="masked-images" class="level4">
<h4><a href="#masked-images">Masked Images</a></h4>
<p>Masked images are rendered by drawing an object’s pixels through a mask; pixels are actually drawn only where the mask specifies that drawing is allowed. This makes it possible to draw nonrectangular objects that don’t improperly interfere with one another when they overlap. Masked images also make it possible to have transparent areas (windows) within objects. Masked images produce far more realistic animation than do rectangular images, and therefore are more desirable. Unfortunately, masked images are also considerably slower to draw—however, a good assembly language implementation can go a long way toward making masked images draw rapidly enough, as illustrated by this chapter’s code. (Masked images are also known as <em>sprites</em>; some video hardware supports sprites directly, but on the PC it’s necessary to handle sprites in software.)</p>
<p>Masked images make it possible to render scenes so that a given image convincingly appears to be in front of or behind other images; that is, so images are displayed in <em>z-order</em> (by distance). By consistently drawing images that are supposed to be farther away before drawing nearer images, the nearer images will appear in front of the other images, and because masked images draw only precisely the correct pixels (as opposed to blank pixels in the bounding rectangle), there’s no interference between overlapping images to destroy the illusion.</p>
<p>In this chapter, I’ve used the approach of having separate, paired masks and images. Another, quite different approach to masking is to specify a transparent color for copying, and copy only those pixels that are not the transparent color. This has the advantage of not requiring separate mask data, so it’s more compact, and the code to implement this is a little less complex than the full masking I’ve implemented. On the other hand, the transparent color approach is less flexible because it makes one color undrawable. Also, with a transparent color, it’s not possible to keep the same base image but use different masks, because the mask information is embedded in the image data.</p>
</section>
<section id="internal-animation" class="level4">
<h4><a href="#internal-animation">Internal Animation</a></h4>
<p>I’ve added another feature essential to producing convincing animation: <em>internal animation</em>, which is the process of changing the appearance of a given object over time, as distinguished from changing only the <em>location</em> of a given object. Internal animation makes images look active and alive. I’ve implemented the simplest possible form of internal animation in Listing 46.1—alternation between two images—but even this level of internal animation greatly improves the feel of the overall animation. You could easily increase the number of images cycled through, simply by increasing the value of <code>InternalAnimateMax</code> for a given entity. You could also implement more complex image-selection logic to produce more interesting and less predictable internal-animation effects, such as jumping, ducking, running, and the like.</p>
</section>
<section id="dirty-rectangle-management" class="level4">
<h4><a href="#dirty-rectangle-management">Dirty-Rectangle Management</a></h4>
<p>As mentioned above, dirty-rectangle animation makes it possible to access display memory a minimum number of times. The previous chapter’s code didn’t do any of that; instead, it copied all portions of every dirty rectangle to the screen, regardless of overlap between rectangles. The code I’ve presented in this chapter goes to the other extreme, taking great pains never to draw overlapped portions of rectangles more than once. This is accomplished by checking for overlap whenever a rectangle is to be added to the dirty list. When overlap with an existing rectangle is detected, the new rectangle is reduced to between zero and four nonoverlapping rectangles. Those rectangles are then again considered for addition to the dirty list, and may again be reduced, if additional overlap is detected.</p>
<p>A good deal of code is required to generate a fully nonoverlapped dirty list. Is it worth it? It certainly can be, but in the case of Listing 46.1, probably not. For one thing, you’d need larger, heavily overlapped objects for this approach to pay off big. Besides, this program is mostly in C, and spends a lot of time doing things other than actually accessing display memory. It also takes a fair amount of time just to generate the nonoverlapped list; the overhead of all the looping, intersecting, and calling required to generate the list eats up a lot of the benefits of accessing display memory less often. Nonetheless, fully nonoverlapped drawing can be useful under the right circumstances, and I’ve implemented it in Listing 46.1 so you’ll have something to refer to should you decide to go this route.</p>
<p>There are a couple of additional techniques you might try if you want to wring maximum performance out of dirty-rectangle animation. You could try coalescing rectangles as you generate the dirty-rectangle list. That is, you could detect pairs of rectangles that can be joined together into larger rectangles, so that fewer, larger rectangles would have to be copied. This would boost the efficiency of the low-level copying code, albeit at the cost of some cycles in the dirty-list management code.</p>
<p>You might also try taking advantage of the natural coherence of animated graphics screens. In particular, because the rectangle used to erase an image at its old location often overlaps the rectangle within which the image resides at its new location, you could just directly generate the two or three nonoverlapped rectangles required to copy both the erase rectangle and the new-image rectangle for any single moving image. The calculation of these rectangles could be very efficient, given that you know in advance the direction of motion of your images. Handling this particular overlap case would eliminate most overlapped drawing, at a minimal cost. You might then decide to ignore overlapped drawing between different images, which tends to be both less common and more expensive to identify and handle.</p>
</section>
<section id="drawing-order-and-visual-quality" class="level4">
<h4><a href="#drawing-order-and-visual-quality">Drawing Order and Visual Quality</a></h4>
<p>A final note on dirty-rectangle animation concerns the quality of the displayed screen image. In the last chapter, we simply stuffed dirty rectangles into a list in the order they became dirty, and then copied all of the rectangles in that same order. Unfortunately, this caused all of the erase rectangles to be copied first, followed by all of the rectangles of the images at their new locations. Consequently, there was a significant delay between the appearance of the erase rectangle for a given image and the appearance of the new rectangle. A byproduct was the fact that a partially complete—part old, part new—image was visible long enough to be noticed. In short, although the pixels ended up correct, they were in an intermediate, incorrect state for a sufficient period of time to make the animation look wrong.</p>
<p>This violated a fundamental rule of animation: <em>No pixel should ever be displayed in a perceptibly incorrect state</em>. To correct the problem, I’ve sorted the dirty rectangles first by Y coordinate, and secondly by X coordinate. This means the screen updates from to draw a given image should be drawn nearly simultaneously. Run the code from the last chapter and then this chapter; you’ll see quite a difference in appearance.</p>
<p>Avoid the trap of thinking animation is merely a matter of drawing the right pixels, one after another. Animation is the art of drawing <em>the right pixels at the right times</em> so that the eye and brain see what you want them to see. Animation is a lot more challenging than merely cranking out pixels, and it sure as heck isn’t a purely linear process.</p>
</section>
</section>
</section>
<section id="chapter-47-mode-x-256-color-vga-magic" class="level2">
<h2><a href="#chapter-47-mode-x-256-color-vga-magic">Chapter 47 – Mode X: 256-Color VGA Magic</a></h2>
<section id="introducing-the-vgas-undocumented-animation-optimal-mode" class="level3">
<h3><a href="#introducing-the-vgas-undocumented-animation-optimal-mode">Introducing the VGA’s Undocumented “Animation-Optimal” Mode</a></h3>
<p>At a book signing for my book <em>Zen of Code Optimization</em>, an attractive young woman came up to me, holding my book, and said, “You’re Michael Abrash, aren’t you?” I confessed that I was, prepared to respond in an appropriately modest yet proud way to the compliments I was sure would follow. (It was my own book signing, after all.) It didn’t work out quite that way, though. The first thing out of her mouth was:</p>
<p>“‘Mode X’ is a stupid name for a graphics mode.” As my jaw started to drop, she added, “And you didn’t invent the mode, either. My husband did it before you did.”</p>
<p>And they say there are no groupies in programming!</p>
<p>Well. I never claimed that I invented the mode (which is a 320x256-color mode with some very special properties, as we’ll see shortly). I did discover it independently, but so did other people in the game business, some of them no doubt before I did. The difference is that all those other people held onto this powerful mode as a trade secret, while I didn’t; instead, I spread the word as broadly as I could in my column in <em>Dr. Dobb’s Journal,</em> on the theory that the more people knew about this mode, the more valuable it would be. And I succeeded, as evidenced by the fact that this now widely-used mode is universally known by the name I gave it in <em>DDJ,</em> “Mode X.” Neither do I think that’s a bad name; it’s short, catchy, and easy to remember, and it befits the mystery status of this mode, which was omitted entirely from IBM’s documentation of the VGA.</p>
<p>In fact, when all is said and done, Mode X is one of my favorite accomplishments. I remember reading that Charles Schultz, creator of “Peanuts,” was particularly proud of having introduced the phrase “security blanket” to the English language. I feel much the same way about Mode X; it’s now a firmly entrenched part of the computer lexicon, and how often do any of us get a chance to do that? And that’s not to mention all the excellent games that would not have been as good without Mode X.</p>
<p>So, in the end, I’m thoroughly pleased with Mode X; the world is a better place for it, even if it did cost me my one potential female fan. (Contrary to popular belief, the lives of computer columnists and rock stars are not, repeat, <em>not</em>, all that similar.) This and the following two chapters are based on the <em>DDJ</em> columns that started it all back in 1991, three columns that generated a tremendous amount of interest and spawned a ton of games, and about which I still regularly get letters and e-mail. Ladies and gentlemen, I give you…Mode X.</p>
</section>
<section id="what-makes-mode-x-special" class="level3">
<h3><a href="#what-makes-mode-x-special">What Makes Mode X Special?</a></h3>
<p>Consider the strange case of the VGA’s 320x256-color mode—Mode X—which is undeniably complex to program and isn’t even documented by IBM—but which is, nonetheless, perhaps the single best mode the VGA has to offer, especially for animation.</p>
<p>We’ve seen the VGA’s undocumented 256-color modes, in Chapters 31 and 32, but now it’s time to delve into the wonders of Mode X itself. (Most of the performance tips I’ll discuss for this mode also apply to the other non-standard 256-color modes, however.) Five features set Mode X apart from other VGA modes. First, it has a 1:1 aspect ratio, resulting in equal pixel spacing horizontally and vertically (that is, square pixels). Square pixels make for the most attractive displays, and avoid considerable programming effort that would otherwise be necessary to adjust graphics primitives and images to match the screen’s pixel spacing. (For example, with square pixels, a circle can be drawn as a circle; otherwise, it must be drawn as an ellipse that corrects for the aspect ratio—a slower and considerably more complicated process.) In contrast, mode 13H, the only documented 256-color mode, provides a nonsquare 320x200 resolution.</p>
<p>Second, Mode X allows page flipping, a prerequisite for the smoothest possible animation. Mode 13H does not allow page flipping, nor does mode 12H, the VGA’s high-resolution 640x480 16-color mode.</p>
<p>Third, Mode X allows the VGA’s plane-oriented hardware to be used to process pixels in parallel, improving performance by up to four times over mode 13H.</p>
<p>Fourth, like mode 13H but unlike all other VGA modes, Mode X is a byte-per-pixel mode (each pixel is controlled by one byte in display memory), eliminating the slow read-before-write and bit-masking operations often required in 16-color modes, where each byte of display memory represents more than a single pixel. In addition to cutting the number of memory accesses in half, this is important because the 486/Pentium write FIFO and the memory caching schemes used by many VGA clones speed up writes more than reads.</p>
<p>Fifth, unlike mode 13H, Mode X has plenty of offscreen memory free for image storage. This is particularly effective in conjunction with the use of the VGA’s latches; together, the latches and the off-screen memory allow images to be copied to the screen four pixels at a time.</p>
<p>There’s a sixth feature of Mode X that’s <em>not</em> so terrific: It’s hard to program efficiently. As Chapters 23 through 30 of this book demonstrates, 16-color VGA programming can be demanding. Mode X is often as demanding as 16-color programming, and operates by a set of rules that turns everything you’ve learned in 16-color mode sideways. Programming Mode X is nothing like programming the nice, flat bitmap of mode 13H, or, for that matter, the flat, linear (albeit banked) bitmap used by 256-color SuperVGA modes. (I’t’s important to remember that Mode X works on <em>all</em> VGAs, not just SuperVGAs.) Many programmers I talk to love the flat bitmap model, and think that it’s the ideal organization for display memory because it’s so straightforward to program. Here, however, the complexity of Mode X is opportunity—opportunity for the best combination of performance and appearance the VGA has to offer. If you do 256-color programming, and especially if you use animation, you’re missing the boat if you’re not using Mode X.</p>
<p>Although some developers have taken advantage of Mode X, its use is certainly not universal, being entirely undocumented; only an experienced VGA programmer would have the slightest inkling that it even exists, and figuring out how to make it perform beyond the write pixel/read pixel level is no mean feat. Little other than my <em>DDJ</em> columns has been published about it, although John Bridges has widely distributed his code for a number of undocumented 256-color resolutions, and I’d like to acknowledge the influence of his code on the mode set routine presented in this chapter.</p>
<p>Given the tremendous advantages of Mode X over the documented mode 13H, I’d very much like to get it into the hands of as many developers as possible, so I’m going to spend the next few chapters exploring this odd but worthy mode. I’ll provide mode set code, delineate the bitmap organization, and show how the basic write pixel and read pixel operations work. Then, I’ll move on to the magic stuff: rectangle fills, screen clears, scrolls, image copies, pixel inversion, and, yes, polygon fills (just a different driver for the polygon code), all blurry fast; hardware raster ops; and page flipping. In the end, I’ll build a working animation program that shows many of the features of Mode X in action.</p>
<p>The mode set code is the logical place to begin.</p>
</section>
<section id="selecting-320x240-256-color-mode" class="level3">
<h3><a href="#selecting-320x240-256-color-mode">Selecting 320x240 256-Color Mode</a></h3>
<p>We could, if we wished, write our own mode set code for Mode X from scratch—but why bother? Instead, we’ll let the BIOS do most of the work by having it set up mode 13H, which we’ll then turn into Mode X by changing a few registers. Listing 47.1 does exactly that.</p>
<p>The code in Listing 47.1 has been around for some time, and the very first version had a bug that serves up an interesting lesson. The original <em>DDJ</em> version made images roll on IBM’s fixed-frequency VGA monitors, a problem that didn’t come to my attention until the code was in print and shipped to 100,000 readers.</p>
<p>The bug came about this way: The code I modified to make the Mode X mode set code used the VGA’s 28-MHz clock. Mode X should have used the 25-MHz clock, a simple matter of setting bit 2 of the Miscellaneous Output register (3C2H) to 0 instead of 1.</p>
<p>Alas, I neglected to change that single bit, so frames were drawn at a faster rate than they should have been; however, both of my monitors are multifrequency types, and they automatically compensated for the faster frame rate. Consequently, my clock-selection bug was invisible and innocuous—until it was distributed broadly and everybody started banging on it.</p>
<p>IBM makes only fixed-frequency VGA monitors, which require very specific frame rates; if they don’t get what you’ve told them to expect, the image rolls. The corrected version is the one shown here as Listing 47.1; it does select the 25-MHz clock, and works just fine on fixed-frequency monitors.</p>
<p>Why didn’t I catch this bug? Neither I nor a single one of my testers had a fixed-frequency monitor! This nicely illustrates how difficult it is these days to test code in all the PC-compatible environments in which it might run. The problem is particularly severe for small developers, who can’t afford to buy every model of every hardware component from every manufacturer; just imagine trying to test network-aware software in all possible configurations!</p>
<p>When people ask why software isn’t bulletproof; why it crashes or doesn’t coexist with certain programs; why PC clones aren’t always compatible; why, in short, the myriad irritations of using a PC exist—this is a big part of the reason. I guess that’s just the price we pay for the unfettered creativity and vast choice of the PC market.</p>
<p><strong>LISTING 47.1 L47-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Mode X (320x240, 256 colors) mode set routine. Works on all VGAs.</span>
<span class="co">; ****************************************************************</span>
<span class="co">; * Revised 6/19/91 to select correct clock; fixes vertical roll *</span>
<span class="co">; * problems on fixed-frequency (IBM 851X-type) monitors.        *</span>
<span class="co">; ****************************************************************</span>
<span class="co">; C near-callable as:</span>
<span class="co">;       void Set320x240Mode(void);</span>
<span class="co">; Tested with TASM</span>
<span class="co">; Modified from public-domain mode set code by John Bridges.</span>

SC_INDEX        <span class="dt">equ</span><span class="bn">  03c4h   </span><span class="co">;Sequence Controller Index</span>
CRTC_INDEX      <span class="dt">equ</span><span class="bn">  03d4h   </span><span class="co">;CRT Controller Index</span>
MISC_OUTPUT     <span class="dt">equ</span><span class="bn">  03c2h   </span><span class="co">;Miscellaneous Output register</span>
SCREEN_SEG      <span class="dt">equ</span><span class="bn">  0a000h  </span><span class="co">;segment of display memory in mode X</span>

        .model  small
        .data
<span class="co">; Index/data pairs for CRT Controller registers that differ between</span>
<span class="co">; mode 13h and mode X.</span>
CRTParms label  <span class="dt">word</span>
        <span class="dt">dw</span><span class="bn">      00d06h  </span><span class="co">;vertical total</span>
        <span class="dt">dw</span><span class="bn">      03e07h  </span><span class="co">;overflow (bit 8 of vertical counts)</span>
        <span class="dt">dw</span><span class="bn">      04109h  </span><span class="co">;cell height (2 to double-scan)</span>
        <span class="dt">dw</span><span class="bn">      0ea10h  </span><span class="co">;v sync start</span>
        <span class="dt">dw</span><span class="bn">      0ac11h  </span><span class="co">;v sync end and protect cr0-cr7</span>
        <span class="dt">dw</span><span class="bn">      0df12h  </span><span class="co">;vertical displayed</span>
        <span class="dt">dw</span><span class="bn">      00014h  </span><span class="co">;turn off dword mode</span>
        <span class="dt">dw</span><span class="bn">      0e715h  </span><span class="co">;v blank start</span>
        <span class="dt">dw</span><span class="bn">      00616h  </span><span class="co">;v blank end</span>
        <span class="dt">dw</span><span class="bn">      0e317h  </span><span class="co">;turn on byte mode</span>
CRT_PARM_LENGTH <span class="dt">equ</span>     ((<span class="dv">$</span>-CRTParms)/<span class="dv">2</span>)

        .code
        public  _Set320x240Mode
_Set320x240Mode proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>      <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>      <span class="co">;preserve C register vars</span>
        <span class="kw">push</span>    <span class="kw">di</span>      <span class="co">; (don&#39;t count on BIOS preserving anything)</span>

        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,13h  </span><span class="co">;let the BIOS set standard 256-color</span>
        <span class="kw">int</span><span class="bn">     10h     </span><span class="co">; mode (320x200 linear)</span>

        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0604h</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>   <span class="co">;disable chain4 mode</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0100h</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>   <span class="co">;synchronous reset while setting Misc Output</span>
                        <span class="co">; for safety, even though clock unchanged</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,MISC_OUTPUT
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0e3h</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>   <span class="co">;select 25 MHz dot clock &amp; 60 Hz scanning rate</span>

        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0300h</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>   <span class="co">;undo reset (restart sequencer)</span>

        <span class="kw">mov</span>     <span class="kw">dx</span>,CRTC_INDEX <span class="co">;reprogram the CRT Controller</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,11h  </span><span class="co">;VSync End reg contains register write</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>   <span class="co">; protect bit</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>      <span class="co">;CRT Controller Data register</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>   <span class="co">;get current VSync End register setting</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,7fh  </span><span class="co">;remove write protect on various</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>   <span class="co">; CRTC registers</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>      <span class="co">;CRT Controller Index</span>
        <span class="kw">cld</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,offset CRTParms <span class="co">;point to CRT parameter table</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,CRT_PARM_LENGTH <span class="co">;# of table entries</span>
<span class="fu">SetCRTParmsLoop:</span>
        <span class="kw">lodsw</span>           <span class="co">;get the next CRT Index/Data pair</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>   <span class="co">;set the next CRT Index/Data pair</span>
        <span class="kw">loop</span>    SetCRTParmsLoop

        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0f02h</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>   <span class="co">;enable writes to all four planes</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEG <span class="co">;now clear all display memory, 8 pixels</span>
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>         <span class="co">; at a time</span>
        <span class="kw">sub</span>     <span class="kw">di</span>,<span class="kw">di</span>   <span class="co">;point ES:DI to display memory</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>   <span class="co">;clear to zero-value pixels</span>
        <span class="kw">mov</span>     <span class="kw">cx</span><span class="bn">,8000h </span><span class="co">;# of words in display memory</span>
        rep     <span class="kw">stosw</span>   <span class="co">;clear all of display memory</span>

        <span class="kw">pop</span>     <span class="kw">di</span>      <span class="co">;restore C register vars</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>      <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_Set320x240Mode endp
        end</code></pre>
<p>After setting up mode 13H, Listing 47.1 alters the vertical counts and timings to select 480 visible scan lines. (There’s no need to alter any horizontal values, because mode 13H and Mode X both have 320-pixel horizontal resolutions.) The Maximum Scan Line register is programmed to double scan each line (that is, repeat each scan line twice), however, so we get an effective vertical resolution of 240 scan lines. It is, in fact, possible to get 400 or 480 independent scan lines in 256-color mode, as discussed in Chapter 31 and 32; however, 400-scan-line modes lack square pixels and can’t support simultaneous off-screen memory and page flipping. Furthermore, 480-scan-line modes lack page flipping altogether, due to memory constraints.</p>
<p>At the same time, Listing 47.1 programs the VGA’s bitmap to a planar organization that is similar to that used by the 16-color modes, and utterly different from the linear bitmap of mode 13H. The bizarre bitmap organization of Mode X is shown in Figure 47.1. The first pixel (the pixel at the upper left corner of the screen) is controlled by the byte at offset 0 in plane 0. (The one thing that Mode X blessedly has in common with mode 13H is that each pixel is controlled by a single byte, eliminating the need to mask out individual bits of display memory.) The second pixel, immediately to the right of the first pixel, is controlled by the byte at offset 0 in plane 1. The third pixel comes from offset 0 in plane 2, and the fourth pixel from offset 0 in plane 3. Then, the fifth pixel is controlled by the byte at offset 1 in plane 0, and that cycle continues, with each group of four pixels spread across the four planes at the same address. The offset M of pixel N in display memory is M = N/4, and the plane P of pixel N is P = N mod 4. For display memory writes, the plane is selected by setting bit P of the Map Mask register (Sequence Controller register 2) to 1 and all other bits to 0; for display memory reads, the plane is selected by setting the Read Map register (Graphics Controller register 4) to P.</p>
<p>It goes without saying that this is one ugly bitmap organization, requiring a lot of overhead to manipulate a single pixel. The write pixel code shown in Listing 47.2 must determine the appropriate plane and perform a 16-bit <code>OUT</code> to select that plane for each pixel written, and likewise for the read pixel code shown in Listing 47.3. Calculating and mapping in a plane once for each pixel written is scarcely a recipe for performance.</p>
<p>That’s all right, though, because most graphics software spends little time drawing individual pixels. I’ve provided the write and read pixel routines as basic primitives, and so you’ll understand how the bitmap is organized, but the building blocks of high-performance graphics software are fills, copies, and bitblts, and it’s there that Mode X shines.</p>
<figure>
<img src="images/47-01.jpg" alt="Figure 47.1  Mode X display memory organization." /><figcaption><strong>Figure 47.1</strong>  <em>Mode X display memory organization.</em></figcaption>
</figure>
<p><strong>LISTING 47.2 L47-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Mode X (320x240, 256 colors) write pixel routine. Works on all VGAs.</span>
<span class="co">; No clipping is performed.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;</span>
<span class="co">;    void WritePixelX(int X, int Y, unsigned int PageBase, int Color);</span>

SC_INDEX      <span class="dt">equ</span><span class="bn">    03c4h              </span><span class="co">;Sequence Controller Index</span>
MAP_MASK      <span class="dt">equ</span><span class="bn">    02h                </span><span class="co">;index in SC of Map Mask register</span>
SCREEN_SEG    <span class="dt">equ</span><span class="bn">    0a000h             </span><span class="co">;segment of display memory in mode X</span>
SCREEN_WIDTH  <span class="dt">equ</span>    <span class="dv">80</span>                 <span class="co">;width of screen in bytes from one scan line</span>
                                        <span class="co">; to the next</span>

parms   <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup (?)               <span class="co">;pushed BP and return address</span>
X       <span class="dt">dw</span>      ?                       <span class="co">;X coordinate of pixel to draw</span>
Y       <span class="dt">dw</span>      ?                       <span class="co">;Y coordinate of pixel to draw</span>
PageBase <span class="dt">dw</span>     ?                       <span class="co">;base offset in display memory of page in</span>
                                        <span class="co">; which to draw pixel</span>
Color   <span class="dt">dw</span>      ?                       <span class="co">;color in which to draw pixel</span>
parms   ends

        .model  small
        .code
        public  _WritePixelX
_WritePixelX    proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>                      <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>                   <span class="co">;point to local stack frame</span>

        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_WIDTH
        <span class="kw">mul</span>     [<span class="kw">bp</span>+Y]                  <span class="co">;offset of pixel&#39;s scan line in page</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+X]
        <span class="kw">shr</span>     <span class="kw">bx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">bx</span>,<span class="dv">1</span>                    <span class="co">;X/4 = offset of pixel in scan line</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,<span class="kw">ax</span>                   <span class="co">;offset of pixel in page</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+PageBase]        <span class="co">;offset of pixel in display memory</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEG
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>                   <span class="co">;point ES:BX to the pixel&#39;s address</span>

        <span class="kw">mov</span>     <span class="kw">cl</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+X]
        <span class="kw">and</span>     <span class="kw">cl</span><span class="bn">,011b                 </span><span class="co">;CL = pixel&#39;s plane</span>
        <span class="kw">mov</span>     <span class="kw">ax</span><span class="bn">,0100h </span>+ MAP_MASK     <span class="co">;AL = index in SC of Map Mask reg</span>
        <span class="kw">shl</span>     <span class="kw">ah</span>,<span class="kw">cl</span>                   <span class="co">;set only the bit for the pixel&#39;s plane to 1</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX             <span class="co">;set the Map Mask to enable only the</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>                   <span class="co">; pixel&#39;s plane</span>

        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Color]
        <span class="kw">mov</span>     <span class="kw">es</span>:[<span class="kw">bx</span>],<span class="kw">al</span>              <span class="co">;draw the pixel in the desired color</span>

        <span class="kw">pop</span>     <span class="kw">bp</span>                      <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_WritePixelX    endp
        end</code></pre>
<p><strong>LISTING 47.3 L47-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Mode X (320x240, 256 colors) read pixel routine. Works on all VGAs.</span>
<span class="co">; No clipping is performed.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;</span>
<span class="co">;    unsigned int ReadPixelX(int X, int Y, unsigned int PageBase);</span>

GC_INDEX     <span class="dt">equ</span><span class="bn">    03ceh               </span><span class="co">;Graphics Controller Index</span>
READ_MAP     <span class="dt">equ</span><span class="bn">    04h                 </span><span class="co">;index in GC of the Read Map register</span>
SCREEN_SEG   <span class="dt">equ</span><span class="bn">    0a000h              </span><span class="co">;segment of display memory in mode X</span>
SCREEN_WIDTH <span class="dt">equ</span>    <span class="dv">80</span>                  <span class="co">;width of screen in bytes from one scan line</span>
                                        <span class="co">; to the next</span>
parms   <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup (?)               <span class="co">;pushed BP and return address</span>
X       <span class="dt">dw</span>      ?                       <span class="co">;X coordinate of pixel to read</span>
Y       <span class="dt">dw</span>      ?                       <span class="co">;Y coordinate of pixel to read</span>
PageBase <span class="dt">dw</span>     ?                       <span class="co">;base offset in display memory of page from</span>
                                        <span class="co">; which to read pixel</span>
parms   ends

        .model  small
        .code
        public  _ReadPixelX
_ReadPixelX     proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>                      <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>                   <span class="co">;point to local stack frame</span>

        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_WIDTH
        <span class="kw">mul</span>     [<span class="kw">bp</span>+Y]                  <span class="co">;offset of pixel&#39;s scan line in page</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+X]
        <span class="kw">shr</span>     <span class="kw">bx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">bx</span>,<span class="dv">1</span>                    <span class="co">;X/4 = offset of pixel in scan line</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,<span class="kw">ax</span>                   <span class="co">;offset of pixel in page</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+PageBase]        <span class="co">;offset of pixel in display memory</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEG
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>                   <span class="co">;point ES:BX to the pixel&#39;s address</span>

        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+X]
        <span class="kw">and</span>     <span class="kw">ah</span><span class="bn">,011b </span><span class="co">;AH = pixel&#39;s plane</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,READ_MAP             <span class="co">;AL = index in GC of the Read Map reg</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX             <span class="co">;set the Read Map to read the pixel&#39;s</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>                   <span class="co">; plane</span>

        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">es</span>:[<span class="kw">bx</span>]              <span class="co">;read the pixel&#39;s color</span>
        <span class="kw">sub</span>     <span class="kw">ah</span>,<span class="kw">ah</span>                   <span class="co">;convert it to an unsigned int</span>

        <span class="kw">pop</span>     <span class="kw">bp</span>                      <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_ReadPixelX     endp
        end</code></pre>
</section>
<section id="designing-from-a-mode-x-perspective" class="level3">
<h3><a href="#designing-from-a-mode-x-perspective">Designing from a Mode X Perspective</a></h3>
<p>Listing 47.4 shows Mode X rectangle fill code. The plane is selected for each pixel in turn, with drawing cycling from plane 0 to plane 3, then wrapping back to plane 0. This is the sort of code that stems from a write-pixel line of thinking; it reflects not a whit of the unique perspective that Mode X demands, and although it looks reasonably efficient, it is in fact some of the slowest graphics code you will ever see. I’ve provided Listing 47.4 partly for illustrative purposes, but mostly so we’ll have a point of reference for the substantial speed-up that’s possible with code that’s designed from a Mode X perspective.</p>
<p><strong>LISTING 47.4 L47-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Mode X (320x240, 256 colors) rectangle fill routine. Works on all</span>
<span class="co">; VGAs. Uses slow approach that selects the plane explicitly for each</span>
<span class="co">; pixel. Fills up to but not including the column at EndX and the row</span>
<span class="co">; at EndY. No clipping is performed.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;</span>
<span class="co">;    void FillRectangleX(int StartX, int StartY, int EndX, int EndY,</span>
<span class="co">;       unsigned int PageBase, int Color);</span>

SC_INDEX      <span class="dt">equ</span><span class="bn">    03c4h              </span><span class="co">;Sequence Controller Index</span>
MAP_MASK      <span class="dt">equ</span><span class="bn">    02h                </span><span class="co">;index in SC of Map Mask register</span>
SCREEN_SEG    <span class="dt">equ</span><span class="bn">    0a000h             </span><span class="co">;segment of display memory in mode X</span>
SCREEN_WIDTH  <span class="dt">equ</span>    <span class="dv">80</span>                 <span class="co">;width of screen in bytes from one scan line</span>
                                        <span class="co">; to the next</span>
parms   <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup (?)               <span class="co">;pushed BP and return address</span>
StartX  <span class="dt">dw</span>      ?                  <span class="co">;X coordinate of upper left corner of rect</span>
StartY  <span class="dt">dw</span>      ?                  <span class="co">;Y coordinate of upper left corner of rect</span>
EndX    <span class="dt">dw</span>      ?                  <span class="co">;X coordinate of lower right corner of rect</span>
                                   <span class="co">; (the row at EndX is not filled)</span>
EndY    <span class="dt">dw</span>      ?                       <span class="co">;Y coordinate of lower right corner of rect</span>
                                        <span class="co">; (the column at EndY is not filled)</span>
PageBase <span class="dt">dw</span>     ?                       <span class="co">;base offset in display memory of page in</span>
                                        <span class="co">; which to fill rectangle</span>
Color   <span class="dt">dw</span>      ?                       <span class="co">;color in which to draw pixel</span>
parms   ends

        .model  small
        .code
        public  _FillRectangleX
_FillRectangleX proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>                      <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>                   <span class="co">;point to local stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>                      <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_WIDTH
        <span class="kw">mul</span>     [<span class="kw">bp</span>+StartY]             <span class="co">;offset in page of top rectangle scan line</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+StartX]
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>                    <span class="co">;X/4 = offset of first rectangle pixel in scan</span>
                                        <span class="co">; line</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>                   <span class="co">;offset of first rectangle pixel in page</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+PageBase]        <span class="co">;offset of first rectangle pixel in</span>
                                        <span class="co">; display memory</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEG
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>                   <span class="co">;point ES:DI to the first rectangle pixel&#39;s</span>
                                        <span class="co">; address</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX             <span class="co">;set the Sequence Controller Index to</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK             <span class="co">; point to the Map Mask register</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>                      <span class="co">;point DX to the SC Data register</span>
        <span class="kw">mov</span>     <span class="kw">cl</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+StartX]
        <span class="kw">and</span>     <span class="kw">cl</span><span class="bn">,011b                 </span><span class="co">;CL = first rectangle pixel&#39;s plane</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,01h</span>
        <span class="kw">shl</span>     <span class="kw">al</span>,<span class="kw">cl</span>                   <span class="co">;set only the bit for the pixel&#39;s plane to 1</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Color]  <span class="co">;color with which to fill</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+EndY]
        <span class="kw">sub</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+StartY]          <span class="co">;BX = height of rectangle</span>
        <span class="kw">jle</span>     FillDone                <span class="co">;skip if 0 or negative height</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+EndX]
        <span class="kw">sub</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+StartX]          <span class="co">;CX = width of rectangle</span>
        <span class="kw">jle</span>     FillDone                <span class="co">;skip if 0 or negative width</span>
<span class="fu">FillRowsLoop:</span>
        <span class="kw">push</span>    <span class="kw">ax</span>                      <span class="co">;remember the plane mask for the left edge</span>
        <span class="kw">push</span>    <span class="kw">di</span>                      <span class="co">;remember the start offset of the scan line</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">si</span>                   <span class="co">;set count of pixels in this scan line</span>
<span class="fu">FillScanLineLoop:</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                   <span class="co">;set the plane for this pixel</span>
        <span class="kw">mov</span>     <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">ah</span>              <span class="co">;draw the pixel</span>
        <span class="kw">shl</span>     <span class="kw">al</span>,<span class="dv">1</span>                    <span class="co">;adjust the plane mask for the next pixel&#39;s</span>
        <span class="kw">and</span>     <span class="kw">al</span><span class="bn">,01111b               </span><span class="co">; bit, modulo 4</span>
        <span class="kw">jnz</span>     AddressSet              <span class="co">;advance address if we turned over from</span>
        <span class="kw">inc</span>     <span class="kw">di</span>                      <span class="co">; plane 3 to plane 0</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,00001b               </span><span class="co">;set plane mask bit for plane 0</span>
<span class="fu">AddressSet:</span>
        <span class="kw">loop</span>    FillScanLineLoop
        <span class="kw">pop</span>     <span class="kw">di</span>                      <span class="co">;retrieve the start offset of the scan line</span>
        <span class="kw">add</span>     <span class="kw">di</span>,SCREEN_WIDTH         <span class="co">;point to the start of the next scan</span>
                                        <span class="co">; line of the rectangle</span>
        <span class="kw">pop</span>     <span class="kw">ax</span>                      <span class="co">;retrieve the plane mask for the left edge</span>
        <span class="kw">dec</span>     <span class="kw">bx</span>                      <span class="co">;count down scan lines</span>
        <span class="kw">jnz</span>     FillRowsLoop
<span class="fu">FillDone:</span>
        <span class="kw">pop</span>     <span class="kw">di</span>                      <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>                      <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_FillRectangleX endp
        end</code></pre>
<p>The two major weaknesses of Listing 47.4 both result from selecting the plane on a pixel by pixel basis. First, endless <code>OUT</code>s (which are particularly slow on 386s, 486s, and Pentiums, much slower than accesses to display memory) must be performed, and, second, <code>REP STOS</code> can’t be used. Listing 47.5 overcomes both these problems by tailoring the fill technique to the organization of display memory. Each plane is filled in its entirety in one burst before the next plane is processed, so only five <code>OUT</code>s are required in all, and <code>REP STOS</code> can indeed be used; I’ve used <code>REP STOSB</code> in Listings 47.5 and 47.6. <code>REP STOSW</code> could be used and would improve performance on most VGAs; however, <code>REP STOSW</code> requires extra overhead to set up, so it can be slower for small rectangles, especially on 8-bit VGAs. Note that doing an entire plane at a time can produce a “fading-in” effect for large images, because all columns for one plane are drawn before any columns for the next. If this is a problem, the four planes can be cycled through once for each scan line, rather than once for the entire rectangle.</p>
<p>Listing 47.5 is 2.5 times faster than Listing 47.4 at clearing the screen on a 20-MHz cached 386 with a Paradise VGA. Although Listing 47.5 is slightly slower than an equivalent mode 13H fill routine would be, it’s not grievously so.</p>
<blockquote>
<p><img src="images/i.jpg" /> In general, performing plane-at-a-time operations can make almost any Mode X operation, at the worst, nearly as fast as the same operation in mode 13H (although this sort of Mode X programming is admittedly fairly complex). In this pursuit, it can help to organize data structures with Mode X in mind. For example, icons could be prearranged in system memory with the pixels organized into four plane-oriented sets (or, again, in four sets per scan line to avoid a fading-in effect) to facilitate copying to the screen a plane at a time with <code>REP MOVS</code>.</p>
</blockquote>
<p><strong>LISTING 47.5 L47-5.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Mode X (320x240, 256 colors) rectangle fill routine. Works on all</span>
<span class="co">; VGAs. Uses medium-speed approach that selects each plane only once</span>
<span class="co">; per rectangle; this results in a fade-in effect for large</span>
<span class="co">; rectangles. Fills up to but not including the column at EndX and the</span>
<span class="co">; row at EndY. No clipping is performed.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;</span>
<span class="co">;    void FillRectangleX(int StartX, int StartY, int EndX, int EndY,</span>
<span class="co">;       unsigned int PageBase, int Color);</span>

SC_INDEX     <span class="dt">equ</span><span class="bn">    03c4h               </span><span class="co">;Sequence Controller Index</span>
MAP_MASK     <span class="dt">equ</span><span class="bn">    02h                 </span><span class="co">;index in SC of Map Mask register</span>
SCREEN_SEG   <span class="dt">equ</span><span class="bn">    0a000h              </span><span class="co">;segment of display memory in mode X</span>
SCREEN_WIDTH <span class="dt">equ</span>    <span class="dv">80</span>                  <span class="co">;width of screen in bytes from one scan line</span>
                                        <span class="co">; to the next</span>
parms <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup (?)               <span class="co">;pushed BP and return address</span>
StartX  <span class="dt">dw</span>      ?                       <span class="co">;X coordinate of upper left corner of rect</span>
StartY  <span class="dt">dw</span>      ?                       <span class="co">;Y coordinate of upper left corner of rect</span>
EndX    <span class="dt">dw</span>      ?                       <span class="co">;X coordinate of lower right corner of rect</span>
                                        <span class="co">; (the row at EndX is not filled)</span>
EndY    <span class="dt">dw</span>      ?                       <span class="co">;Y coordinate of lower right corner of rect</span>
                                        <span class="co">; (the column at EndY is not filled)</span>
PageBase <span class="dt">dw</span>     ?                       <span class="co">;base offset in display memory of page in</span>
                                        <span class="co">; which to fill rectangle</span>
Color   <span class="dt">dw</span>      ?                       <span class="co">;color in which to draw pixel</span>
parms ends

StartOffset  <span class="dt">equ</span>   -<span class="dv">2</span>                   <span class="co">;local storage for start offset of rectangle</span>
Width        <span class="dt">equ</span>   -<span class="dv">4</span>                   <span class="co">;local storage for address width of rectangle</span>
Height       <span class="dt">equ</span>   -<span class="dv">6</span>                   <span class="co">;local storage for height of rectangle</span>
PlaneInfo    <span class="dt">equ</span>   -<span class="dv">8</span>                   <span class="co">;local storage for plane # and plane mask</span>
STACK_FRAME_SIZE  <span class="dt">equ</span>  <span class="dv">8</span>

        .model  small
        .code
        public  _FillRectangleX
_FillRectangleX proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>                      <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>                   <span class="co">;point to local stack frame</span>
        <span class="kw">sub</span>     <span class="kw">sp</span>,STACK_FRAME_SIZE     <span class="co">;allocate space for local vars</span>
        <span class="kw">push</span>    <span class="kw">si</span>                      <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">cld</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_WIDTH
        <span class="kw">mul</span>     [<span class="kw">bp</span>+StartY]             <span class="co">;offset in page of top rectangle scan line</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+StartX]
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>                    <span class="co">;X/4 = offset of first rectangle pixel in scan</span>
                                        <span class="co">; line</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>                   <span class="co">;offset of first rectangle pixel in page</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+PageBase]        <span class="co">;offset of first rectangle pixel in</span>
                                        <span class="co">; display memory</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEG
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>                   <span class="co">;point ES:DI to the first rectangle pixel&#39;s</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+StartOffset],<span class="kw">di</span>     <span class="co">; address</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX             <span class="co">;set the Sequence Controller Index to</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK             <span class="co">; point to the Map Mask register</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+EndY]
        <span class="kw">sub</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+StartY]          <span class="co">;BX = height of rectangle</span>
        <span class="kw">jle</span>     FillDone                <span class="co">;skip if 0 or negative height</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+Height],<span class="kw">bx</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bp</span>+EndX]
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+StartX]
        <span class="kw">cmp</span>     <span class="kw">dx</span>,<span class="kw">cx</span>
        <span class="kw">jle</span>     FillDone                <span class="co">;skip if 0 or negative width</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>
        <span class="kw">and</span>     <span class="kw">cx</span>,<span class="kw">not</span><span class="bn"> 011b</span>
        <span class="kw">sub</span>     <span class="kw">dx</span>,<span class="kw">cx</span>
        <span class="kw">shr</span>     <span class="kw">dx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">dx</span>,<span class="dv">1</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>                      <span class="co">;# of addresses across rectangle to fill</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+Width],<span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+PlaneInfo]<span class="bn">,0001h</span>
                                        <span class="co">;lower byte = plane mask for plane 0,</span>
                                        <span class="co">; upper byte = plane # for plane 0</span>
<span class="fu">FillPlanesLoop:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+PlaneInfo]
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX<span class="dv">+1</span>           <span class="co">;point DX to the SC Data register</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                   <span class="co">;set the plane for this pixel</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+StartOffset]     <span class="co">;point ES:DI to rectangle start</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bp</span>+Width]
        <span class="kw">mov</span>     <span class="kw">cl</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+StartX]
        <span class="kw">and</span>     <span class="kw">cl</span><span class="bn">,011b                 </span><span class="co">;plane # of first pixel in initial byte</span>
        <span class="kw">cmp</span>     <span class="kw">ah</span>,<span class="kw">cl</span>                   <span class="co">;do we draw this plane in the initial byte?</span>
        <span class="kw">jae</span>     InitAddrSet             <span class="co">;yes</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>                      <span class="co">;no, so skip the initial byte</span>
        <span class="kw">jz</span>      FillLoopBottom          <span class="co">;skip this plane if no pixels in it</span>
        <span class="kw">inc</span>     <span class="kw">di</span>
<span class="fu">InitAddrSet:</span>
        <span class="kw">mov</span>     <span class="kw">cl</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+EndX]
        <span class="kw">dec</span>     <span class="kw">cl</span>
        <span class="kw">and</span>     <span class="kw">cl</span><span class="bn">,011b                 </span><span class="co">;plane # of last pixel in final byte</span>
        <span class="kw">cmp</span>     <span class="kw">ah</span>,<span class="kw">cl</span>                   <span class="co">;do we draw this plane in the final byte?</span>
        <span class="kw">jbe</span>     WidthSet                <span class="co">;yes</span>
        <span class="kw">dec</span>     <span class="kw">dx</span>                      <span class="co">;no, so skip the final byte</span>
        <span class="kw">jz</span>      FillLoopBottom          <span class="co">;skip this planes if no pixels in it</span>
<span class="fu">WidthSet:</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,SCREEN_WIDTH
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">dx</span>                   <span class="co">;distance from end of one scan line to start</span>
                                        <span class="co">; of next</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+Height]          <span class="co">;# of lines to fill</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Color]  <span class="co">;color with which to fill</span>
<span class="fu">FillRowsLoop:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">dx</span>                   <span class="co">;# of bytes across scan line</span>
        rep     <span class="kw">stosb</span>                   <span class="co">;fill the scan line in this plane</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">si</span>                   <span class="co">;point to the start of the next scan</span>
                                        <span class="co">; line of the rectangle</span>
        <span class="kw">dec</span>     <span class="kw">bx</span>                      <span class="co">;count down scan lines</span>
        <span class="kw">jnz</span>     FillRowsLoop
<span class="fu">FillLoopBottom:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+PlaneInfo]
        <span class="kw">shl</span>     <span class="kw">al</span>,<span class="dv">1</span>                    <span class="co">;set the plane bit to the next plane</span>
        <span class="kw">inc</span>     <span class="kw">ah</span>                      <span class="co">;increment the plane #</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+PlaneInfo],<span class="kw">ax</span>
        <span class="kw">cmp</span>     <span class="kw">ah</span>,<span class="dv">4</span>                    <span class="co">;have we done all planes?</span>
        <span class="kw">jnz</span>     FillPlanesLoop          <span class="co">;continue if any more planes</span>
<span class="fu">FillDone:</span>
        <span class="kw">pop</span>     <span class="kw">di</span>                      <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">mov</span>     <span class="kw">sp</span>,<span class="kw">bp</span>                   <span class="co">;discard storage for local variables</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>                      <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_FillRectangleX endp
        end</code></pre>
</section>
<section id="hardware-assist-from-an-unexpected-quarter" class="level3">
<h3><a href="#hardware-assist-from-an-unexpected-quarter">Hardware Assist from an Unexpected Quarter</a></h3>
<p>Listing 47.5 illustrates the benefits of designing code from a Mode X perspective; this is the software aspect of Mode X optimization, which suffices to make Mode X about as fast as mode 13H. That alone makes Mode X an attractive mode, given its square pixels, page flipping, and offscreen memory, but superior performance would nonetheless be a pleasant addition to that list. Superior performance is indeed possible in Mode X, although, oddly enough, it comes courtesy of the VGA’s hardware, which was never designed to be used in 256-color modes.</p>
<p>All of the VGA’s hardware assist features are available in Mode X, although some are not particularly useful. The VGA hardware feature that’s truly the key to Mode X performance is the ability to process four planes’ worth of data in parallel; this includes both the latches and the capability to fan data out to any or all planes. For rectangular fills, we’ll just need to fan the data out to various planes, so I’ll defer a discussion of other hardware features for now. (By the way, the ALUs, bit mask, and most other VGA hardware features are also available in mode 13H—but parallel data processing is not.)</p>
<p>In planar modes, such as Mode X, a byte written by the CPU to display memory may actually go to anywhere between zero and four planes, as shown in Figure 47.2. Each plane for which the setting of the corresponding bit in the Map Mask register is 1 receives the CPU data, and each plane for which the corresponding bit is 0 is not modified.</p>
<p>In 16-color modes, each plane contains one-quarter of each of eight pixels, with the 4 bits of each pixel spanning all four planes. Not so in Mode X. Look at Figure 47.1 again; each plane contains one pixel in its entirety, with four pixels at any given address, one per plane. Still, the Map Mask register does the same job in Mode X as in 16-color modes; set it to 0FH (all 1-bits), and all four planes will be written to by each CPU access. Thus, it would seem that up to four pixels could be set by a single Mode X byte-sized write to display memory, potentially speeding up operations like rectangle fills by four times.</p>
<figure>
<img src="images/47-02.jpg" alt="Figure 47.2  Selecting planes with the Map Mask register." /><figcaption><strong>Figure 47.2</strong>  <em>Selecting planes with the Map Mask register.</em></figcaption>
</figure>
<p>And, as it turns out, four-plane parallelism works quite nicely indeed. Listing 47.6 is yet another rectangle-fill routine, this time using the Map Mask to set up to four pixels per <code>STOS</code>. The only trick to Listing 47.6 is that any left or right edge that isn’t aligned to a multiple-of-four pixel column (that is, a column at which one four-pixel set ends and the next begins) must be clipped via the Map Mask register, because not all pixels at the address containing the edge are modified. Performance is as expected; Listing 47.6 is nearly ten times faster at clearing the screen than Listing 47.4 and just about four times faster than Listing 47.5—and also about four times faster than the same rectangle fill in mode 13H. Understanding the bitmap organization and display hardware of Mode X does indeed pay.</p>
<p>Note that the return from Mode X’s parallelism is not always 4x; some adapters lack the underlying memory bandwidth to write data that fast. However, Mode X parallel access should always be faster than mode 13H access; the only question on any given adapter is how <em>much</em> faster.</p>
<p><strong>LISTING 47.6 L47-6.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Mode X (320x240, 256 colors) rectangle fill routine. Works on all</span>
<span class="co">; VGAs. Uses fast approach that fans data out to up to four planes at</span>
<span class="co">; once to draw up to four pixels at once. Fills up to but not</span>
<span class="co">; including the column at EndX and the row at EndY. No clipping is</span>
<span class="co">; performed.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;    void FillRectangleX(int StartX, int StartY, int EndX, int EndY,</span>
<span class="co">;       unsigned int PageBase, int Color);</span>

SC_INDEX     <span class="dt">equ</span><span class="bn">    03c4h               </span><span class="co">;Sequence Controller Index</span>
MAP_MASK     <span class="dt">equ</span><span class="bn">    02h                 </span><span class="co">;index in SC of Map Mask register</span>
SCREEN_SEG   <span class="dt">equ</span><span class="bn">    0a000h              </span><span class="co">;segment of display memory in mode X</span>
SCREEN_WIDTH <span class="dt">equ</span>    <span class="dv">80</span>                  <span class="co">;width of screen in bytes from one scan line</span>
                                        <span class="co">; to the next</span>
parms   <span class="kw">struc</span>
          <span class="dt">dw</span>      <span class="dv">2</span> dup (?)             <span class="co">;pushed BP and return address</span>
StartX    <span class="dt">dw</span>      ?                     <span class="co">;X coordinate of upper left corner of rect</span>
StartY    <span class="dt">dw</span>      ?                     <span class="co">;Y coordinate of upper left corner of rect</span>
EndX      <span class="dt">dw</span>      ?                     <span class="co">;X coordinate of lower right corner of rect</span>
                                        <span class="co">; (the row at EndX is not filled)</span>
EndY      <span class="dt">dw</span>      ?                     <span class="co">;Y coordinate of lower right corner of rect</span>
                                        <span class="co">; (the column at EndY is not filled)</span>
PageBase <span class="dt">dw</span>      ?                      <span class="co">;base offset in display memory of page in</span>
                                        <span class="co">; which to fill rectangle</span>
Color    <span class="dt">dw</span>      ?                      <span class="co">;color in which to draw pixel</span>
parms    ends

         .model  small
         .data
<span class="co">; Plane masks for clipping left and right edges of rectangle.</span>
LeftClipPlaneMask       <span class="dt">db</span><span class="bn">      00fh,</span>00eh<span class="bn">,00ch,</span>008h
RightClipPlaneMask      <span class="dt">db</span><span class="bn">      00fh,</span>001h<span class="bn">,003h,</span>007h
        .code
        public  _FillRectangleX
_FillRectangleX proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>                      <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>                   <span class="co">;point to local stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>                      <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">cld</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_WIDTH
        <span class="kw">mul</span>     [<span class="kw">bp</span>+StartY]             <span class="co">;offset in page of top rectangle scan line</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+StartX]
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>                    <span class="co">;X/4 = offset of first rectangle pixel in scan</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>                    <span class="co">; line</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>                   <span class="co">;offset of first rectangle pixel in page</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+PageBase]        <span class="co">;offset of first rectangle pixel in</span>
                                        <span class="co">; display memory</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEG           <span class="co">;point ES:DI to the first rectangle</span>
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>                   <span class="co">; pixel&#39;s address</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX             <span class="co">;set the Sequence Controller Index to</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK             <span class="co">; point to the Map Mask register</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>                      <span class="co">;point DX to the SC Data register</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+StartX]
        <span class="kw">and</span>     <span class="kw">si</span><span class="bn">,0003h                </span><span class="co">;look up left edge plane mask</span>
        <span class="kw">mov</span>     <span class="kw">bh</span>,LeftClipPlaneMask[<span class="kw">si</span>]<span class="co">; to clip &amp; put in BH</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+EndX]
        <span class="kw">and</span>     <span class="kw">si</span><span class="bn">,0003h                </span><span class="co">;look up right edge plane</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,RightClipPlaneMask[<span class="kw">si</span>]<span class="co">; mask to clip &amp; put in BL</span>

        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+EndX]            <span class="co">;calculate # of addresses across rect</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+StartX]
        <span class="kw">cmp</span>     <span class="kw">cx</span>,<span class="kw">si</span>
        <span class="kw">jle</span>     FillDone                <span class="co">;skip if 0 or negative width</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>
        <span class="kw">and</span>     <span class="kw">si</span>,<span class="kw">not</span><span class="bn"> 011b</span>
        <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">si</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>                    <span class="co">;# of addresses across rectangle to fill - 1</span>
        <span class="kw">jnz</span>     MasksSet                <span class="co">;there&#39;s more than one byte to draw</span>
        <span class="kw">and</span>     <span class="kw">bh</span>,<span class="kw">bl</span>                   <span class="co">;there&#39;s only one byte, so combine the left-</span>
                                        <span class="co">; and right-edge clip masks</span>
<span class="fu">MasksSet:</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+EndY]
        <span class="kw">sub</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+StartY]          <span class="co">;BX = height of rectangle</span>
        <span class="kw">jle</span>     FillDone                <span class="co">;skip if 0 or negative height</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Color]  <span class="co">;color with which to fill</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,SCREEN_WIDTH         <span class="co">;stack frame isn&#39;t needed any more</span>
        <span class="kw">sub</span>     <span class="kw">bp</span>,<span class="kw">cx</span>                   <span class="co">;distance from end of one scan line to start</span>
        <span class="kw">dec</span>     <span class="kw">bp</span>                      <span class="co">; of next</span>
<span class="fu">FillRowsLoop:</span>
        <span class="kw">push</span>    <span class="kw">cx</span>                      <span class="co">;remember width in addresses - 1</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">bh</span>                   <span class="co">;put left-edge clip mask in AL</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                   <span class="co">;set the left-edge plane (clip) mask</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">ah</span>                   <span class="co">;put color in AL</span>
        <span class="kw">stosb</span>                           <span class="co">;draw the left edge</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>                      <span class="co">;count off left edge byte</span>
        <span class="kw">js</span>      FillLoopBottom          <span class="co">;that&#39;s the only byte</span>
        <span class="kw">jz</span>      DoRightEdge             <span class="co">;there are only two bytes</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,00fh                 </span><span class="co">;middle addresses are drawn 4 pixels at a pop</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                   <span class="co">;set the middle pixel mask to no clip</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">ah</span>                   <span class="co">;put color in AL</span>
        rep     <span class="kw">stosb</span>                   <span class="co">;draw the middle addresses four pixels apiece</span>
<span class="fu">DoRightEdge:</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">bl</span>                   <span class="co">;put right-edge clip mask in AL</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                   <span class="co">;set the right-edge plane (clip) mask</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">ah</span>                   <span class="co">;put color in AL</span>
        <span class="kw">stosb</span>                           <span class="co">;draw the right edge</span>
<span class="fu">FillLoopBottom:</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">bp</span>                   <span class="co">;point to the start of the next scan line of</span>
                                        <span class="co">; the rectangle</span>
        <span class="kw">pop</span>     <span class="kw">cx</span>                      <span class="co">;retrieve width in addresses - 1</span>
        <span class="kw">dec</span>     <span class="kw">si</span>                      <span class="co">;count down scan lines</span>
        <span class="kw">jnz</span>     FillRowsLoop
<span class="fu">FillDone:</span>
        <span class="kw">pop</span>     <span class="kw">di</span>                      <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>                      <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_FillRectangleX endp
        end</code></pre>
<p>Just so you can see Mode X in action, Listing 47.7 is a sample program that selects Mode X and draws a number of rectangles. Listing 47.7 links to any of the rectangle fill routines I’ve presented.</p>
<p>And now, I hope, you’re beginning to see why I’m so fond of Mode X. In the next chapter, we’ll continue with Mode X by exploring the wonders that the latches and parallel plane hardware can work on scrolls, copies, blits, and pattern fills.</p>
<p><strong>LISTING 47.7 L47-7.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Program to demonstrate mode X (320x240, 256-colors) rectangle</span>
<span class="co">   fill by drawing adjacent 20x20 rectangles in successive colors from</span>
<span class="co">   0 on up across and down the screen */</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>

<span class="dt">void</span> Set320x240Mode(<span class="dt">void</span>);
<span class="dt">void</span> FillRectangleX(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">int</span>);

<span class="dt">void</span> main() {
   <span class="dt">int</span> i,j;
   <span class="kw">union</span> REGS regset;

   Set320x240Mode();
   FillRectangleX(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">320</span>,<span class="dv">240</span>,<span class="dv">0</span>,<span class="dv">0</span>); <span class="co">/* clear the screen to black */</span>
   <span class="kw">for</span> (j = <span class="dv">1</span>; j &lt; <span class="dv">220</span>; j += <span class="dv">21</span>) {
      <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt; <span class="dv">300</span>; i += <span class="dv">21</span>) {
         FillRectangleX(i, j, i<span class="dv">+20</span>, j<span class="dv">+20</span>, <span class="dv">0</span>, ((j/<span class="dv">21</span>*<span class="dv">15</span>)+i/<span class="dv">21</span>) &amp; <span class="bn">0xFF</span>);
      }
   }
   getch();
   regset.x.ax = <span class="bn">0x0003</span>;   <span class="co">/* switch back to text mode and done */</span>
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}</code></pre>
</section>
</section>
<section id="chapter-48-mode-x-marks-the-latch" class="level2">
<h2><a href="#chapter-48-mode-x-marks-the-latch">Chapter 48 – Mode X Marks the Latch</a></h2>
<section id="the-internals-of-animations-best-video-display-mode" class="level3">
<h3><a href="#the-internals-of-animations-best-video-display-mode">The Internals of Animation’s Best Video Display Mode</a></h3>
<p>In the previous chapter, I introduced you to what I call Mode X, an undocumented 320x240 256-color mode of the VGA. Mode X is distinguished from mode 13H, the documented 320x200 256-color VGA mode, in that it supports page flipping, makes off-screen memory available, has square pixels, and, above all, lets you use the VGA’s hardware to increase performance by as much as four times. (Of course, those four times come at the cost of more complex and demanding programming, to be sure—but end users care about results, not how hard the code was to write, and Mode X delivers results in a big way.) In the previous chapter we saw how the VGA’s plane-oriented hardware can be used to speed solid fills. That’s a nice technique, but now we’re going to move up to the big guns—the VGA latches.</p>
<p>The VGA has four latches, one for each plane of display memory. Each latch stores exactly one byte, and that byte is always the last byte read from the corresponding plane of display memory, as shown in Figure 48.1. Furthermore, whenever a given address in display memory is read, all four planes’ bytes at that address are read and stored in the corresponding latches, regardless of which plane supplied the byte returned to the CPU (as determined by the Read Map register). As with so much else about the VGA, the above will make little sense to VGA neophytes, but the important point is this: By reading one display memory byte, 4 bytes—one from each plane—can be loaded into the latches at once. Any or all of those 4 bytes can then be written anywhere in display memory with a single byte-sized write, as shown in Figure 48.2.</p>
<figure>
<img src="images/48-01.jpg" alt="Figure 48.1  How the VGA latches are loaded." /><figcaption><strong>Figure 48.1</strong>  <em>How the VGA latches are loaded.</em></figcaption>
</figure>
<figure>
<img src="images/48-02.jpg" alt="Figure 48.2  Writing 4 bytes to display memory in a single operation." /><figcaption><strong>Figure 48.2</strong>  <em>Writing 4 bytes to display memory in a single operation.</em></figcaption>
</figure>
<p>The upshot is that the latches make it possible to copy data around from one part of display memory to another, 32 bits (four pixels) at a time—four times as fast as normal. (Recall from the previous chapter that in Mode X, pixels are stored one per byte, with four pixels in a row stored in successive planes at the same address, one pixel per plane.) However, any one latch can only be loaded from and written to the corresponding plane, so an individual latch can only work with every fourth pixel on the screen; the latch for plane 0 can work with pixels 0, 4, 8…, the latch for plane 1 with pixels 1, 5, 9…, and so on.</p>
<p>The latches aren’t intended for use in 256-color mode—they were designed to allow individual bits of display memory to be modified in 16-color mode—but they are nonetheless very useful in Mode X, particularly for patterned fills and screen-to-screen copies, including scrolls. Patterned filling is a good place to start, because patterns are widely used in windowing environments for desktops, window backgrounds, and scroll bars, and for textures and color dithering in drawing and game software.</p>
<p>Fast Mode X fills using patterns that are four pixels in width can be performed by drawing the pattern once to the four pixels at any one address in display memory, reading that address to load the pattern into the latches, setting the Bit Mask register to 0 to specify that all bits drawn to display memory should come from the latches, and then performing the fill pretty much as we did in the previous chapter—except that each line of the pattern must be loaded into the latches before the corresponding scan line on the screen is filled. Listings 48.1 and 48.2 together demonstrate a variety of fast Mode X four-by-four pattern fills. (The mode set function called by Listing 48.1 is from the previous chapter’s listings.)</p>
<p><strong>LISTING 48.1 L48-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Program to demonstrate Mode X (320x240, 256 colors) patterned</span>
<span class="co">   rectangle fills by filling the screen with adjacent 80x60</span>
<span class="co">   rectangles in a variety of patterns. Tested with Borland C++</span>
<span class="co">   in C compilation mode and the small model */</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>

<span class="dt">void</span> Set320x240Mode(<span class="dt">void</span>);
<span class="dt">void</span> FillPatternX(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">char</span>*);

<span class="co">/* 16 4x4 patterns */</span>
<span class="dt">static</span> <span class="dt">char</span> Patt0[]={<span class="dv">10</span>,<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">0</span>,<span class="dv">10</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt1[]={<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt2[]={<span class="dv">5</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">0</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt3[]={<span class="dv">14</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">14</span>,<span class="dv">0</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">0</span>,<span class="dv">14</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">14</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt4[]={<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">1</span>,<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">15</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt5[]={<span class="dv">12</span>,<span class="dv">12</span>,<span class="dv">12</span>,<span class="dv">12</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">12</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">12</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">12</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt6[]={<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">15</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt7[]={<span class="dv">78</span>,<span class="dv">78</span>,<span class="dv">78</span>,<span class="dv">78</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">80</span>,<span class="dv">82</span>,<span class="dv">82</span>,<span class="dv">82</span>,<span class="dv">82</span>,<span class="dv">84</span>,<span class="dv">84</span>,<span class="dv">84</span>,<span class="dv">84</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt8[]={<span class="dv">78</span>,<span class="dv">80</span>,<span class="dv">82</span>,<span class="dv">84</span>,<span class="dv">80</span>,<span class="dv">82</span>,<span class="dv">84</span>,<span class="dv">78</span>,<span class="dv">82</span>,<span class="dv">84</span>,<span class="dv">78</span>,<span class="dv">80</span>,<span class="dv">84</span>,<span class="dv">78</span>,<span class="dv">80</span>,<span class="dv">82</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt9[]={<span class="dv">78</span>,<span class="dv">80</span>,<span class="dv">82</span>,<span class="dv">84</span>,<span class="dv">78</span>,<span class="dv">80</span>,<span class="dv">82</span>,<span class="dv">84</span>,<span class="dv">78</span>,<span class="dv">80</span>,<span class="dv">82</span>,<span class="dv">84</span>,<span class="dv">78</span>,<span class="dv">80</span>,<span class="dv">82</span>,<span class="dv">84</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt10[]={<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>,<span class="dv">14</span>,<span class="dv">15</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt11[]={<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt12[]={<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">9</span>,<span class="dv">14</span>,<span class="dv">14</span>,<span class="dv">9</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt13[]={<span class="dv">15</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">8</span>,<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">8</span>,<span class="dv">15</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt14[]={<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>};
<span class="dt">static</span> <span class="dt">char</span> Patt15[]={<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">64</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">89</span>};
<span class="co">/* Table of pointers to the 16 4x4 patterns with which to draw */</span>
<span class="dt">static</span> <span class="dt">char</span>* PattTable[] = {Patt0,Patt1,Patt2,Patt3,Patt4,Patt5,Patt6,
      Patt7,Patt8,Patt9,Patt10,Patt11,Patt12,Patt13,Patt14,Patt15};
<span class="dt">void</span> main() {
   <span class="dt">int</span> i,j;
   <span class="kw">union</span> REGS regset;

   Set320x240Mode();
   <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; <span class="dv">4</span>; j++) {
      <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; i++) {
         FillPatternX(i*<span class="dv">80</span>,j*<span class="dv">60</span>,i*<span class="dv">80+80</span>,j*<span class="dv">60+60</span>,<span class="dv">0</span>,PattTable[j*<span class="dv">4</span>+i]);
      }
   }
   getch();
   regset.x.ax = <span class="bn">0x0003</span>;   <span class="co">/* switch back to text mode and done */</span>
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}</code></pre>
<p><strong>LISTING 48.2 L48-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Mode X (320x240, 256 colors) rectangle 4x4 pattern fill routine.</span>
<span class="co">; Upper-left corner of pattern is always aligned to a multiple-of-4</span>
<span class="co">; row and column. Works on all VGAs. Uses approach of copying the</span>
<span class="co">; pattern to off-screen display memory, then loading the latches with</span>
<span class="co">; the pattern for each scan line and filling each scan line four</span>
<span class="co">; pixels at a time. Fills up to but not including the column at EndX</span>
<span class="co">; and the row at EndY. No clipping is performed. All ASM code tested</span>
<span class="co">; with TASM. C near-callable as:</span>
<span class="co">;</span>
<span class="co">;    void FillPatternX(int StartX, int StartY, int EndX, int EndY,</span>
<span class="co">;       unsigned int PageBase, char* Pattern);</span>

SC_INDEX              <span class="dt">equ</span><span class="bn">    03c4h   </span><span class="co">;Sequence Controller Index register port</span>
MAP_MASK              <span class="dt">equ</span><span class="bn">    02h     </span><span class="co">;index in SC of Map Mask register</span>
GC_INDEX              <span class="dt">equ</span><span class="bn">    03ceh   </span><span class="co">;Graphics Controller Index register port</span>
BIT_MASK              <span class="dt">equ</span><span class="bn">    08h     </span><span class="co">;index in GC of Bit Mask register</span>
PATTERN_BUFFER        <span class="dt">equ</span><span class="bn">    0fffch  </span><span class="co">;offset in screen memory of the buffer used</span>
                                     <span class="co">; to store each pattern during drawing</span>
SCREEN_SEG            <span class="dt">equ</span><span class="bn">    0a000h  </span><span class="co">;segment of display memory in Mode X</span>
SCREEN_WIDTH          <span class="dt">equ</span>    <span class="dv">80</span>      <span class="co">;width of screen in addresses from one scan</span>
                                     <span class="co">; line to the next</span>
parms   <span class="kw">struc</span>
            <span class="dt">dw</span>      <span class="dv">2</span> dup (?)        <span class="co">;pushed BP and return address</span>
StartX      <span class="dt">dw</span>      ?                <span class="co">;X coordinate of upper left corner of rect</span>
StartY      <span class="dt">dw</span>      ?                <span class="co">;Y coordinate of upper left corner of rect</span>
EndX        <span class="dt">dw</span>      ?                <span class="co">;X coordinate of lower right corner of rect</span>
                                     <span class="co">; (the row at EndX is not filled)</span>
EndY        <span class="dt">dw</span>      ?                <span class="co">;Y coordinate of lower right corner of rect</span>
                                     <span class="co">; (the column at EndY is not filled)</span>

PageBase    <span class="dt">dw</span>      ?                <span class="co">;base offset in display memory of page in</span>
                                     <span class="co">; which to fill rectangle</span>
Pattern     <span class="dt">dw</span>      ?                <span class="co">;4x4 pattern with which to fill rectangle</span>
parms   ends

NextScanOffset        <span class="dt">equ</span>    -<span class="dv">2</span>      <span class="co">;local storage for distance from end of one</span>
                                     <span class="co">; scan line to start of next</span>
RectAddrWidth         <span class="dt">equ</span>    -<span class="dv">4</span>      <span class="co">;local storage for address width of rectangle</span>
Height                <span class="dt">equ</span>    -<span class="dv">6</span>      <span class="co">;local storage for height of rectangle</span>
STACK_FRAME_SIZE      <span class="dt">equ</span>     <span class="dv">6</span>

        .model  small
        .data
<span class="co">; Plane masks for clipping left and right edges of rectangle.</span>
LeftClipPlaneMask       <span class="dt">db</span><span class="bn">      00fh,</span>00eh<span class="bn">,00ch,</span>008h
RightClipPlaneMask      <span class="dt">db</span><span class="bn">      00fh,</span>001h<span class="bn">,003h,</span>007h
        .code
        public  _FillPatternX
_FillPatternX proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>                  <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>               <span class="co">;point to local stack frame</span>
        <span class="kw">sub</span>     <span class="kw">sp</span>,STACK_FRAME_SIZE <span class="co">;allocate space for local vars</span>
        <span class="kw">push</span>    <span class="kw">si</span>                  <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">cld</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEG       <span class="co">;point ES to display memory</span>
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
                                    <span class="co">;copy pattern to display memory buffer</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+Pattern]     <span class="co">;point to pattern to fill with</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,PATTERN_BUFFER   <span class="co">;point ES:DI to pattern buffer</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX         <span class="co">;point Sequence Controller Index to</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK         <span class="co">; Map Mask</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>                  <span class="co">;point to SC Data register</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">4</span>                <span class="co">;4 pixel quadruplets in pattern</span>
<span class="fu">DownloadPatternLoop:</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dv">1</span>                <span class="co">;</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>               <span class="co">;select plane 0 for writes</span>
        <span class="kw">movsb</span>                       <span class="co">;copy over next plane 0 pattern pixel</span>
        <span class="kw">dec</span>     <span class="kw">di</span>                  <span class="co">;stay at same address for next plane</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dv">2</span>                <span class="co">;</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>               <span class="co">;select plane 1 for writes</span>
        <span class="kw">movsb</span>                       <span class="co">;copy over next plane 1 pattern pixel</span>
        <span class="kw">dec</span>     <span class="kw">di</span>                  <span class="co">;stay at same address for next plane</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dv">4</span>                <span class="co">;</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>               <span class="co">;select plane 2 for writes</span>
        <span class="kw">movsb</span>                       <span class="co">;copy over next plane 2 pattern pixel</span>
        <span class="kw">dec</span>     <span class="kw">di</span>                  <span class="co">;stay at same address for next plane</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="dv">8</span>                <span class="co">;</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>               <span class="co">;select plane 3 for writes</span>
        <span class="kw">movsb</span>                       <span class="co">;copy over next plane 3 pattern pixel</span>
                                    <span class="co">; and advance address</span>
        <span class="kw">loop</span>    DownloadPatternLoop

        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX         <span class="co">;set the bit mask to select all bits</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,00000h+BIT_MASK  <span class="co">; from the latches and none from</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>               <span class="co">; the CPU, so that we can write the</span>
                                    <span class="co">; latch contents directly to memory</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+StartY]      <span class="co">;top rectangle scan line</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,<span class="kw">ax</span>
        <span class="kw">and</span>     <span class="kw">si</span><span class="bn">,011b             </span><span class="co">;top rect scan line modulo 4</span>
        <span class="kw">add</span>     <span class="kw">si</span>,PATTERN_BUFFER   <span class="co">;point to pattern scan line that</span>
                                    <span class="co">; maps to top line of rect to draw</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SCREEN_WIDTH
        <span class="kw">mul</span>     <span class="kw">dx</span>                  <span class="co">;offset in page of top rectangle scan line</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+StartX]
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">di</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>                <span class="co">;X/4 = offset of first rectangle pixel in scan</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>                <span class="co">; line</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>               <span class="co">;offset of first rectangle pixel in page</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+PageBase]    <span class="co">;offset of first rectangle pixel in</span>
                                    <span class="co">; display memory</span>
        <span class="kw">and</span>     <span class="kw">bx</span><span class="bn">,0003h                 </span><span class="co">;look up left edge plane mask</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,LeftClipPlaneMask[<span class="kw">bx</span>]  <span class="co">; to clip</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+EndX]
        <span class="kw">and</span>     <span class="kw">bx</span><span class="bn">,0003h                  </span><span class="co">;look up right edge plane</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,RightClipPlaneMask[<span class="kw">bx</span>] <span class="co">; mask to clip</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">ax</span>                     <span class="co">;put the masks in BX</span>
        
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+EndX]              <span class="co">;calculate # of addresses across rect</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+StartX]
        <span class="kw">cmp</span>     <span class="kw">cx</span>,<span class="kw">ax</span>
        <span class="kw">jle</span>     FillDone                  <span class="co">;skip if 0 or negative width</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>
        <span class="kw">and</span>     <span class="kw">ax</span>,<span class="kw">not</span><span class="bn"> 011b</span>
        <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">ax</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>                       <span class="co">;# of addresses across rectangle to fill - 1</span>
        <span class="kw">jnz</span>     MasksSet                   <span class="co">;there&#39;s more than one pixel to draw</span>
        <span class="kw">and</span>     <span class="kw">bh</span>,<span class="kw">bl</span>                      <span class="co">;there&#39;s only one pixel, so combine the left-</span>
                                           <span class="co">; and right-edge clip masks</span>
<span class="fu">MasksSet:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+EndY]
        <span class="kw">sub</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+StartY]             <span class="co">;AX = height of rectangle</span>
        <span class="kw">jle</span>     FillDone                   <span class="co">;skip if 0 or negative height</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+Height],<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_WIDTH
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">cx</span>                      <span class="co">;distance from end of one scan line to start</span>
        <span class="kw">dec</span>     <span class="kw">ax</span>                         <span class="co">; of next</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+NextScanOffset],<span class="kw">ax</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+RectAddrWidth],<span class="kw">cx</span>      <span class="co">;remember width in addresses - 1</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX<span class="dv">+1</span>              <span class="co">;point to Sequence Controller Data reg</span>
                                           <span class="co">; (SC Index still points to Map Mask)</span>
<span class="fu">FillRowsLoop:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+RectAddrWidth]      <span class="co">;width across - 1</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">es</span>:[<span class="kw">si</span>]                 <span class="co">;read display memory to latch this scan</span>
                                           <span class="co">; line&#39;s pattern</span>
        <span class="kw">inc</span>     <span class="kw">si</span>                         <span class="co">;point to the next pattern scan line, wrapping</span>
        <span class="kw">jnz</span>     <span class="dt">short</span> NoWrap               <span class="co">; back to the start of the pattern if</span>
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="dv">4</span>                       <span class="co">; we&#39;ve run off the end</span>
<span class="fu">NoWrap:</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">bh</span>                      <span class="co">;put left-edge clip mask in AL</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                      <span class="co">;set the left-edge plane (clip) mask</span>
        <span class="kw">stosb</span>                              <span class="co">;draw the left edge (pixels come from latches;</span>
                                           <span class="co">; value written by CPU doesn&#39;t matter)</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>                         <span class="co">;count off left edge address</span>
        <span class="kw">js</span>      FillLoopBottom             <span class="co">;that&#39;s the only address</span>
        <span class="kw">jz</span>      DoRightEdge                <span class="co">;there are only two addresses</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,00fh                    </span><span class="co">;middle addresses are drawn 4 pixels at a pop</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                      <span class="co">;set the middle pixel mask to no clip</span>
        rep     <span class="kw">stosb</span>                      <span class="co">;draw the middle addresses four pixels apiece</span>
                                           <span class="co">; (from latches; value written doesn&#39;t matter)</span>
<span class="fu">DoRightEdge:</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">bl</span>                      <span class="co">;put right-edge clip mask in AL</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                      <span class="co">;set the right-edge plane (clip) mask</span>
        <span class="kw">stosb</span>                              <span class="co">;draw the right edge (from latches; value</span>
                                           <span class="co">; written doesn&#39;t matter)</span>
<span class="fu">FillLoopBottom:</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+NextScanOffset]     <span class="co">;point to the start of the next scan</span>
                                           <span class="co">; line of the rectangle</span>
        <span class="kw">dec</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Height]       <span class="co">;count down scan lines</span>
        <span class="kw">jnz</span>     FillRowsLoop
<span class="fu">FillDone:</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX<span class="dv">+1</span>              <span class="co">;restore the bit mask to its default,</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ffh                    </span><span class="co">; which selects all bits from the CPU</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                      <span class="co">; and none from the latches (the GC</span>
                                           <span class="co">; Index still points to Bit Mask)</span>
        <span class="kw">pop</span>     <span class="kw">di</span>                         <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">mov</span>     <span class="kw">sp</span>,<span class="kw">bp</span>                      <span class="co">;discard storage for local variables</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>                         <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_FillPatternX endp
        end</code></pre>
<p>Four-pixel-wide patterns are more useful than you might imagine. There are actually 2128 possible patterns (16 pixels, each with 28 possible colors); that set is certainly large enough for most color-dithering purposes, and includes many often-used patterns, such as halftones, diagonal stripes, and crosshatches.</p>
<p>Furthermore, eight-wide patterns, which are widely used, can be drawn with two passes, one for each half of the pattern. This principle can in fact be extended to patterns of arbitrary multiple-of-four widths. (Widths that aren’t multiples of four are considerably more difficult to handle, because the latches are four pixels wide; one possible solution is expanding such patterns via repetition until they are multiple-of-four widths.)</p>
</section>
<section id="allocating-memory-in-mode-x" class="level3">
<h3><a href="#allocating-memory-in-mode-x">Allocating Memory in Mode X</a></h3>
<p>Listing 48.2 raises some interesting questions about the allocation of display memory in Mode X. In Listing 48.2, whenever a pattern is to be drawn, that pattern is first drawn in its entirety at the very end of display memory; the latches are then loaded from that copy of the pattern before each scan line of the actual fill is drawn. Why this double copying process, and why is the pattern stored in that particular area of display memory?</p>
<p>The double copying process is used because it’s the easiest way to load the latches. Remember, there’s no way to get information directly from the CPU to the latches; the information must first be written to some location in display memory, because the latches can be loaded <em>only</em> from display memory. By writing the pattern to off-screen memory, we don’t have to worry about interfering with whatever is currently displayed on the screen.</p>
<p>As for why the pattern is stored exactly where it is, that’s part of a master memory allocation plan that will come to fruition in the next chapter, when I implement a Mode X animation program. Figure 48.3 shows this master plan; the first two pages of memory (each 76,800 pixels long, spanning 19,200 addresses—that is, 19,200 pixel quadruplets—in display memory) are reserved for page flipping, the next page of memory (also 76,800 pixels long) is reserved for storing the background (which is used to restore the holes left after images move), the last 16 pixels (four addresses) of display memory are reserved for the pattern buffer, and the remaining 31,728 pixels (7,932 addresses) of display memory are free for storage of icons, images, temporary buffers, or whatever.</p>
<figure>
<img src="images/48-03.jpg" alt="Figure 48.3  A useful Mode X display memory layout." /><figcaption><strong>Figure 48.3</strong>  <em>A useful Mode X display memory layout.</em></figcaption>
</figure>
<p>This is an efficient organization for animation, but there are certainly many other possible setups. For example, you might choose to have a solid-colored background, in which case you could dispense with the background page (instead using the solid rectangle fill routine to replace the background after images move), freeing up another 76,800 pixels of off-screen storage for images and buffers. You could even eliminate page-flipping altogether if you needed to free up a great deal of display memory. For example, with enough free display memory it is possible in Mode X to create a virtual bitmap three times larger than the screen, with the screen becoming a scrolling window onto that larger bitmap. This technique has been used to good effect in a number of animated games, with and without the use of Mode X.</p>
</section>
<section id="copying-pixel-blocks-within-display-memory" class="level3">
<h3><a href="#copying-pixel-blocks-within-display-memory">Copying Pixel Blocks within Display Memory</a></h3>
<p>Another fine use for the latches is copying pixels from one place in display memory to another. Whenever both the source and the destination share the same nibble alignment (that is, their start addresses modulo four are the same), it is not only possible but quite easy to use the latches to copy four pixels at a time. Listing 48.3 shows a routine that copies via the latches. (When the source and destination do not share the same nibble alignment, the latches cannot be used because the source and destination planes for any given pixel differ. In that case, you can set the Read Map register to select a source plane and the Map Mask register to select the corresponding destination plane. Then, copy all pixels in that plane, repeating for all four planes.)</p>
<blockquote>
<p><img src="images/i.jpg" /> Although copying through the latches is, in general, a speedy technique, especially on slower VGAs, it’s not always a win. Reading video memory tends to be quite a bit slower than writing, and on a fast VLB or PCI adapter, it can be faster to copy from main memory to display memory than it is to copy from display memory to display memory via the latches.</p>
</blockquote>
<p><strong>LISTING 48.3 L48-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Mode X (320x240, 256 colors) display memory to display memory copy</span>
<span class="co">; routine. Left edge of source rectangle modulo 4 must equal left edge</span>
<span class="co">; of destination rectangle modulo 4. Works on all VGAs. Uses approach</span>
<span class="co">; of reading 4 pixels at a time from the source into the latches, then</span>
<span class="co">; writing the latches to the destination. Copies up to but not</span>
<span class="co">; including the column at SourceEndX and the row at SourceEndY. No</span>
<span class="co">; clipping is performed. Results are not guaranteed if the source and</span>
<span class="co">; destination overlap. C near-callable as:</span>
<span class="co">;</span>
<span class="co">;    void CopyScreenToScreenX(int SourceStartX, int SourceStartY,</span>
<span class="co">;       int SourceEndX, int SourceEndY, int DestStartX,</span>
<span class="co">;       int DestStartY, unsigned int SourcePageBase,</span>
<span class="co">;       unsigned int DestPageBase, int SourceBitmapWidth,</span>
<span class="co">;       int DestBitmapWidth);</span>

SC_INDEX     <span class="dt">equ</span><span class="bn">    03c4h   </span><span class="co">;Sequence Controller Index register port</span>
MAP_MASK     <span class="dt">equ</span><span class="bn">    02h     </span><span class="co">;index in SC of Map Mask register</span>
GC_INDEX     <span class="dt">equ</span><span class="bn">    03ceh   </span><span class="co">;Graphics Controller Index register port</span>
BIT_MASK     <span class="dt">equ</span><span class="bn">    08h     </span><span class="co">;index in GC of Bit Mask register</span>
SCREEN_SEG   <span class="dt">equ</span><span class="bn">    0a000h  </span><span class="co">;segment of display memory in Mode X</span>

parms   <span class="kw">struc</span>
              <span class="dt">dw</span>  <span class="dv">2</span> dup (?) <span class="co">;pushed BP and return address</span>
SourceStartX  <span class="dt">dw</span>  ?         <span class="co">;X coordinate of upper-left corner of source</span>
SourceStartY  <span class="dt">dw</span>  ?         <span class="co">;Y coordinate of upper-left corner of source</span>
SourceEndX    <span class="dt">dw</span>  ?         <span class="co">;X coordinate of lower-right corner of source</span>
                            <span class="co">; (the row at SourceEndX is not copied)</span>
SourceEndY    <span class="dt">dw</span>  ?         <span class="co">;Y coordinate of lower-right corner of source</span>
                            <span class="co">; (the column at SourceEndY is not copied)</span>
DestStartX    <span class="dt">dw</span>  ?         <span class="co">;X coordinate of upper-left corner of dest</span>
DestStartY    <span class="dt">dw</span>  ?         <span class="co">;Y coordinate of upper-left corner of dest</span>
SourcePageBase <span class="dt">dw</span> ?         <span class="co">;base offset in display memory of page in</span>
                            <span class="co">; which source resides</span>
DestPageBase  <span class="dt">dw</span>  ?         <span class="co">;base offset in display memory of page in</span>
                            <span class="co">; which dest resides</span>
SourceBitmapWidth  <span class="dt">dw</span>   ?   <span class="co">;# of pixels across source bitmap</span>
                            <span class="co">; (must be a multiple of 4)</span>
DestBitmapWidth    <span class="dt">dw</span>   ?   <span class="co">;# of pixels across dest bitmap</span>
                            <span class="co">; (must be a multiple of 4)</span>
parms   ends

SourceNextScanOffset <span class="dt">equ</span> -<span class="dv">2</span> <span class="co">;local storage for distance from end of</span>
                            <span class="co">; one source scan line to start of next</span>
DestNextScanOffset   <span class="dt">equ</span> -<span class="dv">4</span> <span class="co">;local storage for distance from end of</span>
                            <span class="co">; one dest scan line to start of next</span>
RectAddrWidth     <span class="dt">equ</span> -<span class="dv">6</span>    <span class="co">;local storage for address width of rectangle</span>
Height       <span class="dt">equ</span> -<span class="dv">8</span><span class="co">;local storage for height of rectangle</span>
STACK_FRAME_SIZE     <span class="dt">equ</span>  <span class="dv">8</span>

        .model  small
        .data
<span class="co">; Plane masks for clipping left and right edges of rectangle.</span>
LeftClipPlaneMask       <span class="dt">db</span><span class="bn">      00fh,</span>00eh<span class="bn">,00ch,</span>008h
RightClipPlaneMask      <span class="dt">db</span><span class="bn">      00fh,</span>001h<span class="bn">,003h,</span>007h
        .code
        public  _CopyScreenToScreenX
_CopyScreenToScreenX proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>      <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>   <span class="co">;point to local stack frame</span>
        <span class="kw">sub</span>     <span class="kw">sp</span>,STACK_FRAME_SIZE <span class="co">;allocate space for local vars</span>
        <span class="kw">push</span>    <span class="kw">si</span>      <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">push</span>    <span class="kw">ds</span>

        <span class="kw">cld</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX        <span class="co">;set the bit mask to select all bits</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,00000h+BIT_MASK <span class="co">; from the latches and none from</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>              <span class="co">; the CPU, so that we can write the</span>
                                   <span class="co">; latch contents directly to memory</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEG      <span class="co">;point ES to display memory</span>
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+DestBitmapWidth]
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>               <span class="co">;convert to width in addresses</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">mul</span>     [<span class="kw">bp</span>+DestStartY]    <span class="co">;top dest rect scan line</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+DestStartX]
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>               <span class="co">;X/4 = offset of first dest rect pixel in</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>               <span class="co">; scan line</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>              <span class="co">;offset of first dest rect pixel in page</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+DestPageBase] <span class="co">;offset of first dest rect pixel</span>
                                   <span class="co">; in display memory</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceBitmapWidth]
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>               <span class="co">;convert to width in addresses</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">mul</span>     [<span class="kw">bp</span>+SourceStartY]  <span class="co">;top source rect scan line</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+SourceStartX]
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">si</span>
        <span class="kw">shr</span>     <span class="kw">si</span>,<span class="dv">1</span>               <span class="co">;X/4 = offset of first source rect pixel in</span>
        <span class="kw">shr</span>     <span class="kw">si</span>,<span class="dv">1</span>               <span class="co">; scan line</span>
        <span class="kw">add</span>     <span class="kw">si</span>,<span class="kw">ax</span>              <span class="co">;offset of first source rect pixel in page</span>
        <span class="kw">add</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+SourcePageBase] <span class="co">;offset of first source rect</span>
                                   <span class="co">; pixel in display memory</span>
        <span class="kw">and</span>     <span class="kw">bx</span><span class="bn">,0003h           </span><span class="co">;look up left edge plane mask</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,LeftClipPlaneMask[<span class="kw">bx</span>]  <span class="co">; to clip</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+SourceEndX]
        <span class="kw">and</span>     <span class="kw">bx</span><span class="bn">,0003h           </span><span class="co">;look up right-edge plane</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,RightClipPlaneMask[<span class="kw">bx</span>] <span class="co">; mask to clip</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">ax</span>              <span class="co">;put the masks in BX</span>
        
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+SourceEndX] <span class="co">;calculate # of addresses across</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceStartX] <span class="co">; rect</span>
        <span class="kw">cmp</span>     <span class="kw">cx</span>,<span class="kw">ax</span>
        <span class="kw">jle</span>     CopyDone           <span class="co">;skip if 0 or negative width</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>
        <span class="kw">and</span>     <span class="kw">ax</span>,<span class="kw">not</span><span class="bn"> 011b</span>
        <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">ax</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>               <span class="co">;# of addresses across rectangle to copy - 1</span>
        <span class="kw">jnz</span>     MasksSet           <span class="co">;there&#39;s more than one address to draw</span>
        <span class="kw">and</span>     <span class="kw">bh</span>,<span class="kw">bl</span>              <span class="co">;there&#39;s only one address, so combine the </span>
                                   <span class="co">; left- and right-edge clip masks</span>
<span class="fu">MasksSet:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceEndY]
        <span class="kw">sub</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceStartY]  <span class="co">;AX = height of rectangle</span>
        <span class="kw">jle</span>     CopyDone           <span class="co">;skip if 0 or negative height</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+Height],<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+DestBitmapWidth]
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>               <span class="co">;convert to width in addresses</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">cx</span>              <span class="co">;distance from end of one dest scan line to</span>
        <span class="kw">dec</span>     <span class="kw">ax</span>                 <span class="co">; start of next</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+DestNextScanOffset],<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceBitmapWidth]
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>               <span class="co">;convert to width in addresses</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">cx</span>              <span class="co">;distance from end of one source scan line to</span>
        <span class="kw">dec</span>     <span class="kw">ax</span>                 <span class="co">; start of next</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+SourceNextScanOffset],<span class="kw">ax</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+RectAddrWidth],<span class="kw">cx</span> <span class="co">;remember width in addresses - 1</span>
<span class="co">;----------------------BUG FIX</span>
<span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>              <span class="co">;point SC Index reg to Map Mask</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>                 <span class="co">;point to SC Data reg</span>
<span class="co">;----------------------BUG FIX</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">es</span>              <span class="co">;DS=ES=screen segment for MOVS</span>
        <span class="kw">mov</span>     <span class="kw">ds</span>,<span class="kw">ax</span>
<span class="fu">CopyRowsLoop:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+RectAddrWidth] <span class="co">;width across - 1</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">bh</span>              <span class="co">;put left-edge clip mask in AL</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>              <span class="co">;set the left-edge plane (clip) mask</span>
        <span class="kw">movsb</span>                      <span class="co">;copy the left edge (pixels go through</span>
                                   <span class="co">; latches)</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>                 <span class="co">;count off left edge address</span>
        <span class="kw">js</span>      CopyLoopBottom     <span class="co">;that&#39;s the only address</span>
        <span class="kw">jz</span>      DoRightEdge        <span class="co">;there are only two addresses</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,00fh            </span><span class="co">;middle addresses are drawn 4 pixels at a pop</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>              <span class="co">;set the middle pixel mask to no clip</span>
        rep     <span class="kw">movsb</span>              <span class="co">;draw the middle addresses four pixels apiece</span>
                                   <span class="co">; (pixels copied through latches)</span>
<span class="fu">DoRightEdge:</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">bl</span>              <span class="co">;put right-edge clip mask in AL</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>              <span class="co">;set the right-edge plane (clip) mask</span>
        <span class="kw">movsb</span>                      <span class="co">;draw the right edge (pixels copied through</span>
                                   <span class="co">; latches)</span>
<span class="fu">CopyLoopBottom:</span>
        <span class="kw">add</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+SourceNextScanOffset] <span class="co">;point to the start of</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+DestNextScanOffset]   <span class="co">; next source &amp; dest lines</span>
        <span class="kw">dec</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Height]         <span class="co">;count down scan lines</span>
        <span class="kw">jnz</span>     CopyRowsLoop
<span class="fu">CopyDone:</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX<span class="dv">+1</span>       <span class="co">;restore the bit mask to its default,</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ffh             </span><span class="co">; which selects all bits from the CPU</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>               <span class="co">; and none from the latches (the GC</span>
                                    <span class="co">; Index still points to Bit Mask)</span>
        <span class="kw">pop</span>     <span class="kw">ds</span>
        <span class="kw">pop</span>     <span class="kw">di</span>                  <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">mov</span>     <span class="kw">sp</span>,<span class="kw">bp</span>               <span class="co">;discard storage for local variables</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>                  <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_CopyScreenToScreenX endp
        end</code></pre>
<p>Listing 48.3 has an important limitation: It does not guarantee proper handling when the source and destination overlap, as in the case of a downward scroll, for example. Listing 48.3 performs top-to-bottom, left-to-right copying. Downward scrolls require bottom-to-top copying; likewise, rightward horizontal scrolls require right-to-left copying. As it happens, my intended use for Listing 48.3 is to copy images between off-screen memory and on-screen memory, and to save areas under pop-up menus and the like, so I don’t really need overlap handling—and I do really need to keep the complexity of this discussion down. However, you will surely want to add overlap handling if you plan to perform arbitrary scrolling and copying in display memory.</p>
<p>Now that we have a fast way to copy images around in display memory, we can draw icons and other images as much as four times faster than in mode 13H, depending on the speed of the VGA’s display memory. (In case you’re worried about the nibble-alignment limitation on fast copies, don’t be; I’ll address that fully in due time, but the secret is to store all four possible rotations in off-screen memory, then select the correct one for each copy.) However, before our fast display memory-to-display memory copy routine can do us any good, we must have a way to get pixel patterns from system memory into display memory, so that they can then be copied with the fast copy routine.</p>
<section id="copying-to-display-memory" class="level4">
<h4><a href="#copying-to-display-memory">Copying to Display Memory</a></h4>
<p>The final piece of the puzzle is the system memory to display-memory-copy-routine shown in Listing 48.4. This routine assumes that pixels are stored in system memory in exactly the order in which they will ultimately appear on the screen; that is, in the same linear order that mode 13H uses. It would be more efficient to store all the pixels for one plane first, then all the pixels for the next plane, and so on for all four planes, because many <code>OUT</code>s could be avoided, but that would make images rather hard to create. And, while it is true that the speed of drawing images is, in general, often a critical performance factor, the speed of copying images from system memory to display memory is not particularly critical in Mode X. Important images can be stored in off-screen memory and copied to the screen via the latches much faster than even the speediest system memory-to-display memory copy routine could manage.</p>
<p>I’m not going to present a routine to perform Mode X copies from display memory to system memory, but such a routine would be a straightforward inverse of Listing 48.4.</p>
<p><strong>LISTING 48.4 L48-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Mode X (320x240, 256 colors) system memory to display memory copy</span>
<span class="co">; routine. Uses approach of changing the plane for each pixel copied;</span>
<span class="co">; this is slower than copying all pixels in one plane, then all pixels</span>
<span class="co">; in the next plane, and so on, but it is simpler; besides, images for</span>
<span class="co">; which performance is critical should be stored in off-screen memory</span>
<span class="co">; and copied to the screen via the latches. Copies up to but not</span>
<span class="co">; including the column at SourceEndX and the row at SourceEndY. No</span>
<span class="co">; clipping is performed. C near-callable as:</span>
<span class="co">;</span>
<span class="co">;    void CopySystemToScreenX(int SourceStartX, int SourceStartY,</span>
<span class="co">;       int SourceEndX, int SourceEndY, int DestStartX,</span>
<span class="co">;       int DestStartY, char* SourcePtr, unsigned int DestPageBase,</span>
<span class="co">;       int SourceBitmapWidth, int DestBitmapWidth);</span>

SC_INDEX        <span class="dt">equ</span><span class="bn">    03c4h           </span><span class="co">;Sequence Controller Index register port</span>
MAP_MASK        <span class="dt">equ</span><span class="bn">    02h             </span><span class="co">;index in SC of Map Mask register</span>
SCREEN_SEG      <span class="dt">equ</span><span class="bn">    0a000h          </span><span class="co">;segment of display memory in Mode X</span>

parms   <span class="kw">struc</span>
                    <span class="dt">dw</span>    <span class="dv">2</span> dup (?)    <span class="co">;pushed BP and return address</span>
SourceStartX        <span class="dt">dw</span>    ?            <span class="co">;X coordinate of upper-left corner of source</span>
SourceStartY        <span class="dt">dw</span>    ?            <span class="co">;Y coordinate of upper-left corner of source</span>
SourceEndX          <span class="dt">dw</span>    ?            <span class="co">;X coordinate of lower-right corner of source</span>
                                       <span class="co">; (the row at EndX is not copied)</span>
SourceEndY          <span class="dt">dw</span>    ?            <span class="co">;Y coordinate of lower-right corner of source</span>
                                       <span class="co">; (the column at EndY is not copied)</span>
DestStartX          <span class="dt">dw</span>    ?            <span class="co">;X coordinate of upper-left corner of dest</span>
DestStartY          <span class="dt">dw</span>    ?            <span class="co">;Y coordinate of upper-left corner of dest</span>
SourcePtr           <span class="dt">dw</span>    ?            <span class="co">;pointer in DS to start of bitmap in which</span>
                                       <span class="co">; source resides</span>
DestPageBase        <span class="dt">dw</span>    ?            <span class="co">;base offset in display memory of page in</span>
                                       <span class="co">; which dest resides</span>
SourceBitmapWidth    <span class="dt">dw</span>    ?           <span class="co">;# of pixels across source bitmap</span>
DestBitmapWidth      <span class="dt">dw</span>    ?           <span class="co">;# of pixels across dest bitmap</span>
                                       <span class="co">; (must be a multiple of 4)</span>
parms   ends

RectWidth            <span class="dt">equ</span>    -<span class="dv">2</span>         <span class="co">;local storage for width of rectangle</span>
LeftMask             <span class="dt">equ</span>    -<span class="dv">4</span>         <span class="co">;local storage for left rect edge plane mask</span>
STACK_FRAME_SIZE     <span class="dt">equ</span>    <span class="dv">4</span>

        .model  small
        .code
        public  _CopySystemToScreenX
_CopySystemToScreenX proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>                     <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>                  <span class="co">;point to local stack frame</span>
        <span class="kw">sub</span>     <span class="kw">sp</span>,STACK_FRAME_SIZE    <span class="co">;allocate space for local vars</span>
        <span class="kw">push</span>    <span class="kw">si</span>                     <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">cld</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEG          <span class="co">;point ES to display memory</span>
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceBitmapWidth]
        <span class="kw">mul</span>     [<span class="kw">bp</span>+SourceStartY]      <span class="co">;top source rect scan line</span>
        <span class="kw">add</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceStartX]
        <span class="kw">add</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourcePtr]      <span class="co">;offset of first source rect pixel</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,<span class="kw">ax</span>                  <span class="co">; in DS</span>
        
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+DestBitmapWidth]
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>                   <span class="co">;convert to width in addresses</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+DestBitmapWidth],<span class="kw">ax</span> <span class="co">;remember address width</span>
        <span class="kw">mul</span>     [<span class="kw">bp</span>+DestStartY]         <span class="co">;top dest rect scan line</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+DestStartX]
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">di</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>                    <span class="co">;X/4 = offset of first dest rect pixel in</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>                    <span class="co">; scan line</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>                   <span class="co">;offset of first dest rect pixel in page</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+DestPageBase]    <span class="co">;offset of first dest rect pixel</span>
                                        <span class="co">; in display memory</span>
        <span class="kw">and</span>     <span class="kw">cl</span><span class="bn">,011b                 </span><span class="co">;CL = first dest pixel&#39;s plane</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,11h                  </span><span class="co">;upper nibble comes into play when </span>
                                        <span class="co">; plane wraps from 3 back to 0</span>
        <span class="kw">shl</span>     <span class="kw">al</span>,<span class="kw">cl</span>                   <span class="co">;set the bit for the first dest pixel&#39;s </span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+LeftMask],<span class="kw">al</span>        <span class="co">; plane in each nibble to 1</span>

        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+SourceEndX]      <span class="co">;calculate # of pixels across</span>
        <span class="kw">sub</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+SourceStartX]    <span class="co">; rect</span>
        <span class="kw">jle</span>     CopyDone                <span class="co">;skip if 0 or negative width</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+RectWidth],<span class="kw">cx</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+SourceEndY]
        <span class="kw">sub</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+SourceStartY]    <span class="co">;BX = height of rectangle</span>
        <span class="kw">jle</span>     CopyDone                <span class="co">;skip if 0 or negative height</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX             <span class="co">;point to SC Index register</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                   <span class="co">;point SC Index reg to the Map Mask</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>                      <span class="co">;point DX to SC Data reg</span>
<span class="fu">CopyRowsLoop:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+LeftMask]
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+RectWidth]
        <span class="kw">push</span>    <span class="kw">si</span>                      <span class="co">;remember the start offset in the source</span>
        <span class="kw">push</span>    <span class="kw">di</span>                      <span class="co">;remember the start offset in the dest</span>
<span class="fu">CopyScanLineLoop:</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                   <span class="co">;set the plane for this pixel</span>
        <span class="kw">movsb</span>                           <span class="co">;copy the pixel to the screen</span>
        <span class="kw">rol</span>     <span class="kw">al</span>,<span class="dv">1</span>                    <span class="co">;set mask for next pixel&#39;s plane</span>
        <span class="kw">cmc</span>                             <span class="co">;advance destination address only when</span>
        <span class="kw">sbb</span>     <span class="kw">di</span>,<span class="dv">0</span>                    <span class="co">; wrapping from plane 3 to plane 0</span>
                                        <span class="co">; (else undo INC DI done by MOVSB)</span>
        <span class="kw">loop</span>    CopyScanLineLoop
        <span class="kw">pop</span>     <span class="kw">di</span>                      <span class="co">;retrieve the dest start offset</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+DestBitmapWidth] <span class="co">;point to the start of the</span>
                                        <span class="co">; next scan line of the dest</span>
        <span class="kw">pop</span>     <span class="kw">si</span>                      <span class="co">;retrieve the source start offset</span>
        <span class="kw">add</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+SourceBitmapWidth] <span class="co">;point to the start of the</span>
                                        <span class="co">; next scan line of the source</span>
        <span class="kw">dec</span>     <span class="kw">bx</span>                      <span class="co">;count down scan lines</span>
        <span class="kw">jnz</span>     CopyRowsLoop
<span class="fu">CopyDone:</span>
        <span class="kw">pop</span>     <span class="kw">di</span>                      <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">mov</span>     <span class="kw">sp</span>,<span class="kw">bp</span>                   <span class="co">;discard storage for local variables</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>                      <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_CopySystemToScreenX endp
        end</code></pre>
</section>
</section>
<section id="who-was-that-masked-image-copier" class="level3">
<h3><a href="#who-was-that-masked-image-copier">Who Was that Masked Image Copier?</a></h3>
<p>At this point, it’s getting to be time for us to take all the Mode X tools we’ve developed, together with one more tool—masked image copying—and the remaining unexplored feature of Mode X, page flipping, and build an animation application. I hope that when we’re done, you’ll agree with me that Mode X is <em>the</em> way to animate on the PC.</p>
<p>In truth, though, it matters less whether or not <em>you</em> think that Mode X is the best way to animate than whether or not your users think it’s the best way based on results; end users care only about results, not how you produced them. For my writing, you folks are the end users—and notice how remarkably little you care about how this book gets written and produced. You care that it turned up in the bookstore, and you care about the contents, but you sure as heck don’t care about how it got that far from a bin of tree pulp. When you’re a creator, the process matters. When you’re a buyer, results are everything. All important. <em>Sine qua non.</em> The whole enchilada.</p>
<p>If you catch my drift.</p>
</section>
</section>
<section id="chapter-49-mode-x-256-color-animation" class="level2">
<h2><a href="#chapter-49-mode-x-256-color-animation">Chapter 49 – Mode X 256-Color Animation</a></h2>
<section id="how-to-make-the-vga-really-get-up-and-dance" class="level3">
<h3><a href="#how-to-make-the-vga-really-get-up-and-dance">How to Make the VGA Really Get up and Dance</a></h3>
<p>Okay—no amusing stories or informative anecdotes to kick off this chapter; lotta ground to cover, gotta hurry—you’re impatient, I can smell it. I won’t talk about the time a friend made the mistake of loudly saying “$100 bill” during an animated discussion while walking among the bums on Market Street in San Francisco one night, thereby graphically illustrating that context is everything. I can’t spare a word about how my daughter thinks my 11-year-old floppy-disk-based CP/M machine is more powerful than my 386 with its 100-MB hard disk because the CP/M machine’s word processor loads and runs twice as fast as the 386’s Windows-based word processor, demonstrating that progress is not the neat exponential curve we’d like to think it is, and that features and performance are often conflicting notions. And, lord knows, I can’t take the time to discuss the habits of small white dogs, notwithstanding that such dogs seem to be relevant to just about every aspect of computing, as Jeff Duntemann’s writings make manifest. No lighthearted fluff for us; we have real work to do, for today we animate with 256 colors in Mode X.</p>
</section>
<section id="masked-copying" class="level3">
<h3><a href="#masked-copying">Masked Copying</a></h3>
<p>Over the past two chapters, we’ve put together most of the tools needed to implement animation in the VGA’s undocumented 320x240 256-color Mode X. We now have mode set code, solid and 4x4 pattern fills, system memory-to-display memory block copies, and display memory-to-display memory block copies. The final piece of the puzzle is the ability to copy a nonrectangular image to display memory. I call this <em>masked copying</em>.</p>
<p>Masked copying is sort of like drawing through a stencil, in that only certain pixels within the destination rectangle are drawn. The objective is to fit the image seamlessly into the background, without the rectangular fringe that results when nonrectangular images are drawn by block copying their bounding rectangle. This is accomplished by using a second rectangular bitmap, separate from the image but corresponding to it on a pixel-by-pixel basis, to control which destination pixels are set from the source and which are left unchanged. With a masked copy, only those pixels properly belonging to an image are drawn, and the image fits perfectly into the background, with no rectangular border. In fact, masked copying even makes it possible to have transparent areas within images.</p>
<p>Note that another way to achieve this effect is to implement copying code that supports a transparent color; that is, a color that doesn’t get copied but rather leaves the destination unchanged. Transparent copying makes for more compact images, because no separate mask is needed, and is generally faster in a software-only implementation. However, Mode X supports masked copying but not transparent copying in hardware, so we’ll use masked copying in this chapter.</p>
<p>The system memory to display memory masked copy routine in Listing 49.1 implements masked copying in a straightforward fashion. In the main drawing loop, the corresponding mask byte is consulted as each image pixel is encountered, and the image pixel is copied only if the mask byte is nonzero. As with most of the system-to-display code I’ve presented, Listing 49.1 is not heavily optimized, because it’s inherently slow; there’s a better way to go when performance matters, and that’s to use the VGA’s hardware.</p>
<p><strong>LISTING 49.1 L49-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Mode X (320x240, 256 colors) system memory-to-display memory masked copy</span>
<span class="co">; routine. Not particularly fast; images for which performance is critical</span>
<span class="co">; should be stored in off-screen memory and copied to screen via latches. Works</span>
<span class="co">; on all VGAs. Copies up to but not including column at SourceEndX and row at</span>
<span class="co">; SourceEndY. No clipping is performed. Mask and source image are both byte-</span>
<span class="co">; per-pixel, and must be of same widths and reside at same coordinates in their</span>
<span class="co">; respective bitmaps. Assembly code tested with TASM C near-callable as:</span>
<span class="co">;</span>
<span class="co">;    void CopySystemToScreenMaskedX(int SourceStartX,</span>
<span class="co">;       int SourceStartY, int SourceEndX, int SourceEndY,</span>
<span class="co">;       int DestStartX, int DestStartY, char * SourcePtr,</span>
<span class="co">;       unsigned int DestPageBase, int SourceBitmapWidth,</span>
<span class="co">;       int DestBitmapWidth, char * MaskPtr);</span>

SC_INDEX <span class="dt">equ</span><span class="bn">    03c4h   </span><span class="co">;Sequence Controller Index register port</span>
MAP_MASK <span class="dt">equ</span><span class="bn">    02h     </span><span class="co">;index in SC of Map Mask register</span>
SCREEN_SEG <span class="dt">equ</span><span class="bn">  0a000h  </span><span class="co">;segment of display memory in mode X</span>

parms   <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup (?) <span class="co">;pushed BP and return address</span>
SourceStartX <span class="dt">dw</span> ?         <span class="co">;X coordinate of upper left corner of source</span>
                          <span class="co">; (source is in system memory)</span>
SourceStartY <span class="dt">dw</span> ?         <span class="co">;Y coordinate of upper left corner of source</span>
SourceEndX   <span class="dt">dw</span> ?         <span class="co">;X coordinate of lower right corner of source</span>
                          <span class="co">; (the column at EndX is not copied)</span>
SourceEndY   <span class="dt">dw</span> ?         <span class="co">;Y coordinate of lower right corner of source</span>
                          <span class="co">; (the row at EndY is not copied)</span>
DestStartX   <span class="dt">dw</span> ?         <span class="co">;X coordinate of upper left corner of dest</span>
                          <span class="co">; (destination is in display memory)</span>
DestStartY   <span class="dt">dw</span> ?         <span class="co">;Y coordinate of upper left corner of dest</span>
SourcePtr    <span class="dt">dw</span> ?         <span class="co">;pointer in DS to start of bitmap which source resides</span>
DestPageBase <span class="dt">dw</span> ?         <span class="co">;base offset in display memory of page in</span>
                          <span class="co">; which dest resides</span>
SourceBitmapWidth   <span class="dt">dw</span> ?  <span class="co">;# of pixels across source bitmap (also must</span>
                          <span class="co">; be width across the mask)</span>
DestBitmapWidth     <span class="dt">dw</span> ?  <span class="co">;# of pixels across dest bitmap (must be multiple of 4)</span>
MaskPtr             <span class="dt">dw</span> ?  <span class="co">;pointer in DS to start of bitmap in which mask</span>
                          <span class="co">; resides (byte-per-pixel format, just like the source</span>
                          <span class="co">; image; 0-bytes mean don&#39;t copy corresponding source</span>
                          <span class="co">; pixel, 1-bytes mean do copy)</span>
parms   ends

RectWidth <span class="dt">equ</span>   -<span class="dv">2</span>      <span class="co">;local storage for width of rectangle</span>
RectHeight <span class="dt">equ</span>  -<span class="dv">4</span>      <span class="co">;local storage for height of rectangle</span>
LeftMask <span class="dt">equ</span>    -<span class="dv">6</span>      <span class="co">;local storage for left rect edge plane mask</span>
STACK_FRAME_SIZE <span class="dt">equ</span> <span class="dv">6</span>
        .model  small
        .code
        public  _CopySystemToScreenMaskedX
_CopySystemToScreenMaskedX proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>                       <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>                    <span class="co">;point to local stack frame</span>
        <span class="kw">sub</span>     <span class="kw">sp</span>,STACK_FRAME_SIZE      <span class="co">;allocate space for local vars</span>
        <span class="kw">push</span>    <span class="kw">si</span>                       <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEG            <span class="co">;point ES to display memory</span>
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceBitmapWidth]
        <span class="kw">mul</span>     [<span class="kw">bp</span>+SourceStartY]    <span class="co">;top source rect scan line</span>
        <span class="kw">add</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceStartX]
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">ax</span>
        <span class="kw">add</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourcePtr]    <span class="co">;offset of first source rect pixel</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,<span class="kw">ax</span>                    <span class="co">; in DS</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+MaskPtr]      <span class="co">;offset of first mask pixel in DS</span>

        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+DestBitmapWidth]
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>                     <span class="co">;convert to width in addresses</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+DestBitmapWidth],<span class="kw">ax</span> <span class="co">;remember address width</span>
        <span class="kw">mul</span>     [<span class="kw">bp</span>+DestStartY]         <span class="co">;top dest rect scan line</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+DestStartX]
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">di</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>                        <span class="co">;X/4 = offset of first dest rect pixel in</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>                        <span class="co">; scan line</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>                       <span class="co">;offset of first dest rect pixel in page</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+DestPageBase]    <span class="co">;offset of first dest rect pixel</span>
                                            <span class="co">; in display memory</span>
        <span class="kw">and</span>     <span class="kw">cl</span><span class="bn">,011b                        </span><span class="co">;CL = first dest pixel&#39;s plane</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,11h                      </span><span class="co">;upper nibble comes into play when plane wraps</span>
                                            <span class="co">; from 3 back to 0</span>
        <span class="kw">shl</span>     <span class="kw">al</span>,<span class="kw">cl</span>                       <span class="co">;set the bit for the first dest pixel&#39;s plane</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+LeftMask],<span class="kw">al</span>        <span class="co">; in each nibble to 1</span>

        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceEndX]      <span class="co">;calculate # of pixels across</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceStartX]    <span class="co">; rect</span>
        <span class="kw">jle</span>     CopyDone                    <span class="co">;skip if 0 or negative width</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+RectWidth],<span class="kw">ax</span>
        <span class="kw">sub</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+SourceBitmapWidth],<span class="kw">ax</span>
                                            <span class="co">;distance from end of one source scan line</span>
                                            to start of next
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceEndY]
        <span class="kw">sub</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceStartY]    <span class="co">;height of rectangle</span>
        <span class="kw">jle</span>     CopyDone                    <span class="co">;skip if 0 or negative height</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+RectHeight],<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX                 <span class="co">;point to SC Index register</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                      <span class="co">;point SC Index reg to the Map Mask</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>                         <span class="co">;point DX to SC Data reg</span>
<span class="fu">CopyRowsLoop:</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,[<span class="kw">bp</span>+LeftMask]
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+RectWidth]
        <span class="kw">push</span>    <span class="kw">di</span>                         <span class="co">;remember the start offset in the dest</span>
<span class="fu">CopyScanLineLoop:</span>
        <span class="kw">cmp</span>     <span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bx</span>],<span class="dv">0</span>            <span class="co">;is this pixel mask-enabled?</span>
        <span class="kw">jz</span>      MaskOff                    <span class="co">;no, so don&#39;t draw it</span>
                                           <span class="co">;yes, draw the pixel</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>                      <span class="co">;set the plane for this pixel</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,[<span class="kw">si</span>]                    <span class="co">;get the pixel from the source</span>
        <span class="kw">mov</span>     <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">ah</span>                 <span class="co">;copy the pixel to the screen</span>
<span class="fu">MaskOff:</span>
        <span class="kw">inc</span>     <span class="kw">bx</span>                         <span class="co">;advance the mask pointer</span>
        <span class="kw">inc</span>     <span class="kw">si</span>                         <span class="co">;advance the source pointer</span>
        <span class="kw">rol</span>     <span class="kw">al</span>,<span class="dv">1</span>                       <span class="co">;set mask for next pixel&#39;s plane</span>
        <span class="kw">adc</span>     <span class="kw">di</span>,<span class="dv">0</span>                       <span class="co">;advance destination address only when</span>
                                           <span class="co">;wrapping from plane 3 to plane 0</span>
        <span class="kw">loop</span>    CopyScanLineLoop
        <span class="kw">pop</span>     <span class="kw">di</span>                         <span class="co">;retrieve the dest start offset</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+DestBitmapWidth]<span class="co">;point to the start of the</span>
                                           <span class="co">; next scan line of the dest</span>
        <span class="kw">add</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+SourceBitmapWidth] <span class="co">;point to the start of the</span>
                                           <span class="co">;next scan line of the source</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+SourceBitmapWidth] <span class="co">;point to the start of the</span>
                                           <span class="co">;next scan line of the mask</span>
        <span class="kw">dec</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+RectHeight] <span class="co">;count down scan lines</span>
        <span class="kw">jnz</span>     CopyRowsLoop
<span class="fu">CopyDone:</span>
        <span class="kw">pop</span>     <span class="kw">di</span>                          <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">mov</span>     <span class="kw">sp</span>,<span class="kw">bp</span>                       <span class="co">;discard storage for local variables</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>                          <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_CopySystemToScreenMaskedX endp
        end</code></pre>
<section id="faster-masked-copying" class="level4">
<h4><a href="#faster-masked-copying">Faster Masked Copying</a></h4>
<p>In the previous chapter we saw how the VGA’s latches can be used to copy four pixels at a time from one area of display memory to another in Mode X. We’ve further seen that in Mode X the Map Mask register can be used to select which planes are copied. That’s all we need to know to be able to perform fast masked copies; we can store an image in off-screen display memory, and set the Map Mask to the appropriate mask value as up to four pixels at a time are copied.</p>
<p>There’s a slight hitch, though. The latches can only be used when the source and destination left edge coordinates, modulo four, are the same, as explained in the previous chapter. The solution is to copy all four possible alignments of each image to display memory, each properly positioned for one of the four possible destination-left-edge-modulo-four cases. These aligned images must be accompanied by the four possible alignments of the image mask, stored in system memory. Given all four image and mask alignments, masked copying is a simple matter of selecting the alignment that’s appropriate for the destination’s left edge, then setting the Map Mask with the 4-bit mask corresponding to each four-pixel set as we copy four pixels at a time via the latches.</p>
<p>Listing 49.2 performs fast masked copying. This code expects to receive a pointer to a <code>MaskedImage</code> structure, which in turn points to four <code>AlignedMaskedImage</code> structures that describe the four possible image and mask alignments. The aligned images are already stored in display memory, and the aligned masks are already stored in system memory; further, the masks are predigested into Map Mask register-compatible form. Given all that ready-to-use data, Listing 49.2 selects and works with the appropriate image-mask pair for the destination’s left edge alignment.</p>
<p><strong>LISTING 49.2 L49-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Mode X (320x240, 256 colors) display memory to display memory masked copy</span>
<span class="co">; routine. Works on all VGAs. Uses approach of reading 4 pixels at a time from</span>
<span class="co">; source into latches, then writing latches to destination, using Map Mask</span>
<span class="co">; register to perform masking. Copies up to but not including column at</span>
<span class="co">; SourceEndX and row at SourceEndY. No clipping is performed. Results are not</span>
<span class="co">; guaranteed if source and destination overlap. C near-callable as:</span>
<span class="co">;</span>
<span class="co">;    void CopyScreenToScreenMaskedX(int SourceStartX,</span>
<span class="co">;       int SourceStartY, int SourceEndX, int SourceEndY,</span>
<span class="co">;       int DestStartX, int DestStartY, MaskedImage * Source,</span>
<span class="co">;       unsigned int DestPageBase, int DestBitmapWidth);</span>

SC_INDEX <span class="dt">equ</span><span class="bn">    03c4h   </span><span class="co">;Sequence Controller Index register port</span>
MAP_MASK <span class="dt">equ</span><span class="bn">    02h     </span><span class="co">;index in SC of Map Mask register</span>
GC_INDEX <span class="dt">equ</span><span class="bn">    03ceh   </span><span class="co">;Graphics Controller Index register port</span>
BIT_MASK <span class="dt">equ</span><span class="bn">    08h     </span><span class="co">;index in GC of Bit Mask register</span>
SCREEN_SEG <span class="dt">equ</span><span class="bn">  0a000h  </span><span class="co">;segment of display memory in mode X</span>

parms   <span class="kw">struc</span>
                <span class="dt">dw</span> <span class="dv">2</span> dup (?) <span class="co">;pushed BP and return address</span>
SourceStartX    <span class="dt">dw</span> ?         <span class="co">;X coordinate of upper left corner of source</span>
SourceStartY    <span class="dt">dw</span> ?         <span class="co">;Y coordinate of upper left corner of source</span>
SourceEndX      <span class="dt">dw</span> ?         <span class="co">;X coordinate of lower right corner of source</span>
                             <span class="co">; (the column at SourceEndX is not copied)</span>
SourceEndY      <span class="dt">dw</span> ?         <span class="co">;Y coordinate of lower right corner of source</span>
                             <span class="co">; (the row at SourceEndY is not copied)</span>
DestStartX      <span class="dt">dw</span> ?         <span class="co">;X coordinate of upper left corner of dest</span>
DestStartY      <span class="dt">dw</span> ?         <span class="co">;Y coordinate of upper left corner of dest</span>
Source          <span class="dt">dw</span> ?         <span class="co">;pointer to MaskedImage struct for source</span>
                             <span class="co">; which source resides</span>
DestPageBase    <span class="dt">dw</span> ?         <span class="co">;base offset in display memory of page in</span>
                             <span class="co">; which dest resides</span>
DestBitmapWidth <span class="dt">dw</span> ?        <span class="co">;# of pixels across dest bitmap (must be multiple of 4)</span>
parms   ends

SourceNextScanOffset <span class="dt">equ</span> -<span class="dv">2</span>   <span class="co">;local storage for distance from end of</span>
                              <span class="co">; one source scan line to start of next</span>
DestNextScanOffset  <span class="dt">equ</span> -<span class="dv">4</span>    <span class="co">;local storage for distance from end of</span>
                              <span class="co">; one dest scan line to start of next</span>
RectAddrWidth       <span class="dt">equ</span> -<span class="dv">6</span>    <span class="co">;local storage for address width of rectangle</span>
RectHeight          <span class="dt">equ</span> -<span class="dv">8</span>    <span class="co">;local storage for height of rectangle</span>
SourceBitmapWidth   <span class="dt">equ</span> -<span class="dv">10</span>   <span class="co">;local storage for width of source bitmap</span>
                              <span class="co">; (in addresses)</span>
STACK_FRAME_SIZE    <span class="dt">equ</span> <span class="dv">10</span>
MaskedImage         <span class="kw">struc</span>
 Alignments         <span class="dt">dw</span>  <span class="dv">4</span> dup(?) <span class="co">;pointers to AlignedMaskedImages for the</span>
                                 <span class="co">; 4 possible destination image alignments</span>
MaskedImage     ends
AlignedMaskedImage      <span class="kw">struc</span>
 ImageWidth     <span class="dt">dw</span>      ?   <span class="co">;image width in addresses (also mask width in bytes)</span>
 ImagePtr       <span class="dt">dw</span>      ?   <span class="co">;offset of image bitmap in display memory</span>
 MaskPtr        <span class="dt">dw</span>      ?   <span class="co">;pointer to mask bitmap in DS</span>
AlignedMaskedImage      ends
        .model  small
        .code
        public  _CopyScreenToScreenMaskedX
_CopyScreenToScreenMaskedX proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>      <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>   <span class="co">;point to local stack frame</span>
        <span class="kw">sub</span>     <span class="kw">sp</span>,STACK_FRAME_SIZE <span class="co">;allocate space for local vars</span>
        <span class="kw">push</span>    <span class="kw">si</span>      <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>

        <span class="kw">cld</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX     <span class="co">;set the bit mask to select all bits</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,00000h+BIT_MASK <span class="co">; from the latches and none from</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>           <span class="co">; the CPU, so that we can write the</span>
                                <span class="co">; latch contents directly to memory</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEG   <span class="co">;point ES to display memory</span>
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+DestBitmapWidth]
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>            <span class="co">;convert to width in addresses</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">mul</span>     [<span class="kw">bp</span>+DestStartY] <span class="co">;top dest rect scan line</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+DestStartX]
        <span class="kw">mov</span>     <span class="kw">si</span>,<span class="kw">di</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>             <span class="co">;X/4 = offset of first dest rect pixel in</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>             <span class="co">; scan line</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>            <span class="co">;offset of first dest rect pixel in page</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+DestPageBase] <span class="co">;offset of first dest rect pixel in display</span>
                                 <span class="co">; memory. now look up the image that&#39;s</span>
                                 <span class="co">; aligned to match left-edge alignment</span>
                                 <span class="co">; of destination</span>
        <span class="kw">and</span>     <span class="kw">si</span>,<span class="dv">3</span>             <span class="co">;DestStartX modulo 4</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">si</span>            <span class="co">;set aside alignment for later</span>
        <span class="kw">shl</span>     <span class="kw">si</span>,<span class="dv">1</span>             <span class="co">;prepare for word look-up</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>+Source] <span class="co">;point to source MaskedImage structure</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bx</span>+Alignments+<span class="kw">si</span>] <span class="co">;point to AlignedMaskedImage</span>
                                 <span class="co">; struc for current left edge alignment</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bx</span>+ImageWidth] <span class="co">;image width in addresses</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+SourceBitmapWidth],<span class="kw">ax</span> <span class="co">;remember image width in addresses</span>
        <span class="kw">mul</span>     [<span class="kw">bp</span>+SourceStartY] <span class="co">;top source rect scan line</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+SourceStartX]
        <span class="kw">shr</span>     <span class="kw">si</span>,<span class="dv">1</span>             <span class="co">;X/4 = address of first source rect pixel in</span>
        <span class="kw">shr</span>     <span class="kw">si</span>,<span class="dv">1</span>             <span class="co">; scan line</span>
        <span class="kw">add</span>     <span class="kw">si</span>,<span class="kw">ax</span>            <span class="co">;offset of first source rect pixel in image</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">si</span>
        <span class="kw">add</span>     <span class="kw">si</span>,[<span class="kw">bx</span>+MaskPtr] <span class="co">;point to mask offset of first mask pixel in DS</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bx</span>+ImagePtr] <span class="co">;offset of first source rect pixel</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,<span class="kw">ax</span>            <span class="co">; in display memory</span>

        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceStartX] <span class="co">;calculate # of addresses across</span>
        <span class="kw">add</span>     <span class="kw">ax</span>,<span class="kw">cx</span>            <span class="co">; rect, shifting if necessary to</span>
        <span class="kw">add</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+SourceEndX]   <span class="co">; account for alignment</span>
        <span class="kw">cmp</span>     <span class="kw">cx</span>,<span class="kw">ax</span>
        <span class="kw">jle</span>     CopyDone         <span class="co">;skip if 0 or negative width</span>
        <span class="kw">add</span>     <span class="kw">cx</span>,<span class="dv">3</span>
        <span class="kw">and</span>     <span class="kw">ax</span>,<span class="kw">not</span><span class="bn"> 011b</span>
        <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">ax</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>             <span class="co">;# of addresses across rectangle to copy</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceEndY]
        <span class="kw">sub</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceStartY]  <span class="co">;AX = height of rectangle</span>
        <span class="kw">jle</span>     CopyDone        <span class="co">;skip if 0 or negative height</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+RectHeight],<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+DestBitmapWidth]
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>            <span class="co">;convert to width in addresses</span>
        <span class="kw">shr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">cx</span> <span class="co">;distance from end of one dest scan line to start of next</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+DestNextScanOffset],<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceBitmapWidth] <span class="co">;width in addresses</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">cx</span> <span class="co">;distance from end of source scan line to start of next</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+SourceNextScanOffset],<span class="kw">ax</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>+RectAddrWidth],<span class="kw">cx</span> <span class="co">;remember width in addresses</span>

        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">;point SC Index register to Map Mask</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>              <span class="co">;point to SC Data register</span>
<span class="fu">CopyRowsLoop:</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bp</span>+RectAddrWidth] <span class="co">;width across</span>
<span class="fu">CopyScanLineLoop:</span>
        <span class="kw">lodsb</span>                   <span class="co">;get the mask for this four-pixel set</span>
                                <span class="co">; and advance the mask pointer</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">;set the mask</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">es</span>:[<span class="kw">bx</span>]      <span class="co">;load the latches with four-pixel set from source</span>
        <span class="kw">mov</span>     <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">al</span>      <span class="co">;copy the four-pixel set to the dest</span>
        <span class="kw">inc</span>     <span class="kw">bx</span>              <span class="co">;advance the source pointer</span>
        <span class="kw">inc</span>     <span class="kw">di</span>              <span class="co">;advance the destination pointer</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>              <span class="co">;count off four-pixel sets</span>
        <span class="kw">jnz</span>     CopyScanLineLoop

        <span class="kw">mov</span>     <span class="kw">ax</span>,[<span class="kw">bp</span>+SourceNextScanOffset]
        <span class="kw">add</span>     <span class="kw">si</span>,<span class="kw">ax</span>           <span class="co">;point to the start of</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,<span class="kw">ax</span>           <span class="co">; the next source, mask,</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[<span class="kw">bp</span>+DestNextScanOffset] <span class="co">; and dest lines</span>
        <span class="kw">dec</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+RectHeight] <span class="co">;count down scan lines</span>
        <span class="kw">jnz</span>     CopyRowsLoop
<span class="fu">CopyDone:</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,GC_INDEX<span class="dv">+1</span>   <span class="co">;restore the bit mask to its default,</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,0ffh         </span><span class="co">; which selects all bits from the CPU</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>           <span class="co">; and none from the latches (the GC</span>
                                <span class="co">; Index still points to Bit Mask)</span>
        <span class="kw">pop</span>     <span class="kw">di</span>              <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">mov</span>     <span class="kw">sp</span>,<span class="kw">bp</span>           <span class="co">;discard storage for local variables</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>              <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_CopyScreenToScreenMaskedX endp
        end</code></pre>
<p>It would be handy to have a function that, given a base image and mask, generates the four image and mask alignments and fills in the <code>MaskedImage</code> structure. Listing 49.3, together with the include file in Listing 49.4 and the system memory-to-display memory block-copy routine in Listing 48.4 (in the previous chapter) does just that. It would be faster if Listing 49.3 were in assembly language, but there’s no reason to think that generating aligned images needs to be particularly fast; in such cases, I prefer to use C, for reasons of coding speed, fewer bugs, and maintainability.</p>
<p><strong>LISTING 49.3 L49-3.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Generates all four possible mode X image/mask alignments, stores image</span>
<span class="co">alignments in display memory, allocates memory for and generates mask</span>
<span class="co">alignments, and fills out an AlignedMaskedImage structure. Image and mask must</span>
<span class="co">both be in byte-per-pixel form, and must both be of width ImageWidth. Mask</span>
<span class="co">maps isomorphically (one to one) onto image, with each 0-byte in mask masking</span>
<span class="co">off corresponding image pixel (causing it not to be drawn), and each non-0-byte</span>
<span class="co">allowing corresponding image pixel to be drawn. Returns 0 if failure, or # of</span>
<span class="co">display memory addresses (4-pixel sets) used if success. For simplicity,</span>
<span class="co">allocated memory is not deallocated in case of failure. Compiled with</span>
<span class="co">Borland C++ in C compilation mode. */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &quot;maskim.h&quot;</span>

<span class="kw">extern</span> <span class="dt">void</span> CopySystemToScreenX(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">char</span> *,
   <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="dt">unsigned</span> <span class="dt">int</span> CreateAlignedMaskedImage(MaskedImage * ImageToSet,
   <span class="dt">unsigned</span> <span class="dt">int</span> DispMemStart, <span class="dt">char</span> * Image, <span class="dt">int</span> ImageWidth,
   <span class="dt">int</span> ImageHeight, <span class="dt">char</span> * Mask)
{
   <span class="dt">int</span> Align, ScanLine, BitNum, Size, TempImageWidth;
   <span class="dt">unsigned</span> <span class="dt">char</span> MaskTemp;
   <span class="dt">unsigned</span> <span class="dt">int</span> DispMemOffset = DispMemStart;
   AlignedMaskedImage *WorkingAMImage;
   <span class="dt">char</span> *NewMaskPtr, *OldMaskPtr;
   <span class="co">/* Generate each of the four alignments in turn. */</span>
   <span class="kw">for</span> (Align = <span class="dv">0</span>; Align &lt; <span class="dv">4</span>; Align++) {
      <span class="co">/* Allocate space for the AlignedMaskedImage struct for this alignment. */</span>
      <span class="kw">if</span> ((WorkingAMImage = ImageToSet-&gt;Alignments[Align] =
            malloc(<span class="kw">sizeof</span>(AlignedMaskedImage))) == NULL)
         <span class="kw">return</span> <span class="dv">0</span>;
      WorkingAMImage-&gt;ImageWidth =
            (ImageWidth + Align + <span class="dv">3</span>) / <span class="dv">4</span>; <span class="co">/* width in 4-pixel sets */</span>
      WorkingAMImage-&gt;ImagePtr = DispMemOffset; <span class="co">/* image dest */</span>
      <span class="co">/* Download this alignment of the image. */</span>
      CopySystemToScreenX(<span class="dv">0</span>, <span class="dv">0</span>, ImageWidth, ImageHeight, Align, <span class="dv">0</span>,
            Image, DispMemOffset, ImageWidth, WorkingAMImage-&gt;ImageWidth * <span class="dv">4</span>);
      <span class="co">/* Calculate the number of bytes needed to store the mask in</span>
<span class="co">         nibble (Map Mask-ready) form, then allocate that space. */</span>
      Size = WorkingAMImage-&gt;ImageWidth * ImageHeight;
      <span class="kw">if</span> ((WorkingAMImage-&gt;MaskPtr = malloc(Size)) == NULL)
         <span class="kw">return</span> <span class="dv">0</span>;
      <span class="co">/* Generate this nibble oriented (Map Mask-ready) alignment of</span>
<span class="co">         the mask, one scan line at a time. */</span>
      OldMaskPtr = Mask;
      NewMaskPtr = WorkingAMImage-&gt;MaskPtr;
      <span class="kw">for</span> (ScanLine = <span class="dv">0</span>; ScanLine &lt; ImageHeight; ScanLine++) {
         BitNum = Align;
         MaskTemp = <span class="dv">0</span>;
         TempImageWidth = ImageWidth;
         <span class="kw">do</span> {
            <span class="co">/* Set the mask bit for next pixel according to its alignment. */</span>
            MaskTemp |= (*OldMaskPtr++ != <span class="dv">0</span>) &lt;&lt; BitNum;
            <span class="kw">if</span> (++BitNum &gt; <span class="dv">3</span>) {
               *NewMaskPtr++ = MaskTemp;
               MaskTemp = BitNum = <span class="dv">0</span>;
            }
         } <span class="kw">while</span> (--TempImageWidth);
         <span class="co">/* Set any partial final mask on this scan line. */</span>
         <span class="kw">if</span> (BitNum != <span class="dv">0</span>) *NewMaskPtr++ = MaskTemp;
      }
      DispMemOffset += Size; <span class="co">/* mark off the space we just used */</span>
   }
   <span class="kw">return</span> DispMemOffset - DispMemStart;
}

**LISTING <span class="fl">49.4</span> MASKIM.H**

<span class="co">/* MASKIM.H: structures used for storing and manipulating masked</span>
<span class="co">   images */</span>

<span class="co">/* Describes one alignment of a mask-image pair. */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
   <span class="dt">int</span> ImageWidth; <span class="co">/* image width in addresses in display memory (also</span>
<span class="co">                      mask width in bytes) */</span>
   <span class="dt">unsigned</span> <span class="dt">int</span> ImagePtr; <span class="co">/* offset of image bitmap in display mem */</span>
   <span class="dt">char</span> *MaskPtr;  <span class="co">/* pointer to mask bitmap */</span>
} AlignedMaskedImage;

<span class="co">/* Describes all four alignments of a mask-image pair. */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
   AlignedMaskedImage *Alignments[<span class="dv">4</span>]; <span class="co">/* ptrs to AlignedMaskedImage</span>
<span class="co">                                         structs for four possible destination</span>
<span class="co">                                         image alignments */</span>
} MaskedImage;</code></pre>
</section>
<section id="notes-on-masked-copying" class="level4">
<h4><a href="#notes-on-masked-copying">Notes on Masked Copying</a></h4>
<p>Listings 49.1 and 49.2, like all Mode X code I’ve presented, perform no clipping, because clipping code would complicate the listings too much. While clipping can be implemented directly in the low-level Mode X routines (at the beginning of Listing 49.1, for instance), another, potentially simpler approach would be to perform clipping at a higher level, modifying the coordinates and dimensions passed to low-level routines such as Listings 49.1 and 49.2 as necessary to accomplish the desired clipping. It is for precisely this reason that the low-level Mode X routines support programmable start coordinates in the source images, rather than assuming (0,0); likewise for the distinction between the width of the image and the width of the area of the image to draw.</p>
<p>Also, it would be more efficient to make up structures that describe the source and destination bitmaps, with dimensions and coordinates built in, and simply pass pointers to these structures to the low level, rather than passing many separate parameters, as is now the case. I’ve used separate parameters for simplicity and flexibility.</p>
<blockquote>
<p><img src="images/i.jpg" /> Be aware that as nifty as Mode X hardware-assisted masked copying is, whether or not it’s actually faster than software-only masked or transparent copying depends upon the processor and the video adapter. The advantage of Mode X masked copying is the 32-bit parallelism; the disadvantages are the need to read display memory and the need to perform an <code>OUT</code> for every four pixels. (<code>OUT</code> is a slow 486/Pentium instruction, and most VGAs respond to <code>OUT</code>s much more slowly than to display memory writes.)</p>
</blockquote>
</section>
</section>
<section id="animation" class="level3">
<h3><a href="#animation">Animation</a></h3>
<p>Gosh. There’s just no way I can discuss high-level animation fundamentals in any detail here; I could spend an entire (and entirely separate) book on animation techniques alone. You might want to have a look at Chapters 43 through 46 before attacking the code in this chapter; that will have to do us for the present volume. (I will return to <em>3-D</em> animation in the next chapter.)</p>
<p>Basically, I’m going to perform page flipped animation, in which one page (that is, a bitmap large enough to hold a full screen) of display memory is displayed while another page is drawn to. When the drawing is finished, the newly modified page is displayed, and the other—now invisible—page is drawn to. The process repeats ad infinitum. For further information, some good places to start are <em>Computer Graphics</em>, by Foley and van Dam (Addison-Wesley); <em>Principles of Interactive Computer Graphics</em>, by Newman and Sproull (McGraw Hill); and “Real-Time Animation” by Rahner James (January 1990, <em>Dr. Dobb’s Journal</em>).</p>
<p>Some of the code in this chapter was adapted for Mode X from the code in Chapter 44—yet another reason to read that chapter before finishing this one.</p>
</section>
<section id="mode-x-animation-in-action" class="level3">
<h3><a href="#mode-x-animation-in-action">Mode X Animation in Action</a></h3>
<p>Listing 49.5 ties together everything I’ve discussed about Mode X so far in a compact but surprisingly powerful animation package. Listing 49.5 first uses solid and patterned fills and system-memory-to-screen-memory masked copying to draw a static background containing a mountain, a sun, a plain, water, and a house with puffs of smoke coming out of the chimney, and sets up the four alignments of a masked kite image. The background is transferred to both display pages, and drawing of 20 kite images in the nondisplayed page using fast masked copying begins. After all images have been drawn, the page is flipped to show the newly updated screen, and the kites are moved and drawn in the other page, which is no longer displayed. Kites are erased at their old positions in the nondisplayed page by block copying from the background page. (See the discussion in the previous chapter for the display memory organization used by Listing 49.5.) So far as the displayed image is concerned, there is never any hint of flicker or disturbance of the background. This continues at a rate of up to 60 times a second until Esc is pressed to exit the program. See Figure 49.1 for a screen shot of the resulting image—add the animation in your imagination.</p>
<figure>
<img src="images/49-01.jpg" alt="Figure 49.1  An animated Mode X screen." /><figcaption><strong>Figure 49.1</strong>  <em>An animated Mode X screen.</em></figcaption>
</figure>
<p><strong>LISTING 49.5 L49-5.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Sample mode X VGA animation program. Portions of this code first appeared</span>
<span class="co">   in PC Techniques. Compiled with Borland C++ 2.0 in C compilation mode. */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &quot;maskim.h&quot;</span>

<span class="ot">#define SCREEN_SEG         0xA000</span>
<span class="ot">#define SCREEN_WIDTH       320</span>
<span class="ot">#define SCREEN_HEIGHT      240</span>
<span class="ot">#define PAGE0_START_OFFSET 0</span>
<span class="ot">#define PAGE1_START_OFFSET (((long)SCREEN_HEIGHT*SCREEN_WIDTH)/4)</span>
<span class="ot">#define BG_START_OFFSET    (((long)SCREEN_HEIGHT*SCREEN_WIDTH*2)/4)</span>
<span class="ot">#define DOWNLOAD_START_OFFSET (((long)SCREEN_HEIGHT*SCREEN_WIDTH*3)/4)</span>

<span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">int</span> PageStartOffsets[<span class="dv">2</span>] = {PAGE0_START_OFFSET,PAGE1_START_OFFSET};
<span class="dt">static</span> <span class="dt">char</span> GreenAndBrownPattern[] = {<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">2</span>,<span class="dv">6</span>, <span class="dv">6</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">2</span>, <span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">2</span>,<span class="dv">6</span>, <span class="dv">6</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">2</span>};
<span class="dt">static</span> <span class="dt">char</span> PineTreePattern[] = {<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>, <span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">2</span>,<span class="dv">6</span>, <span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">2</span>, <span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>};
<span class="dt">static</span> <span class="dt">char</span> BrickPattern[] = {<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">6</span>, <span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">7</span>, <span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>, <span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">7</span>,};
<span class="dt">static</span> <span class="dt">char</span> RoofPattern[] = {<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">7</span>, <span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">7</span>, <span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">7</span>, <span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">7</span>};

<span class="ot">#define SMOKE_WIDTH  7</span>
<span class="ot">#define SMOKE_HEIGHT 7</span>
<span class="dt">static</span> <span class="dt">char</span> SmokePixels[] = {
   <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">7</span>,<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>, <span class="dv">0</span>,
   <span class="dv">8</span>, <span class="dv">7</span>, <span class="dv">7</span>, <span class="dv">7</span>,<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>,
   <span class="dv">8</span>, <span class="dv">7</span>, <span class="dv">7</span>, <span class="dv">7</span>, <span class="dv">7</span>,<span class="dv">15</span>,<span class="dv">15</span>,
   <span class="dv">0</span>, <span class="dv">8</span>, <span class="dv">7</span>, <span class="dv">7</span>, <span class="dv">7</span>, <span class="dv">7</span>,<span class="dv">15</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">8</span>, <span class="dv">7</span>, <span class="dv">7</span>, <span class="dv">7</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">0</span>, <span class="dv">0</span>};
<span class="dt">static</span> <span class="dt">char</span> SmokeMask[] = {
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,
   <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>};
<span class="ot">#define KITE_WIDTH  10</span>
<span class="ot">#define KITE_HEIGHT 16</span>
<span class="dt">static</span> <span class="dt">char</span> KitePixels[] = {
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">45</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">46</span>,<span class="dv">46</span>,<span class="dv">46</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">47</span>,<span class="dv">47</span>,<span class="dv">47</span>,<span class="dv">47</span>,<span class="dv">47</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>,<span class="dv">48</span>,<span class="dv">48</span>,<span class="dv">48</span>,<span class="dv">48</span>,<span class="dv">48</span>,<span class="dv">48</span>,<span class="dv">48</span>, <span class="dv">0</span>, <span class="dv">0</span>,
  <span class="dv">49</span>,<span class="dv">49</span>,<span class="dv">49</span>,<span class="dv">49</span>,<span class="dv">49</span>,<span class="dv">49</span>,<span class="dv">49</span>,<span class="dv">49</span>,<span class="dv">49</span>, <span class="dv">0</span>,
   <span class="dv">0</span>,<span class="dv">50</span>,<span class="dv">50</span>,<span class="dv">50</span>,<span class="dv">50</span>,<span class="dv">50</span>,<span class="dv">50</span>,<span class="dv">50</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>,<span class="dv">51</span>,<span class="dv">51</span>,<span class="dv">51</span>,<span class="dv">51</span>,<span class="dv">51</span>,<span class="dv">51</span>,<span class="dv">51</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">52</span>,<span class="dv">52</span>,<span class="dv">52</span>,<span class="dv">52</span>,<span class="dv">52</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">53</span>,<span class="dv">53</span>,<span class="dv">53</span>,<span class="dv">53</span>,<span class="dv">53</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">54</span>,<span class="dv">54</span>,<span class="dv">54</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">55</span>,<span class="dv">55</span>,<span class="dv">55</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">58</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">59</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">66</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">60</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">64</span>, <span class="dv">0</span>,<span class="dv">65</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">61</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">64</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">62</span>,<span class="dv">63</span>, <span class="dv">0</span>,<span class="dv">64</span>};
<span class="dt">static</span> <span class="dt">char</span> KiteMask[] = {
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>,
   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>};
<span class="dt">static</span> MaskedImage KiteImage;

<span class="ot">#define NUM_OBJECTS  20</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
   <span class="dt">int</span> X,Y,Width,Height,XDir,YDir,XOtherPage,YOtherPage;
   MaskedImage *Image;
} AnimatedObject;
AnimatedObject AnimatedObjects[] = {
   {  <span class="dv">0</span>,  <span class="dv">0</span>,KITE_WIDTH,KITE_HEIGHT, <span class="dv">1</span>, <span class="dv">1</span>,  <span class="dv">0</span>,  <span class="dv">0</span>,&amp;KiteImage},
   { <span class="dv">10</span>, <span class="dv">10</span>,KITE_WIDTH,KITE_HEIGHT, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">10</span>,&amp;KiteImage},
   { <span class="dv">20</span>, <span class="dv">20</span>,KITE_WIDTH,KITE_HEIGHT,-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">20</span>, <span class="dv">20</span>,&amp;KiteImage},
   { <span class="dv">30</span>, <span class="dv">30</span>,KITE_WIDTH,KITE_HEIGHT,-<span class="dv">1</span>,-<span class="dv">1</span>, <span class="dv">30</span>, <span class="dv">30</span>,&amp;KiteImage},
   { <span class="dv">40</span>, <span class="dv">40</span>,KITE_WIDTH,KITE_HEIGHT, <span class="dv">1</span>,-<span class="dv">1</span>, <span class="dv">40</span>, <span class="dv">40</span>,&amp;KiteImage},
   { <span class="dv">50</span>, <span class="dv">50</span>,KITE_WIDTH,KITE_HEIGHT, <span class="dv">0</span>,-<span class="dv">1</span>, <span class="dv">50</span>, <span class="dv">50</span>,&amp;KiteImage},
   { <span class="dv">60</span>, <span class="dv">60</span>,KITE_WIDTH,KITE_HEIGHT, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">60</span>, <span class="dv">60</span>,&amp;KiteImage},
   { <span class="dv">70</span>, <span class="dv">70</span>,KITE_WIDTH,KITE_HEIGHT,-<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">70</span>, <span class="dv">70</span>,&amp;KiteImage},
   { <span class="dv">80</span>, <span class="dv">80</span>,KITE_WIDTH,KITE_HEIGHT, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">80</span>, <span class="dv">80</span>,&amp;KiteImage},
   { <span class="dv">90</span>, <span class="dv">90</span>,KITE_WIDTH,KITE_HEIGHT, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">90</span>, <span class="dv">90</span>,&amp;KiteImage},
   {<span class="dv">100</span>,<span class="dv">100</span>,KITE_WIDTH,KITE_HEIGHT,-<span class="dv">1</span>, <span class="dv">2</span>,<span class="dv">100</span>,<span class="dv">100</span>,&amp;KiteImage},
   {<span class="dv">110</span>,<span class="dv">110</span>,KITE_WIDTH,KITE_HEIGHT,-<span class="dv">1</span>,-<span class="dv">2</span>,<span class="dv">110</span>,<span class="dv">110</span>,&amp;KiteImage},
   {<span class="dv">120</span>,<span class="dv">120</span>,KITE_WIDTH,KITE_HEIGHT, <span class="dv">1</span>,-<span class="dv">2</span>,<span class="dv">120</span>,<span class="dv">120</span>,&amp;KiteImage},
   {<span class="dv">130</span>,<span class="dv">130</span>,KITE_WIDTH,KITE_HEIGHT, <span class="dv">0</span>,-<span class="dv">2</span>,<span class="dv">130</span>,<span class="dv">130</span>,&amp;KiteImage},
   {<span class="dv">140</span>,<span class="dv">140</span>,KITE_WIDTH,KITE_HEIGHT, <span class="dv">2</span>, <span class="dv">0</span>,<span class="dv">140</span>,<span class="dv">140</span>,&amp;KiteImage},
   {<span class="dv">150</span>,<span class="dv">150</span>,KITE_WIDTH,KITE_HEIGHT,-<span class="dv">2</span>, <span class="dv">0</span>,<span class="dv">150</span>,<span class="dv">150</span>,&amp;KiteImage},
   {<span class="dv">160</span>,<span class="dv">160</span>,KITE_WIDTH,KITE_HEIGHT, <span class="dv">2</span>, <span class="dv">2</span>,<span class="dv">160</span>,<span class="dv">160</span>,&amp;KiteImage},
   {<span class="dv">170</span>,<span class="dv">170</span>,KITE_WIDTH,KITE_HEIGHT,-<span class="dv">2</span>, <span class="dv">2</span>,<span class="dv">170</span>,<span class="dv">170</span>,&amp;KiteImage},
   {<span class="dv">180</span>,<span class="dv">180</span>,KITE_WIDTH,KITE_HEIGHT,-<span class="dv">2</span>,-<span class="dv">2</span>,<span class="dv">180</span>,<span class="dv">180</span>,&amp;KiteImage},
   {<span class="dv">190</span>,<span class="dv">190</span>,KITE_WIDTH,KITE_HEIGHT, <span class="dv">2</span>,-<span class="dv">2</span>,<span class="dv">190</span>,<span class="dv">190</span>,&amp;KiteImage},
};
<span class="dt">void</span> main(<span class="dt">void</span>);
<span class="dt">void</span> DrawBackground(<span class="dt">unsigned</span> <span class="dt">int</span>);
<span class="dt">void</span> MoveObject(AnimatedObject *);
<span class="kw">extern</span> <span class="dt">void</span> Set320x240Mode(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">void</span> FillRectangleX(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> FillPatternX(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">char</span>*);
<span class="kw">extern</span> <span class="dt">void</span> CopySystemToScreenMaskedX(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>,
   <span class="dt">char</span> *, <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">char</span> *);
<span class="kw">extern</span> <span class="dt">void</span> CopyScreenToScreenX(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>,
   <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">unsigned</span> <span class="dt">int</span> CreateAlignedMaskedImage(MaskedImage *,
   <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">char</span> *, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">char</span> *);
<span class="kw">extern</span> <span class="dt">void</span> CopyScreenToScreenMaskedX(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>,
   MaskedImage *, <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> ShowPage(<span class="dt">unsigned</span> <span class="dt">int</span>);

<span class="dt">void</span> main()
{
   <span class="dt">int</span> DisplayedPage, NonDisplayedPage, Done, i;
   <span class="kw">union</span> REGS regset;
   Set320x240Mode();
   <span class="co">/* Download the kite image for fast copying later. */</span>
   <span class="kw">if</span> (CreateAlignedMaskedImage(&amp;KiteImage, DOWNLOAD_START_OFFSET,
         KitePixels, KITE_WIDTH, KITE_HEIGHT, KiteMask) == <span class="dv">0</span>) {
      regset.x.ax = <span class="bn">0x0003</span>; int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
      printf(<span class="st">&quot;Couldn&#39;t get memory</span><span class="ch">\n</span><span class="st">&quot;</span>); exit();
   }
   <span class="co">/* Draw the background to the background page. */</span>
   DrawBackground(BG_START_OFFSET);
   <span class="co">/* Copy the background to both displayable pages. */</span>
   CopyScreenToScreenX(<span class="dv">0</span>, <span class="dv">0</span>, SCREEN_WIDTH, SCREEN_HEIGHT, <span class="dv">0</span>, <span class="dv">0</span>,
         BG_START_OFFSET, PAGE0_START_OFFSET, SCREEN_WIDTH, SCREEN_WIDTH);
   CopyScreenToScreenX(<span class="dv">0</span>, <span class="dv">0</span>, SCREEN_WIDTH, SCREEN_HEIGHT, <span class="dv">0</span>, <span class="dv">0</span>,
         BG_START_OFFSET, PAGE1_START_OFFSET, SCREEN_WIDTH, SCREEN_WIDTH);
   <span class="co">/* Move the objects and update their images in the nondisplayed</span>
<span class="co">      page, then flip the page, until Esc is pressed. */</span>
   Done = DisplayedPage = <span class="dv">0</span>;
   <span class="kw">do</span> {
      NonDisplayedPage = DisplayedPage ^ <span class="dv">1</span>;
      <span class="co">/* Erase each object in nondisplayed page by copying block from</span>
<span class="co">            background page at last location in that page. */</span>
      <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NUM_OBJECTS; i++) {
         CopyScreenToScreenX(AnimatedObjects[i].XOtherPage,
               AnimatedObjects[i].YOtherPage,
               AnimatedObjects[i].XOtherPage +
               AnimatedObjects[i].Width,
               AnimatedObjects[i].YOtherPage +
               AnimatedObjects[i].Height,
               AnimatedObjects[i].XOtherPage,
               AnimatedObjects[i].YOtherPage, BG_START_OFFSET,
               PageStartOffsets[NonDisplayedPage], SCREEN_WIDTH, SCREEN_WIDTH);
      }
      <span class="co">/* Move and draw each object in the nondisplayed page. */</span>
      <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NUM_OBJECTS; i++) {
         MoveObject(&amp;AnimatedObjects[i]);
         <span class="co">/* Draw object into nondisplayed page at new location */</span>
         CopyScreenToScreenMaskedX(<span class="dv">0</span>, <span class="dv">0</span>, AnimatedObjects[i].Width,
               AnimatedObjects[i].Height, AnimatedObjects[i].X,
               AnimatedObjects[i].Y, AnimatedObjects[i].Image,
               PageStartOffsets[NonDisplayedPage], SCREEN_WIDTH);
      }
      <span class="co">/* Flip to the page into which we just drew. */</span>
      ShowPage(PageStartOffsets[DisplayedPage = NonDisplayedPage]);
      <span class="co">/* See if it&#39;s time to end. */</span>
      <span class="kw">if</span> (kbhit()) {
         <span class="kw">if</span> (getch() == <span class="bn">0x1B</span>) Done = <span class="dv">1</span>;   <span class="co">/* Esc to end */</span>
      }
   } <span class="kw">while</span> (!Done);
   <span class="co">/* Restore text mode and done. */</span>
   regset.x.ax = <span class="bn">0x0003</span>; int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}
<span class="dt">void</span> DrawBackground(<span class="dt">unsigned</span> <span class="dt">int</span> PageStart)
{
   <span class="dt">int</span> i,j,Temp;
   <span class="co">/* Fill the screen with cyan. */</span>
   FillRectangleX(<span class="dv">0</span>, <span class="dv">0</span>, SCREEN_WIDTH, SCREEN_HEIGHT, PageStart, <span class="dv">11</span>);
   <span class="co">/* Draw a green and brown rectangle to create a flat plain. */</span>
   FillPatternX(<span class="dv">0</span>, <span class="dv">160</span>, SCREEN_WIDTH, SCREEN_HEIGHT, PageStart,
                GreenAndBrownPattern);
   <span class="co">/* Draw blue water at the bottom of the screen. */</span>
   FillRectangleX(<span class="dv">0</span>, SCREEN_HEIGHT<span class="dv">-30</span>, SCREEN_WIDTH, SCREEN_HEIGHT,
                  PageStart, <span class="dv">1</span>);
   <span class="co">/* Draw a brown mountain rising out of the plain. */</span>
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">120</span>; i++)
      FillRectangleX(SCREEN_WIDTH/<span class="dv">2-30</span>-i, <span class="dv">51</span>+i, SCREEN_WIDTH/<span class="dv">2-30</span>+i<span class="dv">+1</span>,
                     <span class="dv">51</span>+i<span class="dv">+1</span>, PageStart, <span class="dv">6</span>);
   <span class="co">/* Draw a yellow sun by overlapping rects of various shapes. */</span>
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;=<span class="dv">20</span>; i++) {
      Temp = (<span class="dt">int</span>)(sqrt(<span class="fl">20.0</span>*<span class="fl">20.0</span> - (<span class="dt">float</span>)i*(<span class="dt">float</span>)i) + <span class="fl">0.5</span>);
      FillRectangleX(SCREEN_WIDTH<span class="dv">-25</span>-i, <span class="dv">30</span>-Temp, SCREEN_WIDTH<span class="dv">-25</span>+i<span class="dv">+1</span>,
                     <span class="dv">30</span>+Temp<span class="dv">+1</span>, PageStart, <span class="dv">14</span>);
   }
   <span class="co">/* Draw green trees down the side of the mountain. */</span>
   <span class="kw">for</span> (i=<span class="dv">10</span>; i&lt;<span class="dv">90</span>; i += <span class="dv">15</span>)
      <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;<span class="dv">20</span>; j++)
       FillPatternX(SCREEN_WIDTH/<span class="dv">2</span>+i-j/<span class="dv">3-15</span>, i+j<span class="dv">+51</span>,SCREEN_WIDTH/<span class="dv">2</span>+i+j/<span class="dv">3-15+1</span>,
                                       i+j<span class="dv">+51+1</span>, PageStart, PineTreePattern);
   <span class="co">/* Draw a house on the plain. */</span>
   FillPatternX(<span class="dv">265</span>, <span class="dv">150</span>, <span class="dv">295</span>, <span class="dv">170</span>, PageStart, BrickPattern);
   FillPatternX(<span class="dv">265</span>, <span class="dv">130</span>, <span class="dv">270</span>, <span class="dv">150</span>, PageStart, BrickPattern);
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">12</span>; i++)
      FillPatternX(<span class="dv">280</span>-i*<span class="dv">2</span>, <span class="dv">138</span>+i, <span class="dv">280</span>+i*<span class="dv">2+1</span>, <span class="dv">138</span>+i<span class="dv">+1</span>, PageStart, RoofPattern);
   <span class="co">/* Finally, draw puffs of smoke rising from the chimney. */</span>
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">4</span>; i++)
      CopySystemToScreenMaskedX(<span class="dv">0</span>, <span class="dv">0</span>, SMOKE_WIDTH, SMOKE_HEIGHT, <span class="dv">264</span>,
        <span class="dv">110</span>-i*<span class="dv">20</span>, SmokePixels, PageStart, SMOKE_WIDTH,SCREEN_WIDTH, SmokeMask);
}
<span class="co">/* Move the specified object, bouncing at the edges of the screen and</span>
<span class="co">   remembering where the object was before the move for erasing next time. */</span>
<span class="dt">void</span> MoveObject(AnimatedObject * ObjectToMove) {
   <span class="dt">int</span> X, Y;
   X = ObjectToMove-&gt;X + ObjectToMove-&gt;XDir;
   Y = ObjectToMove-&gt;Y + ObjectToMove-&gt;YDir;
   <span class="kw">if</span> ((X &lt; <span class="dv">0</span>) || (X &gt; (SCREEN_WIDTH - ObjectToMove-&gt;Width))) {
      ObjectToMove-&gt;XDir = -ObjectToMove-&gt;XDir;
      X = ObjectToMove-&gt;X + ObjectToMove-&gt;XDir;
   }
   <span class="kw">if</span> ((Y &lt; <span class="dv">0</span>) || (Y &gt; (SCREEN_HEIGHT - ObjectToMove-&gt;Height))) {
      ObjectToMove-&gt;YDir = -ObjectToMove-&gt;YDir;
      Y = ObjectToMove-&gt;Y + ObjectToMove-&gt;YDir;
   }
   <span class="co">/* Remember previous location for erasing purposes. */</span>
   ObjectToMove-&gt;XOtherPage = ObjectToMove-&gt;X;
   ObjectToMove-&gt;YOtherPage = ObjectToMove-&gt;Y;
   ObjectToMove-&gt;X = X; <span class="co">/* set new location */</span>
   ObjectToMove-&gt;Y = Y;
}</code></pre>
<p>Here’s something worth noting: The animation is extremely smooth on a 20 MHz 386. It is somewhat more jerky on an 8 MHz 286, because only 30 frames a second can be processed. If animation looks jerky on your PC, try reducing the number of kites.</p>
<p>The kites draw perfectly into the background, with no interference or fringe, thanks to masked copying. In fact, the kites also cross with no interference (the last-drawn kite is always in front), although that’s not readily apparent because they all look the same anyway and are moving fast. Listing 49.5 isn’t inherently limited to kites; create your own images and initialize the object list to display a mix of those images and see the full power of Mode X animation.</p>
<p>The external functions called by Listing 49.5 can be found in Listings 49.1, 49.2, 49.3, and 49.6, and in the listings for the previous two chapters.</p>
<p><strong>LISTING 49.6 L49-6.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Shows the page at the specified offset in the bitmap. Page is displayed when</span>
<span class="co">; this routine returns.</span>
<span class="co">; C near-callable as: void ShowPage(unsigned int StartOffset);</span>
INPUT_STATUS_1     <span class="dt">equ</span><span class="bn">     03dah   </span><span class="co">;Input Status 1 register</span>
CRTC_INDEX         <span class="dt">equ</span><span class="bn">     03d4h   </span><span class="co">;CRT Controller Index reg</span>
START_ADDRESS_HIGH <span class="dt">equ</span><span class="bn">     0ch     </span><span class="co">;bitmap start address high byte</span>
START_ADDRESS_LOW  <span class="dt">equ</span><span class="bn">     0dh     </span><span class="co">;bitmap start address low byte</span>

ShowPageParms   <span class="kw">struc</span>
                 <span class="dt">dw</span>      <span class="dv">2</span> dup (?) <span class="co">;pushed BP and return address</span>
StartOffset <span class="dt">dw</span>   ?                 <span class="co">;offset in bitmap of page to display</span>
ShowPageParms   ends
        .model  small
        .code
        public  _ShowPage
_ShowPage       proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>                 <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>              <span class="co">;point to local stack frame</span>
<span class="co">; Wait for display enable to be active (status is active low), to be</span>
<span class="co">; sure both halves of the start address will take in the same frame.</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,START_ADDRESS_LOW        <span class="co">;preload for fastest</span>
        <span class="kw">mov</span>     <span class="kw">bh</span>,<span class="dt">byte</span> <span class="dt">ptr</span> StartOffset[<span class="kw">bp</span>] <span class="co">; flipping once display</span>
        <span class="kw">mov</span>     <span class="kw">cl</span>,START_ADDRESS_HIGH       <span class="co">; enable is detected</span>
        <span class="kw">mov</span>     <span class="kw">ch</span>,<span class="dt">byte</span> <span class="dt">ptr</span> StartOffset<span class="dv">+1</span>[<span class="kw">bp</span>]
        <span class="kw">mov</span>     <span class="kw">dx</span>,INPUT_STATUS_1
<span class="fu">WaitDE:</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">test</span>    <span class="kw">al</span><span class="bn">,01h</span>
        <span class="kw">jnz</span>     WaitDE  <span class="co">;display enable is active low (0 = active)</span>
<span class="co">; Set the start offset in display memory of the page to display.</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,CRTC_INDEX
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">bx</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>   <span class="co">;start address low</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">cx</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">ax</span>   <span class="co">;start address high</span>
<span class="co">; Now wait for vertical sync, so the other page will be invisible when</span>
<span class="co">; we start drawing to it.</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,INPUT_STATUS_1
<span class="fu">WaitVS:</span>
        <span class="kw">in</span>      <span class="kw">al</span>,<span class="kw">dx</span>
        <span class="kw">test</span>    <span class="kw">al</span><span class="bn">,08h</span>
        <span class="kw">jz</span>      WaitVS  <span class="co">;vertical sync is active high (1 = active)</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>      <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_ShowPage       endp
        end</code></pre>
</section>
<section id="works-fast-looks-great" class="level3">
<h3><a href="#works-fast-looks-great">Works Fast, Looks Great</a></h3>
<p>We now end our exploration of Mode X, although we’ll use it again shortly for 3-D animation. Mode X admittedly has its complexities; that’s why I’ve provided a broad and flexible primitive set. Still, so what if it <em>is</em> complex? Take a look at Listing 49.5 in action. That sort of colorful, high-performance animation is worth jumping through a few hoops for; drawing 20, or even 10, fair-sized objects at a rate of 60 Hz, with no flicker, interference, or fringe, is no mean accomplishment, even on a 386.</p>
<p>There’s much more we could do with animation in general and with Mode X in particular, but it’s time to move on to new challenges. In closing, I’d like to point out that all of the VGA’s hardware features, including the built-in AND, OR, and XOR functions, are available in Mode X, just as they are in the standard VGA modes. If you understand the VGA’s hardware in mode 12H, try applying that knowledge to Mode X; you might be surprised at what you find you can do.</p>
</section>
</section>
<section id="chapter-50-adding-a-dimension" class="level2">
<h2><a href="#chapter-50-adding-a-dimension">Chapter 50 – Adding a Dimension</a></h2>
<section id="d-animation-using-mode-x" class="level3">
<h3><a href="#d-animation-using-mode-x">3-D Animation Using Mode X</a></h3>
<p>When I first started programming micros, more than 11 years ago now, there wasn’t much money in it, or visibility, or anything you could call a promising career. Sometimes, it was a way to accomplish things that would never have gotten done otherwise because minicomputer time cost too much; other times, it paid the rent; mostly, though, it was just for fun. Given free computer time for the first time in my life, I went wild, writing versions of all sorts of software I had seen on mainframes, in arcades, wherever. It was a wonderful way to learn how computers work: Trial and error in an environment where nobody minded the errors, with no meter ticking.</p>
<p>Many sorts of software demanded no particular skills other than a quick mind and a willingness to experiment: Space Invaders, for instance, or full-screen operating system shells. Others, such as compilers, required a good deal of formal knowledge. Still others required not only knowledge but also more horse-power than I had available. The latter I filed away on my ever-growing wish list, and then forgot about for a while.</p>
<p>Three-dimensional animation was the most alluring of the areas I passed over long ago. The information needed to do rotation, projection, rendering, and the like was neither so well developed nor widely so available then as it is now, although, in truth, it seemed more intimidating than it ultimately proved to be. Even had I possessed the knowledge, though, it seems unlikely that I could have coaxed satisfactory 3-D animation out of a 4 MHz Z80 system with 160x72 monochrome graphics. In those days, 3-D was pretty much limited to outrageously expensive terminals attached to minis or mainframes.</p>
<p>Times change, and they seem to do so much faster in computer technology than in other parts of the universe. A 486 is capable of decent 3-D animation, owing to its integrated math coprocessor; not in the class of, say, an i860, but pretty good nonetheless. A 386 is less satisfactory, though; the 387 is no match for the 486’s coprocessor, and most 386 systems lack coprocessors. However, all is not lost; 32-bit registers and built-in integer multiply and divide hardware make it possible to do some very interesting 3-D animation on a 386 with fixed-point arithmetic. Actually, it’s possible to do a surprising amount of 3-D animation in real mode, and even on lesser x86 processors; in fact, the code in this article will perform real-time 3-D animation (admittedly very simple, but nonetheless real-time and 3-D) on a 286 without a 287, even though the code is written in real-mode C and uses floating-point arithmetic. In short, the potential for 3-D animation on the x86 family is considerable.</p>
<p>With this chapter, we kick off an exploration of some of the sorts of 3-D animation that can be performed on the x86 family. Mind you, I’m talking about real-time 3-D animation, with all calculations and drawing performed on-the-fly. Generating frames ahead of time and playing them back is an excellent technique, but I’m interested in seeing how far we can push purely real-time animation. Granted, we’re not going to make it to the level of Terminator 2, but we should have some fun nonetheless. The first few chapters in this final section of the book may seem pretty basic to those of you experienced with 3-D programming, and, at the same time, 3-D neophytes will inevitably be distressed at the amount of material I skip or skim over. That can’t be helped, but at least there’ll be working code, the references mentioned later, and some explanation; that should be enough to start you on your way with 3-D.</p>
<p>Animating in three dimensions is a complex task, so this will be the largest single section of the book, with later chapters building on earlier ones; and even this first 3-D chapter will rely on polygon fill and page-flip code from earlier chapters.</p>
<p>In a sense, I’ve saved the best for last, because, to my mind, real-time 3-D animation is one of the most exciting things of any stripe that can be done with a computer—and because, with today’s hardware, it can in fact be done. Nay, it can be done amazingly well.</p>
</section>
<section id="references-on-3-d-drawing" class="level3">
<h3><a href="#references-on-3-d-drawing">References on 3-D Drawing</a></h3>
<p>There are several good sources for information about 3-D graphics. Foley and van Dam’s <em>Computer Graphics: Principles and Practice</em> (Second Edition, Addison-Wesley, 1990) provides a lengthy discussion of the topic and a great many references for further study. Unfortunately, this book is heavy going at times; a more approachable discussion is provided in <em>Principles of Interactive Computer Graphics</em>, by Newman and Sproull (McGraw-Hill, 1979). Although the latter book lacks the last decade’s worth of graphics developments, it nonetheless provides a good overview of basic 3-D techniques, including many of the approaches likely to work well in realtime on a PC.</p>
<p>A source that you may or may not find useful is the series of six books on C graphics by Lee Adams, as exemplified by <em>High-Performance CAD Graphics in C</em> (Windcrest/Tab, 1986). (I don’t know if all six books discuss 3-D graphics, but the four I’ve seen do.) To be honest, this book has a number of problems, including: Relatively little theory and explanation; incomplete and sometimes erroneous discussions of graphics hardware; use of nothing but global variables, with cryptic names like “array3” and “B21;” and—well, you get the idea. On the other hand, the book at least touches on a great many aspects of 3-D drawing, and there’s a lot of C code to back that up. A number of people have spoken warmly to me of Adams’ books as their introduction to 3-D graphics. I wouldn’t recommend these books as your only 3-D references, but if you’re just starting out, you might want to look at one and see if it helps you bridge the gap between the theory and implementation of 3-D graphics.</p>
</section>
<section id="the-3-d-drawing-pipeline" class="level3">
<h3><a href="#the-3-d-drawing-pipeline">The 3-D Drawing Pipeline</a></h3>
<p>Each 3-D object that we’ll handle will be built out of polygons that represent the surface of the object. Figure 50.1 shows the stages a polygon goes through enroute to being drawn on the screen. (For the present, we’ll avoid complications such as clipping, lighting, and shading.) First, the polygon is transformed from object space, the coordinate system the object is defined in, to world space, the coordinate system of the 3-D universe. Transformation may involve rotating, scaling, and moving the polygon. Fortunately, applying the desired transformation to each of the polygon vertices in an object is equivalent to transforming the polygon; in other words, transformation of a polygon is fully defined by transformation of its vertices, so it is not necessary to transform every point in a polygon, just the vertices. Likewise, transformation of all the polygon vertices in an object fully transforms the object.</p>
<p>Once the polygon is in world space, it must again be transformed, this time into view space, the space defined such that the viewpoint is at (0,0,0), looking down the Z axis, with the Y axis straight up and the X axis off to the right. Once in view space, the polygon can be perspective-projected to the screen, with the projected X and Y coordinates of the vertices finally being used to draw the polygon.</p>
<p>That’s really all there is to basic 3-D drawing: transformation from object space to world space to view space to the screen. Next, we’ll look at the mechanics of transformation.</p>
<p>One note: I’ll use a purely <em>right-handed</em> convention for coordinate systems. Right-handed means that if you hold your right hand with your fingers curled and the thumb sticking out, the thumb points along the Z axis and the fingers point in the direction of rotation from the X axis to the Y axis, as shown in Figure 50.2. Rotations about an axis are counter-clockwise, as viewed looking down an axis toward the origin. The handedness of a coordinate system is just a convention, and left-handed would do equally well; however, right-handed is generally used for object and world space. Sometimes, the handedness is flipped for view space, so that increasing Z equals increasing distance from the viewer along the line of sight, but I have chosen not to do that here, to avoid confusion. Therefore, Z decreases as distance along the line of sight increases; a view space coordinate of (0,0,-1000) is directly ahead, twice as far away as a coordinate of (0,0,-500).</p>
<figure>
<img src="images/50-01.jpg" alt="Figure 50.1  The 3-D drawing pipeline." /><figcaption><strong>Figure 50.1</strong>  <em>The 3-D drawing pipeline.</em></figcaption>
</figure>
<figure>
<img src="images/50-02.jpg" alt="Figure 50.2  A right-handed coordinate system." /><figcaption><strong>Figure 50.2</strong>  <em>A right-handed coordinate system.</em></figcaption>
</figure>
<section id="projection" class="level4">
<h4><a href="#projection">Projection</a></h4>
<p>Working backward from the final image, we want to take the vertices of a polygon, as transformed into view space, and project them to 2-D coordinates on the screen, which, for projection purposes, is assumed to be centered on and perpendicular to the Z axis in view space, at some distance from the screen. We’re after visual realism, so we’ll want to do a perspective projection, in order that farther objects look smaller than nearer objects, and so that the field of view will widen with distance. This is done by scaling the X and Y coordinates of each point proportionately to the Z distance of the point from the viewer, a simple matter of similar triangles, as shown in Figure 50.3. It doesn’t really matter how far down the Z axis the screen is assumed to be; what matters is the ratio of the distance of the screen from the viewpoint to the width of the screen. This ratio defines the rate of divergence of the viewing pyramid—the full field of view—and is used for performing all perspective projections. Once perspective projection has been performed, all that remains before calling the polygon filler is to convert the projected X and Y coordinates to integers, appropriately clipped and adjusted as necessary to center the origin on the screen or otherwise map the image into a window, if desired.</p>
</section>
<section id="translation" class="level4">
<h4><a href="#translation">Translation</a></h4>
<p><em>Translation</em> means adding X, Y, and Z offsets to a coordinate to move it linearly through space. Translation is as simple as it seems; it requires nothing more than an addition for each axis. Translation is, for example, used to move objects from object space, in which the center of the object is typically the origin (0,0,0), into world space, where the object may be located anywhere.</p>
<figure>
<img src="images/50-03.jpg" alt="Figure 50.3  Perspective projection." /><figcaption><strong>Figure 50.3</strong>  <em>Perspective projection.</em></figcaption>
</figure>
</section>
<section id="rotation" class="level4">
<h4><a href="#rotation">Rotation</a></h4>
<p><em>Rotation</em> is the process of circularly moving coordinates around the origin. For our present purposes, it’s necessary only to rotate objects about their centers in object space, so as to turn them to the desired attitude before translating them into world space.</p>
<p>Rotation of a point about an axis is accomplished by transforming it according to the formulas shown in Figure 50.4. These formulas map into the more generally useful matrix-multiplication forms also shown in Figure 50.4. Matrix representation is more useful for two reasons: First, it is possible to concatenate multiple rotations into a single matrix by multiplying them together in the desired order; that single matrix can then be used to perform the rotations more efficiently.</p>
<figure>
<img src="images/50-04.jpg" alt="Figure 50.4  3-D rotation formulas." /><figcaption><strong>Figure 50.4</strong>  <em>3-D rotation formulas.</em></figcaption>
</figure>
<p>Second, 3x3 rotation matrices can become the upper-left-hand portions of 4x4 matrices that also perform translation (and scaling as well, but we won’t need scaling in the near future), as shown in Figure 50.5. A 4x4 matrix of this sort utilizes homogeneous coordinates; that’s a topic way beyond this book, but, basically, homogeneous coordinates allow you to handle both rotations and translations with 4x4 matrices, thereby allowing the same code to work with either, and making it possible to concatenate a long series of rotations and translations into a single matrix that performs the same transformation as the sequence of rotations and transformations.</p>
<p>There’s much more to be said about transformations and the supporting matrix math, but, in the interests of getting to working code in this chapter, I’ll leave that to be discussed as the need arises.</p>
</section>
</section>
<section id="a-simple-3-d-example" class="level3">
<h3><a href="#a-simple-3-d-example">A Simple 3-D Example</a></h3>
<p>At this point, we know enough to be able to put together a simple working 3-D animation example. The example will do nothing more complicated than display a single polygon as it sits in 3-D space, rotating around the Y axis. To make things a little more interesting, we’ll let the user move the polygon around in space with the arrow keys, and with the “A” (away), and “T” (toward) keys. The sample program requires two sorts of functionality: The ability to transform and project the polygon from object space onto the screen (3-D functionality), and the ability to draw the projected polygon (complete with clipping) and handle the other details of animation (2-D functionality).</p>
<figure>
<img src="images/50-05.jpg" alt="Figure 50.5  A 4x4 Transformation Matrix." /><figcaption><strong>Figure 50.5</strong>  <em>A 4x4 Transformation Matrix.</em></figcaption>
</figure>
<p>Happily (and not coincidentally), we put together a nice 2-D animation framework back in Chapters 47, 48, and 49, during our exploratory discussion of Mode X, so we don’t have much to worry about in terms of non-3-D details. Basically, we’ll use Mode X (320x240, 256 colors), and we’ll flip between two display pages, drawing to one while the other is displayed. One new 2-D element that we need is the ability to clip polygons; while we could avoid this for the moment by restricting the range of motion of the polygon so that it stays fully on the screen, certainly in the long run we’ll want to be able to handle partially or fully clipped polygons. Listing 50.1 is the low-level code for a Mode X polygon filler that supports clipping. (The high-level polygon fill code is mode independent, and is the same as that presented in Chapters 38, 39, and 40, as noted further on.) The clipping is implemented at the low level, by trimming the Y extent of the scan line list up front, then clipping the X coordinates of each scan line in turn. This is not a particularly fast approach to clipping—ideally, the polygon would be clipped before it was scanned into a line list, avoiding potentially wasted scanning and eliminating the line-by-line X clipping—but it’s much simpler, and, as we shall see, polygon filling performance is the least of our worries at the moment.</p>
<p><strong>LISTING 50.1 L50-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Draws all pixels in the list of horizontal lines passed in, in</span>
<span class="co">; Mode X, the VGA&#39;s undocumented 320x240 256-color mode. Clips to</span>
<span class="co">; the rectangle specified by (ClipMinX,ClipMinY),(ClipMaxX,ClipMaxY).</span>
<span class="co">; Draws to the page specified by CurrentPageBase.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;</span>
<span class="co">;     void DrawHorizontalLineList(struct HLineList * HLineListPtr,</span>
<span class="co">;          int Color);</span>
<span class="co">;</span>
<span class="co">; All assembly code tested with TASM and MASM</span>

SCREEN_WIDTH    <span class="dt">equ</span>   <span class="dv">320</span>
SCREEN_SEGMENT  <span class="dt">equ</span><span class="bn">   0a000h</span>
SC_INDEX        <span class="dt">equ</span><span class="bn">   03c4h        </span><span class="co">;Sequence Controller Index</span>
MAP_MASK        <span class="dt">equ</span>   <span class="dv">2</span>            <span class="co">;Map Mask register index in SC</span>

HLine   <span class="kw">struc</span>
XStart          <span class="dt">dw</span>      ?          <span class="co">;X coordinate of leftmost pixel in line</span>
XEnd            <span class="dt">dw</span>      ?          <span class="co">;X coordinate of rightmost pixel in line</span>
HLine   ends

HLineList <span class="kw">struc</span>
Lngth           <span class="dt">dw</span>      ?          <span class="co">;# of horizontal lines</span>
YStart          <span class="dt">dw</span>      ?          <span class="co">;Y coordinate of topmost line</span>
HLinePtr        <span class="dt">dw</span>      ?          <span class="co">;pointer to list of horz lines</span>
HLineList ends

Parms   <span class="kw">struc</span>
                <span class="dt">dw</span>      <span class="dv">2</span> dup(?)   <span class="co">;return address &amp; pushed BP</span>
HLineListPtr    <span class="dt">dw</span>      ?          <span class="co">;pointer to HLineList structure</span>
Color           <span class="dt">dw</span>      ?          <span class="co">;color with which to fill</span>
Parms   ends
        .model small
        .data
        extrn   _CurrentPageBase:<span class="dt">word</span>,_ClipMinX:<span class="dt">word</span>
        extrn   _ClipMinY:<span class="dt">word</span>,_ClipMaxX:<span class="dt">word</span>,_ClipMaxY:<span class="dt">word</span>
<span class="co">; Plane masks for clipping left and right edges of rectangle.</span>
LeftClipPlaneMask       <span class="dt">db</span><span class="bn">      00fh,</span>00eh<span class="bn">,00ch,</span>008h
RightClipPlaneMask      <span class="dt">db</span><span class="bn">      001h,</span>003h<span class="bn">,007h,</span>00fh
        .code
        <span class="kw">align</span>   <span class="dv">2</span>
<span class="fu">ToFillDone:</span>
        <span class="kw">jmp</span>     FillDone
        public _DrawHorizontalLineList
        <span class="kw">align</span>   <span class="dv">2</span>
_DrawHorizontalLineList proc
        <span class="kw">push</span>    <span class="kw">bp</span>                 <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>              <span class="co">;point to our stack frame</span>
        <span class="kw">push</span>    <span class="kw">si</span>                 <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>
        <span class="kw">cld</span>                        <span class="co">;make string instructions inc pointers</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP_MASK
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>              <span class="co">;point SC Index to the Map Mask</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_SEGMENT
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>              <span class="co">;point ES to display memory for REP STOS</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>+HLineListPtr] <span class="co">;point to the line list</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">si</span>+HLinePtr]     <span class="co">;point to the XStart/XEnd descriptor</span>
                                   <span class="co">; for the first (top) horizontal line</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">si</span>+YStart] <span class="co">;first scan line to draw</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">si</span>+Lngth]  <span class="co">;# of scan lines to draw</span>
        <span class="kw">cmp</span>     <span class="kw">si</span>,<span class="dv">0</span>               <span class="co">;are there any lines to draw?</span>
        <span class="kw">jle</span>     ToFillDone         <span class="co">;no, so we&#39;re done</span>
        <span class="kw">cmp</span>     <span class="kw">cx</span>,[_ClipMinY]     <span class="co">;clipped at top?</span>
        <span class="kw">jge</span>     MinYNotClipped     <span class="co">;no</span>
        <span class="kw">neg</span>     <span class="kw">cx</span>                 <span class="co">;yes, discard however many lines are</span>
        <span class="kw">add</span>     <span class="kw">cx</span>,[_ClipMinY]     <span class="co">; clipped</span>
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">cx</span>              <span class="co">;that many fewer lines to draw</span>
        <span class="kw">jle</span>     ToFillDone         <span class="co">;no lines left to draw</span>
        <span class="kw">shl</span>     <span class="kw">cx</span>,<span class="dv">1</span>               <span class="co">;lines to skip*2</span>
        <span class="kw">shl</span>     <span class="kw">cx</span>,<span class="dv">1</span>               <span class="co">;lines to skip*4</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,<span class="kw">cx</span>              <span class="co">;advance through the line list</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[_ClipMinY]     <span class="co">;start at the top clip line</span>
<span class="fu">MinYNotClipped:</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="kw">si</span>
        <span class="kw">add</span>     <span class="kw">dx</span>,<span class="kw">cx</span>              <span class="co">;bottom row to draw + 1</span>
        <span class="kw">cmp</span>     <span class="kw">dx</span>,[_ClipMaxY]     <span class="co">;clipped at bottom?</span>
        <span class="kw">jle</span>     MaxYNotClipped     <span class="co">;no</span>
        <span class="kw">sub</span>     <span class="kw">dx</span>,[_ClipMaxY]     <span class="co">;# of lines to clip off the bottom</span>
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">dx</span>              <span class="co">;# of lines left to draw</span>
        <span class="kw">jle</span>     ToFillDone         <span class="co">;all lines are clipped</span>
<span class="fu">MaxYNotClipped:</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN_WIDTH/<span class="dv">4</span>  <span class="co">;point to the start of the first</span>
        <span class="kw">mul</span>     <span class="kw">cx</span>                 <span class="co">; scan line on which to draw</span>
        <span class="kw">add</span>     <span class="kw">ax</span>,[_CurrentPageBase] <span class="co">;offset of first line</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="kw">ax</span>              <span class="co">;ES:DX points to first scan line to draw</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,<span class="dt">byte</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Color] <span class="co">;color with which to fill</span>
<span class="fu">FillLoop:</span>
        <span class="kw">push</span>    <span class="kw">bx</span>                 <span class="co">;remember line list location</span>
        <span class="kw">push</span>    <span class="kw">dx</span>                 <span class="co">;remember offset of start of line</span>
        <span class="kw">push</span>    <span class="kw">si</span>                 <span class="co">;remember # of lines to draw</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bx</span>+XStart] <span class="co">;left edge of fill on this line</span>
        <span class="kw">cmp</span>     <span class="kw">di</span>,[_ClipMinX]     <span class="co">;clipped to left edge?</span>
        <span class="kw">jge</span>     MinXNotClipped     <span class="co">;no</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[_ClipMinX]     <span class="co">;yes, clip to the left edge</span>
<span class="fu">MinXNotClipped:</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,<span class="kw">di</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[<span class="kw">bx</span>+XEnd]   <span class="co">;right edge of fill</span>
        <span class="kw">cmp</span>     <span class="kw">cx</span>,[_ClipMaxX]     <span class="co">;clipped to right edge?</span>
        <span class="kw">jl</span>      MaxXNotClipped     <span class="co">;no</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[_ClipMaxX]     <span class="co">;yes, clip to the right edge</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>
<span class="fu">MaxXNotClipped:</span>
        <span class="kw">cmp</span>     <span class="kw">cx</span>,<span class="kw">di</span>
        <span class="kw">jl</span>      LineFillDone       <span class="co">;skip if negative width</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>    <span class="co">;X/4 = offset of first rect pixel in scan</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>    <span class="co">; line</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">dx</span>   <span class="co">;offset of first rect pixel in display mem</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="kw">si</span>   <span class="co">;XStart</span>
        <span class="kw">and</span>     <span class="kw">si</span><span class="bn">,0003h    </span><span class="co">;look up left-edge plane mask</span>
        <span class="kw">mov</span>     <span class="kw">bh</span>,LeftClipPlaneMask[<span class="kw">si</span>] <span class="co">; to clip &amp; put in BH</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,<span class="kw">cx</span>
        <span class="kw">and</span>     <span class="kw">si</span><span class="bn">,0003h           </span><span class="co">;look up right-edge plane</span>
        <span class="kw">mov</span>     <span class="kw">bl</span>,RightClipPlaneMask[<span class="kw">si</span>] <span class="co">; mask to clip &amp; put in BL</span>
        <span class="kw">and</span>     <span class="kw">dx</span>,<span class="kw">not</span><span class="bn"> 011b        </span><span class="co">;calculate # of addresses across rect</span>
        <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">dx</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">cx</span>,<span class="dv">1</span>               <span class="co">;# of addresses across rectangle to fill - 1</span>
        <span class="kw">jnz</span>     MasksSet           <span class="co">;there&#39;s more than one byte to draw</span>
        <span class="kw">and</span>     <span class="kw">bh</span>,<span class="kw">bl</span>              <span class="co">;there&#39;s only one byte, so combine the left</span>
                                   <span class="co">; and right edge clip masks</span>
<span class="fu">MasksSet:</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC_INDEX<span class="dv">+1</span>  <span class="co">;already points to the Map Mask reg</span>
<span class="fu">FillRowsLoop:</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">bh</span>              <span class="co">;put left-edge clip mask in AL</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>              <span class="co">;set the left-edge plane (clip) mask</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">ah</span>              <span class="co">;put color in AL</span>
        <span class="kw">stosb</span>                      <span class="co">;draw the left edge</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>                 <span class="co">;count off left edge byte</span>
        <span class="kw">js</span>      FillLoopBottom     <span class="co">;that&#39;s the only byte</span>
        <span class="kw">jz</span>      DoRightEdge        <span class="co">;there are only two bytes</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,00fh            </span><span class="co">;middle addresses are drawn 4 pixels at a pop</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>              <span class="co">;set the middle pixel mask to no clip</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">ah</span>              <span class="co">;put color in AL</span>
        rep     <span class="kw">stosb</span>              <span class="co">;draw the middle addresses four pixels apiece</span>
<span class="fu">DoRightEdge:</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">bl</span>              <span class="co">;put right-edge clip mask in AL</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>              <span class="co">;set the right-edge plane (clip) mask</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,<span class="kw">ah</span>              <span class="co">;put color in AL</span>
        <span class="kw">stosb</span>                      <span class="co">;draw the right edge</span>
<span class="fu">FillLoopBottom:</span>
<span class="fu">LineFillDone:</span>
        <span class="kw">pop</span>     <span class="kw">si</span>                 <span class="co">;retrieve # of lines to draw</span>
        <span class="kw">pop</span>     <span class="kw">dx</span>                 <span class="co">;retrieve offset of start of line</span>
        <span class="kw">pop</span>     <span class="kw">bx</span>                 <span class="co">;retrieve line list location</span>
        <span class="kw">add</span>     <span class="kw">dx</span>,SCREEN_WIDTH/<span class="dv">4</span>  <span class="co">;point to start of next line</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,size HLine      <span class="co">;point to the next line descriptor</span>
        <span class="kw">dec</span>     <span class="kw">si</span>                 <span class="co">;count down lines</span>
        <span class="kw">jnz</span>     FillLoop
<span class="fu">FillDone:</span>
        <span class="kw">pop</span>     <span class="kw">di</span>                 <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>                 <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
_DrawHorizontalLineList endp
        end</code></pre>
<p>The other 2-D element we need is some way to erase the polygon at its old location before it’s moved and redrawn. We’ll do that by remembering the bounding rectangle of the polygon each time it’s drawn, then erasing by clearing that area with a rectangle fill.</p>
<p>With the 2-D side of the picture well under control, we’re ready to concentrate on the good stuff. Listings 50.2 through 50.5 are the sample 3-D animation program. Listing 50.2 provides matrix multiplication functions in a straightforward fashion. Listing 50.3 transforms, projects, and draws polygons. Listing 50.4 is the general header file for the program, and Listing 50.5 is the main animation program.</p>
<p>Other modules required are: Listings 47.1 and 47.6 from Chapter 47 (Mode X mode set, rectangle fill); Listing 49.6 from Chapter 49; Listing 39.4 from Chapter 39 (polygon edge scan); and the <code>FillConvexPolygon()</code> function from Listing 38.1 in Chapter 38. All necessary code modules, along with a project file, are present in the subdirectory for this chapter on the listings disk, whether they were presented in this chapter or some earlier chapter. This will be the case for the next several chapters as well, where listings from previous chapters are referenced. This scheme may crowd the listings diskette a little bit, but it will certainly reduce confusion!</p>
<p><strong>LISTING 50.2 L50-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Matrix arithmetic functions.</span>
<span class="co">   Tested with Borland C++ in the small model. */</span>

<span class="co">/* Matrix multiplies Xform by SourceVec, and stores the result in</span>
<span class="co">   DestVec. Multiplies a 4x4 matrix times a 4x1 matrix; the result</span>
<span class="co">   is a 4x1 matrix, as follows:</span>
<span class="co">   --     --     -- --     -- --</span>
<span class="co">   |       |     | 4 |     | 4 |</span>
<span class="co">   |  4x4  |  X  | x |  =  | x |</span>
<span class="co">   |       |     | 1 |     | 1 |</span>
<span class="co">   --     --     -- --     -- -- */</span>
<span class="dt">void</span> XformVec(<span class="dt">double</span> Xform[<span class="dv">4</span>][<span class="dv">4</span>], <span class="dt">double</span> * SourceVec,
   <span class="dt">double</span> * DestVec)
{
   <span class="dt">int</span> i,j;

   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">4</span>; i++) {
      DestVec[i] = <span class="dv">0</span>;
      <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;<span class="dv">4</span>; j++)
         DestVec[i] += Xform[i][j] * SourceVec[j];
   }
}

<span class="co">/* Matrix multiplies SourceXform1 by SourceXform2 and stores the</span>
<span class="co">   result in DestXform. Multiplies a 4x4 matrix times a 4x4 matrix;</span>
<span class="co">   the result is a 4x4 matrix, as follows:</span>
<span class="co">   --     --     --     --     --     --</span>
<span class="co">   |       |     |       |     |       |</span>
<span class="co">   |  4x4  |  X  |  4x4  |  =  |  4x4  |</span>
<span class="co">   |       |     |       |     |       |</span>
<span class="co">   --     --     --     --     --     -- */</span>
<span class="dt">void</span> ConcatXforms(<span class="dt">double</span> SourceXform1[<span class="dv">4</span>][<span class="dv">4</span>], <span class="dt">double</span> SourceXform2[<span class="dv">4</span>][<span class="dv">4</span>],
   <span class="dt">double</span> DestXform[<span class="dv">4</span>][<span class="dv">4</span>])
{
   <span class="dt">int</span> i,j,k;

   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">4</span>; i++) {
      <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;<span class="dv">4</span>; j++) {
         DestXform[i][j] = <span class="dv">0</span>;
         <span class="kw">for</span> (k=<span class="dv">0</span>; k&lt;<span class="dv">4</span>; k++)
            DestXform[i][j] += SourceXform1[i][k] * SourceXform2[k][j];
      }
   }
}</code></pre>
<p><strong>LISTING 50.3 L50-3.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Transforms convex polygon Poly (which has PolyLength vertices),</span>
<span class="co">   performing the transformation according to Xform (which generally</span>
<span class="co">   represents a transformation from object space through world space</span>
<span class="co">   to view space), then projects the transformed polygon onto the</span>
<span class="co">   screen and draws it in color ???Color. Also updates the extent of the</span>
<span class="co">   rectangle (EraseRect) that&#39;s used to erase the screen later.</span>
<span class="co">   Tested with Borland C++ in the small model. */</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="dt">void</span> XformAndProjectPoly(<span class="dt">double</span> Xform[<span class="dv">4</span>][<span class="dv">4</span>], <span class="kw">struct</span> Point3 * Poly,
   <span class="dt">int</span> PolyLength, <span class="dt">int</span> Color)
{
   <span class="dt">int</span> i;
   <span class="kw">struct</span> Point3 XformedPoly[MAX_POLY_LENGTH];
   <span class="kw">struct</span> Point ProjectedPoly[MAX_POLY_LENGTH];
   <span class="kw">struct</span> PointListHeader Polygon;

   <span class="co">/* Transform to view space, then project to the screen */</span>
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;PolyLength; i++) {
      <span class="co">/* Transform to view space */</span>
      XformVec(Xform, (<span class="dt">double</span> *)&amp;Poly[i], (<span class="dt">double</span> *)&amp;XformedPoly[i]);
      <span class="co">/* Project the X &amp; Y coordinates to the screen, rounding to the</span>
<span class="co">         nearest integral coordinates. The Y coordinate is negated to</span>
<span class="co">         flip from view space, where increasing Y is up, to screen</span>
<span class="co">         space, where increasing Y is down. Add in half the screen</span>
<span class="co">         width and height to center on the screen */</span>
      ProjectedPoly[i].X = ((<span class="dt">int</span>) (XformedPoly[i].X/XformedPoly[i].Z *
            PROJECTION_RATIO*(SCREEN_WIDTH/<span class="fl">2.0</span>)+<span class="fl">0.5</span>))+SCREEN_WIDTH/<span class="dv">2</span>;
      ProjectedPoly[i].Y = ((<span class="dt">int</span>) (XformedPoly[i].Y/XformedPoly[i].Z *
            -<span class="fl">1.0</span> * PROJECTION_RATIO * (SCREEN_WIDTH / <span class="fl">2.0</span>) + <span class="fl">0.5</span>)) +
            SCREEN_HEIGHT/<span class="dv">2</span>;
      <span class="co">/* Appropriately adjust the extent of the rectangle used to</span>
<span class="co">         erase this page later */</span>
         <span class="kw">if</span> (ProjectedPoly[i].X &gt; EraseRect[NonDisplayedPage].Right)
          <span class="kw">if</span> (ProjectedPoly[i].X &lt; SCREEN_WIDTH)
            EraseRect[NonDisplayedPage].Right = ProjectedPoly[i].X;
          <span class="kw">else</span> EraseRect[NonDisplayedPage].Right = SCREEN_WIDTH;
         <span class="kw">if</span> (ProjectedPoly[i].Y &gt; EraseRect[NonDisplayedPage].Bottom)
          <span class="kw">if</span> (ProjectedPoly[i].Y &lt; SCREEN_HEIGHT)
            EraseRect[NonDisplayedPage].Bottom = ProjectedPoly[i].Y;
          <span class="kw">else</span> EraseRect[NonDisplayedPage].Bottom = SCREEN_HEIGHT;
         <span class="kw">if</span> (ProjectedPoly[i].X &lt; EraseRect[NonDisplayedPage].Left)
          <span class="kw">if</span> (ProjectedPoly[i].X &gt; <span class="dv">0</span>)
            EraseRect[NonDisplayedPage].Left = ProjectedPoly[i].X;
          <span class="kw">else</span> EraseRect[NonDisplayedPage].Left = <span class="dv">0</span>;
         <span class="kw">if</span> (ProjectedPoly[i].Y &lt; EraseRect[NonDisplayedPage].Top)
          <span class="kw">if</span> (ProjectedPoly[i].Y &gt; <span class="dv">0</span>)
            EraseRect[NonDisplayedPage].Top = ProjectedPoly[i].Y;
          <span class="kw">else</span> EraseRect[NonDisplayedPage].Top = <span class="dv">0</span>;
   }
   <span class="co">/* Draw the polygon */</span>
   DRAW_POLYGON(ProjectedPoly, PolyLength, Color, <span class="dv">0</span>, <span class="dv">0</span>);
}</code></pre>
<p><strong>LISTING 50.4 POLYGON.H</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* POLYGON.H: Header file for polygon-filling code, also includes</span>
<span class="co">   a number of useful items for 3-D animation. */</span>

<span class="ot">#define MAX_POLY_LENGTH 4  </span><span class="co">/* four vertices is the max per poly */</span>
<span class="ot">#define SCREEN_WIDTH 320</span>
<span class="ot">#define SCREEN_HEIGHT 240</span>
<span class="ot">#define PAGE0_START_OFFSET 0</span>
<span class="ot">#define PAGE1_START_OFFSET (((long)SCREEN_HEIGHT*SCREEN_WIDTH)/4)</span>
<span class="co">/* Ratio: distance from viewpoint to projection plane / width of</span>
<span class="co">   projection plane. Defines the width of the field of view. Lower</span>
<span class="co">   absolute values = wider fields of view; higher values = narrower */</span>
<span class="ot">#define PROJECTION_RATIO   -2.0 </span><span class="co">/* negative because visible Z</span>
<span class="co">                                   coordinates are negative */</span>
<span class="co">/* Draws the polygon described by the point list PointList in color</span>
<span class="co">   Color with all vertices offset by (X,Y) */</span>
<span class="ot">#define DRAW_POLYGON(PointList,NumPoints,Color,X,Y)         \</span>
   Polygon.Length = NumPoints;                              \
   Polygon.PointPtr = PointList;                            \
   FillConvexPolygon(&amp;Polygon, Color, X, Y);

<span class="co">/* Describes a single 2-D point */</span>
<span class="kw">struct</span> Point {
   <span class="dt">int</span> X;   <span class="co">/* X coordinate */</span>
   <span class="dt">int</span> Y;   <span class="co">/* Y coordinate */</span>
};
<span class="co">/* Describes a single 3-D point in homogeneous coordinates */</span>
<span class="kw">struct</span> Point3 {
   <span class="dt">double</span> X;   <span class="co">/* X coordinate */</span>
   <span class="dt">double</span> Y;   <span class="co">/* Y coordinate */</span>
   <span class="dt">double</span> Z;   <span class="co">/* Z coordinate */</span>
   <span class="dt">double</span> W;
};
<span class="co">/* Describes a series of points (used to store a list of vertices that</span>
<span class="co">   describe a polygon; each vertex is assumed to connect to the two</span>
<span class="co">   adjacent vertices, and the last vertex is assumed to connect to the</span>
<span class="co">   first) */</span>
<span class="kw">struct</span> PointListHeader {
   <span class="dt">int</span> Length;                <span class="co">/* # of points */</span>
   <span class="kw">struct</span> Point * PointPtr;   <span class="co">/* pointer to list of points */</span>
};

<span class="co">/* Describes the beginning and ending X coordinates of a single</span>
<span class="co">   horizontal line */</span>
<span class="kw">struct</span> HLine {
   <span class="dt">int</span> XStart; <span class="co">/* X coordinate of leftmost pixel in line */</span>
   <span class="dt">int</span> XEnd;   <span class="co">/* X coordinate of rightmost pixel in line */</span>
};

<span class="co">/* Describes a Length-long series of horizontal lines, all assumed to</span>
<span class="co">   be on contiguous scan lines starting at YStart and proceeding</span>
<span class="co">   downward (used to describe a scan-converted polygon to the</span>
<span class="co">   low-level hardware-dependent drawing code) */</span>
<span class="kw">struct</span> HLineList {
   <span class="dt">int</span> Length;                <span class="co">/* # of horizontal lines */</span>
   <span class="dt">int</span> YStart;                <span class="co">/* Y coordinate of topmost line */</span>
   <span class="kw">struct</span> HLine * HLinePtr;   <span class="co">/* pointer to list of horz lines */</span>
};
<span class="kw">struct</span> Rect { <span class="dt">int</span> Left, Top, Right, Bottom; };

<span class="kw">extern</span> <span class="dt">void</span> XformVec(<span class="dt">double</span> Xform[<span class="dv">4</span>][<span class="dv">4</span>], <span class="dt">double</span> * SourceVec,
   <span class="dt">double</span> * DestVec);
<span class="kw">extern</span> <span class="dt">void</span> ConcatXforms(<span class="dt">double</span> SourceXform1[<span class="dv">4</span>][<span class="dv">4</span>],
   <span class="dt">double</span> SourceXform2[<span class="dv">4</span>][<span class="dv">4</span>], <span class="dt">double</span> DestXform[<span class="dv">4</span>][<span class="dv">4</span>]);
<span class="kw">extern</span> <span class="dt">void</span> XformAndProjectPoly(<span class="dt">double</span> Xform[<span class="dv">4</span>][<span class="dv">4</span>],
   <span class="kw">struct</span> Point3 * Poly, <span class="dt">int</span> PolyLength, <span class="dt">int</span> Color);
<span class="kw">extern</span> <span class="dt">int</span> FillConvexPolygon(<span class="kw">struct</span> PointListHeader *, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> Set320x240Mode(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">void</span> ShowPage(<span class="dt">unsigned</span> <span class="dt">int</span> StartOffset);
<span class="kw">extern</span> <span class="dt">void</span> FillRectangleX(<span class="dt">int</span> StartX, <span class="dt">int</span> StartY, <span class="dt">int</span> EndX,
   <span class="dt">int</span> EndY, <span class="dt">unsigned</span> <span class="dt">int</span> PageBase, <span class="dt">int</span> Color);
<span class="kw">extern</span> <span class="dt">int</span> DisplayedPage, NonDisplayedPage;
<span class="kw">extern</span> <span class="kw">struct</span> Rect EraseRect[];</code></pre>
<p><strong>LISTING 50.5 L50-5.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Simple 3-D drawing program to view a polygon as it rotates in</span>
<span class="co">   Mode X. View space is congruent with world space, with the</span>
<span class="co">   viewpoint fixed at the origin (0,0,0) of world space, looking in</span>
<span class="co">   the direction of increasingly negative Z. A right-handed</span>
<span class="co">   coordinate system is used throughout.</span>
<span class="co">   Tested with Borland C++ in the small model. */</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>
<span class="dt">void</span> main(<span class="dt">void</span>);

<span class="co">/* Base offset of page to which to draw */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> CurrentPageBase = <span class="dv">0</span>;
<span class="co">/* Clip rectangle; clips to the screen */</span>
<span class="dt">int</span> ClipMinX=<span class="dv">0</span>, ClipMinY=<span class="dv">0</span>;
<span class="dt">int</span> ClipMaxX=SCREEN_WIDTH, ClipMaxY=SCREEN_HEIGHT;
<span class="co">/* Rectangle specifying extent to be erased in each page */</span>
<span class="kw">struct</span> Rect EraseRect[<span class="dv">2</span>] = { {<span class="dv">0</span>, <span class="dv">0</span>, SCREEN_WIDTH, SCREEN_HEIGHT},
   {<span class="dv">0</span>, <span class="dv">0</span>, SCREEN_WIDTH, SCREEN_HEIGHT} };
<span class="co">/* Transformation from polygon&#39;s object space to world space.</span>
<span class="co">   Initially set up to perform no rotation and to move the polygon</span>
<span class="co">   into world space -140 units away from the origin down the Z axis.</span>
<span class="co">   Given the viewing point, -140 down the Z axis means 140 units away</span>
<span class="co">   straight ahead in the direction of view. The program dynamically</span>
<span class="co">   changes the rotation and translation. */</span>
<span class="dt">static</span> <span class="dt">double</span> PolyWorldXform[<span class="dv">4</span>][<span class="dv">4</span>] = {
   {<span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>},
   {<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>},
   {<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>, -<span class="fl">140.0</span>},
   {<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>} };
<span class="co">/* Transformation from world space into view space. In this program,</span>
<span class="co">   the view point is fixed at the origin of world space, looking down</span>
<span class="co">   the Z axis in the direction of increasingly negative Z, so view</span>
<span class="co">   space is identical to world space; this is the identity matrix. */</span>
<span class="dt">static</span> <span class="dt">double</span> WorldViewXform[<span class="dv">4</span>][<span class="dv">4</span>] = {
   {<span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>},
   {<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>},
   {<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>},
   {<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>}
};
<span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">int</span> PageStartOffsets[<span class="dv">2</span>] =
   {PAGE0_START_OFFSET,PAGE1_START_OFFSET};
<span class="dt">int</span> DisplayedPage, NonDisplayedPage;

<span class="dt">void</span> main() {
   <span class="dt">int</span> Done = <span class="dv">0</span>;
   <span class="dt">double</span> WorkingXform[<span class="dv">4</span>][<span class="dv">4</span>];
   <span class="dt">static</span> <span class="kw">struct</span> Point3 TestPoly[] =
         {{-<span class="dv">30</span>,-<span class="dv">15</span>,<span class="dv">0</span>,<span class="dv">1</span>},{<span class="dv">0</span>,<span class="dv">15</span>,<span class="dv">0</span>,<span class="dv">1</span>},{<span class="dv">10</span>,-<span class="dv">5</span>,<span class="dv">0</span>,<span class="dv">1</span>}};
<span class="ot">#define TEST_POLY_LENGTH   (sizeof(TestPoly)/sizeof(struct Point3))</span>
   <span class="dt">double</span> Rotation = M_PI / <span class="fl">60.0</span>; <span class="co">/* initial rotation = 3 degrees */</span>
   <span class="kw">union</span> REGS regset;

   Set320x240Mode();
   ShowPage(PageStartOffsets[DisplayedPage = <span class="dv">0</span>]);
   <span class="co">/* Keep rotating the polygon, drawing it to the undisplayed page,</span>
<span class="co">      and flipping the page to show it */</span>
   <span class="kw">do</span> {
      CurrentPageBase =    <span class="co">/* select other page for drawing to */</span>
            PageStartOffsets[NonDisplayedPage = DisplayedPage ^ <span class="dv">1</span>];
      <span class="co">/* Modify the object space to world space transformation matrix</span>
<span class="co">         for the current rotation around the Y axis */</span>
      PolyWorldXform[<span class="dv">0</span>][<span class="dv">0</span>] = PolyWorldXform[<span class="dv">2</span>][<span class="dv">2</span>] = cos(Rotation);
      PolyWorldXform[<span class="dv">2</span>][<span class="dv">0</span>] = -(PolyWorldXform[<span class="dv">0</span>][<span class="dv">2</span>] = sin(Rotation));
      <span class="co">/* Concatenate the object-to-world and world-to-view</span>
<span class="co">         transformations to make a transformation matrix that will</span>
<span class="co">         convert vertices from object space to view space in a single</span>
<span class="co">         operation */</span>
      ConcatXforms(WorldViewXform, PolyWorldXform, WorkingXform);
      <span class="co">/* Clear the portion of the non-displayed page that was drawn</span>
<span class="co">         to last time, then reset the erase extent */</span>
      FillRectangleX(EraseRect[NonDisplayedPage].Left,
            EraseRect[NonDisplayedPage].Top,
            EraseRect[NonDisplayedPage].Right,
            EraseRect[NonDisplayedPage].Bottom, CurrentPageBase, <span class="dv">0</span>);
      EraseRect[NonDisplayedPage].Left =
            EraseRect[NonDisplayedPage].Top = <span class="bn">0x7FFF</span>;
      EraseRect[NonDisplayedPage].Right =
         EraseRect[NonDisplayedPage].Bottom = <span class="dv">0</span>;
      <span class="co">/* Transform the polygon, project it on the screen, draw it */</span>
      XformAndProjectPoly(WorkingXform, TestPoly, TEST_POLY_LENGTH,<span class="dv">9</span>);
      <span class="co">/* Flip to display the page into which we just drew */</span>
      ShowPage(PageStartOffsets[DisplayedPage = NonDisplayedPage]);
      <span class="co">/* Rotate 6 degrees farther around the Y axis */</span>
      <span class="kw">if</span> ((Rotation += (M_PI/<span class="fl">30.0</span>)) &gt;= (M_PI*<span class="dv">2</span>)) Rotation -= M_PI*<span class="dv">2</span>;
      <span class="kw">if</span> (kbhit()) {
         <span class="kw">switch</span> (getch()) {
            <span class="kw">case</span> <span class="bn">0x1B</span>:     <span class="co">/* Esc to exit */</span>
               Done = <span class="dv">1</span>; <span class="kw">break</span>;
            <span class="kw">case</span> ‘A&#39;: <span class="kw">case</span> ‘a&#39;:      <span class="co">/* away (-Z) */</span>
               PolyWorldXform[<span class="dv">2</span>][<span class="dv">3</span>] -= <span class="fl">3.0</span>; <span class="kw">break</span>;
            <span class="kw">case</span> ‘T&#39;:      <span class="co">/* towards (+Z). Don&#39;t allow to get too */</span>
            <span class="kw">case</span> ‘t&#39;:      <span class="co">/* close, so Z clipping isn&#39;t needed */</span>
               <span class="kw">if</span> (PolyWorldXform[<span class="dv">2</span>][<span class="dv">3</span>] &lt; -<span class="fl">40.0</span>)
                     PolyWorldXform[<span class="dv">2</span>][<span class="dv">3</span>] += <span class="fl">3.0</span>; <span class="kw">break</span>;
            <span class="kw">case</span> <span class="dv">0</span>:     <span class="co">/* extended code */</span>
               <span class="kw">switch</span> (getch()) {
                  <span class="kw">case</span> <span class="bn">0x4B</span>:  <span class="co">/* left (-X) */</span>
                     PolyWorldXform[<span class="dv">0</span>][<span class="dv">3</span>] -= <span class="fl">3.0</span>; <span class="kw">break</span>;
                  <span class="kw">case</span> <span class="bn">0x4D</span>:  <span class="co">/* right (+X) */</span>
                     PolyWorldXform[<span class="dv">0</span>][<span class="dv">3</span>] += <span class="fl">3.0</span>; <span class="kw">break</span>;
                  <span class="kw">case</span> <span class="bn">0x48</span>:  <span class="co">/* up (+Y) */</span>
                     PolyWorldXform[<span class="dv">1</span>][<span class="dv">3</span>] += <span class="fl">3.0</span>; <span class="kw">break</span>;
                  <span class="kw">case</span> <span class="bn">0x50</span>:  <span class="co">/* down (-Y) */</span>
                     PolyWorldXform[<span class="dv">1</span>][<span class="dv">3</span>] -= <span class="fl">3.0</span>; <span class="kw">break</span>;
                  <span class="kw">default</span>:
                     <span class="kw">break</span>;
               }
               <span class="kw">break</span>;
            <span class="kw">default</span>:       <span class="co">/* any other key to pause */</span>
               getch(); <span class="kw">break</span>;
         }
      }
   } <span class="kw">while</span> (!Done);
   <span class="co">/* Return to text mode and exit */</span>
   regset.x.ax = <span class="bn">0x0003</span>;   <span class="co">/* AL = 3 selects 80x25 text mode */</span>
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}</code></pre>
<section id="notes-on-the-3-d-animation-example" class="level4">
<h4><a href="#notes-on-the-3-d-animation-example">Notes on the 3-D Animation Example</a></h4>
<p>The sample program transforms the polygon’s vertices from object space to world space to view space to the screen, as described earlier. In this case, world space and view space are congruent—we’re looking right down the negative Z axis of world space—so the transformation matrix from world to view is the identity matrix; you might want to experiment with changing this matrix to change the viewpoint. The sample program uses 4x4 homogeneous coordinate matrices to perform transformations, as described above. Floating-point arithmetic is used for all 3-D calculations. Setting the translation from object space to world space is a simple matter of changing the appropriate entry in the fourth column of the object-to-world transformation matrix. Setting the rotation around the Y axis is almost as simple, requiring only the setting of the four matrix entries that control the Y rotation to the sines and cosines of the desired rotation. However, rotations involving more than one axis require multiple rotation matrices, one for each axis rotated around; those matrices are then concatenated together to produce the object-to-world transformation. This area is trickier than it might initially appear to be; more in the near future.</p>
<p>The maximum translation along the Z axis is limited to -40; this keeps the polygon from extending past the viewpoint to positive Z coordinates. This would wreak havoc with the projection and 2-D clipping, and would require 3-D clipping, which is far more complicated than 2-D. We’ll get to 3-D clipping at some point, but, for now, it’s much simpler just to limit all vertices to negative Z coordinates. The polygon does get mighty close to the viewpoint, though; run the program and use the “T” key to move the polygon as close as possible—the near vertex swinging past provides a striking sense of perspective.</p>
<p>The performance of Listing 50.5 is, perhaps, surprisingly good, clocking in at 16 frames per second on a 20 MHz 386 with a VGA of average speed and no 387, although there is, of course, only one polygon being drawn, rather than the hundreds or thousands we’d ultimately like. What’s far more interesting is where the execution time goes. Even though the program is working with only one polygon, 73 percent of the time goes for transformation and projection. An additional 7 percent is spent waiting to flip the screen. Only 20 percent of the total time is spent in all other activity—and only 2 percent is spent actually drawing polygons. Clearly, we’ll want to tackle transformation and projection first when we look to speed things up. (Note, however, that a math coprocessor would considerably decrease the time taken by floating-point calculations.)</p>
<p>In Listing 50.3, when the extent of the bounding rectangle is calculated for later erasure purposes, that extent is clipped to the screen. This is due to the lack of clipping in the rectangle fill code from Listing 47.5 in Chapter 47; the problem would more appropriately be addressed by putting clipping into the fill code, but, unfortunately, I lack the space to do that here.</p>
<p>Finally, observe the jaggies crawling along the edges of the polygon as it rotates. This is temporal aliasing at its finest! We won’t address antialiasing further, realtime antialiasing being decidedly nontrivial, but this should give you an idea of why antialiasing is so desirable.</p>
</section>
</section>
<section id="an-ongoing-journey" class="level3">
<h3><a href="#an-ongoing-journey">An Ongoing Journey</a></h3>
<p>In the next chapter, we’ll assign fronts and backs to polygons, and start drawing only those that are facing the viewer. That will enable us to handle convex polyhedrons, such as tetrahedrons and cubes. We’ll also look at interactively controllable rotation, and at more complex rotations than the simple rotation around the Y axis that we did this time. In time, we’ll use fixed-point arithmetic to speed things up, and do some shading and texture mapping. The journey has only begun; we’ll get to all that and more soon.</p>
</section>
</section>
<section id="chapter-51-sneakers-in-space" class="level2">
<h2><a href="#chapter-51-sneakers-in-space">Chapter 51 – Sneakers in Space</a></h2>
<section id="using-backface-removal-to-eliminate-hidden-surfaces" class="level3">
<h3><a href="#using-backface-removal-to-eliminate-hidden-surfaces">Using Backface Removal to Eliminate Hidden Surfaces</a></h3>
<p>As I’m fond of pointing out, computer animation isn’t a matter of mathematically exact modeling or raw technical prowess, but rather of fooling the eye and the mind. That’s especially true for 3-D animation, where we’re not only trying to convince viewers that they’re seeing objects on a screen—when in truth that screen contains no objects at all, only gaggles of pixels—but we’re also trying to create the illusion that the objects exist in three-space, possessing four dimensions (counting movement over time as a fourth dimension) of their own. To make this magic happen, we must provide cues for the eye not only to pick out boundaries, but also to detect depth, orientation, and motion. This involves perspective, shading, proper handling of hidden surfaces, and rapid and smooth screen updates; the whole deal is considerably more difficult to pull off on a PC than 2-D animation.</p>
<blockquote>
<p><img src="images/i.jpg" /> In some senses, however, 3-D animation is easier than 2-D. Because there’s more going on in 3-D animation, the eye and brain tend to make more assumptions, and so are more apt to see what they expect to see, rather than what’s actually there.</p>
</blockquote>
<p>If you’re piloting a (virtual) ship through a field of thousands of asteroids at high speed, you’re unlikely to notice if the more distant asteroids occasionally seem to go right through each other, or if the topographic detail on the asteroids’ surfaces sometimes shifts about a bit. You’ll be busy viewing the asteroids in their primary role, as objects to be navigated around, and the mere presence of topographic detail will suffice; without being aware of it, you’ll fill in the blanks. Your mind will see the topography peripherally, recognize it for what it is supposed to be, and, unless the landscape does something really obtrusive such as vanishing altogether or suddenly shooting a spike miles into space, you will see what you expect to see: a bunch of nicely detailed asteroids tumbling around you.</p>
<p>To what extent can you rely on the eye and mind to make up for imperfections in the 3-D animation process? In some areas, hardly at all; for example, jaggies crawling along edges stick out like red flags, and likewise for flicker. In other areas, though, the human perceptual system is more forgiving than you’d think. Consider this: At the end of <em>Return of the Jedi</em>, in the battle to end all battles around the Death Star, there is a sequence of about five seconds in which several spaceships are visible in the background. One of those spaceships (and it’s not very far in the background, either) looks a bit unusual. What it looks like is a sneaker. In fact, it <em>is</em> a sneaker—but unless you know to look for it, you’ll never notice it, because your mind is busy making simplifying assumptions about the complex scene it’s seeing—and one of those assumptions is that medium-sized objects floating in space are spaceships, unless proven otherwise. (Thanks to Chris Hecker for pointing this out. I’d never have noticed the sneaker, myself, without being tipped off—which is, of course, the whole point.)</p>
<p>If it’s good enough for George Lucas, it’s good enough for us. And with that, let’s resume our quest for realtime 3-D animation on the PC.</p>
</section>
<section id="one-sided-polygons-backface-removal" class="level3">
<h3><a href="#one-sided-polygons-backface-removal">One-sided Polygons: Backface Removal</a></h3>
<p>In the previous chapter, we implemented the basic polygon drawing pipeline, transforming a polygon all the way from its basic definition in object space, through the shared 3-D world space, and into the 3-D space as seen from the viewpoint, called <em>view space</em>. From view space, we performed a perspective projection to convert the polygon into screen space, then mapped the transformed and projected vertices to the nearest screen coordinates and filled the polygon. Armed with code that implemented this pipeline, we were able to watch as a polygon rotated about its Y axis, and were able to move the polygon around in space freely.</p>
<p>One of the drawbacks of the previous chapter’s approach was that the polygon had two visible sides. Why is that a drawback? It isn’t, necessarily, but in our case we want to use polygons to build solid objects with continuous surfaces, and in that context, only one side of a polygon is visible; the other side always faces the inside of the object, and can never be seen. It would save time and simplify the process of hidden surface removal if we could quickly and easily determine whether the inside or outside face of each polygon was facing us, so that we could draw each polygon only if it were visible (that is, had the outside face pointing toward the viewer). On average, half the polygons in an object could be instantly rejected by a test of this sort. Such testing of polygon visibility goes by a number of names in the literature, including backplane culling, backface removal, and assorted variations thereon; I’ll refer to it as <em>backface removal</em>.</p>
<p>For a single convex polyhedron, removal of polygons that aren’t facing the viewer would solve all hidden surface problems. In a convex polyhedron, any polygon facing the viewer can never be obscured by any other polygon in that polyhedron; this falls out of the definition of a convex polyhedron. Likewise, any polygon facing away from the viewer can never be visible. Therefore, in order to draw a convex polyhedron, if you draw all polygons facing toward the viewer but none facing away from the viewer, everything will work out properly, with no additional checking for overlap and hidden surfaces needed.</p>
<p>Unfortunately, backface removal completely solves the hidden surface problem for convex polyhedrons <em>only</em>, and only if there’s a single convex polyhedron involved; when convex polyhedrons overlap, other methods must be used. Nonetheless, backface removal does instantly halve the number of polygons to be handled in rendering any particular scene. Backface removal can also speed hidden-surface handling if objects are built out of convex polyhedrons. In this chapter, though, we have only one convex polyhedron to deal with, so backface removal alone will do the trick.</p>
<p>Given that I’ve convinced you that backface removal would be a handy thing to have, how do we actually do it? A logical approach, often implemented in the PC literature, would be to calculate the plane equation for the plane in which the polygon lies, and see which way the normal (perpendicular) vector to the plane points. That works, but there’s a more efficient way to calculate the normal to the polygon: as the cross-product of two of the polygon’s edges.</p>
<p>The cross-product of two vectors is defined as the vector shown in Figure 51.1. One interesting property of the cross-product vector is that it is perpendicular to the plane in which the two original vectors lie. If we take the cross-product of the vectors that form two edges of a polygon, the result will be a vector perpendicular to the polygon; then, we’ll know that the polygon is visible if and only if the cross-product vector points toward the viewer. We need one more thing to make the cross-product approach work, though. The cross-product can actually point either way, depending on which edges of the polygon we choose to work with and the order in which we evaluate them, so we must establish some conventions for defining polygons and evaluating the cross-product.</p>
<figure>
<img src="images/51-01.jpg" alt="Figure 51.1  The cross-product of two vectors." /><figcaption><strong>Figure 51.1</strong>  <em>The cross-product of two vectors.</em></figcaption>
</figure>
<p>We’ll define only convex polygons, with the vertices defined in clockwise order, as viewed from the outside; that is, if you’re looking at the visible side of the polygon, the vertices will appear in the polygon definition in clockwise order. With those assumptions, the cross-product becomes a quick and easy indicator of polygon orientation with respect to the viewer; we’ll calculate it as the cross-product of the first and last vectors in a polygon, as shown in Figure 51.2, and if it’s pointing toward the viewer, we’ll know that the polygon is visible. Actually, we don’t even have to calculate the entire cross-product vector, because the Z component alone suffices to tell us which way the polygon is facing: positive Z means visible, negative Z means not. The Z component can be calculated very efficiently, with only two multiplies and a subtraction.</p>
<p>The question remains of the proper space in which to perform backface removal. There’s a temptation to perform it in view space, which is, after all, the space defined with respect to the viewer, but view space is not a good choice. Screen space—the space in which perspective projection has been performed—is the best choice. The purpose of backface removal is to determine whether each polygon is visible to the viewer, and, despite its name, view space does not provide that information; unlike screen space, it does not reflect perspective effects.</p>
<figure>
<img src="images/51-02.jpg" alt="Figure 51.2  Using the cross product to generate a polygon normal." /><figcaption><strong>Figure 51.2</strong>  <em>Using the cross product to generate a polygon normal.</em></figcaption>
</figure>
<p>Backface removal may also be performed using the polygon vertices in screen coordinates, which are integers. This is less accurate than using the screen space coordinates, which are floating point, but is, by the same token, faster. In Listing 51.3, which we’ll discuss shortly, backface removal is performed in screen coordinates in the interests of speed.</p>
<p>Backface removal, as implemented in Listing 51.3, will not work reliably if the polygon is not convex, if the vertices don’t appear in clockwise order, if either the first or last edge in a polygon has zero length, or if the first and last edges are collinear. These latter two points are the reason it’s preferable to work in screen space rather than screen coordinates (which suffer from rounding problems), speed considerations aside.</p>
<section id="backface-removal-in-action" class="level4">
<h4><a href="#backface-removal-in-action">Backface Removal in Action</a></h4>
<p>Listings 51.1 through 51.5 together form a program that rotates a solid cube in real-time under user control. Listing 51.1 is the main program; Listing 51.2 performs transformation and projection; Listing 51.3 performs backface removal and draws visible faces; Listing 51.4 concatenates incremental rotations to the object-to-world transformation matrix; Listing 51.5 is the general header file. Also required from previous chapters are: Listings 50.1 and 50.2 from Chapter 50 (draw clipped line list, matrix math functions); Listings 47.1 and 47.6 from Chapter 47, (Mode X mode set, rectangle fill); Listing 49.6 from Chapter 49; Listing 39.4 from Chapter 39 (polygon edge scan); and the <code>FillConvexPolygon()</code> function from Listing 38.1 from Chapter 38. All necessary modules, along with a project file, will be present in the subdirectory for this chapter on the listings diskette, whether they were presented in this chapter or some earlier chapter. This may crowd the listings diskette a little bit, but it will certainly reduce confusion!</p>
<p><strong>LISTING 51.1 L51-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* 3D animation program to view a cube as it rotates in Mode X. The viewpoint</span>
<span class="co">   is fixed at the origin (0,0,0) of world space, looking in the direction of</span>
<span class="co">   increasingly negative Z. A right-handed coordinate system is used throughout.</span>
<span class="co">   All C code tested with Borland C++ in C compilation mode. */</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="ot">#define ROTATION  (M_PI / 30.0)  </span><span class="co">/* rotate by 6 degrees at a time */</span>

<span class="co">/* base offset of page to which to draw */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> CurrentPageBase = <span class="dv">0</span>;
<span class="co">/* Clip rectangle; clips to the screen */</span>
<span class="dt">int</span> ClipMinX=<span class="dv">0</span>, ClipMinY=<span class="dv">0</span>;
<span class="dt">int</span> ClipMaxX=SCREEN_WIDTH, ClipMaxY=SCREEN_HEIGHT;
<span class="co">/* Rectangle specifying extent to be erased in each page. */</span>
<span class="kw">struct</span> Rect EraseRect[<span class="dv">2</span>] = { {<span class="dv">0</span>, <span class="dv">0</span>, SCREEN_WIDTH, SCREEN_HEIGHT},
   {<span class="dv">0</span>, <span class="dv">0</span>, SCREEN_WIDTH, SCREEN_HEIGHT} };
<span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">int</span> PageStartOffsets[<span class="dv">2</span>] =
   {PAGE0_START_OFFSET,PAGE1_START_OFFSET};
<span class="dt">int</span> DisplayedPage, NonDisplayedPage;
<span class="co">/* Transformation from cube&#39;s object space to world space. Initially</span>
<span class="co">   set up to perform no rotation and to move the cube into world</span>
<span class="co">   space -100 units away from the origin down the Z axis. Given the</span>
<span class="co">   viewing point, -100 down the Z axis means 100 units away in the</span>
<span class="co">   direction of view. The program dynamically changes both the</span>
<span class="co">   translation and the rotation. */</span>
<span class="dt">static</span> <span class="dt">double</span> CubeWorldXform[<span class="dv">4</span>][<span class="dv">4</span>] = {
   {<span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>},
   {<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>},
   {<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>, -<span class="fl">100.0</span>},
   {<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>} };
<span class="co">/* Transformation from world space into view space. Because in this</span>
<span class="co">   application the view point is fixed at the origin of world space,</span>
<span class="co">   looking down the Z axis in the direction of increasing Z, view space is</span>
<span class="co">   identical to world space, and this is the identity matrix. */</span>
<span class="dt">static</span> <span class="dt">double</span> WorldViewXform[<span class="dv">4</span>][<span class="dv">4</span>] = {
   {<span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>},
   {<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>},
   {<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>},
   {<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>}
};
<span class="co">/* all vertices in the cube */</span>
<span class="dt">static</span> <span class="kw">struct</span> Point3 CubeVerts[] = {
   {<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">1</span>},{<span class="dv">15</span>,<span class="dv">15</span>,-<span class="dv">15</span>,<span class="dv">1</span>},{<span class="dv">15</span>,-<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">1</span>},{<span class="dv">15</span>,-<span class="dv">15</span>,-<span class="dv">15</span>,<span class="dv">1</span>},
   {-<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">1</span>},{-<span class="dv">15</span>,<span class="dv">15</span>,-<span class="dv">15</span>,<span class="dv">1</span>},{-<span class="dv">15</span>,-<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">1</span>},{-<span class="dv">15</span>,-<span class="dv">15</span>,-<span class="dv">15</span>,<span class="dv">1</span>}};
<span class="co">/* vertices after transformation */</span>
<span class="dt">static</span> <span class="kw">struct</span> Point3
      XformedCubeVerts[<span class="kw">sizeof</span>(CubeVerts)/<span class="kw">sizeof</span>(<span class="kw">struct</span> Point3)];
<span class="co">/* vertices after projection */</span>
<span class="dt">static</span> <span class="kw">struct</span> Point3
      ProjectedCubeVerts[<span class="kw">sizeof</span>(CubeVerts)/<span class="kw">sizeof</span>(<span class="kw">struct</span> Point3)];
<span class="co">/* vertices in screen coordinates */</span>
<span class="dt">static</span> <span class="kw">struct</span> Point
      ScreenCubeVerts[<span class="kw">sizeof</span>(CubeVerts)/<span class="kw">sizeof</span>(<span class="kw">struct</span> Point3)];
<span class="co">/* vertex indices for individual faces */</span>
<span class="dt">static</span> <span class="dt">int</span> Face1[] = {<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">0</span>};
<span class="dt">static</span> <span class="dt">int</span> Face2[] = {<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">3</span>,<span class="dv">1</span>};
<span class="dt">static</span> <span class="dt">int</span> Face3[] = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">0</span>};
<span class="dt">static</span> <span class="dt">int</span> Face4[] = {<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">2</span>};
<span class="dt">static</span> <span class="dt">int</span> Face5[] = {<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>};
<span class="dt">static</span> <span class="dt">int</span> Face6[] = {<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">4</span>};
<span class="co">/* list of cube faces */</span>
<span class="dt">static</span> <span class="kw">struct</span> Face CubeFaces[] = {{Face1,<span class="dv">4</span>,<span class="dv">15</span>},{Face2,<span class="dv">4</span>,<span class="dv">14</span>},
   {Face3,<span class="dv">4</span>,<span class="dv">12</span>},{Face4,<span class="dv">4</span>,<span class="dv">11</span>},{Face5,<span class="dv">4</span>,<span class="dv">10</span>},{Face6,<span class="dv">4</span>,<span class="dv">9</span>}};
<span class="co">/* master description for cube */</span>
<span class="dt">static</span> <span class="kw">struct</span> Object Cube = {<span class="kw">sizeof</span>(CubeVerts)/<span class="kw">sizeof</span>(<span class="kw">struct</span> Point3),
   CubeVerts, XformedCubeVerts, ProjectedCubeVerts, ScreenCubeVerts,
   <span class="kw">sizeof</span>(CubeFaces)/<span class="kw">sizeof</span>(<span class="kw">struct</span> Face), CubeFaces};

<span class="dt">void</span> main() {
   <span class="dt">int</span> Done = <span class="dv">0</span>, RecalcXform = <span class="dv">1</span>;
   <span class="dt">double</span> WorkingXform[<span class="dv">4</span>][<span class="dv">4</span>];
   <span class="kw">union</span> REGS regset;

   <span class="co">/* Set up the initial transformation */</span>
   Set320x240Mode(); <span class="co">/* set the screen to Mode X */</span>
   ShowPage(PageStartOffsets[DisplayedPage = <span class="dv">0</span>]);
   <span class="co">/* Keep transforming the cube, drawing it to the undisplayed page,</span>
<span class="co">      and flipping the page to show it */</span>
   <span class="kw">do</span> {
      <span class="co">/* Regenerate the object-&gt;view transformation and</span>
<span class="co">         retransform/project if necessary */</span>
      <span class="kw">if</span> (RecalcXform) {
         ConcatXforms(WorldViewXform, CubeWorldXform, WorkingXform);
         <span class="co">/* Transform and project all the vertices in the cube */</span>
         XformAndProjectPoints(WorkingXform, &amp;Cube);
         RecalcXform = <span class="dv">0</span>;
      }
      CurrentPageBase =    <span class="co">/* select other page for drawing to */</span>
            PageStartOffsets[NonDisplayedPage = DisplayedPage ^ <span class="dv">1</span>];
      <span class="co">/* Clear the portion of the non-displayed page that was drawn</span>
<span class="co">         to last time, then reset the erase extent */</span>
      FillRectangleX(EraseRect[NonDisplayedPage].Left,
            EraseRect[NonDisplayedPage].Top,
            EraseRect[NonDisplayedPage].Right,
            EraseRect[NonDisplayedPage].Bottom, CurrentPageBase, <span class="dv">0</span>);
      EraseRect[NonDisplayedPage].Left =
            EraseRect[NonDisplayedPage].Top = <span class="bn">0x7FFF</span>;
      EraseRect[NonDisplayedPage].Right =
            EraseRect[NonDisplayedPage].Bottom = <span class="dv">0</span>;
      <span class="co">/* Draw all visible faces of the cube */</span>
      DrawVisibleFaces(&amp;Cube);
      <span class="co">/* Flip to display the page into which we just drew */</span>
      ShowPage(PageStartOffsets[DisplayedPage = NonDisplayedPage]);
      <span class="kw">while</span> (kbhit()) {
         <span class="kw">switch</span> (getch()) {
            <span class="kw">case</span> <span class="bn">0x1B</span>:     <span class="co">/* Esc to exit */</span>
               Done = <span class="dv">1</span>; <span class="kw">break</span>;
            <span class="kw">case</span> ‘A&#39;: <span class="kw">case</span> ‘a&#39;:      <span class="co">/* away (-Z) */</span>
               CubeWorldXform[<span class="dv">2</span>][<span class="dv">3</span>] -= <span class="fl">3.0</span>; RecalcXform = <span class="dv">1</span>; <span class="kw">break</span>;
            <span class="kw">case</span> ‘T&#39;:      <span class="co">/* towards (+Z). Don&#39;t allow to get too */</span>
            <span class="kw">case</span> ‘t&#39;:      <span class="co">/* close, so Z clipping isn&#39;t needed */</span>
               <span class="kw">if</span> (CubeWorldXform[<span class="dv">2</span>][<span class="dv">3</span>] &lt; -<span class="fl">40.0</span>) {
                     CubeWorldXform[<span class="dv">2</span>][<span class="dv">3</span>] += <span class="fl">3.0</span>;
                     RecalcXform = <span class="dv">1</span>;
               }
               <span class="kw">break</span>;
            <span class="kw">case</span> ‘4&#39;:         <span class="co">/* rotate clockwise around Y */</span>
               AppendRotationY(CubeWorldXform, -ROTATION);
               RecalcXform=<span class="dv">1</span>; <span class="kw">break</span>;
            <span class="kw">case</span> ‘6&#39;:         <span class="co">/* rotate counterclockwise around Y */</span>
               AppendRotationY(CubeWorldXform, ROTATION);
               RecalcXform=<span class="dv">1</span>; <span class="kw">break</span>;
            <span class="kw">case</span> ‘8&#39;:         <span class="co">/* rotate clockwise around X */</span>
               AppendRotationX(CubeWorldXform, -ROTATION);
               RecalcXform=<span class="dv">1</span>; <span class="kw">break</span>;
            <span class="kw">case</span> ‘2&#39;:         <span class="co">/* rotate counterclockwise around X */</span>
               AppendRotationX(CubeWorldXform, ROTATION);
               RecalcXform=<span class="dv">1</span>; <span class="kw">break</span>;
            <span class="kw">case</span> <span class="dv">0</span>:     <span class="co">/* extended code */</span>
               <span class="kw">switch</span> (getch()) {
                  <span class="kw">case</span> <span class="bn">0x3B</span>:  <span class="co">/* rotate counterclockwise around Z */</span>
                     AppendRotationZ(CubeWorldXform, ROTATION);
                     RecalcXform=<span class="dv">1</span>; <span class="kw">break</span>;
                  <span class="kw">case</span> <span class="bn">0x3C</span>:  <span class="co">/* rotate clockwise around Z */</span>
                     AppendRotationZ(CubeWorldXform, -ROTATION);
                     RecalcXform=<span class="dv">1</span>; <span class="kw">break</span>;
                  <span class="kw">case</span> <span class="bn">0x4B</span>:  <span class="co">/* left (-X) */</span>
                    CubeWorldXform[<span class="dv">0</span>][<span class="dv">3</span>] -= <span class="fl">3.0</span>; RecalcXform=<span class="dv">1</span>; <span class="kw">break</span>;
                  <span class="kw">case</span> <span class="bn">0x4D</span>:  <span class="co">/* right (+X) */</span>
                    CubeWorldXform[<span class="dv">0</span>][<span class="dv">3</span>] += <span class="fl">3.0</span>; RecalcXform=<span class="dv">1</span>; <span class="kw">break</span>;
                  <span class="kw">case</span> <span class="bn">0x48</span>:  <span class="co">/* up (+Y) */</span>
                    CubeWorldXform[<span class="dv">1</span>][<span class="dv">3</span>] += <span class="fl">3.0</span>; RecalcXform=<span class="dv">1</span>; <span class="kw">break</span>;
                  <span class="kw">case</span> <span class="bn">0x50</span>:  <span class="co">/* down (-Y) */</span>
                    CubeWorldXform[<span class="dv">1</span>][<span class="dv">3</span>] -= <span class="fl">3.0</span>; RecalcXform=<span class="dv">1</span>; <span class="kw">break</span>;
                  <span class="kw">default</span>:
                    <span class="kw">break</span>;
               }
               <span class="kw">break</span>;
            <span class="kw">default</span>:       <span class="co">/* any other key to pause */</span>
               getch(); <span class="kw">break</span>;
         }
      }
   } <span class="kw">while</span> (!Done);
   <span class="co">/* Return to text mode and exit */</span>
   regset.x.ax = <span class="bn">0x0003</span>;   <span class="co">/* AL = 3 selects 80x25 text mode */</span>
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
}</code></pre>
<p><strong>LISTING 51.2 L51-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Transforms all vertices in the specified object into view spa ce, then</span>
<span class="co">   perspective projects them to screen space and maps them to screen coordinates,</span>
<span class="co">   storing the results in the object. */</span>
<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;/</span>

<span class="dt">void</span> XformAndProjectPoints(<span class="dt">double</span> Xform[<span class="dv">4</span>][<span class="dv">4</span>],
   <span class="kw">struct</span> Object * ObjectToXform)
{
   <span class="dt">int</span> i, NumPoints = ObjectToXform-&gt;NumVerts;
   <span class="kw">struct</span> Point3 * Points = ObjectToXform-&gt;VertexList;
   <span class="kw">struct</span> Point3 * XformedPoints = ObjectToXform-&gt;XformedVertexList;
   <span class="kw">struct</span> Point3 * ProjectedPoints = ObjectToXform-&gt;ProjectedVertexList;
   <span class="kw">struct</span> Point * ScreenPoints = ObjectToXform-&gt;ScreenVertexList;

   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NumPoints; i++, Points++, XformedPoints++,
         ProjectedPoints++, ScreenPoints++) {
      <span class="co">/* Transform to view space */</span>
      XformVec(Xform, (<span class="dt">double</span> *)Points, (<span class="dt">double</span> *)XformedPoints);
      <span class="co">/* Perspective-project to screen space */</span>
      ProjectedPoints-&gt;X = XformedPoints-&gt;X / XformedPoints-&gt;Z *
            PROJECTION_RATIO * (SCREEN_WIDTH / <span class="fl">2.0</span>);
      ProjectedPoints-&gt;Y = XformedPoints-&gt;Y / XformedPoints-&gt;Z *
            PROJECTION_RATIO * (SCREEN_WIDTH / <span class="fl">2.0</span>);
      ProjectedPoints-&gt;Z = XformedPoints-&gt;Z;
      <span class="co">/* Convert to screen coordinates. The Y coord is negated to</span>
<span class="co">         flip from increasing Y being up to increasing Y being down,</span>
<span class="co">         as expected by the polygon filler. Add in half the screen</span>
<span class="co">         width and height to center on the screen. */</span>
      ScreenPoints-&gt;X = ((<span class="dt">int</span>) floor(ProjectedPoints-&gt;X + <span class="fl">0.5</span>)) + SCREEN_WIDTH/<span class="dv">2</span>;
      ScreenPoints-&gt;Y = (-((<span class="dt">int</span>) floor(ProjectedPoints-&gt;Y + <span class="fl">0.5</span>))) +
               SCREEN_HEIGHT/<span class="dv">2</span>;
   }
}</code></pre>
<p><strong>LISTING 51.3 L51-3.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Draws all visible faces (faces pointing toward the viewer) in the specified</span>
<span class="co">   object. The object must have previously been transformed and projected, so</span>
<span class="co">   that the ScreenVertexList array is filled in. */</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="dt">void</span> DrawVisibleFaces(<span class="kw">struct</span> Object * ObjectToXform)
{
   <span class="dt">int</span> i, j, NumFaces = ObjectToXform-&gt;NumFaces, NumVertices;
   <span class="dt">int</span> * VertNumsPtr;
   <span class="kw">struct</span> Face * FacePtr = ObjectToXform-&gt;FaceList;
   <span class="kw">struct</span> Point * ScreenPoints = ObjectToXform-&gt;ScreenVertexList;
   <span class="dt">long</span> v1,v2,w1,w2;
   <span class="kw">struct</span> Point Vertices[MAX_POLY_LENGTH];
   <span class="kw">struct</span> PointListHeader Polygon;

   <span class="co">/* Draw each visible face (polygon) of the object in turn */</span>
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NumFaces; i++, FacePtr++) {
      NumVertices = FacePtr-&gt;NumVerts;
      <span class="co">/* Copy over the face&#39;s vertices from the vertex list */</span>
      <span class="kw">for</span> (j=<span class="dv">0</span>, VertNumsPtr=FacePtr-&gt;VertNums; j&lt;NumVertices; j++)
         Vertices[j] = ScreenPoints[*VertNumsPtr++];
      <span class="co">/* Draw only if outside face showing (if the normal to the</span>
<span class="co">         polygon points toward the viewer; that is, has a positive</span>
<span class="co">         Z component) */</span>
      v1 = Vertices[<span class="dv">1</span>].X - Vertices[<span class="dv">0</span>].X;
      w1 = Vertices[NumVertices<span class="dv">-1</span>].X - Vertices[<span class="dv">0</span>].X;
      v2 = Vertices[<span class="dv">1</span>].Y - Vertices[<span class="dv">0</span>].Y;
      w2 = Vertices[NumVertices<span class="dv">-1</span>].Y - Vertices[<span class="dv">0</span>].Y;
      <span class="kw">if</span> ((v1*w2 - v2*w1) &gt; <span class="dv">0</span>) {
         <span class="co">/* It is facing the screen, so draw */</span>
         <span class="co">/* Appropriately adjust the extent of the rectangle used to</span>
<span class="co">            erase this page later */</span>
         <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;NumVertices; j++) {
            <span class="kw">if</span> (Vertices[j].X &gt; EraseRect[NonDisplayedPage].Right)
               <span class="kw">if</span> (Vertices[j].X &lt; SCREEN_WIDTH)
                  EraseRect[NonDisplayedPage].Right = Vertices[j].X;
               <span class="kw">else</span> EraseRect[NonDisplayedPage].Right = SCREEN_WIDTH;
            <span class="kw">if</span> (Vertices[j].Y &gt; EraseRect[NonDisplayedPage].Bottom)
               <span class="kw">if</span> (Vertices[j].Y &lt; SCREEN_HEIGHT)
                  EraseRect[NonDisplayedPage].Bottom = Vertices[j].Y;
               <span class="kw">else</span> EraseRect[NonDisplayedPage].Bottom=SCREEN_HEIGHT;
            <span class="kw">if</span> (Vertices[j].X &lt; EraseRect[NonDisplayedPage].Left)
               <span class="kw">if</span> (Vertices[j].X &gt; <span class="dv">0</span>)
                  EraseRect[NonDisplayedPage].Left = Vertices[j].X;
               <span class="kw">else</span> EraseRect[NonDisplayedPage].Left = <span class="dv">0</span>;
            <span class="kw">if</span> (Vertices[j].Y &lt; EraseRect[NonDisplayedPage].Top)
               <span class="kw">if</span> (Vertices[j].Y &gt; <span class="dv">0</span>)
                  EraseRect[NonDisplayedPage].Top = Vertices[j].Y;
               <span class="kw">else</span> EraseRect[NonDisplayedPage].Top = <span class="dv">0</span>;
         }
         <span class="co">/* Draw the polygon */</span>
         DRAW_POLYGON(Vertices, NumVertices, FacePtr-&gt;Color, <span class="dv">0</span>, <span class="dv">0</span>);
      }
   }
}</code></pre>
<p>The sample program, as shown in Figure 51.3, places a cube, floating in three-space, under the complete control of the user. The arrow keys may be used to move the cube left, right, up, and down, and the A and T keys may be used to move the cube away from or toward the viewer. The F1 and F2 keys perform rotation around the Z axis, the axis running from the viewer straight into the screen. The 4 and 6 keys perform rotation around the Y (vertical) axis, and the 2 and 8 keys perform rotation around the X axis, which runs horizontally across the screen; the latter four keys are most conveniently used by flipping the keypad to the numeric state.</p>
<figure>
<img src="images/51-03.jpg" alt="Figure 51.3  Sample screens from the 3-D cube program." /><figcaption><strong>Figure 51.3</strong>  <em>Sample screens from the 3-D cube program.</em></figcaption>
</figure>
<p>The demo involves six polygons, one for each side of the cube. Each of the polygons must be transformed and projected, so it would seem that 24 vertices (four for each polygon) must be handled, but some steps have been taken to improve performance. All vertices for the object have been stored in a single list; the definition of each face contains not the vertices for that face themselves, but rather indexes into the object’s vertex list, as shown in Figure 51.4. This reduces the number of vertices to be manipulated from 24 to 8, for there are, after all, only eight vertices in a cube, with three faces sharing each vertex. In this way, the transformation burden is lightened by two-thirds. Also, as mentioned earlier, backface removal is performed with integers, in screen coordinates, rather than with floating-point values in screen space. Finally, the <code>RecalcXForm</code> flag is set whenever the user changes the object-to-world transformation. Only when this flag is set is the full object-to-view transformation recalculated and the object’s vertices transformed and projected again; otherwise, the values already stored within the object are reused. In the sample application, this brings no visual improvement, because there’s only the one object, but the underlying mechanism is sound: In a full-blown 3-D animation application, with multiple objects moving about the screen, it would help a great deal to flag which of the objects had moved with respect to the viewer, performing a new transformation and projection only for those that had.</p>
<figure>
<img src="images/51-04.jpg" alt="Figure 51.4  The object data structure" /><figcaption><strong>Figure 51.4</strong>  <em>The object data structure</em></figcaption>
</figure>
<p>With the above optimizations, the sample program is certainly adequately responsive on a 20 MHz 386 (sans 387; I’m sure it’s wonderfully responsive with a math coprocessor). Still, it couldn’t quite keep up with the keyboard when I modified it to read only one key each time through the loop—and we’re talking about only eight vertices here. This indicates that we’re already near the limit of animation complexity possible with our current approach. It’s time to start rethinking that approach; over two-thirds of the overall time is spent in floating-point calculations, and it’s there that we’ll begin to attack the performance bottleneck we find ourselves up against.</p>
</section>
</section>
<section id="incremental-transformation" class="level3">
<h3><a href="#incremental-transformation">Incremental Transformation</a></h3>
<p>Listing 51.4 contains three functions; each concatenates an additional rotation around one of the three axes to an existing rotation. To improve performance, only the matrix entries that are affected in a rotation around each particular axis are recalculated (all but four of the entries in a single-axis rotation matrix are either 0 or 1, as shown in Chapter 50). This cuts the number of floating-point multiplies from the 64 required for the multiplication of two 4x4 matrices to just 12, and floating point adds from 48 to 6.</p>
<p>Be aware that Listing 51.4 performs an incremental rotation on top of whatever rotation is already in the matrix. The cube may already have been turned left, right, up, down, and sideways; regardless, Listing 51.4 just tacks the specified rotation onto whatever already exists. In this way, the object-to-world transformation matrix contains a history of all the rotations ever specified by the user, concatenated one after another onto the original matrix. Potential loss of precision is a problem associated with using such an approach to represent a very long concatenation of transformations, especially with fixed-point arithmetic; that’s not a problem for us yet, but we’ll run into it eventually.</p>
<p><strong>LISTING 51.4 L51-4.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Routines to perform incremental rotations around the three axes */</span>
<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="co">/* Concatenate a rotation by Angle around the X axis to the transformation in</span>
<span class="co">   XformToChange, placing result back in XformToChange. */</span>
   <span class="dt">void</span> AppendRotationX(<span class="dt">double</span> XformToChange[<span class="dv">4</span>][<span class="dv">4</span>], <span class="dt">double</span> Angle)
{
   <span class="dt">double</span> Temp10, Temp11, Temp12, Temp20, Temp21, Temp22;
   <span class="dt">double</span> CosTemp = cos(Angle), SinTemp = sin(Angle);
   <span class="co">/* Calculate the new values of the four affected matrix entries */</span>
   Temp10 = CosTemp*XformToChange[<span class="dv">1</span>][<span class="dv">0</span>]+ -SinTemp*XformToChange[<span class="dv">2</span>][<span class="dv">0</span>];
   Temp11 = CosTemp*XformToChange[<span class="dv">1</span>][<span class="dv">1</span>]+ -SinTemp*XformToChange[<span class="dv">2</span>][<span class="dv">1</span>];
   Temp12 = CosTemp*XformToChange[<span class="dv">1</span>][<span class="dv">2</span>]+ -SinTemp*XformToChange[<span class="dv">2</span>][<span class="dv">2</span>];
   Temp20 = SinTemp*XformToChange[<span class="dv">1</span>][<span class="dv">0</span>]+ CosTemp*XformToChange[<span class="dv">2</span>][<span class="dv">0</span>];
   Temp21 = SinTemp*XformToChange[<span class="dv">1</span>][<span class="dv">1</span>]+ CosTemp*XformToChange[<span class="dv">2</span>][<span class="dv">1</span>];
   Temp22 = SinTemp*XformToChange[<span class="dv">1</span>][<span class="dv">2</span>]+ CosTemp*XformToChange[<span class="dv">2</span>][<span class="dv">2</span>];
   <span class="co">/* Put the results back into XformToChange */</span>
   XformToChange[<span class="dv">1</span>][<span class="dv">0</span>] = Temp10; XformToChange[<span class="dv">1</span>][<span class="dv">1</span>] = Temp11;
   XformToChange[<span class="dv">1</span>][<span class="dv">2</span>] = Temp12; XformToChange[<span class="dv">2</span>][<span class="dv">0</span>] = Temp20;
   XformToChange[<span class="dv">2</span>][<span class="dv">1</span>] = Temp21; XformToChange[<span class="dv">2</span>][<span class="dv">2</span>] = Temp22;
}

<span class="co">/* Concatenate a rotation by Angle around the Y axis to the transformation in</span>
<span class="co">   XformToChange, placing result back in XformToChange. */</span>
   <span class="dt">void</span> AppendRotationY(<span class="dt">double</span> XformToChange[<span class="dv">4</span>][<span class="dv">4</span>], <span class="dt">double</span> Angle)
{
   <span class="dt">double</span> Temp00, Temp01, Temp02, Temp20, Temp21, Temp22;
   <span class="dt">double</span> CosTemp = cos(Angle), SinTemp = sin(Angle);

   <span class="co">/* Calculate the new values of the four affected matrix entries */</span>
   Temp00 = CosTemp*XformToChange[<span class="dv">0</span>][<span class="dv">0</span>]+ SinTemp*XformToChange[<span class="dv">2</span>][<span class="dv">0</span>];
   Temp01 = CosTemp*XformToChange[<span class="dv">0</span>][<span class="dv">1</span>]+ SinTemp*XformToChange[<span class="dv">2</span>][<span class="dv">1</span>];
   Temp02 = CosTemp*XformToChange[<span class="dv">0</span>][<span class="dv">2</span>]+ SinTemp*XformToChange[<span class="dv">2</span>][<span class="dv">2</span>];
   Temp20 = -SinTemp*XformToChange[<span class="dv">0</span>][<span class="dv">0</span>]+ CosTemp*XformToChange[<span class="dv">2</span>][<span class="dv">0</span>];
   Temp21 = -SinTemp*XformToChange[<span class="dv">0</span>][<span class="dv">1</span>]+ CosTemp*XformToChange[<span class="dv">2</span>][<span class="dv">1</span>];
   Temp22 = -SinTemp*XformToChange[<span class="dv">0</span>][<span class="dv">2</span>]+ CosTemp*XformToChange[<span class="dv">2</span>][<span class="dv">2</span>];
   <span class="co">/* Put the results back into XformToChange */</span>
   XformToChange[<span class="dv">0</span>][<span class="dv">0</span>] = Temp00; XformToChange[<span class="dv">0</span>][<span class="dv">1</span>] = Temp01;
   XformToChange[<span class="dv">0</span>][<span class="dv">2</span>] = Temp02; XformToChange[<span class="dv">2</span>][<span class="dv">0</span>] = Temp20;
   XformToChange[<span class="dv">2</span>][<span class="dv">1</span>] = Temp21; XformToChange[<span class="dv">2</span>][<span class="dv">2</span>] = Temp22;
}

<span class="co">/* Concatenate a rotation by Angle around the Z axis to the transformation in</span>
<span class="co">   XformToChange, placing result back in XformToChange. */</span>
   <span class="dt">void</span> AppendRotationZ(<span class="dt">double</span> XformToChange[<span class="dv">4</span>][<span class="dv">4</span>], <span class="dt">double</span> Angle)
{
   <span class="dt">double</span> Temp00, Temp01, Temp02, Temp10, Temp11, Temp12;
   <span class="dt">double</span> CosTemp = cos(Angle), SinTemp = sin(Angle);
   <span class="co">/* Calculate the new values of the four affected matrix entries */</span>
   Temp00 = CosTemp*XformToChange[<span class="dv">0</span>][<span class="dv">0</span>]+ -SinTemp*XformToChange[<span class="dv">1</span>][<span class="dv">0</span>];
   Temp01 = CosTemp*XformToChange[<span class="dv">0</span>][<span class="dv">1</span>]+ -SinTemp*XformToChange[<span class="dv">1</span>][<span class="dv">1</span>];
   Temp02 = CosTemp*XformToChange[<span class="dv">0</span>][<span class="dv">2</span>]+ -SinTemp*XformToChange[<span class="dv">1</span>][<span class="dv">2</span>];
   Temp10 = SinTemp*XformToChange[<span class="dv">0</span>][<span class="dv">0</span>]+ CosTemp*XformToChange[<span class="dv">1</span>][<span class="dv">0</span>];
   Temp11 = SinTemp*XformToChange[<span class="dv">0</span>][<span class="dv">1</span>]+ CosTemp*XformToChange[<span class="dv">1</span>][<span class="dv">1</span>];
   Temp12 = SinTemp*XformToChange[<span class="dv">0</span>][<span class="dv">2</span>]+ CosTemp*XformToChange[<span class="dv">1</span>][<span class="dv">2</span>];
   <span class="co">/* Put the results back into XformToChange */</span>
   XformToChange[<span class="dv">0</span>][<span class="dv">0</span>] = Temp00; XformToChange[<span class="dv">0</span>][<span class="dv">1</span>] = Temp01;
   XformToChange[<span class="dv">0</span>][<span class="dv">2</span>] = Temp02; XformToChange[<span class="dv">1</span>][<span class="dv">0</span>] = Temp10;
   XformToChange[<span class="dv">1</span>][<span class="dv">1</span>] = Temp11; XformToChange[<span class="dv">1</span>][<span class="dv">2</span>] = Temp12;
}</code></pre>
<p><strong>LISTING 51.5 POLYGON.H</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* POLYGON.H: Header file for polygon-filling code, also includes a number of</span>
<span class="co">   useful items for 3D animation. */</span>
<span class="ot">#define MAX_POLY_LENGTH 4  </span><span class="co">/* four vertices is the max per poly */</span>
<span class="ot">#define SCREEN_WIDTH 320</span>
<span class="ot">#define SCREEN_HEIGHT 240</span>
<span class="ot">#define PAGE0_START_OFFSET 0</span>
<span class="ot">#define PAGE1_START_OFFSET (((long)SCREEN_HEIGHT*SCREEN_WIDTH)/4)</span>
<span class="co">/* Ratio: distance from viewpoint to projection plane / width of projection</span>
<span class="co">   plane. Defines the width of the field of view. Lower absolute values = wider</span>
<span class="co">   fields of view; higher values = narrower. */</span>
<span class="ot">#define PROJECTION_RATIO   -2.0 </span><span class="co">/* negative because visible Z coordinates are negative */</span>
<span class="co">/* Draws the polygon described by the point list PointList in color Color with</span>
<span class="co">   all vertices offset by (X,Y) */</span>
<span class="ot">#define DRAW_POLYGON(PointList,NumPoints,Color,X,Y)          \</span>
   Polygon.Length = NumPoints; Polygon.PointPtr = PointList; \
   FillConvexPolygon(&amp;Polygon, Color, X, Y);
<span class="co">/* Describes a single 2D point */</span>
<span class="kw">struct</span> Point {
   <span class="dt">int</span> X;   <span class="co">/* X coordinate */</span>
   <span class="dt">int</span> Y;   <span class="co">/* Y coordinate */</span>
};
<span class="co">/* Describes a single 3D point in homogeneous coordinates */</span>
<span class="kw">struct</span> Point3 {
   <span class="dt">double</span> X;   <span class="co">/* X coordinate */</span>
   <span class="dt">double</span> Y;   <span class="co">/* Y coordinate */</span>
   <span class="dt">double</span> Z;   <span class="co">/* Z coordinate */</span>
   <span class="dt">double</span> W;
};
<span class="co">/* Describes a series of points (used to store a list of vertices that</span>
<span class="co">   describe a polygon; each vertex is assumed to connect to the two adjacent</span>
<span class="co">   vertices, and the last vertex is assumed to connect to the first) */</span>
   <span class="kw">struct</span> PointListHeader {
   <span class="dt">int</span> Length;                <span class="co">/* # of points */</span>
   <span class="kw">struct</span> Point * PointPtr;   <span class="co">/* pointer to list of points */</span>
};
<span class="co">/* Describes beginning and ending X coordinates of a single horizontal line */</span>
<span class="kw">struct</span> HLine {
   <span class="dt">int</span> XStart; <span class="co">/* X coordinate of leftmost pixel in line */</span>
   <span class="dt">int</span> XEnd;   <span class="co">/* X coordinate of rightmost pixel in line */</span>
};
<span class="co">/* Describes a Length-long series of horizontal lines, all assumed to be on</span>
<span class="co">   contiguous scan lines starting at YStart and proceeding downward (describes</span>
<span class="co">   a scan-converted polygon to low-level hardware-dependent drawing code) */</span>
<span class="kw">struct</span> HLineList {
   <span class="dt">int</span> Length;                <span class="co">/* # of horizontal lines */</span>
   <span class="dt">int</span> YStart;                <span class="co">/* Y coordinate of topmost line */</span>
   <span class="kw">struct</span> HLine * HLinePtr;   <span class="co">/* pointer to list of horz lines */</span>
};
<span class="kw">struct</span> Rect { <span class="dt">int</span> Left, Top, Right, Bottom; };
<span class="co">/* Structure describing one face of an object (one polygon) */</span>
<span class="kw">struct</span> Face {
   <span class="dt">int</span> * VertNums;   <span class="co">/* pointer to vertex ptrs */</span>
   <span class="dt">int</span> NumVerts;     <span class="co">/* # of vertices */</span>
   <span class="dt">int</span> Color;        <span class="co">/* polygon color */</span>
};
<span class="co">/* Structure describing an object */</span>
<span class="kw">struct</span> Object {
   <span class="dt">int</span> NumVerts;
   <span class="kw">struct</span> Point3 * VertexList;
   <span class="kw">struct</span> Point3 * XformedVertexList;
   <span class="kw">struct</span> Point3 * ProjectedVertexList;
   <span class="kw">struct</span> Point * ScreenVertexList;
   <span class="dt">int</span> NumFaces;
   <span class="kw">struct</span> Face * FaceList;
};
<span class="kw">extern</span> <span class="dt">void</span> XformVec(<span class="dt">double</span> Xform[<span class="dv">4</span>][<span class="dv">4</span>], <span class="dt">double</span> * SourceVec, <span class="dt">double</span> * DestVec);
<span class="kw">extern</span> <span class="dt">void</span> ConcatXforms(<span class="dt">double</span> SourceXform1[<span class="dv">4</span>][<span class="dv">4</span>],
   <span class="dt">double</span> SourceXform2[<span class="dv">4</span>][<span class="dv">4</span>], <span class="dt">double</span> DestXform[<span class="dv">4</span>][<span class="dv">4</span>]);
<span class="kw">extern</span> <span class="dt">void</span> XformAndProjectPoly(<span class="dt">double</span> Xform[<span class="dv">4</span>][<span class="dv">4</span>],
   <span class="kw">struct</span> Point3 * Poly, <span class="dt">int</span> PolyLength, <span class="dt">int</span> Color);
<span class="kw">extern</span> <span class="dt">int</span> FillConvexPolygon(<span class="kw">struct</span> PointListHeader *, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> Set320x240Mode(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">void</span> ShowPage(<span class="dt">unsigned</span> <span class="dt">int</span> StartOffset);
<span class="kw">extern</span> <span class="dt">void</span> FillRectangleX(<span class="dt">int</span> StartX, <span class="dt">int</span> StartY, <span class="dt">int</span> EndX,
   <span class="dt">int</span> EndY, <span class="dt">unsigned</span> <span class="dt">int</span> PageBase, <span class="dt">int</span> Color);
<span class="kw">extern</span> <span class="dt">void</span> XformAndProjectPoints(<span class="dt">double</span> Xform[<span class="dv">4</span>][<span class="dv">4</span>],<span class="kw">struct</span> Object * ObjectToXform);
<span class="kw">extern</span> <span class="dt">void</span> DrawVisibleFaces(<span class="kw">struct</span> Object * ObjectToXform);
<span class="kw">extern</span> <span class="dt">void</span> AppendRotationX(<span class="dt">double</span> XformToChange[<span class="dv">4</span>][<span class="dv">4</span>], <span class="dt">double</span> Angle);
<span class="kw">extern</span> <span class="dt">void</span> AppendRotationY(<span class="dt">double</span> XformToChange[<span class="dv">4</span>][<span class="dv">4</span>], <span class="dt">double</span> Angle);
<span class="kw">extern</span> <span class="dt">void</span> AppendRotationZ(<span class="dt">double</span> XformToChange[<span class="dv">4</span>][<span class="dv">4</span>], <span class="dt">double</span> Angle);
<span class="kw">extern</span> <span class="dt">int</span> DisplayedPage, NonDisplayedPage;
<span class="kw">extern</span> <span class="kw">struct</span> Rect EraseRect[];</code></pre>
</section>
<section id="a-note-on-rounding-negative-numbers" class="level3">
<h3><a href="#a-note-on-rounding-negative-numbers">A Note on Rounding Negative Numbers</a></h3>
<p>In the previous chapter, I added 0.5 and truncated in order to round values from floating-point to integer format. Here, in Listing 51.2, I’ve switched to adding 0.5 and using the <code>floor()</code> function. For positive values, the two approaches are equivalent; for negative values, only the <code>floor()</code> approach works properly.</p>
</section>
<section id="object-representation" class="level3">
<h3><a href="#object-representation">Object Representation</a></h3>
<p>Each object consists of a list of vertices and a list of faces, with the vertices of each face defined by pointers into the vertex list; this allows each vertex to be transformed exactly once, even though several faces may share a single vertex. Each object contains the vertices not only in their original, untransformed state, but in three other forms as well: transformed to view space, transformed and projected to screen space, and converted to screen coordinates. Earlier, we saw that it can be convenient to store the screen coordinates within the object, so that if the object hasn’t moved with respect to the viewer, it can be redrawn without the need for recalculation, but why bother storing the view and screen space forms of the vertices as well?</p>
<p>The screen space vertices are useful for some sorts of hidden surface removal. For example, to determine whether two polygons overlap as seen by the viewer, you must first know how they look to the viewer, accounting for perspective; screen space provides that information. (So do the final screen coordinates, but with less accuracy, and without any Z information.) The view space vertices are useful for collision and proximity detection; screen space can’t be used here, because objects are distorted by the perspective projection into screen space. World space would serve as well as view space for collision detection, but because it’s possible to transform directly from object space to view space with a single matrix, it’s often preferable to skip over world space. It’s not mandatory that vertices be stored for all these different spaces, but the coordinates in all those spaces have to be calculated as intermediate steps anyway, so we might as well keep them around for those occasions when they’re needed.</p>
</section>
</section>
<section id="chapter-52-fast-3-d-animation-meet-x-sharp" class="level2">
<h2><a href="#chapter-52-fast-3-d-animation-meet-x-sharp">Chapter 52 – Fast 3-D Animation: Meet X-Sharp</a></h2>
<section id="the-first-iteration-of-a-generalized-3-d-animation-package" class="level3">
<h3><a href="#the-first-iteration-of-a-generalized-3-d-animation-package">The First Iteration of a Generalized 3-D Animation Package</a></h3>
<p>Across the lake from Vermont, a few miles into upstate New York, the Ausable River has carved out a fairly impressive gorge known as “Ausable Chasm.” Impressive for the East, anyway; you might think of it as the poor man’s Grand Canyon. Some time back, I did the tour with my wife and five-year-old, and it was fun, although I confess that I didn’t loosen my grip on my daughter’s hand until we were on the bus and headed for home; that gorge is deep, and the railings tend to be of the single-bar, rusted-out variety.</p>
<p>New Yorkers can drive straight to this wonder of nature, but Vermonters must take their cars across on the ferry; the alternative is driving three hours around the south end of Lake Champlain. No problem; the ferry ride is an hour well spent on a beautiful lake. Or, rather, no problem—once you’re on the ferry. Getting to New York is easy, but, as we found out, the line of cars waiting to come back from Ausable Chasm gets lengthy about mid-afternoon. The ferry can hold only so many cars, and we wound up spending an unexpected hour exploring the wonders of the ferry docks. Not a big deal, with a good-natured kid and an entertaining mom; we got ice cream, explored the beach, looked through binoculars, and told stories. It was a fun break, actually, and before we knew it, the ferry was steaming back to pick us up.</p>
<p>A friend of mine, an elementary-school teacher, helped take 65 sixth graders to Ausable Chasm. Never mind the potential for trouble with 65 kids loose on a ferry. Never mind what it was like trying to herd that group around a gorge that looks like it was designed to swallow children and small animals without a trace. The hard part was getting back to the docks and finding they’d have to wait an hour for the next ferry. As my friend put it, “Let me tell you, an hour is an eternity with 65 sixth graders screaming the song ‘You Are My Sunshine.’”</p>
<p>Apart from reminding you how lucky you are to be working in a quiet, air-conditioned room, in front of a gently humming computer, free to think deep thoughts and eat Cheetos to your heart’s content, this story provides a useful perspective on the malleable nature of time. An hour isn’t just an hour—it can be forever, or it can be the wink of an eye. Just think of the last hour you spent working under a deadline; I bet it went past in a flash. Which is not to say, mind you, that I recommend working in a bus full of screaming kids in order to make time pass more slowly; there are quality issues here as well.</p>
<p>In our 3-D animation work so far, we’ve used floating-point arithmetic. Floating-point arithmetic—even with a floating-point processor but especially <em>without</em> one—is the microcomputer animation equivalent of working in a school bus: It takes forever to do anything, and you just <em>know</em> you’re never going to accomplish as much as you want to. In this chapter, we’ll address fixed-point arithmetic, which will give us an instant order-of-magnitude performance boost. We’ll also give our 3-D animation code a much more powerful and extensible framework, making it easy to add new and different sorts of objects. Taken together, these alterations will let us start to do some really interesting real-time animation.</p>
</section>
<section id="this-chapters-demo-program" class="level3">
<h3><a href="#this-chapters-demo-program">This Chapter’s Demo Program</a></h3>
<p>Three-dimensional animation is a complicated business, and it takes an astonishing amount of functionality just to get off the launching pad: page flipping, polygon filling, clipping, transformations, list management, and so forth. I’ve been building toward a critical mass of animation functionality over the course of this book, and this chapter’s code builds on the code from no fewer than five previous chapters. The code that’s required in order to link this chapter’s animation demo program is the following:</p>
<ul>
<li>Listing 50.1 from Chapter 50 (draw clipped line list);</li>
<li>Listings 47.1 and 47.6 from Chapter 47 (Mode X mode set, rectangle fill);</li>
<li>Listing 49.6 from Chapter 49;</li>
<li>Listing 39.4 from Chapter 39 (polygon edge scan); and</li>
<li>The <code>FillConvexPolygon( )</code> function from Listing 38.1 from Chapter
<ol start="38" type="1">
<li>Note that the <code>struct</code> keywords in <code>FillConvexPolygon( )</code> must be removed to reflect the switch to typedefs in the animation header file.</li>
</ol></li>
</ul>
<p>As always, all required files are in this chapter’s subdirectory on the CD-ROM.</p>
<p><strong>LISTING 52.1 L52-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* 3-D animation program to rotate 12 cubes. Uses fixed point. All C code</span>
<span class="co">   tested with Borland C++ in C compilation mode and the small model. */</span>

<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="co">/* base offset of page to which to draw */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> CurrentPageBase = <span class="dv">0</span>;
<span class="co">/* clip rectangle; clips to the screen */</span>
<span class="dt">int</span> ClipMinX = <span class="dv">0</span>, ClipMinY = <span class="dv">0</span>;
<span class="dt">int</span> ClipMaxX = SCREEN_WIDTH, ClipMaxY = SCREEN_HEIGHT;
<span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">int</span> PageStartOffsets[<span class="dv">2</span>] =
   {PAGE0_START_OFFSET,PAGE1_START_OFFSET};
<span class="dt">int</span> DisplayedPage, NonDisplayedPage;
<span class="dt">int</span> RecalcAllXforms = <span class="dv">1</span>, NumObjects = <span class="dv">0</span>;
Xform WorldViewXform;   <span class="co">/* initialized from floats */</span>
<span class="co">/* pointers to objects */</span>
Object *ObjectList[MAX_OBJECTS];

<span class="dt">void</span> main() {
   <span class="dt">int</span> Done = <span class="dv">0</span>, i;
   Object *ObjectPtr;
   <span class="kw">union</span> REGS regset;

   InitializeFixedPoint(); <span class="co">/* set up fixed-point data */</span>
   InitializeCubes();      <span class="co">/* set up cubes and add them to object list; other</span>
<span class="co">                              objects would be initialized now, if there were any */</span>
   Set320x240Mode();       <span class="co">/* set the screen to mode X */</span>
   ShowPage(PageStartOffsets[DisplayedPage = <span class="dv">0</span>]);
   <span class="co">/* Keep transforming the cube, drawing it to the undisplayed page,</span>
<span class="co">      and flipping the page to show it */</span>
   <span class="kw">do</span> {
      <span class="co">/* For each object, regenerate viewing info, if necessary */</span>
      <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NumObjects; i++) {
         <span class="kw">if</span> ((ObjectPtr = ObjectList[i])-&gt;RecalcXform ||
               RecalcAllXforms) {
            ObjectPtr-&gt;RecalcFunc(ObjectPtr);
            ObjectPtr-&gt;RecalcXform = <span class="dv">0</span>;
         }
      }
      RecalcAllXforms = <span class="dv">0</span>;
      CurrentPageBase =    <span class="co">/* select other page for drawing to */</span>
            PageStartOffsets[NonDisplayedPage = DisplayedPage ^ <span class="dv">1</span>];
      <span class="co">/* For each object, clear the portion of the non-displayed page</span>
<span class="co">         that was drawn to last time, then reset the erase extent */</span>
      <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NumObjects; i++) {
         ObjectPtr = ObjectList[i];
         FillRectangleX(ObjectPtr-&gt;EraseRect[NonDisplayedPage].Left,
            ObjectPtr-&gt;EraseRect[NonDisplayedPage].Top,
            ObjectPtr-&gt;EraseRect[NonDisplayedPage].Right,
            ObjectPtr-&gt;EraseRect[NonDisplayedPage].Bottom,
            CurrentPageBase, <span class="dv">0</span>);
         ObjectPtr-&gt;EraseRect[NonDisplayedPage].Left =
              ObjectPtr-&gt;EraseRect[NonDisplayedPage].Top = <span class="bn">0x7FFF</span>;
         ObjectPtr-&gt;EraseRect[NonDisplayedPage].Right =
               ObjectPtr-&gt;EraseRect[NonDisplayedPage].Bottom = <span class="dv">0</span>;
      }
      <span class="co">/* Draw all objects */</span>
      <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NumObjects; i++)
         ObjectList[i]-&gt;DrawFunc(ObjectList[i]);
      <span class="co">/* Flip to display the page into which we just drew */</span>
      ShowPage(PageStartOffsets[DisplayedPage = NonDisplayedPage]);
      <span class="co">/* Move and reorient each object */</span>
      <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NumObjects; i++)
         ObjectList[i]-&gt;MoveFunc(ObjectList[i]);
      <span class="kw">if</span> (kbhit())
         <span class="kw">if</span> (getch() == <span class="bn">0x1B</span>) Done = <span class="dv">1</span>;   <span class="co">/* Esc to exit */</span>
   } <span class="kw">while</span> (!Done);
   <span class="co">/* Return to text mode and exit */</span>
   regset.x.ax = <span class="bn">0x0003</span>;   <span class="co">/* AL = 3 selects 80x25 text mode */</span>
   int86(<span class="bn">0x10</span>, &amp;regset, &amp;regset);
   exit(<span class="dv">1</span>);
}</code></pre>
<p><strong>LISTING 52.2 L52-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Transforms all vertices in the specified polygon-based object into view</span>
<span class="co">   space, then perspective projects them to screen space and maps them to screen</span>
<span class="co">   coordinates, storing results in the object. Recalculates object-&gt;view</span>
<span class="co">   transformation because only if transform changes would we bother</span>
<span class="co">   to retransform the vertices. */</span>

<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="dt">void</span> XformAndProjectPObject(PObject * ObjectToXform)
{
   <span class="dt">int</span> i, NumPoints = ObjectToXform-&gt;NumVerts;
   Point3 * Points = ObjectToXform-&gt;VertexList;
   Point3 * XformedPoints = ObjectToXform-&gt;XformedVertexList;
   Point3 * ProjectedPoints = ObjectToXform-&gt;ProjectedVertexList;
   Point * ScreenPoints = ObjectToXform-&gt;ScreenVertexList;

   <span class="co">/* Recalculate the object-&gt;view transform */</span>
   ConcatXforms(WorldViewXform, ObjectToXform-&gt;XformToWorld,
                ObjectToXform-&gt;XformToView);
   <span class="co">/* Apply that new transformation and project the points */</span>
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NumPoints; i++, Points++, XformedPoints++,
         ProjectedPoints++, ScreenPoints++) {
      <span class="co">/* Transform to view space */</span>
      XformVec(ObjectToXform-&gt;XformToView, (Fixedpoint *) Points,
            (Fixedpoint *) XformedPoints);
      <span class="co">/* Perspective-project to screen space */</span>
      ProjectedPoints-&gt;X =
            FixedMul(FixedDiv(XformedPoints-&gt;X, XformedPoints-&gt;Z),
            DOUBLE_TO_FIXED(PROJECTION_RATIO * (SCREEN_WIDTH/<span class="dv">2</span>)));
      ProjectedPoints-&gt;Y =
            FixedMul(FixedDiv(XformedPoints-&gt;Y, XformedPoints-&gt;Z),
            DOUBLE_TO_FIXED(PROJECTION_RATIO * (SCREEN_WIDTH/<span class="dv">2</span>)));
      ProjectedPoints-&gt;Z = XformedPoints-&gt;Z;
      <span class="co">/* Convert to screen coordinates. The Y coord is negated to flip from</span>
<span class="co">         increasing Y being up to increasing Y being down, as expected by polygon</span>
<span class="co">         filler. Add in half the screen width and height to center on screen. */</span>
      ScreenPoints-&gt;X = ((<span class="dt">int</span>) ((ProjectedPoints-&gt;X +
            DOUBLE_TO_FIXED(<span class="fl">0.5</span>)) &gt;&gt; <span class="dv">16</span>)) + SCREEN_WIDTH/<span class="dv">2</span>;
      ScreenPoints-&gt;Y = (-((<span class="dt">int</span>) ((ProjectedPoints-&gt;Y +
            DOUBLE_TO_FIXED(<span class="fl">0.5</span>)) &gt;&gt; <span class="dv">16</span>))) + SCREEN_HEIGHT/<span class="dv">2</span>;
   }
}</code></pre>
<p><strong>LISTING 52.3 L52-3.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Routines to perform incremental rotations around the three axes. */</span>

<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="co">/* Concatenate a rotation by Angle around the X axis to transformation in</span>
<span class="co">   XformToChange, placing the result back into XformToChange. */</span>
<span class="dt">void</span> AppendRotationX(Xform XformToChange, <span class="dt">double</span> Angle)
{
   Fixedpoint Temp10, Temp11, Temp12, Temp20, Temp21, Temp22;
   Fixedpoint CosTemp = DOUBLE_TO_FIXED(cos(Angle));
   Fixedpoint SinTemp = DOUBLE_TO_FIXED(sin(Angle));

   <span class="co">/* Calculate the new values of the six affected matrix entries */</span>
   Temp10 = FixedMul(CosTemp, XformToChange[<span class="dv">1</span>][<span class="dv">0</span>]) +
         FixedMul(-SinTemp, XformToChange[<span class="dv">2</span>][<span class="dv">0</span>]);
   Temp11 = FixedMul(CosTemp, XformToChange[<span class="dv">1</span>][<span class="dv">1</span>]) +
         FixedMul(-SinTemp, XformToChange[<span class="dv">2</span>][<span class="dv">1</span>]);
   Temp12 = FixedMul(CosTemp, XformToChange[<span class="dv">1</span>][<span class="dv">2</span>]) +
         FixedMul(-SinTemp, XformToChange[<span class="dv">2</span>][<span class="dv">2</span>]);
   Temp20 = FixedMul(SinTemp, XformToChange[<span class="dv">1</span>][<span class="dv">0</span>]) +
         FixedMul(CosTemp, XformToChange[<span class="dv">2</span>][<span class="dv">0</span>]);
   Temp21 = FixedMul(SinTemp, XformToChange[<span class="dv">1</span>][<span class="dv">1</span>]) +
         FixedMul(CosTemp, XformToChange[<span class="dv">2</span>][<span class="dv">1</span>]);
   Temp22 = FixedMul(SinTemp, XformToChange[<span class="dv">1</span>][<span class="dv">2</span>]) +
         FixedMul(CosTemp, XformToChange[<span class="dv">2</span>][<span class="dv">2</span>]);
   <span class="co">/* Put the results back into XformToChange */</span>
   XformToChange[<span class="dv">1</span>][<span class="dv">0</span>] = Temp10; XformToChange[<span class="dv">1</span>][<span class="dv">1</span>] = Temp11;
   XformToChange[<span class="dv">1</span>][<span class="dv">2</span>] = Temp12; XformToChange[<span class="dv">2</span>][<span class="dv">0</span>] = Temp20;
   XformToChange[<span class="dv">2</span>][<span class="dv">1</span>] = Temp21; XformToChange[<span class="dv">2</span>][<span class="dv">2</span>] = Temp22;
}
<span class="co">/* Concatenate a rotation by Angle around the Y axis to transformation in</span>
<span class="co">   XformToChange, placing the result back into XformToChange. */</span>
<span class="dt">void</span> AppendRotationY(Xform XformToChange, <span class="dt">double</span> Angle)
{
   Fixedpoint Temp00, Temp01, Temp02, Temp20, Temp21, Temp22;
   Fixedpoint CosTemp = DOUBLE_TO_FIXED(cos(Angle));
   Fixedpoint SinTemp = DOUBLE_TO_FIXED(sin(Angle));

   <span class="co">/* Calculate the new values of the six affected matrix entries */</span>
   Temp00 = FixedMul(CosTemp, XformToChange[<span class="dv">0</span>][<span class="dv">0</span>]) +
         FixedMul(SinTemp, XformToChange[<span class="dv">2</span>][<span class="dv">0</span>]);
   Temp01 = FixedMul(CosTemp, XformToChange[<span class="dv">0</span>][<span class="dv">1</span>]) +
         FixedMul(SinTemp, XformToChange[<span class="dv">2</span>][<span class="dv">1</span>]);
   Temp02 = FixedMul(CosTemp, XformToChange[<span class="dv">0</span>][<span class="dv">2</span>]) +
         FixedMul(SinTemp, XformToChange[<span class="dv">2</span>][<span class="dv">2</span>]);
   Temp20 = FixedMul(-SinTemp, XformToChange[<span class="dv">0</span>][<span class="dv">0</span>]) +
         FixedMul( CosTemp, XformToChange[<span class="dv">2</span>][<span class="dv">0</span>]);
   Temp21 = FixedMul(-SinTemp, XformToChange[<span class="dv">0</span>][<span class="dv">1</span>]) +
         FixedMul(CosTemp, XformToChange[<span class="dv">2</span>][<span class="dv">1</span>]);
   Temp22 = FixedMul(-SinTemp, XformToChange[<span class="dv">0</span>][<span class="dv">2</span>]) +
         FixedMul(CosTemp, XformToChange[<span class="dv">2</span>][<span class="dv">2</span>]);
   <span class="co">/* Put the results back into XformToChange */</span>
   XformToChange[<span class="dv">0</span>][<span class="dv">0</span>] = Temp00; XformToChange[<span class="dv">0</span>][<span class="dv">1</span>] = Temp01;
   XformToChange[<span class="dv">0</span>][<span class="dv">2</span>] = Temp02; XformToChange[<span class="dv">2</span>][<span class="dv">0</span>] = Temp20;
   XformToChange[<span class="dv">2</span>][<span class="dv">1</span>] = Temp21; XformToChange[<span class="dv">2</span>][<span class="dv">2</span>] = Temp22;
}

<span class="co">/* Concatenate a rotation by Angle around the Z axis to transformation in</span>
<span class="co">   XformToChange, placing the result back into XformToChange. */</span>
<span class="dt">void</span> AppendRotationZ(Xform XformToChange, <span class="dt">double</span> Angle)
{
   Fixedpoint Temp00, Temp01, Temp02, Temp10, Temp11, Temp12;
   Fixedpoint CosTemp = DOUBLE_TO_FIXED(cos(Angle));
   Fixedpoint SinTemp = DOUBLE_TO_FIXED(sin(Angle));

   <span class="co">/* Calculate the new values of the six affected matrix entries */</span>
   Temp00 = FixedMul(CosTemp, XformToChange[<span class="dv">0</span>][<span class="dv">0</span>]) +
         FixedMul(-SinTemp, XformToChange[<span class="dv">1</span>][<span class="dv">0</span>]);
   Temp01 = FixedMul(CosTemp, XformToChange[<span class="dv">0</span>][<span class="dv">1</span>]) +
         FixedMul(-SinTemp, XformToChange[<span class="dv">1</span>][<span class="dv">1</span>]);
   Temp02 = FixedMul(CosTemp, XformToChange[<span class="dv">0</span>][<span class="dv">2</span>]) +
         FixedMul(-SinTemp, XformToChange[<span class="dv">1</span>][<span class="dv">2</span>]);
   Temp10 = FixedMul(SinTemp, XformToChange[<span class="dv">0</span>][<span class="dv">0</span>]) +
         FixedMul(CosTemp, XformToChange[<span class="dv">1</span>][<span class="dv">0</span>]);
   Temp11 = FixedMul(SinTemp, XformToChange[<span class="dv">0</span>][<span class="dv">1</span>]) +
         FixedMul(CosTemp, XformToChange[<span class="dv">1</span>][<span class="dv">1</span>]);
   Temp12 = FixedMul(SinTemp, XformToChange[<span class="dv">0</span>][<span class="dv">2</span>]) +
         FixedMul(CosTemp, XformToChange[<span class="dv">1</span>][<span class="dv">2</span>]);
   <span class="co">/* Put the results back into XformToChange */</span>
   XformToChange[<span class="dv">0</span>][<span class="dv">0</span>] = Temp00; XformToChange[<span class="dv">0</span>][<span class="dv">1</span>] = Temp01;
   XformToChange[<span class="dv">0</span>][<span class="dv">2</span>] = Temp02; XformToChange[<span class="dv">1</span>][<span class="dv">0</span>] = Temp10;
   XformToChange[<span class="dv">1</span>][<span class="dv">1</span>] = Temp11; XformToChange[<span class="dv">1</span>][<span class="dv">2</span>] = Temp12;
}</code></pre>
<p><strong>LISTING 52.4 L52-4.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Fixed point matrix arithmetic functions. */</span>

<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="co">/* Matrix multiplies Xform by SourceVec, and stores the result in DestVec.</span>
<span class="co">   Multiplies a 4x4 matrix times a 4x1 matrix; the result is a 4x1 matrix. Cheats</span>
<span class="co">   by assuming the W coord is 1 and bottom row of matrix is 0 0 0 1, and doesn&#39;t</span>
<span class="co">   bother to set the W coordinate of the destination. */</span>
<span class="dt">void</span> XformVec(Xform WorkingXform, Fixedpoint *SourceVec,
   Fixedpoint *DestVec)
{
   <span class="dt">int</span> i;

   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">3</span>; i++)
      DestVec[i] = FixedMul(WorkingXform[i][<span class="dv">0</span>], SourceVec[<span class="dv">0</span>]) +
            FixedMul(WorkingXform[i][<span class="dv">1</span>], SourceVec[<span class="dv">1</span>]) +
            FixedMul(WorkingXform[i][<span class="dv">2</span>], SourceVec[<span class="dv">2</span>]) +
            WorkingXform[i][<span class="dv">3</span>];   <span class="co">/* no need to multiply by W = 1 */</span>
}

<span class="co">/* Matrix multiplies SourceXform1 by SourceXform2 and stores result in</span>
<span class="co">   DestXform. Multiplies a 4x4 matrix times a 4x4 matrix; result is a 4x4 matrix.</span>
<span class="co">   Cheats by assuming bottom row of each matrix is 0 0 0 1, and doesn&#39;t bother</span>
<span class="co">   to set the bottom row of the destination. */</span>
<span class="dt">void</span> ConcatXforms(Xform SourceXform1, Xform SourceXform2,
   Xform DestXform)
{
   <span class="dt">int</span> i, j;

   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">3</span>; i++) {
      <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;<span class="dv">4</span>; j++)
         DestXform[i][j] =
               FixedMul(SourceXform1[i][<span class="dv">0</span>], SourceXform2[<span class="dv">0</span>][j]) +
               FixedMul(SourceXform1[i][<span class="dv">1</span>], SourceXform2[<span class="dv">1</span>][j]) +
               FixedMul(SourceXform1[i][<span class="dv">2</span>], SourceXform2[<span class="dv">2</span>][j]) +
               SourceXform1[i][<span class="dv">3</span>];
   }
}</code></pre>
<p><strong>LISTING 52.5 L52-5.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Set up basic data that needs to be in fixed point, to avoid data</span>
<span class="co">   definition hassles. */</span>

<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="co">/* All vertices in the basic cube */</span>
<span class="dt">static</span> IntPoint3 IntCubeVerts[NUM_CUBE_VERTS] = {
   {<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>},{<span class="dv">15</span>,<span class="dv">15</span>,-<span class="dv">15</span>},{<span class="dv">15</span>,-<span class="dv">15</span>,<span class="dv">15</span>},{<span class="dv">15</span>,-<span class="dv">15</span>,-<span class="dv">15</span>},
   {-<span class="dv">15</span>,<span class="dv">15</span>,<span class="dv">15</span>},{-<span class="dv">15</span>,<span class="dv">15</span>,-<span class="dv">15</span>},{-<span class="dv">15</span>,-<span class="dv">15</span>,<span class="dv">15</span>},{-<span class="dv">15</span>,-<span class="dv">15</span>,-<span class="dv">15</span>} };
<span class="co">/* Transformation from world space into view space (no transformation,</span>
<span class="co">   currently) */</span>
<span class="dt">static</span> <span class="dt">int</span> IntWorldViewXform[<span class="dv">3</span>][<span class="dv">4</span>] = {
   {<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>}, {<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>}, {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>}};

<span class="dt">void</span> InitializeFixedPoint()
{
   <span class="dt">int</span> i, j;

   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">3</span>; i++)
      <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;<span class="dv">4</span>; j++)
         WorldViewXform[i][j] = INT_TO_FIXED(IntWorldViewXform[i][j]);
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NUM_CUBE_VERTS; i++) {
      CubeVerts[i].X = INT_TO_FIXED(IntCubeVerts[i].X);
      CubeVerts[i].Y = INT_TO_FIXED(IntCubeVerts[i].Y);
      CubeVerts[i].Z = INT_TO_FIXED(IntCubeVerts[i].Z);
   }
}</code></pre>
<p><strong>LISTING 52.6 L52-6.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Rotates and moves a polygon-based object around the three axes.</span>
<span class="co">   Movement is implemented only along the Z axis currently. */</span>

<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="dt">void</span> RotateAndMovePObject(PObject * ObjectToMove)
{
   <span class="kw">if</span> (--ObjectToMove-&gt;RDelayCount == <span class="dv">0</span>) {   <span class="co">/* rotate */</span>
      ObjectToMove-&gt;RDelayCount = ObjectToMove-&gt;RDelayCountBase;
      <span class="kw">if</span> (ObjectToMove-&gt;Rotate.RotateX != <span class="fl">0.0</span>)
         AppendRotationX(ObjectToMove-&gt;XformToWorld,
               ObjectToMove-&gt;Rotate.RotateX);
      <span class="kw">if</span> (ObjectToMove-&gt;Rotate.RotateY != <span class="fl">0.0</span>)
         AppendRotationY(ObjectToMove-&gt;XformToWorld,
               ObjectToMove-&gt;Rotate.RotateY);
      <span class="kw">if</span> (ObjectToMove-&gt;Rotate.RotateZ != <span class="fl">0.0</span>)
         AppendRotationZ(ObjectToMove-&gt;XformToWorld,
               ObjectToMove-&gt;Rotate.RotateZ);
      ObjectToMove-&gt;RecalcXform = <span class="dv">1</span>;
   }
   <span class="co">/* Move in Z, checking for bouncing and stopping */</span>
   <span class="kw">if</span> (--ObjectToMove-&gt;MDelayCount == <span class="dv">0</span>) {
      ObjectToMove-&gt;MDelayCount = ObjectToMove-&gt;MDelayCountBase;
      ObjectToMove-&gt;XformToWorld[<span class="dv">2</span>][<span class="dv">3</span>] += ObjectToMove-&gt;Move.MoveZ;
      <span class="kw">if</span> (ObjectToMove-&gt;XformToWorld[<span class="dv">2</span>][<span class="dv">3</span>]&gt;ObjectToMove-&gt;Move.MaxZ)
         ObjectToMove-&gt;Move.MoveZ = <span class="dv">0</span>; <span class="co">/* stop if close enough */</span>
      ObjectToMove-&gt;RecalcXform = <span class="dv">1</span>;
   }
}</code></pre>
<p><strong>LISTING 52.7 L52-7.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Draws all visible faces in specified polygon-based object. Object must have</span>
<span class="co">   previously been transformed and projected, so that ScreenVertexList array is</span>
<span class="co">   filled in. */</span>

<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="dt">void</span> DrawPObject(PObject * ObjectToXform)
{
   <span class="dt">int</span> i, j, NumFaces = ObjectToXform-&gt;NumFaces, NumVertices;
   <span class="dt">int</span> * VertNumsPtr;
   Face * FacePtr = ObjectToXform-&gt;FaceList;
   Point * ScreenPoints = ObjectToXform-&gt;ScreenVertexList;
   <span class="dt">long</span> v1, v2, w1, w2;
   Point Vertices[MAX_POLY_LENGTH];
   PointListHeader Polygon;

   <span class="co">/* Draw each visible face (polygon) of the object in turn */</span>
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NumFaces; i++, FacePtr++) {
      NumVertices = FacePtr-&gt;NumVerts;
      <span class="co">/* Copy over the face&#39;s vertices from the vertex list */</span>
      <span class="kw">for</span> (j=<span class="dv">0</span>, VertNumsPtr=FacePtr-&gt;VertNums; j&lt;NumVertices; j++)
         Vertices[j] = ScreenPoints[*VertNumsPtr++];
      <span class="co">/* Draw only if outside face showing (if the normal to the</span>
<span class="co">         polygon points toward viewer; that is, has a positive Z component) */</span>
      v1 = Vertices[<span class="dv">1</span>].X - Vertices[<span class="dv">0</span>].X;
      w1 = Vertices[NumVertices<span class="dv">-1</span>].X - Vertices[<span class="dv">0</span>].X;
      v2 = Vertices[<span class="dv">1</span>].Y - Vertices[<span class="dv">0</span>].Y;
      w2 = Vertices[NumVertices<span class="dv">-1</span>].Y - Vertices[<span class="dv">0</span>].Y;
      <span class="kw">if</span> ((v1*w2 - v2*w1) &gt; <span class="dv">0</span>) {
         <span class="co">/* It is facing the screen, so draw */</span>
         <span class="co">/* Appropriately adjust the extent of the rectangle used to</span>
<span class="co">            erase this object later */</span>
         <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;NumVertices; j++) {
            <span class="kw">if</span> (Vertices[j].X &gt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Right)
               <span class="kw">if</span> (Vertices[j].X &lt; SCREEN_WIDTH)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Right =
                        Vertices[j].X;
               <span class="kw">else</span> ObjectToXform-&gt;EraseRect[NonDisplayedPage].Right =
                     SCREEN_WIDTH;
            <span class="kw">if</span> (Vertices[j].Y &gt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Bottom)
               <span class="kw">if</span> (Vertices[j].Y &lt; SCREEN_HEIGHT)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Bottom =
                        Vertices[j].Y;
               <span class="kw">else</span> ObjectToXform-&gt;EraseRect[NonDisplayedPage].Bottom=
                     SCREEN_HEIGHT;
            <span class="kw">if</span> (Vertices[j].X &lt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Left)
               <span class="kw">if</span> (Vertices[j].X &gt; <span class="dv">0</span>)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Left =
                        Vertices[j].X;
               <span class="kw">else</span> ObjectToXform-&gt;EraseRect[NonDisplayedPage].Left=<span class="dv">0</span>;
            <span class="kw">if</span> (Vertices[j].Y &lt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Top)
               <span class="kw">if</span> (Vertices[j].Y &gt; <span class="dv">0</span>)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Top =
                        Vertices[j].Y;
               <span class="kw">else</span> ObjectToXform-&gt;EraseRect[NonDisplayedPage].Top=<span class="dv">0</span>;
         }
         <span class="co">/* Draw the polygon */</span>
         DRAW_POLYGON(Vertices, NumVertices, FacePtr-&gt;Color, <span class="dv">0</span>, <span class="dv">0</span>);
      }
   }
}</code></pre>
<p><strong>LISTING 52.8 L52-8.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Initializes the cubes and adds them to the object list. */</span>

<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="ot">#define ROT_6  (M_PI / 30.0)     </span><span class="co">/* rotate 6 degrees at a time */</span>
<span class="ot">#define ROT_3  (M_PI / 60.0)     </span><span class="co">/* rotate 3 degrees at a time */</span>
<span class="ot">#define ROT_2  (M_PI / 90.0)     </span><span class="co">/* rotate 2 degrees at a time */</span>
<span class="ot">#define NUM_CUBES 12             </span><span class="co">/* # of cubes */</span>

Point3 CubeVerts[NUM_CUBE_VERTS]; <span class="co">/* set elsewhere, from floats */</span>
<span class="co">/* vertex indices for individual cube faces */</span>
<span class="dt">static</span> <span class="dt">int</span> Face1[] = {<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">0</span>};
<span class="dt">static</span> <span class="dt">int</span> Face2[] = {<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">3</span>,<span class="dv">1</span>};
<span class="dt">static</span> <span class="dt">int</span> Face3[] = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">0</span>};
<span class="dt">static</span> <span class="dt">int</span> Face4[] = {<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">2</span>};
<span class="dt">static</span> <span class="dt">int</span> Face5[] = {<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>};
<span class="dt">static</span> <span class="dt">int</span> Face6[] = {<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">4</span>};
<span class="dt">static</span> <span class="dt">int</span> *VertNumList[]={Face1, Face2, Face3, Face4, Face5, Face6};
<span class="dt">static</span> <span class="dt">int</span> VertsInFace[]={ <span class="kw">sizeof</span>(Face1)/<span class="kw">sizeof</span>(<span class="dt">int</span>),
   <span class="kw">sizeof</span>(Face2)/<span class="kw">sizeof</span>(<span class="dt">int</span>), <span class="kw">sizeof</span>(Face3)/<span class="kw">sizeof</span>(<span class="dt">int</span>),
   <span class="kw">sizeof</span>(Face4)/<span class="kw">sizeof</span>(<span class="dt">int</span>), <span class="kw">sizeof</span>(Face5)/<span class="kw">sizeof</span>(<span class="dt">int</span>),
   <span class="kw">sizeof</span>(Face6)/<span class="kw">sizeof</span>(<span class="dt">int</span>) };
<span class="co">/* X, Y, Z rotations for cubes */</span>
<span class="dt">static</span> RotateControl InitialRotate[NUM_CUBES] = {
   {<span class="fl">0.0</span>,ROT_6,ROT_6},{ROT_3,<span class="fl">0.0</span>,ROT_3},{ROT_3,ROT_3,<span class="fl">0.0</span>},
   {ROT_3,-ROT_3,<span class="fl">0.0</span>},{-ROT_3,ROT_2,<span class="fl">0.0</span>},{-ROT_6,-ROT_3,<span class="fl">0.0</span>},
   {ROT_3,<span class="fl">0.0</span>,-ROT_6},{-ROT_2,<span class="fl">0.0</span>,ROT_3},{-ROT_3,<span class="fl">0.0</span>,-ROT_3},
   {<span class="fl">0.0</span>,ROT_2,-ROT_2},{<span class="fl">0.0</span>,-ROT_3,ROT_3},{<span class="fl">0.0</span>,-ROT_6,-ROT_6},};
<span class="dt">static</span> MoveControl InitialMove[NUM_CUBES] = {
   {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">80</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,-<span class="dv">350</span>},{<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">80</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,-<span class="dv">350</span>},
   {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">80</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,-<span class="dv">350</span>},{<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">80</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,-<span class="dv">350</span>},
   {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">80</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,-<span class="dv">350</span>},{<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">80</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,-<span class="dv">350</span>},
   {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">80</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,-<span class="dv">350</span>},{<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">80</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,-<span class="dv">350</span>},
   {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">80</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,-<span class="dv">350</span>},{<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">80</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,-<span class="dv">350</span>},
   {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">80</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,-<span class="dv">350</span>},{<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">80</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,-<span class="dv">350</span>}, };
<span class="co">/* face colors for various cubes */</span>
<span class="dt">static</span> <span class="dt">int</span> Colors[NUM_CUBES][NUM_CUBE_FACES] = {
   {<span class="dv">15</span>,<span class="dv">14</span>,<span class="dv">12</span>,<span class="dv">11</span>,<span class="dv">10</span>,<span class="dv">9</span>},{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>},{<span class="dv">35</span>,<span class="dv">37</span>,<span class="dv">39</span>,<span class="dv">41</span>,<span class="dv">43</span>,<span class="dv">45</span>},
   {<span class="dv">47</span>,<span class="dv">49</span>,<span class="dv">51</span>,<span class="dv">53</span>,<span class="dv">55</span>,<span class="dv">57</span>},{<span class="dv">59</span>,<span class="dv">61</span>,<span class="dv">63</span>,<span class="dv">65</span>,<span class="dv">67</span>,<span class="dv">69</span>},{<span class="dv">71</span>,<span class="dv">73</span>,<span class="dv">75</span>,<span class="dv">77</span>,<span class="dv">79</span>,<span class="dv">81</span>},
   {<span class="dv">83</span>,<span class="dv">85</span>,<span class="dv">87</span>,<span class="dv">89</span>,<span class="dv">91</span>,<span class="dv">93</span>},{<span class="dv">95</span>,<span class="dv">97</span>,<span class="dv">99</span>,<span class="dv">101</span>,<span class="dv">103</span>,<span class="dv">105</span>},
   {<span class="dv">107</span>,<span class="dv">109</span>,<span class="dv">111</span>,<span class="dv">113</span>,<span class="dv">115</span>,<span class="dv">117</span>},{<span class="dv">119</span>,<span class="dv">121</span>,<span class="dv">123</span>,<span class="dv">125</span>,<span class="dv">127</span>,<span class="dv">129</span>},
   {<span class="dv">131</span>,<span class="dv">133</span>,<span class="dv">135</span>,<span class="dv">137</span>,<span class="dv">139</span>,<span class="dv">141</span>},{<span class="dv">143</span>,<span class="dv">145</span>,<span class="dv">147</span>,<span class="dv">149</span>,<span class="dv">151</span>,<span class="dv">153</span>} };
<span class="co">/* starting coordinates for cubes in world space */</span>
<span class="dt">static</span> <span class="dt">int</span> CubeStartCoords[NUM_CUBES][<span class="dv">3</span>] = {
   {<span class="dv">100</span>,<span class="dv">0</span>,-<span class="dv">6000</span>},  {<span class="dv">100</span>,<span class="dv">70</span>,-<span class="dv">6000</span>}, {<span class="dv">100</span>,-<span class="dv">70</span>,-<span class="dv">6000</span>}, {<span class="dv">33</span>,<span class="dv">0</span>,-<span class="dv">6000</span>},
   {<span class="dv">33</span>,<span class="dv">70</span>,-<span class="dv">6000</span>},  {<span class="dv">33</span>,-<span class="dv">70</span>,-<span class="dv">6000</span>}, {-<span class="dv">33</span>,<span class="dv">0</span>,-<span class="dv">6000</span>},   {-<span class="dv">33</span>,<span class="dv">70</span>,-<span class="dv">6000</span>},
   {-<span class="dv">33</span>,-<span class="dv">70</span>,-<span class="dv">6000</span>},{-<span class="dv">100</span>,<span class="dv">0</span>,-<span class="dv">6000</span>}, {-<span class="dv">100</span>,<span class="dv">70</span>,-<span class="dv">6000</span>}, {-<span class="dv">100</span>,-<span class="dv">70</span>,-<span class="dv">6000</span>}};
<span class="co">/* delay counts (speed control) for cubes */</span>
<span class="dt">static</span> <span class="dt">int</span> InitRDelayCounts[NUM_CUBES] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>};
<span class="dt">static</span> <span class="dt">int</span> BaseRDelayCounts[NUM_CUBES] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">1</span>};
<span class="dt">static</span> <span class="dt">int</span> InitMDelayCounts[NUM_CUBES] = {<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>};
<span class="dt">static</span> <span class="dt">int</span> BaseMDelayCounts[NUM_CUBES] = {<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>};

<span class="dt">void</span> InitializeCubes()
{
   <span class="dt">int</span> i, j, k;
   PObject *WorkingCube;

   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NUM_CUBES; i++) {
      <span class="kw">if</span> ((WorkingCube = malloc(<span class="kw">sizeof</span>(PObject))) == NULL) {
         printf(<span class="st">&quot;Couldn&#39;t get memory</span><span class="ch">\n</span><span class="st">&quot;</span>); exit(<span class="dv">1</span>); }
      WorkingCube-&gt;DrawFunc = DrawPObject;
      WorkingCube-&gt;RecalcFunc = XformAndProjectPObject;
      WorkingCube-&gt;MoveFunc = RotateAndMovePObject;
      WorkingCube-&gt;RecalcXform = <span class="dv">1</span>;
      <span class="kw">for</span> (k=<span class="dv">0</span>; k&lt;<span class="dv">2</span>; k++) {
         WorkingCube-&gt;EraseRect[k].Left =
            WorkingCube-&gt;EraseRect[k].Top = <span class="bn">0x7FFF</span>;
         WorkingCube-&gt;EraseRect[k].Right = <span class="dv">0</span>;
         WorkingCube-&gt;EraseRect[k].Bottom = <span class="dv">0</span>;
      }
      WorkingCube-&gt;RDelayCount = InitRDelayCounts[i];
      WorkingCube-&gt;RDelayCountBase = BaseRDelayCounts[i];
      WorkingCube-&gt;MDelayCount = InitMDelayCounts[i];
      WorkingCube-&gt;MDelayCountBase = BaseMDelayCounts[i];
      <span class="co">/* Set the object-&gt;world xform to none */</span>
      <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;<span class="dv">3</span>; j++)
         <span class="kw">for</span> (k=<span class="dv">0</span>; k&lt;<span class="dv">4</span>; k++)
            WorkingCube-&gt;XformToWorld[j][k] = INT_TO_FIXED(<span class="dv">0</span>);
      WorkingCube-&gt;XformToWorld[<span class="dv">0</span>][<span class="dv">0</span>] =
         WorkingCube-&gt;XformToWorld[<span class="dv">1</span>][<span class="dv">1</span>] =
         WorkingCube-&gt;XformToWorld[<span class="dv">2</span>][<span class="dv">2</span>] =
         WorkingCube-&gt;XformToWorld[<span class="dv">3</span>][<span class="dv">3</span>] = INT_TO_FIXED(<span class="dv">1</span>);
      <span class="co">/* Set the initial location */</span>
      <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;<span class="dv">3</span>; j++) WorkingCube-&gt;XformToWorld[j][<span class="dv">3</span>] =
            INT_TO_FIXED(CubeStartCoords[i][j]);
      WorkingCube-&gt;NumVerts = NUM_CUBE_VERTS;
      WorkingCube-&gt;VertexList = CubeVerts;
      WorkingCube-&gt;NumFaces = NUM_CUBE_FACES;
      WorkingCube-&gt;Rotate = InitialRotate[i];
      WorkingCube-&gt;Move.MoveX = INT_TO_FIXED(InitialMove[i].MoveX);
      WorkingCube-&gt;Move.MoveY = INT_TO_FIXED(InitialMove[i].MoveY);
      WorkingCube-&gt;Move.MoveZ = INT_TO_FIXED(InitialMove[i].MoveZ);
      WorkingCube-&gt;Move.MinX = INT_TO_FIXED(InitialMove[i].MinX);
      WorkingCube-&gt;Move.MinY = INT_TO_FIXED(InitialMove[i].MinY);
      WorkingCube-&gt;Move.MinZ = INT_TO_FIXED(InitialMove[i].MinZ);
      WorkingCube-&gt;Move.MaxX = INT_TO_FIXED(InitialMove[i].MaxX);
      WorkingCube-&gt;Move.MaxY = INT_TO_FIXED(InitialMove[i].MaxY);
      WorkingCube-&gt;Move.MaxZ = INT_TO_FIXED(InitialMove[i].MaxZ);
      <span class="kw">if</span> ((WorkingCube-&gt;XformedVertexList =
            malloc(NUM_CUBE_VERTS*<span class="kw">sizeof</span>(Point3))) == NULL) {
         printf(<span class="st">&quot;Couldn&#39;t get memory</span><span class="ch">\n</span><span class="st">&quot;</span>); exit(<span class="dv">1</span>); }
      <span class="kw">if</span> ((WorkingCube-&gt;ProjectedVertexList =
            malloc(NUM_CUBE_VERTS*<span class="kw">sizeof</span>(Point3))) == NULL) {
         printf(<span class="st">&quot;Couldn&#39;t get memory</span><span class="ch">\n</span><span class="st">&quot;</span>); exit(<span class="dv">1</span>); }
      <span class="kw">if</span> ((WorkingCube-&gt;ScreenVertexList =
            malloc(NUM_CUBE_VERTS*<span class="kw">sizeof</span>(Point))) == NULL) {
         printf(<span class="st">&quot;Couldn&#39;t get memory</span><span class="ch">\n</span><span class="st">&quot;</span>); exit(<span class="dv">1</span>); }
      <span class="kw">if</span> ((WorkingCube-&gt;FaceList =
            malloc(NUM_CUBE_FACES*<span class="kw">sizeof</span>(Face))) == NULL) {
         printf(<span class="st">&quot;Couldn&#39;t get memory</span><span class="ch">\n</span><span class="st">&quot;</span>); exit(<span class="dv">1</span>); }
      <span class="co">/* Initialize the faces */</span>
      <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;NUM_CUBE_FACES; j++) {
         WorkingCube-&gt;FaceList[j].VertNums = VertNumList[j];
         WorkingCube-&gt;FaceList[j].NumVerts = VertsInFace[j];
         WorkingCube-&gt;FaceList[j].Color = Colors[i][j];
      }
      ObjectList[NumObjects++] = (Object *)WorkingCube;
   }
}</code></pre>
<p><strong>LISTING 52.9 L52-9.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; 386-specific fixed point multiply and divide.</span>
<span class="co">;</span>
<span class="co">; C near-callable as: Fixedpoint FixedMul(Fixedpoint M1, Fixedpoint M2);</span>
<span class="co">;                 Fixedpoint FixedDiv(Fixedpoint Dividend, Fixedpoint Divisor);</span>
<span class="co">;</span>
<span class="co">; Tested with TASM</span>
<span class="co">;</span>
        .model small
        .<span class="dv">386</span>
        .code
        public  _FixedMul,_FixedDiv
<span class="co">; Multiplies two fixed-point values together.</span>
FMparms <span class="kw">struc</span>
        <span class="dt">dw</span>      <span class="dv">2</span> dup(?)          <span class="co">;return address &amp; pushed BP</span>
M1      <span class="dt">dd</span>      ?
M2      <span class="dt">dd</span>      ?
FMparms ends
        <span class="kw">align</span>   <span class="dv">2</span>
_FixedMul       proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>
        <span class="kw">mov</span>     <span class="kw">eax</span>,[<span class="kw">bp</span>+M1]
        <span class="kw">imul</span>    <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+M2] <span class="co">;multiply</span>
        <span class="kw">add</span>     <span class="kw">eax</span><span class="bn">,8000h         </span><span class="co">;round by adding 2^(-16)</span>
        <span class="kw">adc</span>     <span class="kw">edx</span>,<span class="dv">0</span>             <span class="co">;whole part of result is in DX</span>
        <span class="kw">shr</span>     <span class="kw">eax</span>,<span class="dv">16</span>            <span class="co">;put the fractional part in AX</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>
        <span class="kw">ret</span>
_FixedMul       endp
<span class="co">; Divides one fixed-point value by another.</span>
FDparms <span class="kw">struc</span>
         <span class="dt">dw</span>     <span class="dv">2</span> dup(?)          <span class="co">;return address &amp; pushed BP</span>
Dividend <span class="dt">dd</span>     ?
Divisor  <span class="dt">dd</span>     ?
FDparms ends
        <span class="kw">align</span>   <span class="dv">2</span>
_FixedDiv       proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>
        <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">cx</span>           <span class="co">;assume positive result</span>
        <span class="kw">mov</span>     <span class="kw">eax</span>,[<span class="kw">bp</span>+Dividend]
        <span class="kw">and</span>     <span class="kw">eax</span>,<span class="kw">eax</span>         <span class="co">;positive dividend?</span>
        <span class="kw">jns</span>     FDP1            <span class="co">;yes</span>
        <span class="kw">inc</span>     <span class="kw">cx</span>              <span class="co">;mark it&#39;s a negative dividend</span>
        <span class="kw">neg</span>     <span class="kw">eax</span>             <span class="co">;make the dividend positive</span>
<span class="fu">FDP1:</span>   <span class="kw">sub</span>     <span class="kw">edx</span>,<span class="kw">edx</span>         <span class="co">;make it a 64-bit dividend, then shift</span>
                                <span class="co">; left 16 bits so that result will be in EAX</span>
        <span class="kw">rol</span>     <span class="kw">eax</span>,<span class="dv">16</span>          <span class="co">;put fractional part of dividend in</span>
                                <span class="co">; high word of EAX</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="kw">ax</span>           <span class="co">;put whole part of dividend in DX</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>           <span class="co">;clear low word of EAX</span>
        <span class="kw">mov</span>     <span class="kw">ebx</span>,<span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Divisor]
        <span class="kw">and</span>     <span class="kw">ebx</span>,<span class="kw">ebx</span>         <span class="co">;positive divisor?</span>
        <span class="kw">jns</span>     FDP2            <span class="co">;yes</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>              <span class="co">;mark it&#39;s a negative divisor</span>
        <span class="kw">neg</span>     <span class="kw">ebx</span>             <span class="co">;make divisor positive</span>
<span class="fu">FDP2:</span>   <span class="kw">div</span>     <span class="kw">ebx</span>             <span class="co">;divide</span>
        <span class="kw">shr</span>     <span class="kw">ebx</span>,<span class="dv">1</span>           <span class="co">;divisor/2, minus 1 if the divisor is</span>
        <span class="kw">adc</span>     <span class="kw">ebx</span>,<span class="dv">0</span>           <span class="co">; even</span>
        <span class="kw">dec</span>     <span class="kw">ebx</span>
        <span class="kw">cmp</span>     <span class="kw">ebx</span>,<span class="kw">edx</span>         <span class="co">;set Carry if remainder is at least</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="dv">0</span>           <span class="co">; half as large as the divisor, then</span>
                                <span class="co">; use that to round up if necessary</span>
        <span class="kw">and</span>     <span class="kw">cx</span>,<span class="kw">cx</span>           <span class="co">;should the result be made negative?</span>
        <span class="kw">jz</span>      FDP3            <span class="co">;no</span>
        <span class="kw">neg</span>     <span class="kw">eax</span>             <span class="co">;yes, negate it</span>
<span class="fu">FDP3:</span>   <span class="kw">mov</span>     <span class="kw">edx</span>,<span class="kw">eax</span>         <span class="co">;return result in DX:AX; fractional</span>
                                <span class="co">; part is already in AX</span>
        <span class="kw">shr</span>     <span class="kw">edx</span>,<span class="dv">16</span>          <span class="co">;whole part of result in DX</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>
        <span class="kw">ret</span>
_FixedDiv       endp
        end</code></pre>
<p><strong>LISTING 52.10 POLYGON.H</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* POLYGON.H: Header file for polygon-filling code, also includes</span>
<span class="co">   a number of useful items for 3-D animation. */</span>

<span class="ot">#define MAX_OBJECTS  100   </span><span class="co">/* max simultaneous # objects supported */</span>
<span class="ot">#define MAX_POLY_LENGTH 4  </span><span class="co">/* four vertices is the max per poly */</span>
<span class="ot">#define SCREEN_WIDTH 320</span>
<span class="ot">#define SCREEN_HEIGHT 240</span>
<span class="ot">#define PAGE0_START_OFFSET 0</span>
<span class="ot">#define PAGE1_START_OFFSET (((long)SCREEN_HEIGHT*SCREEN_WIDTH)/4)</span>
<span class="ot">#define NUM_CUBE_VERTS 8              </span><span class="co">/* # of vertices per cube */</span>
<span class="ot">#define NUM_CUBE_FACES 6              </span><span class="co">/* # of faces per cube */</span>
<span class="co">/* Ratio: distance from viewpoint to projection plane / width of</span>
<span class="co">   projection plane. Defines the width of the field of view. Lower</span>
<span class="co">   absolute values = wider fields of view; higher values = narrower */</span>
<span class="ot">#define PROJECTION_RATIO -2.0 </span><span class="co">/* negative because visible Z</span>
<span class="co">                                 coordinates are negative */</span>
<span class="co">/* Draws the polygon described by the point list PointList in color</span>
<span class="co">   Color with all vertices offset by (X,Y) */</span>
<span class="ot">#define DRAW_POLYGON(PointList,NumPoints,Color,X,Y)          \</span>
   Polygon.Length = NumPoints; Polygon.PointPtr = PointList; \
   FillConvexPolygon(&amp;Polygon, Color, X, Y);
<span class="ot">#define INT_TO_FIXED(x) (((long)(int)x) &lt;&lt; 16)</span>
<span class="ot">#define DOUBLE_TO_FIXED(x) ((long) (x * 65536.0 + 0.5))</span>

<span class="kw">typedef</span> <span class="dt">long</span> Fixedpoint;
<span class="kw">typedef</span> Fixedpoint Xform[<span class="dv">3</span>][<span class="dv">4</span>];
<span class="co">/* Describes a single 2D point */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">int</span> X; <span class="dt">int</span> Y; } Point;
<span class="co">/* Describes a single 3D point in homogeneous coordinates; the W</span>
<span class="co">   coordinate isn&#39;t present, though; assumed to be 1 and implied */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { Fixedpoint X, Y, Z; } Point3;
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">int</span> X; <span class="dt">int</span> Y; <span class="dt">int</span> Z; } IntPoint3;
<span class="co">/* Describes a series of points (used to store a list of vertices that</span>
<span class="co">   describe a polygon; each vertex is assumed to connect to the two</span>
<span class="co">   adjacent vertices; last vertex is assumed to connect to first) */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">int</span> Length; Point * PointPtr; } PointListHeader;
<span class="co">/* Describes the beginning and ending X coordinates of a single</span>
<span class="co">   horizontal line */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">int</span> XStart; <span class="dt">int</span> XEnd; } HLine;
<span class="co">/* Describes a Length-long series of horizontal lines, all assumed to</span>
<span class="co">   be on contiguous scan lines starting at YStart and proceeding</span>
<span class="co">   downward (used to describe a scan-converted polygon to the</span>
<span class="co">   low-level hardware-dependent drawing code). */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">int</span> Length; <span class="dt">int</span> YStart; HLine * HLinePtr;} HLineList;
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">int</span> Left, Top, Right, Bottom; } Rect;
<span class="co">/* structure describing one face of an object (one polygon) */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">int</span> * VertNums; <span class="dt">int</span> NumVerts; <span class="dt">int</span> Color; }  Face;
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">double</span> RotateX, RotateY, RotateZ; } RotateControl;
<span class="kw">typedef</span> <span class="kw">struct</span> { Fixedpoint MoveX, MoveY, MoveZ, MinX, MinY, MinZ,
   MaxX, MaxY, MaxZ; } MoveControl;
<span class="co">/* fields common to every object */</span>
<span class="ot">#define BASE_OBJECT                                              \</span>
   <span class="dt">void</span> (*DrawFunc)();     <span class="co">/* draws object */</span>                    \
   <span class="dt">void</span> (*RecalcFunc)();   <span class="co">/* prepares object for drawing */</span>     \
   <span class="dt">void</span> (*MoveFunc)();     <span class="co">/* moves object */</span>                    \
   <span class="dt">int</span> RecalcXform;        <span class="co">/* 1 to indicate need to recalc */</span>    \
   Rect EraseRect[<span class="dv">2</span>];      <span class="co">/* rectangle to erase in each page */</span>
<span class="co">/* basic object */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { BASE_OBJECT } Object;
<span class="co">/* structure describing a polygon-based object */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
   BASE_OBJECT
   <span class="dt">int</span> RDelayCount, RDelayCountBase; <span class="co">/* controls rotation speed */</span>
   <span class="dt">int</span> MDelayCount, MDelayCountBase; <span class="co">/* controls movement speed */</span>
   Xform XformToWorld;        <span class="co">/* transform from object-&gt;world space */</span>
   Xform XformToView;         <span class="co">/* transform from object-&gt;view space */</span>
   RotateControl Rotate;      <span class="co">/* controls rotation change over time */</span>
   MoveControl Move;          <span class="co">/* controls object movement over time */</span>
   <span class="dt">int</span> NumVerts;              <span class="co">/* # vertices in VertexList */</span>
   Point3 * VertexList;       <span class="co">/* untransformed vertices */</span>
   Point3 * XformedVertexList;   <span class="co">/* transformed into view space */</span>
   Point3 * ProjectedVertexList; <span class="co">/* projected into screen space */</span>
   Point * ScreenVertexList;     <span class="co">/* converted to screen coordinates */</span>
   <span class="dt">int</span> NumFaces;              <span class="co">/* # of faces in object */</span>
   Face * FaceList;           <span class="co">/* pointer to face info */</span>
} PObject;

<span class="kw">extern</span> <span class="dt">void</span> XformVec(Xform, Fixedpoint *, Fixedpoint *);
<span class="kw">extern</span> <span class="dt">void</span> ConcatXforms(Xform, Xform, Xform);
<span class="kw">extern</span> <span class="dt">int</span> FillConvexPolygon(PointListHeader *, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> Set320x240Mode(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">void</span> ShowPage(<span class="dt">unsigned</span> <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> FillRectangleX(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">int</span>);
<span class="kw">extern</span> <span class="dt">void</span> XformAndProjectPObject(PObject *);
<span class="kw">extern</span> <span class="dt">void</span> DrawPObject(PObject *);
<span class="kw">extern</span> <span class="dt">void</span> AppendRotationX(Xform, <span class="dt">double</span>);
<span class="kw">extern</span> <span class="dt">void</span> AppendRotationY(Xform, <span class="dt">double</span>);
<span class="kw">extern</span> <span class="dt">void</span> AppendRotationZ(Xform, <span class="dt">double</span>);
<span class="kw">extern</span> near Fixedpoint FixedMul(Fixedpoint, Fixedpoint);
<span class="kw">extern</span> near Fixedpoint FixedDiv(Fixedpoint, Fixedpoint);
<span class="kw">extern</span> <span class="dt">void</span> InitializeFixedPoint(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">void</span> RotateAndMovePObject(PObject *);
<span class="kw">extern</span> <span class="dt">void</span> InitializeCubes(<span class="dt">void</span>);
<span class="kw">extern</span> <span class="dt">int</span> DisplayedPage, NonDisplayedPage, RecalcAllXforms;
<span class="kw">extern</span> <span class="dt">int</span> NumObjects;
<span class="kw">extern</span> Xform WorldViewXform;
<span class="kw">extern</span> Object *ObjectList[];
<span class="kw">extern</span> Point3 CubeVerts[];</code></pre>
</section>
<section id="a-new-animation-framework-x-sharp" class="level3">
<h3><a href="#a-new-animation-framework-x-sharp">A New Animation Framework: X-Sharp</a></h3>
<p>Listings 52.1 through 52.10 shown earlier represent not merely faster animation in library form, but also a nearly complete, extensible, data-driven animation framework. Whereas much of the earlier animation code I’ve presented in this book was hardwired to demonstrate certain concepts, this chapter’s code is intended to serve as the basis for a solid animation package. Objects are stored, in their entirety, in customizable structures; new structures can be devised for new sorts of objects. Drawing, preparing for drawing, and moving are all vectored functions, so that variations such as shading or texturing, or even radically different sorts of graphics objects, such as scaled bitmaps, could be supported. The cube initialization is entirely data driven; more or different cubes, or other sorts of convex polyhedrons, could be added by simply changing the initialization data in Listing 52.8.</p>
<p>Somewhere along the way in writing the material that became this section of the book, I realized that I had a generally useful animation package by the tail and gave it a name: X-Sharp. (<em>X</em> for Mode X, <em>sharp</em> because good animation looks sharp, and, well, who would want a flat animation package?)</p>
<p>Note that the X-Sharp library as presented in this chapter (and, indeed, in this book) is not a fully complete 3-D library. Movement is supported only along the Z axis in this chapter’s version, and then in a non-general fashion. More interesting movement isn’t supported at this point because of one of the two missing features in X-Sharp: hidden-surface removal. (The other missing feature is general 3-D clipping.) Without hidden surface removal, nothing can safely overlap. It would actually be easy enough to perform hidden-surface removal by keeping the cubes in different Z bands and drawing them back to front, but this gets into sorting and list issues, and is not a complete solution—and I’ve crammed as much as will fit into one chapter’s code, anyway.</p>
<p>I’m working toward a goal in this last section of the book, and there are many lessons to be learned and stories to be told along the way. So as X-Sharp grows, you’ll find its evolving implementations in the chapter subdirectories on the listings diskette. This chapter’s subdirectory, for example, contains the self-extracting archive file XSHARP14.EXE, (to extract its contents you simply run it as though it were a program) and the code in that archive is the code I’m speaking of specifically in this chapter, with all the limitations mentioned above. Chapter 53’s subdirectory, however, contains the file XSHARP15.EXE, which is the next step in the evolution of X-Sharp, and it is the version that I’ll be specifically talking about in that chapter. Later chapters will have their own implementations in their respective chapter subdirectories, in files of the form XSHARPxx.EXE, where xx is an ascending number indicating the version. The final and most recent X-Sharp version will be present in its own subdirectory called XSHARP22. If you’re intending to use X-Sharp in a real project, use the most recent version to be sure that you avail yourself of all new features and bug fixes.</p>
</section>
<section id="three-keys-to-realtime-animation-performance" class="level3">
<h3><a href="#three-keys-to-realtime-animation-performance">Three Keys to Realtime Animation Performance</a></h3>
<p>As of the previous chapter, we were at the point where we could rotate, move, and draw a solid cube in real time. Not too shabby…but the code I’m presenting in this chapter goes a bit further, rotating 12 solid cubes at an update rate of about 15 frames per second (fps) on a 20 MHz 386 with a slow VGA. That’s 12 transformation matrices, 72 polygons, and 96 vertices being handled in real time; not Star Wars, granted, but a giant step beyond a single cube. Run the program if you get a chance; you may be surprised at just how effective this level of animation is. I’d like to point out, in case anyone missed it, that this is fully <em>general</em> 3-D. I’m not using any shortcuts or tricks, like prestoring coordinates or pregenerating bitmaps; if you were to feed in different rotations or vertices, the animation would change accordingly.</p>
<p>The keys to the performance increase manifested in this chapter’s code are three. The first key is fixed-point arithmetic. In the previous two chapters, we worked with floating-point coordinates and transformation matrices. Those values are now stored as 32-bit fixed-point numbers, in the form 16.16 (16 bits of whole number, 16 bits of fraction). 32-bit fixed-point numbers allow sufficient precision for 3-D animation, but can be manipulated with fast integer operations, rather than by slow floating-point processor operations or excruciatingly slow floating-point emulator operations. Although the speed advantage of fixed-point varies depending on the operation, on the processor, and on whether or not a coprocessor is present, fixed-point multiplication can be as much as 100 times faster than the emulated floating-point equivalent. (I’d like to take a moment to thank Chris Hecker for his invaluable input in this area.)</p>
<p>The second performance key is the use of the 386’s native 32-bit multiply and divide instructions. C compilers operating in real mode call library routines to perform multiplications and divisions involving 32-bit values, and those library functions are fairly slow, especially for division. On a 386, 32-bit multiplication and division can be handled with the bit of code in Listing 52.9—and most of even that code is only for rounding.</p>
<p>The third performance key is maintaining and operating on only the relevant portions of transformation matrices and coordinates. The bottom row of every transformation matrix we’ll use (in this book) is [0 0 0 1], so why bother using or recalculating it when concatenating transforms and transforming points? Likewise for the fourth element of a 3-D vector in homogeneous coordinates, which is always 1. Basically, transformation matrices are treated as consisting of a 3x3 rotation matrix and a 3x1 translation vector, and coordinates are treated as 3x1 vectors. This saves a great many multiplications in the course of transforming each point.</p>
<p>Just for fun, I reimplemented the animation of Listings 52.1 through 52.10 with floating-point instructions. Together, the preceeding optimizations improve the performance of the entire animation—including drawing time and overhead, and not just math—by more than ten times over the code that uses the floating-point emulator. Amazing what one can accomplish with a few dozen lines of assembly and a switch in number format, isn’t it? Note that no assembly code other than the native 386 multiply and divide is used in Listings 52.1 through 52.10, although the polygon fill code is of course mostly in assembly; we’ve achieved 12 cubes animated at 15 fps while doing the 3-D work almost entirely in Borland C++, and we’re <em>still</em> doing sine and cosine via the floating-point emulator. Happily, we’re still nowhere near the upper limit on the animation potential of the PC.</p>
<section id="drawbacks" class="level4">
<h4><a href="#drawbacks">Drawbacks</a></h4>
<p>The techniques we’ve used to turbocharge 3-D animation are very powerful, but there’s a dark side to them as well. Obviously, native 386 instructions won’t work on 8088 and 286 machines. That’s rectifiable; equivalent multiplication and division routines could be implemented for real mode and performance would still be reasonable. It sure is nice to be able to plug in a 32-bit <code>IMUL</code> or <code>DIV</code> and be done with it, though. More importantly, 32-bit fixed-point arithmetic has limitations in range and accuracy. Points outside a 64Kx64Kx64K space can’t be handled, imprecision tends to creep in over the course of multiple matrix concatenations, and it’s quite possible to generate the dreaded divide by 0 interrupt if Z coordinates with absolute values less than one are used.</p>
<p>I don’t have space to discuss these issues in detail, but here are some brief thoughts: The working 64Kx64Kx64K fixed-point space can be paged into a larger virtual space. Imprecision of a pixel or two rarely matters in terms of display quality, and deterioration of concatenated rotations can be corrected by restoring orthogonality, for example by periodically calculating one row of the matrix as the cross-product of the other two (forcing it to be perpendicular to both). Alternatively, transformations can be calculated from scratch each time an object or the viewer moves, so there’s no chance for cumulative error. 3-D clipping with a front clip plane of -1 or less can prevent divide overflow.</p>
</section>
<section id="where-the-time-goes" class="level4">
<h4><a href="#where-the-time-goes">Where the Time Goes</a></h4>
<p>The distribution of execution time in the animation code is no longer wildly biased toward transformation, but sine and cosine are certainly still sucking up cycles. Likewise, the overhead in the calls to <code>FixedMul()</code> and <code>FixedDiv()</code> is costly. Much of this is correctable with a little carefully crafted assembly language and a lookup table; I’ll provide that shortly.</p>
<p>Regardless, with this chapter we have made the critical jump to a usable level of performance and a serviceable general-purpose framework. From here on out, it’s the fun stuff.</p>
</section>
</section>
</section>
<section id="chapter-53-raw-speed-and-more" class="level2">
<h2><a href="#chapter-53-raw-speed-and-more">Chapter 53 – Raw Speed and More</a></h2>
<section id="the-naked-truth-about-speed-in-3-d-animation" class="level3">
<h3><a href="#the-naked-truth-about-speed-in-3-d-animation">The Naked Truth About Speed in 3-D Animation</a></h3>
<p>Years ago, this friend of mine—let’s call him Bert—went to Hawaii with three other fellows to celebrate their graduation from high school. This was an unchaperoned trip, and they behaved pretty much as responsibly as you’d expect four teenagers to behave, which is to say, not; there’s a story about a rental car that, to this day, Bert can’t bring himself to tell. They had a good time, though, save for one thing: no girls.</p>
<p>By and by, they met a group of girls by the pool, but the boys couldn’t get past the hi-howya-doin stage, so they retired to their hotel room to plot a better approach. This being the early ‘70s, and them being slightly tipsy teenagers with raging hormones and the effective combined IQ of four eggplants, it took them no time at all to come up with a brilliant plan: streaking. The girls had mentioned their room number, so the boys piled into the elevator, pushed the button for the girls’ floor, shucked their clothes as fast as they could, and sprinted to the girls’ door. They knocked on the door and ran on down the hall. As the girls opened their door, Bert and his crew raced past, toward the elevator, laughing hysterically.</p>
<p>Bert was by far the fastest of them all. He whisked between the elevator doors just as they started to close; by the time his friends got there, it was too late, and the doors slid shut in their faces. As the elevator began to move, Bert could hear the frantic pounding of six fists thudding on the closed doors. As Bert stood among the clothes littering the elevator floor, the thought of his friends stuck in the hall, naked as jaybirds, was just too much, and he doubled over with helpless laughter, tears streaming down his face. The universe had blessed him with one of those exceedingly rare moments of perfect timing and execution.</p>
<p>The universe wasn’t done with Bert quite yet, though. He was still contorted with laughter—and still quite thoroughly undressed—when the elevator doors opened again. On the lobby.</p>
<p>And with that, we come to this chapter’s topics: raw speed and hidden surfaces.</p>
</section>
<section id="raw-speed-part-1-assembly-language" class="level3">
<h3><a href="#raw-speed-part-1-assembly-language">Raw Speed, Part 1: Assembly Language</a></h3>
<p>I would like to state, here and for the record, that I am not an assembly language fanatic. Frankly, I prefer programming in C; assembly language is hard work, and I can get a whole lot more done with fewer hassles in C. However, I <em>am</em> a performance fanatic, performance being defined as having programs be as nimble as possible in those areas where the user wants fast response. And, in the course of pursuing performance, there are times when a little assembly language goes a long way.</p>
<p>We’re now four chapters into development of the X-Sharp 3-D animation package. In realtime animation, performance is <em>sine qua non</em> (Latin for “Make it fast or find another line of work”), so some judiciously applied assembly language is in order. In the previous chapter, we got up to a serviceable performance level by switching to fixed-point math, then implementing the fixed-point multiplication and division functions in assembly in order to take advantage of the 386’s 32-bit capabilities. There’s another area of the program that fairly cries out for assembly language: matrix math. The function to multiply a matrix by a vector (<code>XformVec()</code>) and the function to concatenate matrices (<code>ConcatXforms()</code>) both loop heavily around calls to <strong>FixedMul();</strong> a lot of calling and looping can be eliminated by converting these functions to pure assembly language.</p>
<p>Listing 53.1 is the module FIXED.ASM from this chapter’s iteration of X-Sharp, with <code>XformVec()</code> and <code>ConcatXforms()</code> implemented in assembly language. The code is heavily optimized, to the extent of completely unrolling the loops via macros so that looping is eliminated altogether. FIXED.ASM is highly effective; the time taken for matrix math is now down to the point where it’s a fairly minor component of execution time, representing less than ten percent of the total. It’s time to turn our optimization sights elsewhere.</p>
<p><strong>LISTING 53.1 FIXED.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; 386-specific fixed point routines.</span>
<span class="co">; Tested with TASM</span>
ROUNDING-ON     <span class="dt">equ</span>     <span class="dv">1</span>     <span class="co">;1 for rounding, 0 for no rounding</span>
                              <span class="co">;no rounding is faster, rounding is</span>
                              <span class="co">; more accurate</span>
ALIGNMENT        <span class="dt">equ</span>    <span class="dv">2</span>
      .model     small
      .<span class="dv">386</span>
      .code
<span class="co">;=====================================================================</span>
<span class="co">; Multiplies two fixed-point values together.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;     Fixedpoint FixedMul(Fixedpoint M1, Fixedpoint M2);</span>
<span class="co">;     Fixedpoint FixedDiv(Fixedpoint Dividend, Fixedpoint Divisor);</span>
FMparms <span class="kw">struc</span>
            <span class="dt">dw</span>   <span class="dv">2</span> dup(?)      <span class="co">;return address &amp; pushed BP</span>
M1          <span class="dt">dd</span>   ?
M2          <span class="dt">dd</span>   ?
FMparms     ends
            <span class="kw">align</span>   ALIGNMENT
            public  -FixedMul
-FixedMul       proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>
        <span class="kw">mov</span>     <span class="kw">eax</span>,[<span class="kw">bp</span>+M1]
        <span class="kw">imul</span>    <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+M2] <span class="co">;multiply</span>
if ROUNDING-ON
        <span class="kw">add</span>     <span class="kw">eax</span><span class="bn">,8000h       </span><span class="co">;round by adding 2^(-17)</span>
        <span class="kw">adc</span>     <span class="kw">edx</span>,<span class="dv">0</span>           <span class="co">;whole part of result is in DX</span>
endif <span class="co">;ROUNDING-ON</span>
        <span class="kw">shr</span>     <span class="kw">eax</span>,<span class="dv">16</span>          <span class="co">;put the fractional part in AX</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>
        <span class="kw">ret</span>
-FixedMul       endp
<span class="co">;=====================================================================</span>
<span class="co">; Divides one fixed-point value by another.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;     Fixedpoint FixedDiv(Fixedpoint Dividend, Fixedpoint Divisor);</span>
FDparms <span class="kw">struc</span>
           <span class="dt">dw</span>    <span class="dv">2</span> dup(?)       <span class="co">;return address &amp; pushed BP</span>
Dividend   <span class="dt">dd</span>    ?
Divisor    <span class="dt">dd</span>    ?
FDparms    ends
      <span class="kw">align</span> ALIGNMENT
public        -FixedDiv
-FixedDiv       proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>

if ROUNDING-ON
        <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">cx</span>           <span class="co">;assume positive result</span>
        <span class="kw">mov</span>     <span class="kw">eax</span>,[<span class="kw">bp</span>+Dividend]
        <span class="kw">and</span>     <span class="kw">eax</span>,<span class="kw">eax</span>         <span class="co">;positive dividend?</span>
        <span class="kw">jns</span>     FDP1            <span class="co">;yes</span>
        <span class="kw">inc</span>     <span class="kw">cx</span>              <span class="co">;mark it&#39;s a negative dividend</span>
        <span class="kw">neg</span>     <span class="kw">eax</span>             <span class="co">;make the dividend positive</span>
<span class="fu">FDP1:</span>   <span class="kw">sub</span>     <span class="kw">edx</span>,<span class="kw">edx</span>         <span class="co">;make it a 64-bit dividend, then shift</span>
                                <span class="co">; left 16 bits so that result will be</span>
                                <span class="co">; in EAX</span>
        <span class="kw">rol</span>     <span class="kw">eax</span>,<span class="dv">16</span>          <span class="co">;put fractional part of dividend in</span>
                                <span class="co">; high word of EAX</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="kw">ax</span>           <span class="co">;put whole part of dividend in DX</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>           <span class="co">;clear low word of EAX</span>
        <span class="kw">mov</span>     <span class="kw">ebx</span>,<span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Divisor]
        <span class="kw">and</span>     <span class="kw">ebx</span>,<span class="kw">ebx</span>         <span class="co">;positive divisor?</span>
        <span class="kw">jns</span>     FDP2            <span class="co">;yes</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>              <span class="co">;mark it&#39;s a negative divisor</span>
        <span class="kw">neg</span>     <span class="kw">ebx</span>             <span class="co">;make divisor positive</span>
<span class="fu">FDP2:</span>   <span class="kw">div</span>     <span class="kw">ebx</span>             <span class="co">;divide</span>
        <span class="kw">shr</span>     <span class="kw">ebx</span>,<span class="dv">1</span>           <span class="co">;divisor/2, minus 1 if the divisor is</span>
        <span class="kw">adc</span>     <span class="kw">ebx</span>,<span class="dv">0</span>           <span class="co">; even</span>
        <span class="kw">dec</span>     <span class="kw">ebx</span>
        <span class="kw">cmp</span>     <span class="kw">ebx</span>,<span class="kw">edx</span>         <span class="co">;set Carry if remainder is at least</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="dv">0</span>           <span class="co">; half as large as the divisor, then</span>
                                <span class="co">; use that to round up if necessary</span>
        <span class="kw">and</span>     <span class="kw">cx</span>,<span class="kw">cx</span>           <span class="co">;should the result be made negative?</span>
        <span class="kw">jz</span>      FDP3            <span class="co">;no</span>
        <span class="kw">neg</span>     <span class="kw">eax</span>             <span class="co">;yes, negate it</span>
<span class="fu">FDP3:</span>
else <span class="co">;  !ROUNDING-ON</span>
        <span class="kw">mov</span>     <span class="kw">edx</span>,[<span class="kw">bp</span>+Dividend]
        <span class="kw">sub</span>     <span class="kw">eax</span>,<span class="kw">eax</span>
        <span class="kw">shrd</span>    <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>       <span class="co">;position so that result ends up</span>
        <span class="kw">sar</span>     <span class="kw">edx</span>,<span class="dv">16</span>           <span class="co">; in EAX</span>
        idivdword <span class="dt">ptr</span> [<span class="kw">bp</span>+Divisor]
endif <span class="co">;ROUNDING-ON</span>
        <span class="kw">shld</span>    <span class="kw">edx</span>,<span class="kw">eax</span>,<span class="dv">16</span>       <span class="co">;whole part of result in DX;</span>
                                 <span class="co">; fractional part is already in AX</span>
        <span class="kw">pop</span>      <span class="kw">bp</span>
        <span class="kw">ret</span>
-FixedDiv       endp
<span class="co">;=====================================================================</span>
<span class="co">; Returns the sine and cosine of an angle.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;void CosSin(TAngle Angle, Fixedpoint *Cos, Fixedpoint *);</span>

<span class="kw">align</span> ALIGNMENT
CosTable label <span class="dt">dword</span>
include costable.<span class="kw">inc</span>

SCparms <span class="kw">struc</span>
            <span class="dt">dw</span>    <span class="dv">2</span> dup(?)    <span class="co">;return address &amp; pushed BP</span>
Angle       <span class="dt">dw</span>    ?           <span class="co">;angle to calculate sine &amp; cosine for</span>
Cos         <span class="dt">dw</span>    ?           <span class="co">;pointer to cos destination</span>
Sin         <span class="dt">dw</span>    ?           <span class="co">;pointer to sin destination</span>
SCparms ends

   <span class="kw">align</span> ALIGNMENT
   public -CosSin
-CosSinprocnear
     <span class="kw">push</span>  <span class="kw">bp</span>                  <span class="co">;preserve stack frame</span>
     <span class="kw">mov</span>   <span class="kw">bp</span>,<span class="kw">sp</span>               <span class="co">;set up local stack frame</span>

     <span class="kw">mov</span>   <span class="kw">bx</span>,[<span class="kw">bp</span>].Angle
     <span class="kw">and</span>   <span class="kw">bx</span>,<span class="kw">bx</span>               <span class="co">;make sure angle&#39;s between 0 and 2*pi</span>
<span class="kw">jns</span>  CheckInRange
<span class="fu">MakePos:</span><span class="co">;less than 0, so make it positive</span>
     <span class="kw">add</span>    <span class="kw">bx</span>,<span class="dv">360</span>*<span class="dv">10</span>
     <span class="kw">js</span>     MakePos
     <span class="kw">jmp</span>    <span class="dt">short</span> CheckInRange

<span class="kw">align</span> ALIGNMENT
<span class="fu">MakeInRange:</span>                   <span class="co">;make sure angle is no more than 2*pi</span>
     <span class="kw">sub</span>   <span class="kw">bx</span>,<span class="dv">360</span>*<span class="dv">10</span>
<span class="fu">CheckInRange:</span>
<span class="kw">cmp</span>   <span class="kw">bx</span>,<span class="dv">360</span>*<span class="dv">10</span>
<span class="kw">jg</span>    MakeInRange

      <span class="kw">cmp</span>  <span class="kw">bx</span>,<span class="dv">180</span>*<span class="dv">10</span>        <span class="co">;figure out which quadrant</span>
      <span class="kw">ja</span>   BottomHalf       <span class="co">;quadrant 2 or 3</span>
      <span class="kw">cmp</span>  <span class="kw">bx</span>,<span class="dv">90</span>*<span class="dv">10</span>         <span class="co">;quadrant 0 or 1</span>
      <span class="kw">ja</span>   Quadrant1
                            <span class="co">;quadrant 0</span>
      <span class="kw">shl</span>   <span class="kw">bx</span>,<span class="dv">2</span>
      move  <span class="kw">ax</span>,CosTable[<span class="kw">bx</span>] <span class="co">;look up sine</span>
      <span class="kw">neg</span>   <span class="kw">bx</span>              <span class="co">;sin(Angle) = cos(90-Angle)</span>
      move  <span class="kw">dx</span>,CosTable[<span class="kw">bx</span><span class="dv">+90</span>*<span class="dv">10</span>*<span class="dv">4</span>] <span class="co">;look up cosine</span>
      <span class="kw">jmp</span>   <span class="dt">short</span> CSDone

      <span class="kw">align</span>  ALIGNMENT
<span class="fu">Quadrant1:</span>
      <span class="kw">neg</span>    <span class="kw">bx</span>
      <span class="kw">add</span>    <span class="kw">bx</span>,<span class="dv">180</span>*<span class="dv">10</span>       <span class="co">;convert to angle between 0 and 90</span>
      <span class="kw">shl</span>    <span class="kw">bx</span>,<span class="dv">2</span>
      <span class="kw">mov</span>    <span class="kw">eax</span>,CosTable[<span class="kw">bx</span>] <span class="co">;look up cosine</span>
      <span class="kw">neg</span>    <span class="kw">eax</span>             <span class="co">;negative in this quadrant</span>
      <span class="kw">neg</span>    <span class="kw">bx</span>              <span class="co">;sin(Angle) = cos(90-Angle)</span>
      move   <span class="kw">dx</span>,CosTable[<span class="kw">bx</span><span class="dv">+90</span>*<span class="dv">10</span>*<span class="dv">4</span>] <span class="co">;look up cosine</span>
      <span class="kw">jmp</span>    <span class="dt">short</span> CSDone

      <span class="kw">align</span>  ALIGNMENT
<span class="fu">BottomHalf:</span>                <span class="co">;quadrant 2 or 3</span>
      <span class="kw">neg</span>     <span class="kw">bx</span>
      <span class="kw">add</span>     <span class="kw">bx</span>,<span class="dv">360</span>*<span class="dv">10</span>    <span class="co">;convert to angle between 0 and 180</span>
      <span class="kw">cmp</span>     <span class="kw">bx</span>,<span class="dv">90</span>*<span class="dv">10</span>     <span class="co">;quadrant 2 or 3</span>
      <span class="kw">ja</span>      Quadrant2
                           <span class="co">;quadrant 3</span>
      <span class="kw">shl</span>      <span class="kw">bx</span>, <span class="dv">2</span>
      <span class="kw">mov</span>   <span class="kw">eax</span>,CosTable[<span class="kw">bx</span>]     <span class="co">;look up cosine</span>
      <span class="kw">neg</span>   <span class="kw">bx</span>              <span class="co">;sin(Angle) = cos(90-Angle)</span>
      movedx,CosTable[<span class="dv">90</span>*<span class="dv">10</span>*<span class="dv">4</span>+<span class="kw">bx</span>] <span class="co">;look up sine</span>
      nege     <span class="kw">dx</span>          <span class="co">;negative in this quadrant</span>
      <span class="kw">jmp</span>     <span class="dt">short</span> CSDone

      <span class="kw">align</span>  ALIGNMENT
<span class="fu">Quadrant2:</span>
     <span class="kw">neg</span>     <span class="kw">bx</span>
     <span class="kw">add</span>     <span class="kw">bx</span>,<span class="dv">180</span>*<span class="dv">10</span>      <span class="co">;convert to angle between 0 and 90</span>
     <span class="kw">shl</span>     <span class="kw">bx</span>,<span class="dv">2</span>
     <span class="kw">mov</span>     <span class="kw">eax</span>,CosTable[<span class="kw">bx</span>] <span class="co">;look up cosine</span>
     <span class="kw">neg</span>     <span class="kw">eax</span>          <span class="co">;negative in this quadrant</span>
     <span class="kw">neg</span>     <span class="kw">bx</span>           <span class="co">;sin(Angle) = cos(90-Angle)</span>
     move    <span class="kw">dx</span>,CosTable[<span class="dv">90</span>*<span class="dv">10</span>*<span class="dv">4</span>+<span class="kw">bx</span>] <span class="co">;look up sine</span>
     nege    <span class="kw">dx</span>             <span class="co">;negative in this quadrant</span>
<span class="fu">CSDone:</span>
     <span class="kw">mov</span>      <span class="kw">bx</span>,[<span class="kw">bp</span>].Cos
     <span class="kw">mov</span>      [<span class="kw">bx</span>],<span class="kw">eax</span>
     <span class="kw">mov</span>      <span class="kw">bx</span>,[<span class="kw">bp</span>].Sin
     <span class="kw">mov</span>      [<span class="kw">bx</span>],<span class="kw">edx</span>

     <span class="kw">pop</span>      <span class="kw">bp</span><span class="co">;restore stack frame</span>
<span class="kw">ret</span>
-CosSinendp
<span class="co">;=====================================================================</span>
<span class="co">; Matrix multiplies Xform by SourceVec, and stores the result in</span>
<span class="co">; DestVec. Multiplies a 4x4 matrix times a 4x1 matrix; the result</span>
<span class="co">; is a 4x1 matrix. Cheats by assuming the W coord is 1 and the</span>
<span class="co">; bottom row of the matrix is 0 0 0 1, and doesn&#39;t bother to set</span>
<span class="co">; the W coordinate of the destination.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;     void XformVec(Xform WorkingXform, Fixedpoint *SourceVec,</span>
<span class="co">;          Fixedpoint *DestVec);</span>
<span class="co">;</span>
<span class="co">; This assembly code is equivalent to this C code:</span>
<span class="co">;   int i;</span>
<span class="co">;</span>
<span class="co">;   for (i=0; i&lt;3; i++)</span>
<span class="co">;      DestVec[i] = FixedMul(WorkingXform[i][0], SourceVec[0]) +</span>
<span class="co">;     FixedMul(WorkingXform[i][1], SourceVec[1]) +</span>
<span class="co">;     FixedMul(WorkingXform[i][2], SourceVec[2]) +</span>
<span class="co">;     WorkingXform[i][3];   /* no need to multiply by W = 1 */</span>

XVparms <span class="kw">struc</span>
               <span class="dt">dw</span>    <span class="dv">2</span> dup(?)   <span class="co">;return address &amp; pushed BP</span>
WorkingXform   <span class="dt">dw</span>    ?          <span class="co">;pointer to transform matrix</span>
SourceVec      <span class="dt">dw</span>    ?          <span class="co">;pointer to source vector</span>
DestVec        <span class="dt">dw</span>    ?          <span class="co">;pointer to destination vector</span>
XVparms       ends

    <span class="kw">align</span>  ALIGNMENT
    public -XformVec
-XformVec   proc   near
    <span class="kw">push</span>    <span class="kw">bp</span>                  <span class="co">;preserve stack frame</span>
    <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>               <span class="co">;set up local stack frame</span>
    <span class="kw">push</span>    <span class="kw">si</span>                  <span class="co">;preserve register variables</span>
    <span class="kw">push</span>    <span class="kw">di</span>

    <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>].WorkingXform  <span class="co">;SI points to xform matrix</span>
    <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].SourceVec    <span class="co">;BX points to source vector</span>
    <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>].DestVec    <span class="co">;DI points to dest vector</span>

soff=<span class="dv">0</span>
doff=<span class="dv">0</span>
    REPT <span class="dv">3</span>                     <span class="co">;do once each for dest X, Y, and Z</span>
    <span class="kw">mov</span>    <span class="kw">eax</span>,[<span class="kw">si</span>+soff]       <span class="co">;column 0 entry on this row</span>
    <span class="kw">imul</span>   <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bx</span>]      <span class="co">;xform entry times source X entry</span>
if ROUNDING-ON
    <span class="kw">add</span>    <span class="kw">eax</span><span class="bn">,8000h           </span><span class="co">;round by adding 2^(-17)</span>
    <span class="kw">adc</span>    <span class="kw">edx</span>,<span class="dv">0</span>               <span class="co">;whole part of result is in DX</span>
endif <span class="co">;ROUNDING-ON</span>
    <span class="kw">shrd</span>   <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span><span class="co">;shift the result back to 16.16 form</span>
    <span class="kw">mov</span>    <span class="kw">ecx</span>,<span class="kw">eax</span>             <span class="co">;set running total</span>

    <span class="kw">mov</span>    <span class="kw">eax</span>,[<span class="kw">si</span>+soff<span class="dv">+4</span>]     <span class="co">;column 1 entry on this row</span>
    <span class="kw">imul</span>   <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bx</span><span class="dv">+4</span>]    <span class="co">;xform entry times source Y entry</span>
if ROUNDING-ON
    <span class="kw">add</span>    <span class="kw">eax</span><span class="bn">,8000h           </span><span class="co">;round by adding 2^(-17)</span>
    <span class="kw">adc</span>    <span class="kw">edx</span>,<span class="dv">0</span>               <span class="co">;whole part of result is in DX</span>
endif <span class="co">;ROUNDING-ON</span>
    <span class="kw">shrd</span>   <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>          <span class="co">;shift the result back to 16.16 form</span>
    <span class="kw">add</span>    <span class="kw">ecx</span>,<span class="kw">eax</span>             <span class="co">;running total for this row</span>

    <span class="kw">mov</span>    <span class="kw">eax</span>,[<span class="kw">si</span>+soff<span class="dv">+8</span>]     <span class="co">;column 2 entry on this row</span>
    <span class="kw">imul</span>   <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bx</span><span class="dv">+8</span>]    <span class="co">;xform entry times source Z entry</span>
if ROUNDING-ON
    <span class="kw">add</span>    <span class="kw">eax</span><span class="bn">,8000h           </span><span class="co">;round by adding 2^(-17)</span>
    <span class="kw">adc</span>    <span class="kw">edx</span>,<span class="dv">0</span>               <span class="co">;whole part of result is in DX</span>
endif <span class="co">;ROUNDING-ON</span>
    <span class="kw">shrd</span>   <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>          <span class="co">;shift the result back to 16.16 form</span>
    <span class="kw">add</span>    <span class="kw">ecx</span>,<span class="kw">eax</span>             <span class="co">;running total for this row</span>

    <span class="kw">add</span>    <span class="kw">ecx</span>,[<span class="kw">si</span>+soff<span class="dv">+12</span>]    <span class="co">;add in translation</span>
    <span class="kw">mov</span>[<span class="kw">di</span>+doff],<span class="kw">ecx</span>          <span class="co">;save the result in the dest vector</span>
soff=soff<span class="dv">+16</span>
doff=doff<span class="dv">+4</span>
ENDM

popdi<span class="co">;restore register variables</span>
popsi
popbp<span class="co">;restore stack frame</span>
<span class="kw">ret</span>
-XformVecendp
<span class="co">;=====================================================================</span>
<span class="co">; Matrix multiplies SourceXform1 by SourceXform2 and stores the</span>
<span class="co">; result in DestXform. Multiplies a 4x4 matrix times a 4x4 matrix;</span>
<span class="co">; the result is a 4x4 matrix. Cheats by assuming the bottom row of</span>
<span class="co">; each matrix is 0 0 0 1, and doesn&#39;t bother to set the bottom row</span>
<span class="co">; of the destination.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;       void ConcatXforms(Xform SourceXform1, Xform SourceXform2,</span>
<span class="co">;               Xform DestXform)</span>
<span class="co">;</span>
<span class="co">; This assembly code is equivalent to this C code:</span>
<span class="co">;   int i, j;</span>
<span class="co">;</span>
<span class="co">;   for (i=0; i&lt;3; i++) {</span>
<span class="co">;      for (j=0; j&lt;3; j++)</span>
<span class="co">;         DestXform[i][j] =</span>
<span class="co">;               FixedMul(SourceXform1[i][0], SourceXform2[0][j]) +</span>
<span class="co">;               FixedMul(SourceXform1[i][1], SourceXform2[1][j]) +</span>
<span class="co">;               FixedMul(SourceXform1[i][2], SourceXform2[2][j]);</span>
<span class="co">;      DestXform[i][3] =</span>
<span class="co">;            FixedMul(SourceXform1[i][0], SourceXform2[0][3]) +</span>
<span class="co">;            FixedMul(SourceXform1[i][1], SourceXform2[1][3]) +</span>
<span class="co">;            FixedMul(SourceXform1[i][2], SourceXform2[2][3]) +</span>
<span class="co">;            SourceXform1[i][3];</span>
<span class="co">;   }</span>

CXparms <span class="kw">struc</span>
             <span class="dt">dw</span>     <span class="dv">2</span> dup(?)         <span class="co">;return address &amp; pushed BP</span>
SourceXform1 <span class="dt">dw</span>     ?                <span class="co">;pointer to first source xform matrix</span>
SourceXform2  <span class="dt">dw</span>    ?                <span class="co">;pointer to second source xform matrix</span>
DestXform     <span class="dt">dw</span>    ?                <span class="co">;pointer to destination xform matrix</span>
CXparms       ends

       <span class="kw">align</span>  ALIGNMENT
       public -ConcatXforms
-ConcatXforms    proc  near
     <span class="kw">push</span>   <span class="kw">bp</span>                     <span class="co">;preserve stack frame</span>
     <span class="kw">mov</span>    <span class="kw">bp</span>,<span class="kw">sp</span>                  <span class="co">;set up local stack frame</span>
     <span class="kw">push</span>   <span class="kw">si</span>                     <span class="co">;preserve register variables</span>
pushdi

     <span class="kw">mov</span>    <span class="kw">bx</span>,[<span class="kw">bp</span>].SourceXform2    <span class="co">;BX points to xform2 matrix</span>
     <span class="kw">mov</span>    <span class="kw">si</span>,[<span class="kw">bp</span>].SourceXform1    <span class="co">;SI points to xform1 matrix</span>
     <span class="kw">mov</span>    <span class="kw">di</span>,[<span class="kw">bp</span>].DestXform       <span class="co">;DI points to dest xform matrix</span>

roff=<span class="dv">0</span>                          <span class="co">;row offset</span>
      REPT <span class="dv">3</span>                    <span class="co">;once for each row</span>
coff=<span class="dv">0</span>                          <span class="co">;column offset</span>
      REPT <span class="dv">3</span>                    <span class="co">;once for each of the first 3 columns,</span>
                                <span class="co">; assuming 0 as the bottom entry (no</span>
<span class="co">; translation)</span>
      <span class="kw">mov</span>     <span class="kw">eax</span>,[<span class="kw">si</span>+roff]     <span class="co">;column 0 entry on this row</span>
      <span class="kw">imul</span>    <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bx</span>+coff]<span class="co">;times row 0 entry in column</span>
if ROUNDING-ON
      <span class="kw">add</span>     <span class="kw">eax</span><span class="bn">,8000h        </span><span class="co">;round by adding 2^(-17)</span>
      adcedx,<span class="dv">0</span><span class="co">;whole part of result is in DX</span>
endif <span class="co">;ROUNDING-ON</span>
       <span class="kw">shrd</span>    <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>       <span class="co">;shift the result back to 16.16 form</span>
       <span class="kw">mov</span>     <span class="kw">ecx</span>,<span class="kw">eax</span>          <span class="co">;set running total</span>

       <span class="kw">mov</span>     <span class="kw">eax</span>,[<span class="kw">si</span>+roff<span class="dv">+4</span>]  <span class="co">;column 1 entry on this row</span>
       <span class="kw">imul</span>    <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bx</span>+coff<span class="dv">+16</span>]<span class="co">;times row 1 entry in col</span>
if ROUNDING-ON
       <span class="kw">add</span>    <span class="kw">eax</span><span class="bn">,8000h         </span><span class="co">;round by adding 2^(-17)</span>
       <span class="kw">adc</span>    <span class="kw">edx</span>,<span class="dv">0</span>             <span class="co">;whole part of result is in DX</span>
endif <span class="co">;ROUNDING-ON</span>
       <span class="kw">shrd</span>   <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>        <span class="co">;shift the result back to 16.16 form</span>
       <span class="kw">add</span>    <span class="kw">ecx</span>,<span class="kw">eax</span>           <span class="co">;running total</span>

       <span class="kw">mov</span>    <span class="kw">eax</span>,[<span class="kw">si</span>+roff<span class="dv">+8</span>]   <span class="co">;column 2 entry on this row</span>
       <span class="kw">imul</span>   <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bx</span>+coff<span class="dv">+32</span>]<span class="co">;times row 2 entry in col</span>
if ROUNDING-ON
       <span class="kw">add</span>    <span class="kw">eax</span><span class="bn">,8000h         </span><span class="co">;round by adding 2^(-17)</span>
       <span class="kw">adc</span>    <span class="kw">edx</span>,<span class="dv">0</span>             <span class="co">;whole part of result is in DX</span>
endif <span class="co">;ROUNDING-ON</span>
       <span class="kw">shrd</span>   <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>        <span class="co">;shift the result back to 16.16 form</span>
       <span class="kw">add</span>    <span class="kw">ecx</span>,<span class="kw">eax</span>           <span class="co">;running total</span>

       <span class="kw">mov</span>[<span class="kw">di</span>+coff+roff],<span class="kw">ecx</span>    <span class="co">;save the result in dest matrix</span>
coff=coff<span class="dv">+4</span>                     <span class="co">;point to next col in xform2 &amp; dest</span>
ENDM
                               <span class="co">;now do the fourth column, assuming</span>
                               <span class="co">; 1 as the bottom entry, causing</span>
                               <span class="co">; translation to be performed</span>
       <span class="kw">mov</span>     <span class="kw">eax</span>,[<span class="kw">si</span>+roff]   <span class="co">;column 0 entry on this row</span>
       <span class="kw">imul</span>    <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bx</span>+coff]   <span class="co">;times row 0 entry in column</span>
if ROUNDING-ON
       <span class="kw">add</span>     <span class="kw">eax</span><span class="bn">,8000h       </span><span class="co">;round by adding 2^(-17)</span>
       <span class="kw">adc</span>     <span class="kw">edx</span>,<span class="dv">0</span>           <span class="co">;whole part of result is in DX</span>
endif <span class="co">;ROUNDING-ON</span>
       <span class="kw">shrd</span>    <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>      <span class="co">;shift the result back to 16.16 form</span>
       <span class="kw">mov</span>     <span class="kw">ecx</span>,<span class="kw">eax</span>         <span class="co">;set running total</span>

       <span class="kw">mov</span>     <span class="kw">eax</span>,[<span class="kw">si</span>+roff<span class="dv">+4</span>] <span class="co">;column 1 entry on this row</span>
       <span class="kw">imul</span>    <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bx</span>+coff<span class="dv">+16</span>]<span class="co">;times row 1 entry in col</span>
if ROUNDING-ON
        <span class="kw">add</span>    <span class="kw">eax</span><span class="bn">,8000h       </span><span class="co">;round by adding 2^(-17)</span>
        <span class="kw">adc</span>    <span class="kw">edx</span>,<span class="dv">0</span>           <span class="co">;whole part of result is in DX</span>
endif <span class="co">;ROUNDING-ON</span>
        <span class="kw">shrd</span>   <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>      <span class="co">;shift the result back to 16.16 form</span>
       <span class="kw">add</span>     <span class="kw">ecx</span>,<span class="kw">eax</span>         <span class="co">;running total</span>

       <span class="kw">mov</span>     <span class="kw">eax</span>,[<span class="kw">si</span>+roff<span class="dv">+8</span>]  <span class="co">;column 2 entry on this row</span>
       <span class="kw">imul</span>    <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bx</span>+coff<span class="dv">+32</span>]<span class="co">;times row 2 entry in col</span>
if ROUNDING-ON
       <span class="kw">add</span>    <span class="kw">eax</span><span class="bn">,8000h         </span><span class="co">;round by adding 2^(-17)</span>
       <span class="kw">adc</span>    <span class="kw">edx</span>,<span class="dv">0</span>             <span class="co">;whole part of result is in DX</span>
endif <span class="co">;ROUNDING-ON</span>
       <span class="kw">shrd</span>   <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>        <span class="co">;shift the result back to 16.16 form</span>
addecx,<span class="kw">eax</span><span class="co">;running total</span>

addecx,[<span class="kw">si</span>+roff<span class="dv">+12</span>]<span class="co">;add in translation</span>

<span class="kw">mov</span>[<span class="kw">di</span>+coff+roff],<span class="kw">ecx</span><span class="co">;save the result in dest matrix</span>
coff=coff<span class="dv">+4</span>                <span class="co">;point to next col in xform2 &amp; dest</span>

roff=roff<span class="dv">+16</span>                <span class="co">;point to next col in xform2 &amp; dest</span>
ENDM

popdi<span class="co">;restore register variables</span>
popsi
popbp<span class="co">;restore stack frame</span>
<span class="kw">ret</span>
-ConcatXformsendp
end</code></pre>
</section>
<section id="raw-speed-part-ii-look-it-up" class="level3">
<h3><a href="#raw-speed-part-ii-look-it-up">Raw Speed, Part II: Look it Up</a></h3>
<p>It’s a funny thing about Turbo Profiler: Time spent in the Borland C++ 80x87 emulator doesn’t show up directly anywhere that I can see in the timing results. The only way to detect it is by way of the line that reports what percent of total time is represented by all the areas that were profiled; if you’re profiling all areas, whatever’s not explicitly accounted for seems to be the floating-point emulator time. This quirk fooled me for a while, leading me to think sine and cosine weren’t major drags on performance, because the <code>sin()</code> and <code>cos()</code> functions spend most of their time in the emulator, and that time doesn’t show up in Turbo Profiler’s statistics on those functions. Once I figured out what was going on, it turned out that not only were <code>sin()</code> and <code>cos()</code> major drags, they were taking up over half the total execution time by themselves.</p>
<p>The solution is a lookup table. Listing 53.1 contains a function called <code>CosSin()</code> that calculates both the sine and cosine of an angle, via a lookup table. The function accepts angles in tenths of degrees; I decided to use tenths of degrees rather than radians because that way it’s always possible to look up the sine and cosine of the exact angle requested, rather than approximating, as would be required with radians. Tenths of degrees should be fine enough control for most purposes; if not, it’s easy to alter <code>CosSin()</code> for finer gradations yet. GENCOS.C, the program used to generate the lookup table (COSTABLE.INC), included in Listing 53.1, can be found in the XSHARP22 subdirectory on the listings diskette. GENCOS.C can generate a cosine table with any integral number of steps per degree.</p>
<p>FIXED.ASM (Listing 53.1) speeds X-Sharp up quite a bit, and it changes the performance balance a great deal. When we started out with 3-D animation, calculation time was the dragon we faced; more than 90 percent of the total time was spent doing matrix and projection math. Additional optimizations in the area of math could still be made (using 32-bit multiplies in the backface-removal code, for example), but fixed-point math, the sine and cosine lookup, and selective assembly optimizations have done a pretty good job already. The bulk of the time taken by X-Sharp is now spent drawing polygons, drawing rectangles (to erase objects), and waiting for the page to flip. In other words, we’ve slain the dragon of 3-D math, or at least wounded it grievously; now we’re back to the dragon of polygon filling. We’ll address faster polygon filling soon, but for the moment, we have more than enough horsepower to have some fun with. First, though, we need one more feature: hidden surfaces.</p>
<section id="hidden-surfaces" class="level4">
<h4><a href="#hidden-surfaces">Hidden Surfaces</a></h4>
<p>So far, we’ve made a number of simplifying assumptions in order to get the animation to look good; for example, all objects must currently be convex polyhedrons. What’s more, right now, objects can never pass behind or in front of each other. What that means is that it’s time to have a look at hidden surfaces.</p>
<p>There are a passel of ways to do hidden surfaces. Way off at one end (the slow end) of the spectrum is Z-buffering, whereby each pixel of each polygon is checked as it’s drawn to see whether it’s the frontmost version of the pixel at those coordinates. At the other end is the technique of simply drawing the objects in back-to-front order, so that nearer objects are drawn on top of farther objects. The latter approach, depth sorting, is the one we’ll take today. (Actually, true depth sorting involves detecting and resolving possible ambiguities when objects overlap in Z; in this chapter, we’ll simply sort the objects on Z and leave it at that.)</p>
<p>This limited version of depth sorting is fast but less than perfect. For one thing, it doesn’t address the issue of nonconvex objects, so we’ll have to stick with convex polyhedrons. For another, there’s the question of what part of each object to use as the sorting key; the nearest point, the center, and the farthest point are all possibilities—and, whichever point is used, depth sorting doesn’t handle some overlap cases properly. Figure 53.1 illustrates one case in which back-to-front sorting doesn’t work, regardless of what point is used as the sorting key.</p>
<p>For photo-realistic rendering, these are serious problems. For fast PC-based animation, however, they’re manageable. Choose objects that aren’t too elongated; arrange their paths of travel so they don’t intersect in problematic ways; and, if they do overlap incorrectly, trust that the glitch will be lost in the speed of the animation and the complexity of the screen.</p>
<p>Listing 53.2 shows X-Sharp file OLIST.C, which includes the key routines for depth sorting. Objects are now stored in a linked list. The initial, empty list, created by <code>InitializeObjectList()</code>, consists of a sentinel entry at either end, one at the farthest possible z coordinate, and one at the nearest. New entries are inserted by <code>AddObject()</code> in z-sorted order. Each time the objects are moved, before they’re drawn at their new locations, <code>SortObjects()</code> is called to Z-sort the object list, so that drawing will proceed from back to front. The Z-sorting is done on the basis of the objects’ center points; a center-point field has been added to the object structure to support this, and the center point for each object is now transformed along with the vertices. That’s really all there is to depth sorting—and now we can have objects that overlap in X and Y.</p>
<figure>
<img src="images/53-01.jpg" alt="Figure 53.1  Why back-to-front sorting doesn’t always work properly." /><figcaption><strong>Figure 53.1</strong>  <em>Why back-to-front sorting doesn’t always work properly.</em></figcaption>
</figure>
<p><strong>LISTING 53.2 OLIST.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Object list-related functions. */</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="co">/* Set up the empty object list, with sentinels at both ends to</span>
<span class="co">  terminate searches */</span>
<span class="dt">void</span> InitializeObjectList()
{
   ObjectListStart.NextObject = &amp;ObjectListEnd;
   ObjectListStart.PreviousObject = NULL;
   ObjectListStart.CenterInView.Z = INT-TO-FIXED(-<span class="dv">32768</span>);
   ObjectListEnd.NextObject = NULL;
   ObjectListEnd.PreviousObject = &amp;ObjectListStart;
   ObjectListEnd.CenterInView.Z = 0x7FFFFFFFL;
   NumObjects = <span class="dv">0</span>;
}

<span class="co">/* Adds an object to the object list, sorted by center Z coord. */</span>
<span class="dt">void</span> AddObject(Object *ObjectPtr)
{
   Object *ObjectListPtr = ObjectListStart.NextObject;

   <span class="co">/* Find the insertion point. Guaranteed to terminate because of</span>
<span class="co">      the end sentinel */</span>
   <span class="kw">while</span> (ObjectPtr-&gt;CenterInView.Z &gt; ObjectListPtr-&gt;CenterInView.Z) {
      ObjectListPtr = ObjectListPtr-&gt;NextObject;
   }

   <span class="co">/* Link in the new object */</span>
   ObjectListPtr-&gt;PreviousObject-&gt;NextObject = ObjectPtr;
   ObjectPtr-&gt;NextObject = ObjectListPtr;
   ObjectPtr-&gt;PreviousObject = ObjectListPtr-&gt;PreviousObject;
   ObjectListPtr-&gt;PreviousObject = ObjectPtr;
   NumObjects++;
}

<span class="co">/* Resorts the objects in order of ascending center Z coordinate in view space,</span>
<span class="co">   by moving each object in turn to the correct position in the object list. */</span>
<span class="dt">void</span> SortObjects()
{
   <span class="dt">int</span> i;
   Object *ObjectPtr, *ObjectCmpPtr, *NextObjectPtr;

   <span class="co">/* Start checking with the second object */</span>
   ObjectCmpPtr = ObjectListStart.NextObject;
   ObjectPtr = ObjectCmpPtr-&gt;NextObject;
   <span class="kw">for</span> (i=<span class="dv">1</span>; i&lt;NumObjects; i++) {
      <span class="co">/* See if we need to move backward through the list */</span>
      <span class="kw">if</span> (ObjectPtr-&gt;CenterInView.Z &lt; ObjectCmpPtr-&gt;CenterInView.Z) {
         <span class="co">/* Remember where to resume sorting with the next object */</span>
         NextObjectPtr = ObjectPtr-&gt;NextObject;
         <span class="co">/* Yes, move backward until we find the proper insertion</span>
<span class="co">            point. Termination guaranteed because of start sentinel */</span>
         <span class="kw">do</span> {
            ObjectCmpPtr = ObjectCmpPtr-&gt;PreviousObject;
         } <span class="kw">while</span> (ObjectPtr-&gt;CenterInView.Z &lt;
               ObjectCmpPtr-&gt;CenterInView.Z);

         <span class="co">/* Now move the object to its new location */</span>
         <span class="co">/* Unlink the object at the old location */</span>
         ObjectPtr-&gt;PreviousObject-&gt;NextObject =
               ObjectPtr-&gt;NextObject;
         ObjectPtr-&gt;NextObject-&gt;PreviousObject =
               ObjectPtr-&gt;PreviousObject;

         <span class="co">/* Link in the object at the new location */</span>
         ObjectCmpPtr-&gt;NextObject-&gt;PreviousObject = ObjectPtr;
         ObjectPtr-&gt;PreviousObject = ObjectCmpPtr;
         ObjectPtr-&gt;NextObject = ObjectCmpPtr-&gt;NextObject;
         ObjectCmpPtr-&gt;NextObject = ObjectPtr;

         <span class="co">/* Advance to the next object to sort */</span>
         ObjectCmpPtr = NextObjectPtr-&gt;PreviousObject;
         ObjectPtr = NextObjectPtr;
      } <span class="kw">else</span> {
         <span class="co">/* Advance to the next object to sort */</span>
         ObjectCmpPtr = ObjectPtr;
         ObjectPtr = ObjectPtr-&gt;NextObject;
      }
   }
}</code></pre>
</section>
<section id="rounding" class="level4">
<h4><a href="#rounding">Rounding</a></h4>
<p>FIXED.ASM contains the equate <strong>ROUNDING-ON</strong>. When this equate is 1, the results of multiplications and divisions are rounded to the nearest fixed-point values; when it’s 0, the results are truncated. The difference between the results produced by the two approaches is, at most, 2<sup>-16</sup>; you wouldn’t think that would make much difference, now, would you? But it does. When the animation is run with rounding disabled, the cubes start to distort visibly after a few minutes, and after a few minutes more they look like they’ve been run over. In contrast, I’ve never seen any significant distortion with rounding on, even after a half-hour or so. I think the difference with rounding is not that it’s so much more accurate, but rather that the errors are evenly distributed; with truncation, the errors are biased, and biased errors become very visible when they’re applied to right-angle objects. Even with rounding, though, the errors will eventually creep in, and reorthogonalization will become necessary at some point.</p>
<p>The performance cost of rounding is small, and the benefits are highly visible. Still, truncation errors become significant only when they accumulate over time, as, for example, when rotation matrices are repeatedly concatenated over the course of many transformations. Some time could be saved by rounding only in such cases. For example, division is performed only in the course of projection, and the results do not accumulate over time, so it would be reasonable to disable rounding for division.</p>
</section>
<section id="having-a-ball" class="level4">
<h4><a href="#having-a-ball">Having a Ball</a></h4>
<p>So far in our exploration of 3-D animation, we’ve had nothing to look at but triangles and cubes. It’s time for something a little more visually appealing, so the demonstration program now features a 72-sided ball. What’s particularly interesting about this ball is that it’s created by the GENBALL.C program in the BALL subdirectory of X-Sharp, and both the size of the ball and the number of bands of faces are programmable. GENBALL.C spits out to a file all the arrays of vertices and faces needed to create the ball, ready for inclusion in INITBALL.C. True, if you change the number of bands, you must change the Colors array in INITBALL.C to match, but that’s a tiny detail; by and large, the process of generating a ball-shaped object is now automated. In fact, we’re not limited to ball-shaped objects; substitute a different vertex and face generation program for GENBALL.C, and you can make whatever convex polyhedron you want; again, all you have to do is change the <code>Colors</code> array correspondingly. You can easily create multiple versions of the base object, too; INITCUBE.C is an example of this, creating 11 different cubes.</p>
<p>What we have here is the first glimmer of an object-editing system. GENBALL.C is the prototype for object definition, and INITBALL.C is the prototype for general-purpose object instantiation. Certainly, it would be nice to someday have an interactive 3-D object editing tool and resource management setup. We have our hands full with the drawing end of things at the moment, though, and for now it’s enough to be able to create objects in a semiautomated way.</p>
</section>
</section>
</section>
<section id="chapter-54-3-d-shading" class="level2">
<h2><a href="#chapter-54-3-d-shading">Chapter 54 – 3-D Shading</a></h2>
<section id="putting-realistic-surfaces-on-animated-3-d-objects" class="level3">
<h3><a href="#putting-realistic-surfaces-on-animated-3-d-objects">Putting Realistic Surfaces on Animated 3-D Objects</a></h3>
<p>At the end of the previous chapter, X-Sharp had just acquired basic hidden-surface capability, and performance had been vastly improved through the use of fixed-point arithmetic. In this chapter, we’re going to add quite a bit more: support for 8088 and 80286 PCs, a general color model, and shading. That’s an awful lot to cover in one chapter (actually, it’ll spill over into the next chapter), so let’s get to it!</p>
</section>
<section id="support-for-older-processors" class="level3">
<h3><a href="#support-for-older-processors">Support for Older Processors</a></h3>
<p>To date, X-Sharp has run on only the 386 and 486, because it uses 32-bit multiply and divide instructions that sub-386 processors don’t support. I chose 32-bit instructions for two reasons: They’re much faster for 16.16 fixed-point arithmetic than any approach that works on the 8088 and 286; and they’re much easier to implement than any other approach. In short, I was after maximum performance, and I was perhaps just a little lazy.</p>
<p>I should have known better than to try to sneak this one by you. The most common feedback I’ve gotten on X-Sharp is that I should make it support the 8088 and 286. Well, I can take a hint as well as the next guy. Listing 54.1 is an improved version of FIXED.ASM, containing dual 386/8088 versions of <code>CosSin(), XformVec()</code>, and <code>ConcatXforms()</code>, as well as <code>FixedMul()</code> and <code>FixedDiv()</code>.</p>
<p>Given the new version of FIXED.ASM, with <code>USE386</code> set to 0, X-Sharp will now run on any processor. That’s not to say that it will run fast on any processor, or at least not as fast as it used to. The switch to 8088 instructions makes X-Sharp’s fixed-point calculations about 2.5 times slower overall. Since a PC is perhaps 40 times slower than a 486/33, we’re talking about a hundred-times speed difference between the low end and mainstream. A 486/33 can animate a 72-sided ball, complete with shading (as discussed later), at 60 frames per second (fps), with plenty of cycles to spare; an 8-MHz AT can animate the same ball at about 6 fps. Clearly, the level of animation an application uses must be tailored to the available CPU horsepower.</p>
<p>The implementation of a 32-bit multiply using 8088 instructions is a simple matter of adding together four partial products. A 32-bit divide is not so simple, however. In fact, in Listing 54.1 I’ve chosen not to implement a full 32x32 divide, but rather only a 32x16 divide. The reason is simple: performance. A 32x16 divide can be implemented on an 8088 with two <code>DIV</code> instructions, but a 32x32 divide takes a great deal more work, so far as I can see. (If anyone has a fast 32x32 divide, or has a faster way to handle signed multiplies and divides than the approach taken by Listing 54.1, please drop me a line care of the publisher.) In X-Sharp, division is used only to divide either X or Y by Z in the process of projecting from view space to screen space, so the cost of using a 32x16 divide is merely some inaccuracy in calculating screen coordinates, especially when objects get very close to the Z = 0 plane. This error is not cumulative (that is, it doesn’t carry over to later frames), and in my experience doesn’t cause noticeable image degradation; therefore, given the already slow performance of the 8088 and 286, I’ve opted for performance over precision.</p>
<p>At any rate, please keep in mind that the non-386 version of <code>FixedDiv()</code> is <em>not</em> a general-purpose 32x32 fixed-point division routine. In fact, it will generate a divide-by-zero error if passed a fixed-point divisor between -1 and 1. As I’ve explained, the non-386 version of <code>Fixed-Div()</code> is designed to do just what X-Sharp needs, and no more, as quickly as possible.</p>
<p><strong>LISTING 54.1 FIXED.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Fixed point routines.</span>
<span class="co">; Tested with TASM</span>

USE386             <span class="dt">equ</span>       <span class="dv">1</span>  <span class="co">;1 for 386-specific opcodes, 0 for</span>
                                <span class="co">; 8088 opcodes</span>
<span class="kw">MUL</span>-ROUNDING-ON    <span class="dt">equ</span>       <span class="dv">1</span>  <span class="co">;1 for rounding on multiplies,</span>
                                <span class="co">; 0 for no rounding. Not rounding is faster,</span>
                                <span class="co">; rounding is more accurate and generally a</span>
                                <span class="co">; good idea</span>
<span class="kw">DIV</span>-ROUNDING-ON    <span class="dt">equ</span>       <span class="dv">0</span>  <span class="co">;1 for rounding on divides,</span>
                                <span class="co">; 0 for no rounding. Not rounding is faster,</span>
                                <span class="co">; rounding is more accurate, but because</span>
                                <span class="co">; division is only performed to project to</span>
                                <span class="co">; the screen, rounding quotients generally</span>
                                <span class="co">; isn&#39;t necessary</span>
ALIGNMENT          <span class="dt">equ</span>       <span class="dv">2</span>

     .model small
     .<span class="dv">386</span>
     .code

<span class="co">;=====================================================================</span>
<span class="co">; Multiplies two fixed-point values together.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;     Fixedpoint FixedMul(Fixedpoint M1, Fixedpoint M2);</span>
FMparms <span class="kw">struc</span>
            <span class="dt">dw</span>     <span class="dv">2</span> dup(?)        <span class="co">;return address &amp; pushed BP</span>
M1          <span class="dt">dd</span>     ?
M2          <span class="dt">dd</span>     ?
FMparms ends
     <span class="kw">align</span> ALIGNMENT
     public   _FixedMul
_FixedMul    proc     near
     <span class="kw">push</span>    <span class="kw">bp</span>
     <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>

if USE386

     <span class="kw">mov</span>     <span class="kw">eax</span>,[<span class="kw">bp</span>+M1]
     <span class="kw">imul</span>    <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+M2]       <span class="co">;multiply</span>
if <span class="kw">MUL</span>-ROUNDING-ON
     <span class="kw">add</span>   <span class="kw">eax</span><span class="bn">,8000h                 </span><span class="co">;round by adding 2^(-17)</span>
adcedx,<span class="dv">0</span>                             <span class="co">;whole part of result is in DX</span>
endif <span class="co">;MUL-ROUNDING-ON</span>
shreax,<span class="dv">16</span>                            <span class="co">;put the fractional part in AX</span>

else<span class="co">;!USE386</span>

                                     <span class="co">;do four partial products and</span>
                                     <span class="co">; add them together, accumulating</span>
                                     <span class="co">; the result in CX:BX</span>
    <span class="kw">push</span>     <span class="kw">si</span>                      <span class="co">;preserve C register variables</span>
    <span class="kw">push</span>     <span class="kw">di</span>
                                     <span class="co">;figure out signs, so we can use</span>
                                    <span class="co">; unsigned multiplies</span>
   <span class="kw">sub</span>      <span class="kw">cx</span>,<span class="kw">cx</span>                   <span class="co">;assume both operands positive</span>
   <span class="kw">mov</span>      <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+M1<span class="dv">+2</span>]
   <span class="kw">mov</span>      <span class="kw">si</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+M1]
   <span class="kw">and</span>      <span class="kw">ax</span>,<span class="kw">ax</span>                    <span class="co">;first operand negative?</span>
   <span class="kw">jns</span>      CheckSecondOperand       <span class="co">;no</span>
   <span class="kw">neg</span>      <span class="kw">ax</span>                       <span class="co">;yes, so negate first operand</span>
   <span class="kw">neg</span>      <span class="kw">si</span>
   <span class="kw">sbb</span>      <span class="kw">ax</span>,<span class="dv">0</span>
   <span class="kw">inc</span>      <span class="kw">cx</span>                       <span class="co">;mark that first operand is negative</span>
<span class="fu">CheckSecondOperand:</span>
    <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+M2<span class="dv">+2</span>]
    <span class="kw">mov</span>     <span class="kw">di</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+M2]
    <span class="kw">and</span>     <span class="kw">bx</span>,<span class="kw">bx</span>                    <span class="co">;second operand negative?</span>
    <span class="kw">jns</span>     SaveSignStatus           <span class="co">;no</span>
    <span class="kw">neg</span>     <span class="kw">bx</span>                       <span class="co">;yes, so negate second operand</span>
    <span class="kw">neg</span>     <span class="kw">di</span>
    <span class="kw">sbb</span>     <span class="kw">bx</span>,<span class="dv">0</span>
    <span class="kw">xor</span>     <span class="kw">cx</span>,<span class="dv">1</span>                     <span class="co">;mark that second operand is negative</span>
<span class="fu">SaveSignStatus:</span>
     <span class="kw">push</span>   <span class="kw">cx</span>                       <span class="co">;remember sign of result; 1 if result</span>
                                     <span class="co">; negative, 0 if result nonnegative</span>
    <span class="kw">push</span>    <span class="kw">ax</span>                       <span class="co">;remember high word of M1</span>
    <span class="kw">mul</span>     <span class="kw">bx</span>                       <span class="co">;high word M1 times high word M2</span>
    <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">ax</span>                    <span class="co">;accumulate result in CX:BX (BX not used</span>
                                     <span class="co">; until next operation, however)</span>
                                     <span class="co">;assume no overflow into DX</span>
    <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="kw">si</span>                    <span class="co">;low word M1 times high word M2</span>
    <span class="kw">mul</span>     <span class="kw">bx</span>
    <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="kw">ax</span>
    <span class="kw">add</span>     <span class="kw">cx</span>,<span class="kw">dx</span>                    <span class="co">;accumulate result in CX:BX</span>
    <span class="kw">pop</span>     <span class="kw">ax</span>                       <span class="co">;retrieve high word of M1</span>
    <span class="kw">mul</span>     <span class="kw">di</span>                       <span class="co">;high word M1 times low word M2</span>
   <span class="kw">add</span>      <span class="kw">bx</span>,<span class="kw">ax</span>
   <span class="kw">adc</span>      <span class="kw">cx</span>,<span class="kw">dx</span>                    <span class="co">;accumulate result in CX:BX</span>
   <span class="kw">mov</span>      <span class="kw">ax</span>,<span class="kw">si</span>                    <span class="co">;low word M1 times low word M2</span>
muldi
if <span class="kw">MUL</span>-ROUNDING-ON
   <span class="kw">add</span>     <span class="kw">ax</span><span class="bn">,8000h                  </span><span class="co">;round by adding 2^(-17)</span>
adcbx,<span class="kw">dx</span>
else <span class="co">;!MUL-ROUNDING-ON</span>
    <span class="kw">add</span>     <span class="kw">bx</span>,<span class="kw">dx</span>,                   <span class="co">;don&#39;t round</span>
endif <span class="co">;MUL-ROUNDING-ON</span>
    <span class="kw">adc</span>    <span class="kw">cx</span>,<span class="dv">0</span>                      <span class="co">;accumulate result in CX:BX</span>
    <span class="kw">mov</span>    <span class="kw">dx</span>,<span class="kw">cx</span>
    <span class="kw">mov</span>    <span class="kw">ax</span>,<span class="kw">bx</span>
    <span class="kw">pop</span>    <span class="kw">cx</span>
    <span class="kw">and</span>    <span class="kw">cx</span>,<span class="kw">cx</span>                     <span class="co">;is the result negative?</span>
    <span class="kw">jz</span>     FixedMulDone              <span class="co">;no, we&#39;re all set</span>
    <span class="kw">neg</span>    <span class="kw">dx</span>                        <span class="co">;yes, so negate DX:AX</span>
    <span class="kw">neg</span>    <span class="kw">ax</span>
    <span class="kw">sbb</span>    <span class="kw">dx</span>,<span class="dv">0</span>
<span class="fu">FixedMulDone:</span>

    <span class="kw">pop</span>    <span class="kw">di</span>                        <span class="co">;restore C register variables</span>
    <span class="kw">pop</span>    <span class="kw">si</span>

endif<span class="co">;USE386</span>

    <span class="kw">pop</span>    <span class="kw">bp</span>
    <span class="kw">ret</span>
_FixedMul   endp

<span class="co">;=====================================================================</span>
<span class="co">; Divides one fixed-point value by another.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;       Fixedpoint FixedDiv(Fixedpoint Dividend, Fixedpoint Divisor);</span>
FDparms <span class="kw">struc</span>
         <span class="dt">dw</span>      <span class="dv">2</span>    dup(?)       <span class="co">;return address &amp; pushed BP</span>
Dividend <span class="dt">dd</span>?
Divisor  <span class="dt">dd</span>?
FDparms ends
        alignALIGNMENT
        public_FixedDiv
_FixedDivproc    near
        pushbp
        movbp,<span class="kw">sp</span>

if USE386

if <span class="kw">DIV</span>-ROUNDING-ON
        <span class="kw">sub</span>     <span class="kw">cx</span>,<span class="kw">cx</span>           <span class="co">;assume positive result</span>
        <span class="kw">mov</span>     <span class="kw">eax</span>,[<span class="kw">bp</span>+Dividend]
        <span class="kw">and</span>     <span class="kw">eax</span>,<span class="kw">eax</span>         <span class="co">;positive dividend?</span>
        <span class="kw">jns</span>     FDP1            <span class="co">;yes</span>
        <span class="kw">inc</span>     <span class="kw">cx</span>              <span class="co">;mark it&#39;s a negative dividend</span>
        <span class="kw">neg</span>     <span class="kw">eax</span>             <span class="co">;make the dividend positive</span>
<span class="fu">FDP1:</span>   <span class="kw">sub</span>     <span class="kw">edx</span>,<span class="kw">edx</span>         <span class="co">;make it a 64-bit dividend, then shift</span>
                                <span class="co">; left 16 bits so that result will be in EAX</span>
        <span class="kw">rol</span>     <span class="kw">eax</span>,<span class="dv">16</span>          <span class="co">;put fractional part of dividend in</span>
                                <span class="co">; high word of EAX</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="kw">ax</span>           <span class="co">;put whole part of dividend in DX</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>           <span class="co">;clear low word of EAX</span>
        <span class="kw">mov</span>     <span class="kw">ebx</span>,<span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Divisor]
        <span class="kw">and</span>     <span class="kw">ebx</span>,<span class="kw">ebx</span>         <span class="co">;positive divisor?</span>
        <span class="kw">jns</span>     FDP2            <span class="co">;yes</span>
        <span class="kw">dec</span>     <span class="kw">cx</span>              <span class="co">;mark it&#39;s a negative divisor</span>
        <span class="kw">neg</span>     <span class="kw">ebx</span>             <span class="co">;make divisor positive</span>
<span class="fu">FDP2:</span>   <span class="kw">div</span>     <span class="kw">ebx</span>             <span class="co">;divide</span>
        <span class="kw">shr</span>     <span class="kw">ebx</span>,<span class="dv">1</span>           <span class="co">;divisor/2, minus 1 if the divisor is</span>
        <span class="kw">adc</span>     <span class="kw">ebx</span>,<span class="dv">0</span>           <span class="co">; even</span>
        <span class="kw">dec</span>     <span class="kw">ebx</span>
        <span class="kw">cmp</span>     <span class="kw">ebx</span>,<span class="kw">edx</span>         <span class="co">;set Carry if the remainder is at least</span>
        <span class="kw">adc</span>     <span class="kw">eax</span>,<span class="dv">0</span>           <span class="co">; half as large as the divisor, then</span>
                                <span class="co">; use that to round up if necessary</span>
        <span class="kw">and</span>     <span class="kw">cx</span>,<span class="kw">cx</span>           <span class="co">;should the result be made negative?</span>
        <span class="kw">jz</span>      FDP3            <span class="co">;no</span>
        <span class="kw">neg</span>     <span class="kw">eax</span>             <span class="co">;yes, negate it</span>
<span class="fu">FDP3:</span>
else <span class="co">;!DIV-ROUNDING-ON</span>
        <span class="kw">mov</span>     <span class="kw">edx</span>,[<span class="kw">bp</span>+Dividend]
        <span class="kw">sub</span>     <span class="kw">eax</span>,<span class="kw">eax</span>
        <span class="kw">shrd</span>    <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>      <span class="co">;position so that result ends up</span>
        <span class="kw">sar</span>     <span class="kw">edx</span>,<span class="dv">16</span>          <span class="co">; in EAX</span>
        <span class="kw">idiv</span>    <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Divisor]
endif <span class="co">;DIV-ROUNDING-ON</span>
        <span class="kw">shld</span>    <span class="kw">edx</span>,<span class="kw">eax</span>,<span class="dv">16</span>      <span class="co">;whole part of result in DX;</span>
                                <span class="co">; fractional part is already in AX</span>

else                            <span class="co">;!USE386</span>

 <span class="co">;NOTE!!! Non-386 division uses a 32-bit dividend but only the upper 16 bits</span>
 <span class="co">; of the divisor; in other words, only the integer part of the divisor is</span>
 <span class="co">; used. This is done so that the division can be accomplished with two fast</span>
 <span class="co">; hardware divides instead of a slow software implementation, and is (in my</span>
 <span class="co">; opinion) acceptable because division is only used to project points to the</span>
 <span class="co">; screen (normally, the divisor is a Z coordinate), so there&#39;s no cumulative</span>
 <span class="co">; error, although there will be some error in pixel placement (the magnitude</span>
 <span class="co">; of the error is less the farther away from the Z=0 plane objects are). This</span>
 <span class="co">; is *not* a general-purpose divide, though; if the divisor is less than 1,</span>
 <span class="co">; for instance, a divide-by-zero error will result! For this reason, non-386</span>
 <span class="co">; projection can&#39;t be performed for points closer to the viewpoint than Z=1.</span>
                                      <span class="co">;figure out signs, so we can use</span>
                                      <span class="co">; unsigned divisions</span>
      subcx,    <span class="kw">cx</span>                    <span class="co">;assume both operands positive</span>
      <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Dividend<span class="dv">+2</span>]
      <span class="kw">and</span>   <span class="kw">ax</span>,<span class="kw">ax</span><span class="co">;first operand negative?</span>
      <span class="kw">jns</span>   CheckSecondOperandD <span class="co">;no</span>
      <span class="kw">neg</span>   <span class="kw">ax</span>                         <span class="co">;yes, so negate first operand</span>
      <span class="kw">neg</span>   <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Dividend]
      sbbax,<span class="dv">0</span>
      <span class="kw">inc</span>   <span class="kw">cx</span>                         <span class="co">;mark that first operand is negative</span>
<span class="fu">      CheckSecondOperandD:</span>
      <span class="kw">mov</span>    <span class="kw">bx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Divisor<span class="dv">+2</span>]
      <span class="kw">and</span>    <span class="kw">bx</span>,<span class="kw">bx</span>                      <span class="co">;second operand negative?</span>
<span class="kw">jns</span>SaveSignStatusD<span class="co">;no</span>
      <span class="kw">neg</span>    <span class="kw">bx</span>                         <span class="co">;yes, so negate second operand</span>
      <span class="kw">neg</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Divisor]
      <span class="kw">sbb</span>    <span class="kw">bx</span>,<span class="dv">0</span>
      <span class="kw">xor</span>    <span class="kw">cx</span>,<span class="dv">1</span>                       <span class="co">;mark that second operand is negative</span>
<span class="fu">SaveSignStatusD:</span>
      <span class="kw">push</span>   <span class="kw">cx</span>                         <span class="co">;remember sign of result; 1 if result</span>
                                        <span class="co">; negative, 0 if result nonnegative</span>
      <span class="kw">sub</span>    <span class="kw">dx</span>,<span class="kw">dx</span>                      <span class="co">;put Dividend+2 (integer part) in DX:AX</span>
      <span class="kw">div</span>    <span class="kw">bx</span>                         <span class="co">;first half of 32/16 division, integer part</span>
                                        <span class="co">; divided by integer part</span>
      <span class="kw">mov</span>    <span class="kw">cx</span>,<span class="kw">ax</span>                      <span class="co">;set aside integer part of result</span>
      <span class="kw">mov</span>    <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>+Dividend]  <span class="co">;concatenate the fractional part of</span>
                                        <span class="co">; the dividend to the remainder (fractional</span>
                                        <span class="co">; part) of the result from dividing the</span>
                                        <span class="co">; integer part of the dividend</span>
     <span class="kw">div</span>     <span class="kw">bx</span>                         <span class="co">;second half of 32/16 division</span>

if <span class="kw">DIV</span>-ROUNDING-ON EQ <span class="dv">0</span>
     <span class="kw">shr</span>     <span class="kw">bx</span>,<span class="dv">1</span>                       <span class="co">;divisor/2, minus 1 if the divisor is</span>
     <span class="kw">adc</span>     <span class="kw">bx</span>,<span class="dv">0</span>                       <span class="co">; even</span>
     <span class="kw">dec</span>     <span class="kw">bx</span>
     <span class="kw">cmp</span>     <span class="kw">bx</span>,<span class="kw">dx</span>                      <span class="co">;set Carry if the remainder is at least</span>
     <span class="kw">adc</span>     <span class="kw">ax</span>,<span class="dv">0</span>                       <span class="co">; half as large as the divisor, then</span>
     <span class="kw">adc</span>     <span class="kw">cx</span>,<span class="dv">0</span>                       <span class="co">; use that to round up if necessary</span>
endif <span class="co">;DIV-ROUNDING-ON</span>

     <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="kw">cx</span>                      <span class="co">;absolute value of result in DX:AX</span>
     <span class="kw">pop</span>     <span class="kw">cx</span>
     <span class="kw">and</span>     <span class="kw">cx</span>,<span class="kw">cx</span>                      <span class="co">;is the result negative?</span>
     <span class="kw">jz</span>       FixedDivDone              <span class="co">;no, we&#39;re all set</span>
     <span class="kw">neg</span>      <span class="kw">dx</span>                        <span class="co">;yes, so negate DX:AX</span>
     <span class="kw">neg</span>      <span class="kw">ax</span>
     <span class="kw">sbb</span>      <span class="kw">dx</span>,<span class="dv">0</span>
<span class="fu">FixedDivDone:</span>

endif <span class="co">;USE386</span>

     <span class="kw">pop</span>     <span class="kw">bp</span>
     <span class="kw">ret</span>
_FixedDiv       endp

<span class="co">;=====================================================================</span>
<span class="co">; Returns the sine and cosine of an angle.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;     void CosSin(TAngle Angle, Fixedpoint *Cos, Fixedpoint *);</span>

      alignALIGNMENT
CosTable label <span class="dt">dword</span>
      include costable.<span class="kw">inc</span>

SCparms <span class="kw">struc</span>
           <span class="dt">dw</span>    <span class="dv">2</span> dup(?)              <span class="co">;return address &amp; pushed BP</span>
Angle      <span class="dt">dw</span>    ?                     <span class="co">;angle to calculate sine &amp; cosine for</span>
Cos        <span class="dt">dw</span>    ?                     <span class="co">;pointer to cos destination</span>
Sin        <span class="dt">dw</span>    ?                     <span class="co">;pointer to sin destination</span>
SCparms    ends

    alignALIGNMENT
    public _CosSin
_CosSin    procnear
     <span class="kw">push</span>  <span class="kw">bp</span>                          <span class="co">;preserve stack frame</span>
     <span class="kw">mov</span>   <span class="kw">bp</span>,<span class="kw">sp</span>                       <span class="co">;set up local stack frame</span>

if USE386

     <span class="kw">mov</span>   <span class="kw">bx</span>,[<span class="kw">bp</span>].Angle
     <span class="kw">and</span>   <span class="kw">bx</span>,<span class="kw">bx</span>                       <span class="co">;make sure angle&#39;s between 0 and 2*pi</span>
     <span class="kw">jns</span>   CheckInRange
<span class="fu">MakePos:</span>                               <span class="co">;less than 0, so make it positive</span>
     <span class="kw">add</span>   <span class="kw">bx</span>,<span class="dv">360</span>*<span class="dv">10</span>
     <span class="kw">js</span>    MakePos
     <span class="kw">jmp</span>   <span class="dt">short</span> CheckInRange

     <span class="kw">align</span> ALIGNMENT
<span class="fu">MakeInRange:</span>                           <span class="co">;make sure angle is no more than 2*pi</span>
     <span class="kw">sub</span>   <span class="kw">bx</span>,<span class="dv">360</span>*<span class="dv">10</span>
<span class="fu">CheckInRange:</span>
     <span class="kw">cmp</span>   <span class="kw">bx</span>,<span class="dv">360</span>*<span class="dv">10</span>
     <span class="kw">jg</span>    MakeInRange

     <span class="kw">cmp</span>   <span class="kw">bx</span>,<span class="dv">180</span>*<span class="dv">10</span>                   <span class="co">;figure out which quadrant</span>
     <span class="kw">ja</span>    BottomHalf                  <span class="co">;quadrant 2 or 3</span>
     <span class="kw">cmp</span>   <span class="kw">bx</span>,<span class="dv">90</span>*<span class="dv">10</span>                    <span class="co">;quadrant 0 or 1</span>
     <span class="kw">ja</span>    Quadrant1
<span class="co">;quadrant 0</span>
     <span class="kw">shl</span>   <span class="kw">bx</span>,<span class="dv">2</span>
     move  <span class="kw">ax</span>,CosTable[<span class="kw">bx</span>]              <span class="co">;look up sine</span>
     <span class="kw">neg</span>   <span class="kw">bx</span><span class="co">;sin(Angle) = cos(90-Angle)</span>
     move  <span class="kw">dx</span>,CosTable[<span class="kw">bx</span><span class="dv">+90</span>*<span class="dv">10</span>*<span class="dv">4</span>]      <span class="co">;look up cosine</span>
     <span class="kw">jmp</span>   <span class="dt">short</span> CSDone

     <span class="kw">align</span> ALIGNMENT
<span class="fu">Quadrant1:</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>
     <span class="kw">add</span>   <span class="kw">bx</span>,<span class="dv">180</span>*<span class="dv">10</span>                    <span class="co">;convert to angle between 0 and 90</span>
     <span class="kw">shl</span>   <span class="kw">bx</span>,<span class="dv">2</span>
     move  <span class="kw">ax</span>,CosTable[<span class="kw">bx</span>]              <span class="co">;look up cosine</span>
     <span class="kw">neg</span>   <span class="kw">eax</span>                          <span class="co">;negative in this quadrant</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>                           <span class="co">;sin(Angle) = cos(90-Angle)</span>
     move  <span class="kw">dx</span>,CosTable[<span class="kw">bx</span><span class="dv">+90</span>*<span class="dv">10</span>*<span class="dv">4</span>]      <span class="co">;look up cosine</span>
     <span class="kw">jmp</span>   <span class="dt">short</span> CSDone

     <span class="kw">align</span> ALIGNMENT
<span class="fu">BottomHalf:</span>                             <span class="co">;quadrant 2 or 3</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>
     <span class="kw">add</span>   <span class="kw">bx</span>,<span class="dv">360</span>*<span class="dv">10</span>                    <span class="co">;convert to angle between 0 and 180</span>
     <span class="kw">cmp</span>   <span class="kw">bx</span>,<span class="dv">90</span>*<span class="dv">10</span>                     <span class="co">;quadrant 2 or 3</span>
     <span class="kw">ja</span>    Quadrant2
                                        <span class="co">;quadrant 3</span>
     <span class="kw">shl</span>   <span class="kw">bx</span>,<span class="dv">2</span>
     move  <span class="kw">ax</span>,CosTable[<span class="kw">bx</span>]              <span class="co">;look up cosine</span>
     <span class="kw">neg</span>   <span class="kw">bx</span><span class="co">;sin(Angle) = cos(90-Angle)</span>
     move  <span class="kw">dx</span>,CosTable[<span class="dv">90</span>*<span class="dv">10</span>*<span class="dv">4</span>+<span class="kw">bx</span>]      <span class="co">;look up sine</span>
     <span class="kw">neg</span>   <span class="kw">edx</span>                          <span class="co">;negative in this quadrant</span>
     <span class="kw">jmp</span>   <span class="dt">short</span> CSDone

     <span class="kw">align</span> ALIGNMENT
<span class="fu">Quadrant2:</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>
     <span class="kw">add</span>   <span class="kw">bx</span>,<span class="dv">180</span>*<span class="dv">10</span>                    <span class="co">;convert to angle between 0 and 90</span>
     <span class="kw">shl</span>   <span class="kw">bx</span>,<span class="dv">2</span>
     move  <span class="kw">ax</span>,CosTable[<span class="kw">bx</span>]              <span class="co">;look up cosine</span>
     <span class="kw">neg</span>   <span class="kw">eax</span>                          <span class="co">;negative in this quadrant</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>                           <span class="co">;sin(Angle) = cos(90-Angle)</span>
     move  <span class="kw">dx</span>,CosTable[<span class="dv">90</span>*<span class="dv">10</span>*<span class="dv">4</span>+<span class="kw">bx</span>]      <span class="co">;look up sine</span>
     <span class="kw">neg</span>   <span class="kw">edx</span>                          <span class="co">;negative in this quadrant</span>
<span class="fu">CSDone:</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>,[<span class="kw">bp</span>].Cos
     <span class="kw">mov</span>   [<span class="kw">bx</span>],<span class="kw">eax</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>,[<span class="kw">bp</span>].Sin
     <span class="kw">mov</span>   [<span class="kw">bx</span>],<span class="kw">edx</span>

else <span class="co">;!USE386</span>

     <span class="kw">mov</span>   <span class="kw">bx</span>,[<span class="kw">bp</span>].Angle
     <span class="kw">and</span>   <span class="kw">bx</span>,<span class="kw">bx</span>                         <span class="co">;make sure angle&#39;s between 0 and 2*pi</span>
     <span class="kw">jns</span>   CheckInRange
<span class="fu">MakePos:</span>                                 <span class="co">;less than 0, so make it positive</span>
     <span class="kw">add</span>    <span class="kw">bx</span>,<span class="dv">360</span>*<span class="dv">10</span>
     <span class="kw">js</span>     MakePos
     <span class="kw">jmp</span>    <span class="dt">short</span> CheckInRange

      <span class="kw">align</span> ALIGNMENT
<span class="fu">MakeInRange:</span>                             <span class="co">; make sure angle is no more than 2*pi</span>
     <span class="kw">sub</span>   <span class="kw">bx</span>,<span class="dv">360</span>*<span class="dv">10</span>
<span class="fu">CheckInRange:</span>
     <span class="kw">cmp</span>   <span class="kw">bx</span>,<span class="dv">360</span>*<span class="dv">10</span>
     <span class="kw">jg</span>    MakeInRange

     <span class="kw">cmp</span>   <span class="kw">bx</span>,<span class="dv">180</span>*<span class="dv">10</span>                     <span class="co">;figure out which quadrant</span>
     <span class="kw">ja</span>    BottomHalf                    <span class="co">;quadrant 2 or 3</span>
     <span class="kw">cmp</span>   <span class="kw">bx</span>,<span class="dv">90</span>*<span class="dv">10</span>                      <span class="co">;quadrant 0 or 1</span>
<span class="kw">ja</span>Quadrant1
                                         <span class="co">;quadrant 0</span>
     <span class="kw">shl</span>   <span class="kw">bx</span>,<span class="dv">2</span>
     <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="kw">bx</span>]      <span class="co">;look up sine</span>
     <span class="kw">mov</span>   <span class="kw">dx</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="kw">bx</span><span class="dv">+2</span>]
     <span class="kw">neg</span>   <span class="kw">bx</span>                            <span class="co">;sin(Angle) = cos(90-Angle)</span>
     <span class="kw">mov</span>   <span class="kw">cx</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="kw">bx</span><span class="dv">+90</span>*<span class="dv">10</span>*<span class="dv">4+2</span>] <span class="co">;look up cosine</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="kw">bx</span><span class="dv">+90</span>*<span class="dv">10</span>*<span class="dv">4</span>]
     <span class="kw">jmp</span>   CSDone

     <span class="kw">align</span> ALIGNMENT
<span class="fu">Quadrant1:</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>
     <span class="kw">add</span>   <span class="kw">bx</span>,<span class="dv">180</span>*<span class="dv">10</span>                     <span class="co">;convert to angle between 0 and 90</span>
     <span class="kw">shl</span>   <span class="kw">bx</span>,<span class="dv">2</span>
     <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="kw">bx</span>]      <span class="co">;look up cosine</span>
     <span class="kw">mov</span>   <span class="kw">dx</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="kw">bx</span><span class="dv">+2</span>]
     <span class="kw">neg</span>   <span class="kw">dx</span>                            <span class="co">;negative in this quadrant</span>
     <span class="kw">neg</span>   <span class="kw">ax</span>
     <span class="kw">sbb</span>   <span class="kw">dx</span>,<span class="dv">0</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>                            <span class="co">;sin(Angle) = cos(90-Angle)</span>
     <span class="kw">mov</span>   <span class="kw">cx</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="kw">bx</span><span class="dv">+90</span>*<span class="dv">10</span>*<span class="dv">4+2</span>] <span class="co">;look up cosine</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="kw">bx</span><span class="dv">+90</span>*<span class="dv">10</span>*<span class="dv">4</span>]
     <span class="kw">jmp</span>   <span class="dt">short</span> CSDone

     <span class="kw">align</span> ALIGNMENT
<span class="fu">BottomHalf:</span>                              <span class="co">;quadrant 2 or 3</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>
     <span class="kw">add</span>   <span class="kw">bx</span>,<span class="dv">360</span>*<span class="dv">10</span>                     <span class="co">;convert to angle between 0 and 180</span>
     <span class="kw">cmp</span>   <span class="kw">bx</span>,<span class="dv">90</span>*<span class="dv">10</span>                      <span class="co">;quadrant 2 or 3</span>
<span class="kw">ja</span>Quadrant2
                                         <span class="co">;quadrant 3</span>
     <span class="kw">shl</span>   <span class="kw">bx</span>,<span class="dv">2</span>
     <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="kw">bx</span>]      <span class="co">;look up cosine</span>
     <span class="kw">mov</span>   <span class="kw">dx</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="kw">bx</span><span class="dv">+2</span>]
     <span class="kw">neg</span>   <span class="kw">bx</span>                            <span class="co">;sin(Angle) = cos(90-Angle)</span>
     <span class="kw">mov</span>   <span class="kw">cx</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="dv">90</span>*<span class="dv">10</span>*<span class="dv">4</span>+<span class="kw">bx</span><span class="dv">+2</span>] <span class="co">;look up sine</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="dv">90</span>*<span class="dv">10</span>*<span class="dv">4</span>+<span class="kw">bx</span>]
     <span class="kw">neg</span>   <span class="kw">cx</span>                            <span class="co">;negative in this quadrant</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>
     <span class="kw">sbb</span>   <span class="kw">cx</span>,<span class="dv">0</span>
     <span class="kw">jmp</span>   <span class="dt">short</span> CSDone

     <span class="kw">align</span> ALIGNMENT
<span class="fu">Quadrant2:</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>
     <span class="kw">add</span>   <span class="kw">bx</span>,<span class="dv">180</span>*<span class="dv">10</span>                     <span class="co">;convert to angle between 0 and 90</span>
     <span class="kw">shl</span>   <span class="kw">bx</span>,<span class="dv">2</span>
     <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="kw">bx</span>]      <span class="co">;look up cosine</span>
     <span class="kw">mov</span>   <span class="kw">dx</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="kw">bx</span><span class="dv">+2</span>]
     <span class="kw">neg</span>   <span class="kw">dx</span>                            <span class="co">;negative in this quadrant</span>
     <span class="kw">neg</span>   <span class="kw">ax</span>
     <span class="kw">sbb</span>   <span class="kw">dx</span>,<span class="dv">0</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>                            <span class="co">;sin(Angle) = cos(90-Angle)</span>
     <span class="kw">mov</span>   <span class="kw">cx</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="dv">90</span>*<span class="dv">10</span>*<span class="dv">4</span>+<span class="kw">bx</span><span class="dv">+2</span>] <span class="co">;look up sine</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>,<span class="dt">word</span> <span class="dt">ptr</span> CosTable[<span class="dv">90</span>*<span class="dv">10</span>*<span class="dv">4</span>+<span class="kw">bx</span>]
     <span class="kw">neg</span>   <span class="kw">cx</span>                            <span class="co">;negative in this quadrant</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>
     <span class="kw">sbb</span>   <span class="kw">cx</span>,<span class="dv">0</span>
<span class="fu">CSDone:</span>
     <span class="kw">push</span>  <span class="kw">bx</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>,[<span class="kw">bp</span>].Cos
     <span class="kw">mov</span>   [<span class="kw">bx</span>],<span class="kw">ax</span>
     <span class="kw">mov</span>   [<span class="kw">bx</span><span class="dv">+2</span>],<span class="kw">dx</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>,[<span class="kw">bp</span>].Sin
     <span class="kw">pop</span>   <span class="kw">ax</span>
     <span class="kw">mov</span>   [<span class="kw">bx</span>],<span class="kw">ax</span>
     <span class="kw">mov</span>   [<span class="kw">bx</span><span class="dv">+2</span>],<span class="kw">cx</span>

endif <span class="co">;USE386</span>

     <span class="kw">pop</span>   <span class="kw">bp</span>                            <span class="co">;restore stack frame</span>
     <span class="kw">ret</span>
_CosSin    endp

<span class="co">;=====================================================================</span>
<span class="co">; Matrix multiplies Xform by SourceVec, and stores the result in</span>
<span class="co">; DestVec. Multiplies a 4x4 matrix times a 4x1 matrix; the result</span>
<span class="co">; is a 4x1 matrix. Cheats by assuming the W coord is 1 and the</span>
<span class="co">; bottom row of the matrix is 0 0 0 1, and doesn&#39;t bother to set</span>
<span class="co">; the W coordinate of the destination.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;    void XformVec(Xform WorkingXform, Fixedpoint *SourceVec,</span>
<span class="co">;          Fixedpoint *DestVec);</span>
<span class="co">;</span>
<span class="co">; This assembly code is equivalent to this C code:</span>
<span class="co">;   int i;</span>
<span class="co">;</span>
<span class="co">;   for (i=0; i&lt;3; i++)</span>
<span class="co">;      DestVec[i] = FixedMul(WorkingXform[i][0], SourceVec[0]) +</span>
<span class="co">;           FixedMul(WorkingXform[i][1], SourceVec[1]) +</span>
<span class="co">;           FixedMul(WorkingXform[i][2], SourceVec[2]) +</span>
<span class="co">;           WorkingXform[i][3];   /* no need to multiply by W = 1 */</span>

XVparms <span class="kw">struc</span>
                 <span class="dt">dw</span>    <span class="dv">2</span> dup(?)          <span class="co">;return address &amp; pushed BP</span>
WorkingXform     <span class="dt">dw</span>    ?                 <span class="co">;pointer to transform matrix</span>
SourceVec        <span class="dt">dw</span>    ?                 <span class="co">;pointer to source vector</span>
DestVec          <span class="dt">dw</span>    ?                 <span class="co">;pointer to destination vector</span>
XVparms ends

<span class="co">; Macro for non-386 multiply. AX, BX, CX, DX destroyed.</span>
FIXED-<span class="kw">MUL</span> MACRO M1,M2
      local CheckSecondOperand,SaveSignStatus,FixedMulDone

                                         <span class="co">;do four partial products and </span>
                                         <span class="co">; add them together, accumulating</span>
                                         <span class="co">; the result in CX:BX</span>
                                         <span class="co">;figure out signs, so we can use</span>
                                         <span class="co">; unsigned multiplies</span>
     <span class="kw">sub</span>   <span class="kw">cx</span>,<span class="kw">cx</span>                         <span class="co">;assume both operands positive</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [&amp;M1&amp;+<span class="dv">2</span>]
     <span class="kw">and</span>   <span class="kw">bx</span>,<span class="kw">bx</span>                         <span class="co">;first operand negative?</span>
     <span class="kw">jns</span>   CheckSecondOperand            <span class="co">;no</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>                            <span class="co">;yes, so negate first operand</span>
     <span class="kw">neg</span>   <span class="dt">word</span> <span class="dt">ptr</span> [&amp;M1&amp;]
     <span class="kw">sbb</span>   <span class="kw">bx</span>,<span class="dv">0</span>
     <span class="kw">mov</span>   <span class="dt">word</span> <span class="dt">ptr</span> [&amp;M1&amp;+<span class="dv">2</span>],<span class="kw">bx</span>
     <span class="kw">inc</span>   <span class="kw">cx</span>                            <span class="co">;mark that first operand is negative</span>
<span class="fu">CheckSecondOperand:</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [&amp;M2&amp;+<span class="dv">2</span>]
     <span class="kw">and</span>   <span class="kw">bx</span>,<span class="kw">bx</span>                         <span class="co">;second operand negative?</span>
     <span class="kw">jns</span>   SaveSignStatus                <span class="co">;no</span>
     <span class="kw">neg</span>   <span class="kw">bx</span>                            <span class="co">;yes, so negate second operand</span>
     <span class="kw">neg</span>   <span class="dt">word</span> <span class="dt">ptr</span> [&amp;M2&amp;]
     <span class="kw">sbb</span>   <span class="kw">bx</span>,<span class="dv">0</span>
     <span class="kw">mov</span>   <span class="dt">word</span> <span class="dt">ptr</span> [&amp;M2&amp;+<span class="dv">2</span>],<span class="kw">bx</span>
     <span class="kw">xor</span>   <span class="kw">cx</span>,<span class="dv">1</span>                          <span class="co">;mark that second operand is negative</span>
<span class="fu">SaveSignStatus:</span>
     <span class="kw">push</span>   <span class="kw">cx</span>                           <span class="co">;remember sign of result; 1 if result</span>
                                         <span class="co">; negative, 0 if result nonnegative</span>
     <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [&amp;M1&amp;+<span class="dv">2</span>]    <span class="co">;high word times high word</span>
     <span class="kw">mul</span>   <span class="dt">word</span> <span class="dt">ptr</span> [&amp;M2&amp;+<span class="dv">2</span>]
     <span class="kw">mov</span>   <span class="kw">cx</span>,<span class="kw">ax</span>           <span class="co">;</span>
                                         <span class="co">;assume no overflow into DX</span>
     <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [&amp;M1&amp;+<span class="dv">2</span>]    <span class="co">;high word times low word</span>
     <span class="kw">mul</span>   <span class="dt">word</span> <span class="dt">ptr</span> [&amp;M2&amp;]
     <span class="kw">mov</span>   <span class="kw">bx</span>,<span class="kw">ax</span>
     <span class="kw">add</span>   <span class="kw">cx</span>,<span class="kw">dx</span>
     <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [&amp;M1&amp;]      <span class="co">;low word times high word</span>
     <span class="kw">mul</span>   <span class="dt">word</span> <span class="dt">ptr</span> [&amp;M2&amp;+<span class="dv">2</span>]
     <span class="kw">add</span>   <span class="kw">bx</span>,<span class="kw">ax</span>
     <span class="kw">adc</span>   <span class="kw">cx</span>,<span class="kw">dx</span>
     <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [&amp;M1&amp;]      <span class="co">;low word times low word</span>
     <span class="kw">mul</span>   <span class="dt">word</span> <span class="dt">ptr</span> [&amp;M2&amp;]
if <span class="kw">MUL</span>-ROUNDING-ON
     <span class="kw">add</span>   <span class="kw">ax</span><span class="bn">,8000h                      </span><span class="co">;round by adding 2^(-17)</span>
  <span class="kw">adc</span>   <span class="kw">bx</span>,<span class="kw">dx</span>
else <span class="co">;!MUL-ROUNDING-ON</span>
     <span class="kw">add</span>   <span class="kw">bx</span>,<span class="kw">dx</span>                         <span class="co">;don&#39;t round</span>
endif <span class="co">;MUL-ROUNDING-ON</span>
     <span class="kw">adc</span>   <span class="kw">cx</span>,<span class="dv">0</span>
     <span class="kw">mov</span>   <span class="kw">dx</span>,<span class="kw">cx</span>
     <span class="kw">mov</span>   <span class="kw">ax</span>,<span class="kw">bx</span>
     <span class="kw">pop</span>   <span class="kw">cx</span>
     <span class="kw">and</span>   <span class="kw">cx</span>,<span class="kw">cx</span>                         <span class="co">;is the result negative?</span>
     <span class="kw">jz</span>    FixedMulDone                  <span class="co">;no, we&#39;re all set</span>
     <span class="kw">neg</span>   <span class="kw">dx</span>                            <span class="co">;yes, so negate DX:AX</span>
     <span class="kw">neg</span>   <span class="kw">ax</span>
     <span class="kw">sbb</span>   <span class="kw">dx</span>,<span class="dv">0</span>
<span class="fu">FixedMulDone:</span>
     ENDM

     <span class="kw">align</span> ALIGNMENT
     public _XformVec
_XformVecprocnear
     <span class="kw">push</span>   <span class="kw">bp</span>                           <span class="co">;preserve stack frame</span>
     <span class="kw">mov</span>    <span class="kw">bp</span>,<span class="kw">sp</span>                        <span class="co">;set up local stack frame</span>
     <span class="kw">push</span>   <span class="kw">si</span>                           <span class="co">;preserve register variables</span>
     <span class="kw">push</span>   <span class="kw">di</span>

if USE386

     <span class="kw">mov</span>   <span class="kw">si</span>,[<span class="kw">bp</span>].WorkingXform           <span class="co">;SI points to xform matrix</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>,[<span class="kw">bp</span>].SourceVec              <span class="co">;BX points to source vector</span>
     <span class="kw">mov</span>   <span class="kw">di</span>,[<span class="kw">bp</span>].DestVec                <span class="co">;DI points to dest vector</span>

soff=<span class="dv">0</span>
doff=<span class="dv">0</span>
     REPT <span class="dv">3</span>                               <span class="co">;do once each for dest X, Y, and Z</span>
     <span class="kw">mov</span>   <span class="kw">eax</span>,[<span class="kw">si</span>+soff]                  <span class="co">;column 0 entry on this row</span>
     <span class="kw">imul</span>  <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bx</span>]                 <span class="co">;xform entry times source X entry</span>
if <span class="kw">MUL</span>-ROUNDING-ON
     <span class="kw">add</span>   <span class="kw">eax</span><span class="bn">,8000h                      </span><span class="co">;round by adding 2^(-17)</span>
     <span class="kw">adc</span>   <span class="kw">edx</span>,<span class="dv">0</span>                          <span class="co">;whole part of result is in DX</span>
endif <span class="co">;MUL-ROUNDING-ON</span>
     <span class="kw">shrd</span>  <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>                     <span class="co">;shift the result back to 16.16 form</span>
     move  <span class="kw">cx</span>,<span class="kw">eax</span>                         <span class="co">;set running total</span>

     move  <span class="kw">ax</span>,[<span class="kw">si</span>+soff<span class="dv">+4</span>]                 <span class="co">;column 1 entry on this row</span>
     <span class="kw">imul</span>  <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bx</span><span class="dv">+4</span>]               <span class="co">;xform entry times source Y entry</span>
if <span class="kw">MUL</span>-ROUNDING-ON
     <span class="kw">add</span>   <span class="kw">eax</span><span class="bn">,8000h                      </span><span class="co">;round by adding 2^(-17)</span>
     <span class="kw">adc</span>   <span class="kw">edx</span>,<span class="dv">0</span>                          <span class="co">;whole part of result is in DX</span>
endif <span class="co">;MUL-ROUNDING-ON</span>
     <span class="kw">shrd</span>  <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>                     <span class="co">;shift the result back to 16.16 form</span>
     <span class="kw">add</span>   <span class="kw">ecx</span>,<span class="kw">eax</span>                        <span class="co">;running total for this row</span>

     move  <span class="kw">ax</span>,[<span class="kw">si</span>+soff<span class="dv">+8</span>]                <span class="co">;column 2 entry on this row</span>
     <span class="kw">imul</span>  <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bx</span><span class="dv">+8</span>]              <span class="co">;xform entry times source Z entry</span>
if <span class="kw">MUL</span>-ROUNDING-ON
     <span class="kw">add</span>   <span class="kw">eax</span><span class="bn">,8000h                     </span><span class="co">;round by adding 2^(-17)</span>
     <span class="kw">adc</span>   <span class="kw">edx</span>,<span class="dv">0</span>                         <span class="co">;whole part of result is in DX</span>
endif <span class="co">;MUL-ROUNDING-ON</span>
     <span class="kw">shrd</span>  <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>                    <span class="co">;shift the result back to 16.16 form</span>
     <span class="kw">add</span>   <span class="kw">ecx</span>,<span class="kw">eax</span>                       <span class="co">;running total for this row</span>

     <span class="kw">add</span>   <span class="kw">ecx</span>,[<span class="kw">si</span>+soff<span class="dv">+12</span>]              <span class="co">;add in translation</span>
     <span class="kw">mov</span>   [<span class="kw">di</span>+doff],<span class="kw">ecx</span>                 <span class="co">;save the result in the dest vector</span>
soff=soff<span class="dv">+16</span>
doff=doff<span class="dv">+4</span>
     ENDM

else <span class="co">;!USE386</span>

     <span class="kw">mov</span>   <span class="kw">si</span>,[<span class="kw">bp</span>].WorkingXform          <span class="co">;SI points to xform matrix</span>
     <span class="kw">mov</span>   <span class="kw">di</span>,[<span class="kw">bp</span>].SourceVec             <span class="co">;DI points to source vector</span>
     <span class="kw">mov</span>   <span class="kw">bx</span>,[<span class="kw">bp</span>].DestVec               <span class="co">;BX points to dest vector</span>
     <span class="kw">push</span>  <span class="kw">bp</span>                            <span class="co">;preserve stack frame pointer</span>

soff=<span class="dv">0</span>
doff=<span class="dv">0</span>
     REPT <span class="dv">3</span>                              <span class="co">;do once each for dest X, Y, and Z</span>
     <span class="kw">push</span>  <span class="kw">bx</span>                           <span class="co">;remember dest vector pointer</span>
     <span class="kw">push</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+soff<span class="dv">+2</span>]
     <span class="kw">push</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+soff]
     <span class="kw">push</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span><span class="dv">+2</span>]
     <span class="kw">push</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>]
     <span class="kw">call</span>  _FixedMul                     <span class="co">;xform entry times source X entry</span>
     <span class="kw">add</span>   <span class="kw">sp</span>,<span class="dv">8</span><span class="co">;clear parameters from stack</span>
     <span class="kw">mov</span>   <span class="kw">cx</span>,<span class="kw">ax</span>                         <span class="co">;set running total</span>
     <span class="kw">mov</span>   <span class="kw">bp</span>,<span class="kw">dx</span>

     <span class="kw">push</span>  <span class="kw">cx</span>                            <span class="co">;preserve low word of running total</span>
     <span class="kw">push</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+soff<span class="dv">+4+2</span>]
     <span class="kw">push</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+soff<span class="dv">+4</span>]
     <span class="kw">push</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span><span class="dv">+4+2</span>]
     <span class="kw">push</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span><span class="dv">+4</span>]
     <span class="kw">call</span>  _FixedMul                     <span class="co">;xform entry times source Y entry</span>
     <span class="kw">add</span>   <span class="kw">sp</span>,<span class="dv">8</span>                          <span class="co">;clear parameters from stack</span>
     <span class="kw">pop</span>   <span class="kw">cx</span>                            <span class="co">;restore low word of running total</span>
     <span class="kw">add</span>   <span class="kw">cx</span>,<span class="kw">ax</span>                         <span class="co">;running total for this row</span>
     <span class="kw">adc</span>   <span class="kw">bp</span>,<span class="kw">dx</span>

     <span class="kw">push</span>  <span class="kw">cx</span>                            <span class="co">;preserve low word of running total</span>
     <span class="kw">push</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+soff<span class="dv">+8+2</span>]
     <span class="kw">push</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+soff<span class="dv">+8</span>]
     <span class="kw">push</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span><span class="dv">+8+2</span>]
     <span class="kw">push</span>  <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span><span class="dv">+8</span>]
     <span class="kw">call</span>  _FixedMul                     <span class="co">;xform entry times source Z entry</span>
     <span class="kw">add</span>   <span class="kw">sp</span>,<span class="dv">8</span>                          <span class="co">;clear parameters from stack</span>
     <span class="kw">pop</span>   <span class="kw">cx</span>                            <span class="co">;restore low word of running total</span>
     <span class="kw">add</span>   <span class="kw">cx</span>,<span class="kw">ax</span>                         <span class="co">;running total for this row</span>
     <span class="kw">adc</span>   <span class="kw">bp</span>,<span class="kw">dx</span>

     <span class="kw">add</span>   <span class="kw">cx</span>,[<span class="kw">si</span>+soff<span class="dv">+12</span>]               <span class="co">;add in translation</span>
     <span class="kw">adc</span>   <span class="kw">bp</span>,[<span class="kw">si</span>+soff<span class="dv">+12+2</span>]
     <span class="kw">pop</span>   <span class="kw">bx</span>                            <span class="co">;restore dest vector pointer</span>
     <span class="kw">mov</span>   [<span class="kw">bx</span>+doff],<span class="kw">cx</span>                  <span class="co">;save the result in the       dest  vector</span>
     <span class="kw">mov</span>   [<span class="kw">bx</span>+doff<span class="dv">+2</span>],<span class="kw">bp</span>
soff=soff<span class="dv">+16</span>
doff=doff<span class="dv">+4</span>
     ENDM

     <span class="kw">pop</span>   <span class="kw">bp</span>                            <span class="co">;restore stack frame pointer</span>

endif <span class="co">;USE386</span>

     <span class="kw">pop</span>   <span class="kw">di</span>                             <span class="co">;restore register variables</span>
     <span class="kw">pop</span>   <span class="kw">si</span>
     <span class="kw">pop</span>   <span class="kw">bp</span>                             <span class="co">;restore stack frame</span>
<span class="kw">ret</span>
_XformVecendp

<span class="co">;=====================================================================</span>
<span class="co">; Matrix multiplies SourceXform1 by SourceXform2 and stores the</span>
<span class="co">; result in DestXform. Multiplies a 4x4 matrix times a 4x4 matrix;</span>
<span class="co">; the result is a 4x4 matrix. Cheats by assuming the bottom row of</span>
<span class="co">; each matrix is 0 0 0 1, and doesn&#39;t bother to set the bottom row</span>
<span class="co">; of the destination.</span>
<span class="co">; C near-callable as:</span>
<span class="co">;       void ConcatXforms(Xform SourceXform1, Xform SourceXform2,</span>
<span class="co">;               Xform DestXform)</span>
<span class="co">;</span>
<span class="co">; This assembly code is equivalent to this C code:</span>
<span class="co">;   int i, j;</span>
<span class="co">;</span>
<span class="co">;   for (i=0; i&lt;3; i++) {</span>
<span class="co">;      for (j=0; j&lt;3; j++)</span>
<span class="co">;         DestXform[i][j] =</span>
<span class="co">;               FixedMul(SourceXform1[i][0], SourceXform2[0][j]) +</span>
<span class="co">;               FixedMul(SourceXform1[i][1], SourceXform2[1][j]) +</span>
<span class="co">;               FixedMul(SourceXform1[i][2], SourceXform2[2][j]);</span>
<span class="co">;      DestXform[i][3] =</span>
<span class="co">;            FixedMul(SourceXform1[i][0], SourceXform2[0][3]) +</span>
<span class="co">;            FixedMul(SourceXform1[i][1], SourceXform2[1][3]) +</span>
<span class="co">;            FixedMul(SourceXform1[i][2], SourceXform2[2][3]) +</span>
<span class="co">;            SourceXform1[i][3];</span>
<span class="co">;   }</span>

CXparms <span class="kw">struc</span>
                  <span class="dt">dw</span>    <span class="dv">2</span> dup(?)       <span class="co">;return address &amp; pushed BP</span>
SourceXform1      <span class="dt">dw</span>    ?              <span class="co">;pointer to first source xform matrix</span>
SourceXform2      <span class="dt">dw</span>    ?              <span class="co">;pointer to second source xform matrix</span>
DestXform         <span class="dt">dw</span>    ?              <span class="co">;pointer to destination xform matrix</span>
CXparms ends

          <span class="kw">align</span> ALIGNMENT
          public _ConcatXforms
_ConcatXformsprocnear
          <span class="kw">push</span>    <span class="kw">bp</span>                   <span class="co">;preserve stack frame</span>
          <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>                <span class="co">;set up local stack frame</span>
          <span class="kw">push</span>    <span class="kw">si</span>                   <span class="co">;preserve register variables</span>
          <span class="kw">push</span>    <span class="kw">di</span>

if USE386

          <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].SourceXform2 <span class="co">;BX points to xform2 matrix</span>
          <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">bp</span>].SourceXform1 <span class="co">;SI points to xform1 matrix</span>
          <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>].DestXform    <span class="co">;DI points to dest xform matrix</span>

roff=<span class="dv">0</span>                                 <span class="co">;row offset</span>
          REPT <span class="dv">3</span>                       <span class="co">;once for each row</span>
coff=<span class="dv">0</span>                                 <span class="co">;column offset</span>
REPT <span class="dv">3</span>                                 <span class="co">;once for each of the first 3 columns,</span>
                                       <span class="co">; assuming 0 as the bottom entry (no</span>
                                       <span class="co">; translation)</span>
          move    <span class="kw">ax</span>,[<span class="kw">si</span>+roff]         <span class="co">;column 0 entry on this row</span>
          <span class="kw">imul</span>    <span class="dt">dword</span> <span class="dt">ptr</span> [<span class="kw">bx</span>+coff]  <span class="co">;times row 0 entry in column</span>
if <span class="kw">MUL</span>-ROUNDING-ON
          <span class="kw">add</span>     <span class="kw">eax</span><span class="bn">,8000h            </span><span class="co">;round by adding 2^(-17)</span>
          <span class="kw">adc</span>     <span class="kw">edx</span>,<span class="dv">0</span>                <span class="co">;whole part of result is in DX</span>
endif <span class="co">;MUL-ROUNDING-ON</span>
          <span class="kw">shrd</span>    <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>           <span class="co">;shift the result back to 16.16 form</span>
          move    <span class="kw">cx</span>,<span class="kw">eax</span>               <span class="co">;set running total</span>

          move    <span class="kw">ax</span>,[<span class="kw">si</span>+roff<span class="dv">+4</span>]       <span class="co">;column 1 entry on this row</span>
          imuld   <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bx</span>+coff<span class="dv">+16</span>] <span class="co">;times row 1 entry in col</span>
if <span class="kw">MUL</span>-ROUNDING-ON
          <span class="kw">add</span>     <span class="kw">eax</span><span class="bn">,8000h            </span><span class="co">;round by adding 2^(-17)</span>
          <span class="kw">adc</span>     <span class="kw">edx</span>,<span class="dv">0</span>                <span class="co">;whole part of result is in DX</span>
endif <span class="co">;MUL-ROUNDING-ON</span>
          <span class="kw">shrd</span>    <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>           <span class="co">;shift the result back to 16.16 form</span>
          <span class="kw">add</span>     <span class="kw">ecx</span>,<span class="kw">eax</span>              <span class="co">;running total</span>

          move    <span class="kw">ax</span>,[<span class="kw">si</span>+roff<span class="dv">+8</span>]       <span class="co">;column 2 entry on this row</span>
          imuld   <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bx</span>+coff<span class="dv">+32</span>] <span class="co">;times row 2 entry in col</span>
if <span class="kw">MUL</span>-ROUNDING-ON
          <span class="kw">add</span>     <span class="kw">eax</span><span class="bn">,8000h             </span><span class="co">;round by adding 2^(-17)</span>
          <span class="kw">adc</span>     <span class="kw">edx</span>,<span class="dv">0</span>                 <span class="co">;whole part of result is in DX</span>
endif <span class="co">;MUL-ROUNDING-ON</span>
          <span class="kw">shrd</span>    <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>            <span class="co">;shift the result back to 16.16 form</span>
          <span class="kw">add</span>     <span class="kw">ecx</span>,<span class="kw">eax</span>               <span class="co">;running total</span>

          <span class="kw">mov</span>     [<span class="kw">di</span>+coff+roff],<span class="kw">ecx</span>    <span class="co">;save the result in dest matrix</span>
coff=coff<span class="dv">+4</span>                             <span class="co">;point to next col in xform2 &amp; dest</span>
          ENDM
<span class="co">;now do the fourth column, assuming</span>
<span class="co">; 1 as the bottom entry, causing</span>
<span class="co">; translation to be performed</span>
          move    <span class="kw">ax</span>,[<span class="kw">si</span>+roff]          <span class="co">;column 0 entry on this row</span>
          imuld   <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bx</span>+coff]    <span class="co">;times row 0 entry in column</span>
if <span class="kw">MUL</span>-ROUNDING-ON
          <span class="kw">add</span>     <span class="kw">eax</span><span class="bn">,8000h              </span><span class="co">;round by adding 2^(-17)</span>
          <span class="kw">adc</span>     <span class="kw">edx</span>,<span class="dv">0</span>                  <span class="co">;whole part of result is in DX</span>
endif <span class="co">;MUL-ROUNDING-ON</span>
          <span class="kw">shrd</span>    <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>             <span class="co">;shift the result back to 16.16 form</span>
          move    <span class="kw">cx</span>,<span class="kw">eax</span>                 <span class="co">;set running total</span>

          move    <span class="kw">ax</span>,[<span class="kw">si</span>+roff<span class="dv">+4</span>]         <span class="co">;column 1 entry on this row</span>
          imuld   <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bx</span>+coff<span class="dv">+16</span>]  <span class="co">;times row 1 entry in col</span>
if <span class="kw">MUL</span>-ROUNDING-ON
          <span class="kw">add</span>     <span class="kw">eax</span><span class="bn">,8000h              </span><span class="co">;round by adding 2^(-17)</span>
          <span class="kw">adc</span>     <span class="kw">edx</span>,<span class="dv">0</span>                  <span class="co">;whole part of result is in DX</span>
endif <span class="co">;MUL-ROUNDING-ON</span>
          <span class="kw">shrd</span>    <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>             <span class="co">;shift the result back to 16.16 form</span>
          <span class="kw">add</span>     <span class="kw">ecx</span>,<span class="kw">eax</span>                <span class="co">;running total</span>

          move    <span class="kw">ax</span>,[<span class="kw">si</span>+roff<span class="dv">+8</span>]         <span class="co">;column 2 entry on this row</span>
          imuld   <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bx</span>+coff<span class="dv">+32</span>]  <span class="co">;times row 2 entry in col</span>
if <span class="kw">MUL</span>-ROUNDING-ON
          <span class="kw">add</span>     <span class="kw">eax</span><span class="bn">,8000h              </span><span class="co">;round by adding 2^(-17)</span>
          <span class="kw">adc</span>     <span class="kw">edx</span>,<span class="dv">0</span>                  <span class="co">;whole part of result is in DX</span>
endif <span class="co">;MUL-ROUNDING-ON</span>
          <span class="kw">shrd</span>    <span class="kw">eax</span>,<span class="kw">edx</span>,<span class="dv">16</span>             <span class="co">;shift the result back to 16.16 form</span>
          <span class="kw">add</span>     <span class="kw">ecx</span>,<span class="kw">eax</span>                <span class="co">;running total</span>

          <span class="kw">add</span>     <span class="kw">ecx</span>,[<span class="kw">si</span>+roff<span class="dv">+12</span>]       <span class="co">;add in translation</span>

          <span class="kw">mov</span>     [<span class="kw">di</span>+coff+roff],<span class="kw">ecx</span>     <span class="co">;save the result in dest matrix</span>
coff=coff<span class="dv">+4</span>                              <span class="co">;point to next col in xform2 &amp; dest</span>

roff=roff<span class="dv">+16</span>                             <span class="co">;point to next col in xform2 &amp; dest</span>
          ENDM

else <span class="co">;!USE386</span>

          <span class="kw">mov</span>    <span class="kw">di</span>,[<span class="kw">bp</span>].SourceXform2    <span class="co">;DI points to xform2 matrix</span>
          <span class="kw">mov</span>    <span class="kw">si</span>,[<span class="kw">bp</span>].SourceXform1    <span class="co">;SI points to xform1 matrix</span>
          <span class="kw">mov</span>    <span class="kw">bx</span>,[<span class="kw">bp</span>].DestXform       <span class="co">;BX points to dest xform matrix</span>
          <span class="kw">push</span>   <span class="kw">bp</span>                      <span class="co">;preserve stack frame pointer</span>

roff=<span class="dv">0</span>                                   <span class="co">;row offset</span>
          REPT <span class="dv">3</span>                         <span class="co">;once for each row</span>
coff=<span class="dv">0</span>                                   <span class="co">;column offset</span>
          REPT <span class="dv">3</span>                         <span class="co">;once for each of the first 3 columns,</span>
<span class="co">; assuming 0 as the bottom entry (no</span>
<span class="co">; translation)</span>
          <span class="kw">push</span>    <span class="kw">bx</span>                     <span class="co">;remember dest vector pointer</span>
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+roff<span class="dv">+2</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+roff]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>+coff<span class="dv">+2</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>+coff]
          <span class="kw">call</span>    _FixedMul               <span class="co">;column 0 entry on this row times row 0</span>
<span class="co">; entry in column</span>
addsp,<span class="dv">8</span><span class="co">;clear parameters from stack</span>
          <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">ax</span>                   <span class="co">;set running total</span>
          <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">dx</span>

          <span class="kw">push</span>    <span class="kw">cx</span>                      <span class="co">;preserve low word of running total</span>
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+roff<span class="dv">+4+2</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+roff<span class="dv">+4</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>+coff<span class="dv">+16+2</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>+coff<span class="dv">+16</span>]
          <span class="kw">call</span>    _FixedMul               <span class="co">;column 1 entry on this row times row 1</span>
<span class="co">; entry in column</span>
          <span class="kw">add</span>     <span class="kw">sp</span>,<span class="dv">8</span>                    <span class="co">;clear parameters from stack</span>
          <span class="kw">pop</span>     <span class="kw">cx</span>                      <span class="co">;restore low word of running total</span>
          <span class="kw">add</span>     <span class="kw">cx</span>,<span class="kw">ax</span>                   <span class="co">;running total for this row</span>
          <span class="kw">adc</span>     <span class="kw">bp</span>,<span class="kw">dx</span>

          <span class="kw">push</span>    <span class="kw">cx</span>                      <span class="co">;preserve low word of running total</span>
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+roff<span class="dv">+8+2</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+roff<span class="dv">+8</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>+coff<span class="dv">+32+2</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>+coff<span class="dv">+32</span>]
          <span class="kw">call</span>    _FixedMul               <span class="co">;column 1 entry on this row times row 1</span>
<span class="co">; entry in column</span>
          <span class="kw">add</span>     <span class="kw">sp</span>,<span class="dv">8</span>                    <span class="co">;clear parameters from stack</span>
          <span class="kw">pop</span>     <span class="kw">cx</span>                      <span class="co">;restore low word of running total</span>
          <span class="kw">add</span>     <span class="kw">cx</span>,<span class="kw">ax</span>                   <span class="co">;running total for this row</span>
          <span class="kw">adc</span>     <span class="kw">bp</span>,<span class="kw">dx</span>

          <span class="kw">pop</span>     <span class="kw">bx</span>                      <span class="co">;restore DestXForm pointer</span>
          <span class="kw">mov</span>     [<span class="kw">bx</span>+coff+roff],<span class="kw">cx</span>       <span class="co">;save the result in dest matrix</span>
          <span class="kw">mov</span>     [<span class="kw">bx</span>+coff+roff<span class="dv">+2</span>],<span class="kw">bp</span>
coff=coff<span class="dv">+4</span>                               <span class="co">;point to next col in xform2 &amp; dest</span>
          ENDM
<span class="co">;now do the fourth column, assuming</span>
<span class="co">; 1 as the bottom entry, causing</span>
<span class="co">; translation to be performed</span>
          <span class="kw">push</span>    <span class="kw">bx</span>                      <span class="co">;remember dest vector pointer</span>
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+roff<span class="dv">+2</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+roff]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>+coff<span class="dv">+2</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>+coff]
          <span class="kw">call</span>    _FixedMul               <span class="co">;column 0 entry on this row times row 0</span>
<span class="co">; entry in column</span>
          <span class="kw">add</span>     <span class="kw">sp</span>,<span class="dv">8</span>                    <span class="co">;clear parameters from stack</span>
          <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">ax</span>                   <span class="co">;set running total</span>
          <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">dx</span>

          <span class="kw">push</span>    <span class="kw">cx</span>                      <span class="co">;preserve low word of running total</span>
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+roff<span class="dv">+4+2</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+roff<span class="dv">+4</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>+coff<span class="dv">+16+2</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>+coff<span class="dv">+16</span>]
          <span class="kw">call</span>    _FixedMul               <span class="co">;column 1 entry on this row times row 1</span>
<span class="co">; entry in column</span>
          <span class="kw">add</span>     <span class="kw">sp</span>,<span class="dv">8</span>                    <span class="co">;clear parameters from stack</span>
          <span class="kw">pop</span>     <span class="kw">cx</span>                      <span class="co">;restore low word of running total</span>
          <span class="kw">add</span>     <span class="kw">cx</span>,<span class="kw">ax</span>                   <span class="co">;running total for this row</span>
          <span class="kw">adc</span>     <span class="kw">bp</span>,<span class="kw">dx</span>

          <span class="kw">push</span>    <span class="kw">cx</span>                      <span class="co">;preserve low word of running total</span>
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+roff<span class="dv">+8+2</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">si</span>+roff<span class="dv">+8</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>+coff<span class="dv">+32+2</span>]
          <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>+coff<span class="dv">+32</span>]
          <span class="kw">call</span>    _FixedMul               <span class="co">;column 1 entry on this row times row 1</span>
<span class="co">; entry in column</span>
          <span class="kw">add</span>     <span class="kw">sp</span>,<span class="dv">8</span>                    <span class="co">;clear parameters from stack</span>
          <span class="kw">pop</span>     <span class="kw">cx</span>                      <span class="co">;restore low word of running total</span>
          <span class="kw">add</span>     <span class="kw">cx</span>,<span class="kw">ax</span>                   <span class="co">;running total for this row</span>
          <span class="kw">adc</span>     <span class="kw">bp</span>,<span class="kw">dx</span>

          <span class="kw">add</span>     <span class="kw">cx</span>,[<span class="kw">si</span>+roff<span class="dv">+12</span>]         <span class="co">;add in translation</span>
          <span class="kw">add</span>     <span class="kw">bp</span>,[<span class="kw">si</span>+roff<span class="dv">+12+2</span>]

          <span class="kw">pop</span>     <span class="kw">bx</span>                      <span class="co">;restore DestXForm pointer</span>
          <span class="kw">mov</span>     [<span class="kw">bx</span>+coff+roff],<span class="kw">cx</span>       <span class="co">;save the result in dest matrix</span>
          <span class="kw">mov</span>     [<span class="kw">bx</span>+coff+roff<span class="dv">+2</span>],<span class="kw">bp</span>
coff=coff<span class="dv">+4</span>                               <span class="co">;point to next col in xform2 &amp; dest</span>

roff=roff<span class="dv">+16</span>                              <span class="co">;point to next col in xform2 &amp; dest</span>
          ENDM

          <span class="kw">pop</span>    <span class="kw">bp</span>                       <span class="co">;restore stack frame pointer</span>

endif <span class="co">;USE386</span>

          <span class="kw">pop</span>    <span class="kw">di</span>                       <span class="co">;restore register variables</span>
          <span class="kw">pop</span>    <span class="kw">si</span>
          <span class="kw">pop</span>    <span class="kw">bp</span>                       <span class="co">;restore stack frame</span>
<span class="kw">ret</span>
_ConcatXforms    endp
end</code></pre>
<section id="shading" class="level4">
<h4><a href="#shading">Shading</a></h4>
<p>So far, the polygons out of which our animated objects have been built have had colors of fixed intensities. For example, a face of a cube might be blue, or green, or white, but whatever color it is, that color never brightens or dims. Fixed colors are easy to implement, but they don’t make for very realistic animation. In the real world, the intensity of the color of a surface varies depending on how brightly it is illuminated. The ability to simulate the illumination of a surface, or shading, is the next feature we’ll add to X-Sharp.</p>
<p>The overall shading of an object is the sum of several types of shading components. <em>Ambient shading</em> is illumination by what you might think of as background light, light that’s coming from all directions; all surfaces are equally illuminated by ambient light, regardless of their orientation. <em>Directed lighting</em>, producing diffuse shading, is illumination from one or more specific light sources. Directed light has a specific direction, and the angle at which it strikes a surface determines how brightly it lights that surface. <em>Specular reflection</em> is the tendency of a surface to reflect light in a mirrorlike fashion. There are other sorts of shading components, including transparency and atmospheric effects, but the ambient and diffuse-shading components are all we’re going to deal with in X-Sharp.</p>
</section>
<section id="ambient-shading" class="level4">
<h4><a href="#ambient-shading">Ambient Shading</a></h4>
<p>The basic model for both ambient and diffuse shading is a simple one. Each surface has a reflectivity between 0 and 1, where 0 means all light is absorbed and 1 means all light is reflected. A certain amount of light energy strikes each surface. The energy (intensity) of the light is expressed such that if light of intensity 1 strikes a surface with reflectivity 1, then the brightest possible shading is displayed for that surface. Complicating this somewhat is the need to support color; we do this by separating reflectance and shading into three components each—red, green, and blue—and calculating the shading for each color component separately for each surface.</p>
<p>Given an ambient-light red intensity of IA<sub>red</sub> and a surface red reflectance R<sub>red</sub>, the displayed red ambient shading for that surface, as a fraction of the maximum red intensity, is simply min(IA<sub>red</sub>x R<sub>red</sub>, 1). The green and blue color components are handled similarly. That’s really all there is to ambient shading, although of course we must design some way to map displayed color components into the available palette of colors; I’ll do that in the next chapter. Ambient shading isn’t the whole shading picture, though. In fact, scenes tend to look pretty bland without diffuse shading.</p>
</section>
<section id="diffuse-shading" class="level4">
<h4><a href="#diffuse-shading">Diffuse Shading</a></h4>
<p>Diffuse shading is more complicated than ambient shading, because the effective intensity of directed light falling on a surface depends on the angle at which it strikes the surface. According to Lambert’s law, the light energy from a directed light source striking a surface is proportional to the cosine of the angle at which it strikes the surface, with the angle measured relative to a vector perpendicular to the polygon (a polygon normal), as shown in Figure 54.1. If the red intensity of directed light is ID<sub>red</sub>, the red reflectance of the surface is R<sub>red</sub>, and the angle between the incoming directed light and the surface’s normal is theta, then the displayed red diffuse shading for that surface, as a fraction of the largest possible red intensity, is min (ID<sub>red</sub>xR<sub>red</sub>xcos(θ), 1).</p>
<p>That’s easy enough to calculate—but seemingly slow. Determining the cosine of an angle can be sped up with a table lookup, but there’s also the task of figuring out the angle, and, all in all, it doesn’t seem that diffuse shading is going to be speedy enough for our purposes. Consider this, however: According to the properties of the dot product (denoted by the operator “•”, as shown in Figure 54.2), cos(q)=(v•w)/ |v| x |w| ), where v and w are vectors, q is the angle between v and w, and |v| is the length of v. Suppose, now, that v and w are unit vectors; that is, vectors exactly one unit long. Then the above equation reduces to cos(q)=v•w. In other words, we can calculate the cosine between N, the unit-normal vector (one-unit-long perpendicular vector) of a polygon, and L’, the reverse of a unit vector describing the direction of a light source, with just three multiplies and two adds. (I’ll explain why the light-direction vector must be reversed later.) Once we have that, we can easily calculate the red diffuse shading from a directed light source as min(ID<sub>red</sub>xR<sub>red</sub>x(L’• N), 1) and likewise for the green and blue color components.</p>
<figure>
<img src="images/54-01.jpg" alt="Figure 54.1  Illumination by a directed light source" /><figcaption><strong>Figure 54.1</strong>  <em>Illumination by a directed light source</em></figcaption>
</figure>
<figure>
<img src="images/54-02.jpg" alt="Figure 54.2  The dot product of two vectors." /><figcaption><strong>Figure 54.2</strong>  <em>The dot product of two vectors.</em></figcaption>
</figure>
<p>The overall red shading for each polygon can be calculated by summing the ambient-shading red component with the diffuse-shading component from each light source, as in min((IA<sub>red</sub>xR<sub>red</sub>) + (ID<sub>red0</sub>xR<sub>red</sub>x(L<sub>0</sub>‘• N)) + (ID<sub>red1</sub>xR<sub>red</sub>x(L<sub>1</sub>’ • N)) +…, 1) where ID<sub>red0</sub> and L<sub>0</sub>’ are the red intensity and the reversed unit-direction vector, respectively, for spotlight 0. Listing 54.2 shows the X-Sharp module DRAWPOBJ.C, which performs ambient and diffuse shading. Toward the end, you will find the code that performs shading exactly as described by the above equation, first calculating the ambient red, green, and blue shadings, then summing that with the diffuse red, green, and blue shadings generated by each directed light source.</p>
<p><strong>LISTING 54.2 DRAWPOBJ.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Draws all visible faces in the specified polygon-based object. The object</span>
<span class="co">   must have previously been transformed and projected, so that all vertex</span>
<span class="co">   arrays are filled in. Ambient and diffuse shading are supported. */</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="dt">void</span> DrawPObject(PObject * ObjectToXform)
{
   <span class="dt">int</span> i, j, NumFaces = ObjectToXform-&gt;NumFaces, NumVertices;
   <span class="dt">int</span> * VertNumsPtr, Spot;
   Face * FacePtr = ObjectToXform-&gt;FaceList;
   Point * ScreenPoints = ObjectToXform-&gt;ScreenVertexList;
   PointListHeader Polygon;
   Fixedpoint Diffusion;
   ModelColor ColorTemp;
   ModelIntensity IntensityTemp;
   Point3 UnitNormal, *NormalStartpoint, *NormalEndpoint;
   <span class="dt">long</span> v1, v2, w1, w2;
   Point Vertices[MAX-POLY-LENGTH];

   <span class="co">/* Draw each visible face (polygon) of the object in turn */</span>
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NumFaces; i++, FacePtr++) {
      <span class="co">/* Remember where we can find the start and end of the polygon&#39;s</span>
<span class="co">         unit normal in view space, and skip over the unit normal endpoint</span>
<span class="co">         entry. The end and start points of the unit normal to the polygon</span>
<span class="co">         must be the first and second entries in the polgyon&#39;s vertex list.</span>
<span class="co">         Note that the second point is also an active polygon vertex */</span>
      VertNumsPtr = FacePtr-&gt;VertNums;
      NormalEndpoint = &amp;ObjectToXform-&gt;XformedVertexList[*VertNumsPtr++];
      NormalStartpoint = &amp;ObjectToXform-&gt;XformedVertexList[*VertNumsPtr];
      <span class="co">/* Copy over the face&#39;s vertices from the vertex list */</span>
      NumVertices = FacePtr-&gt;NumVerts;
      <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;NumVertices; j++)
         Vertices[j] = ScreenPoints[*VertNumsPtr++];
      <span class="co">/* Draw only if outside face showing (if the normal to the polygon</span>
<span class="co">         in screen coordinates points toward the viewer; that is, has a</span>
<span class="co">         positive Z component) */</span>
      v1 = Vertices[<span class="dv">1</span>].X - Vertices[<span class="dv">0</span>].X;
      w1 = Vertices[NumVertices<span class="dv">-1</span>].X - Vertices[<span class="dv">0</span>].X;
      v2 = Vertices[<span class="dv">1</span>].Y - Vertices[<span class="dv">0</span>].Y;
      w2 = Vertices[NumVertices<span class="dv">-1</span>].Y - Vertices[<span class="dv">0</span>].Y;
      <span class="kw">if</span> ((v1*w2 - v2*w1) &gt; <span class="dv">0</span>) {
         <span class="co">/* It is facing the screen, so draw */</span>
         <span class="co">/* Appropriately adjust the extent of the rectangle used to</span>
<span class="co">            erase this object later */</span>
         <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;NumVertices; j++) {
            <span class="kw">if</span> (Vertices[j].X &gt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Right)
               <span class="kw">if</span> (Vertices[j].X &lt; SCREEN-WIDTH)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Right =
                        Vertices[j].X;
               <span class="kw">else</span> ObjectToXform-&gt;EraseRect[NonDisplayedPage].Right =
                     SCREEN-WIDTH;
            <span class="kw">if</span> (Vertices[j].Y &gt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Bottom)
               <span class="kw">if</span> (Vertices[j].Y &lt; SCREEN-HEIGHT)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Bottom =
                        Vertices[j].Y;
               <span class="kw">else</span> ObjectToXform-&gt;EraseRect[NonDisplayedPage].Bottom=
                     SCREEN-HEIGHT;
            <span class="kw">if</span> (Vertices[j].X &lt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Left)
               <span class="kw">if</span> (Vertices[j].X &gt; <span class="dv">0</span>)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Left =
                        Vertices[j].X;
               <span class="kw">else</span> ObjectToXform-&gt;EraseRect[NonDisplayedPage].Left=<span class="dv">0</span>;
            <span class="kw">if</span> (Vertices[j].Y &lt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Top)
               <span class="kw">if</span> (Vertices[j].Y &gt; <span class="dv">0</span>)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Top =
                        Vertices[j].Y;
               <span class="kw">else</span> ObjectToXform-&gt;EraseRect[NonDisplayedPage].Top=<span class="dv">0</span>;
         }
         <span class="co">/* See if there&#39;s any shading */</span>
            <span class="kw">if</span> (FacePtr-&gt;ShadingType == <span class="dv">0</span>) {
            <span class="co">/* No shading in effect, so just draw */</span>
            DRAW-POLYGON(Vertices, NumVertices, FacePtr-&gt;ColorIndex, <span class="dv">0</span>, <span class="dv">0</span>);
         } <span class="kw">else</span> {
            <span class="co">/* Handle shading */</span>
            <span class="co">/* Do ambient shading, if enabled */</span>
            <span class="kw">if</span> (AmbientOn &amp;&amp; (FacePtr-&gt;ShadingType &amp; AMBIENT-SHADING)) {
               <span class="co">/* Use the ambient shading component */</span>
               IntensityTemp = AmbientIntensity;
            } <span class="kw">else</span> {
               SET-INTENSITY(IntensityTemp, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>);
            }
            <span class="co">/* Do diffuse shading, if enabled */</span>
            <span class="kw">if</span> (FacePtr-&gt;ShadingType &amp; DIFFUSE-SHADING) {
               <span class="co">/* Calculate the unit normal for this polygon, for use in dot</span>
<span class="co">                  products */</span>
               UnitNormal.X = NormalEndpoint-&gt;X - NormalStartpoint-&gt;X;
               UnitNormal.Y = NormalEndpoint-&gt;Y - NormalStartpoint-&gt;Y;
               UnitNormal.Z = NormalEndpoint-&gt;Z - NormalStartpoint-&gt;Z;
               <span class="co">/* Calculate the diffuse shading component for each active</span>
<span class="co">                  spotlight */</span>
               <span class="kw">for</span> (Spot=<span class="dv">0</span>; Spot&lt;MAX-SPOTS; Spot++) {
                  <span class="kw">if</span> (SpotOn[Spot] != <span class="dv">0</span>) {
                     <span class="co">/* Spot is on, so sum, for each color component, the</span>
<span class="co">                        intensity, accounting for the angle of the light rays</span>
<span class="co">                        relative to the orientation of the polygon */</span>
                     <span class="co">/* Calculate cosine of angle between the light and the</span>
<span class="co">                        polygon normal; skip if spot is shining from behind</span>
<span class="co">                        the polygon */</span>
                     <span class="kw">if</span> ((Diffusion = DOT-PRODUCT(SpotDirectionView[Spot],
                           UnitNormal)) &gt; <span class="dv">0</span>) {
                        IntensityTemp.Red +=
                              FixedMul(SpotIntensity[Spot].Red, Diffusion);
                        IntensityTemp.Green +=
                              FixedMul(SpotIntensity[Spot].Green, Diffusion);
                        IntensityTemp.Blue +=
                              FixedMul(SpotIntensity[Spot].Blue, Diffusion);
                     }
                  }
               }
            }
            <span class="co">/* Convert the drawing color to the desired fraction of the</span>
<span class="co">               brightest possible color */</span>
            IntensityAdjustColor(&amp;ColorTemp, &amp;FacePtr-&gt;FullColor,
                  &amp;IntensityTemp);
            <span class="co">/* Draw with the cumulative shading, converting from the general</span>
<span class="co">               color representation to the best-match color index */</span>
            DRAW-POLYGON(Vertices, NumVertices,
                  ModelColorToColorIndex(&amp;ColorTemp), <span class="dv">0</span>, <span class="dv">0</span>);
         }
      }
   }
}</code></pre>
</section>
<section id="shading-implementation-details" class="level4">
<h4><a href="#shading-implementation-details">Shading: Implementation Details</a></h4>
<p>In order to calculate the cosine of the angle between an incoming light source and a polygon’s unit normal, we must first have the polygon’s unit normal. This could be calculated by generating a cross-product on two polygon edges to generate a normal, then calculating the normal’s length and scaling to produce a unit normal. Unfortunately, that would require taking a square root, so it’s not a desirable course of action. Instead, I’ve made a change to X-Sharp’s polygon format. Now, the first vertex in a shaded polygon’s vertex list is the end-point of a unit normal that starts at the second point in the polygon’s vertex list, as shown in Figure 54.3. The first point isn’t one of the polygon’s vertices, but is used only to generate a unit normal. The second point, however, is a polygon vertex. Calculating the difference vector between the first and second points yields the polygon’s unit normal. Adding a unit-normal endpoint to each polygon isn’t free; each of those end-points has to be transformed, along with the rest of the vertices, and that takes time. Still, it’s faster than calculating a unit normal for each polygon from scratch.</p>
<figure>
<img src="images/54-03.jpg" alt="Figure 54.3  The unit normal in the polygon data structure." /><figcaption><strong>Figure 54.3</strong>  <em>The unit normal in the polygon data structure.</em></figcaption>
</figure>
<figure>
<img src="images/54-04.jpg" alt="Figure 54.4  The reversed light source vector." /><figcaption><strong>Figure 54.4</strong>  <em>The reversed light source vector.</em></figcaption>
</figure>
<p>We also need a unit vector for each directed light source. The directed light sources I’ve implemented in X-Sharp are spotlights; that is, they’re considered to be point light sources that are infinitely far away. This allows the simplifying assumption that all light rays from a spotlight are parallel and of equal intensity throughout the displayed universe, so each spotlight can be represented with a single unit vector and a single intensity. The only trick is that in order to calculate the desired cos(theta) between the polygon unit normal and a spotlight’s unit vector, the direction of the spotlight’s unit vector must be reversed, as shown in Figure 54.4. This is necessary because the dot product implicitly places vectors with their start points at the same location when it’s used to calculate the cosine of the angle between two vectors. The light vector is incoming to the polygon surface, and the unit normal is outbound, so only by reversing one vector or the other will we get the cosine of the desired angle.</p>
<p>Given the two unit vectors, it’s a piece of cake to calculate intensities, as shown in Listing 54.2. The sample program DEMO1, in the X-Sharp archive on the listings disk (built by running K1.BAT), puts the shading code to work displaying a rotating ball with ambient lighting and three spot lighting sources that the user can turn on and off. What you’ll see when you run DEMO1 is that the shading is very good—face colors change very smoothly indeed—so long as only green lighting sources are on. However, if you combine spotlight two, which is blue, with any other light source, polygon colors will start to shift abruptly and unevenly. As configured in the demo, the palette supports a wide range of shading intensities for a pure version of any one of the three primary colors, but a very limited number of intensity steps (four, in this case) for each color component when two or more primary colors are mixed. While this situation can be improved, it is fundamentally a result of the restricted capabilities of the 256-color palette, and there is only so much that can be done without a larger color set. In the next chapter, I’ll talk about some ways to improve the quality of 256-color shading.</p>
</section>
</section>
</section>
<section id="chapter-55-color-modeling-in-256-color-mode" class="level2">
<h2><a href="#chapter-55-color-modeling-in-256-color-mode">Chapter 55 – Color Modeling in 256-Color Mode</a></h2>
<section id="pondering-x-sharps-color-model-in-an-rgb-state-of-mind" class="level3">
<h3><a href="#pondering-x-sharps-color-model-in-an-rgb-state-of-mind">Pondering X-Sharp’s Color Model in an RGB State of Mind</a></h3>
<p>Once she turned six, my daughter wanted some fairly sophisticated books read to her<em>. Wind in the Willows.</em> <em>Little House on the Prairie.</em> Pretty heady stuff for one so young, and sometimes I wondered how much of it she really understood. As an experiment, during one reading I stopped whenever I came to a word I thought she might not know, and asked her what it meant. One such word was “mulling.”</p>
<p>“Do you know what ‘mulling’ means?” I asked.</p>
<p>She thought about it for a while, then said, “Pondering.”</p>
<p>“Very good!” I said, more than a little surprised.</p>
<p>She smiled and said, “But, Dad, how do you know that I know what ‘pondering’ means?”</p>
<p>“Okay,” I said, “What does ‘pondering’ mean?”</p>
<p>“Mulling,” she said.</p>
<p>What does this anecdote tell us about the universe in which we live? Well, it certainly indicates that this universe is inhabited by at least one comedian and one good straight man. Beyond that, though, it can be construed as a parable about the difficulty of defining things properly; for example, consider the complications inherent in the definition of color on a 256-color display adapter such as the VGA. Coincidentally, VGA color modeling just happens to be this chapter’s topic, and the place to start is with color modeling in general.</p>
<section id="a-color-model" class="level4">
<h4><a href="#a-color-model">A Color Model</a></h4>
<p>We’ve been developing X-Sharp for several chapters now. In the previous chapter, we added illumination sources and shading; that addition makes it necessary for us to have a general-purpose color model, so that we can display the gradations of color intensity necessary to render illuminated surfaces properly. In other words, when a bright light is shining straight at a green surface, we need to be able to display bright green, and as that light dims or tilts to strike the surface at a shallower angle, we need to be able to display progressively dimmer shades of green.</p>
<p>The first thing to do is to select a color model in which to perform our shading calculations. I’ll use the dot product-based stuff I discussed in the previous chapter. The approach we’ll take is to select an ideal representation of the full color space and do our calculations there, as if we really could display every possible color; only as a final step will we map each desired color into the limited 256-color set of the VGA, or the color range of whatever adapter we happen to be working with. There are a number of color models that we might choose to work with, but I’m going to go with the one that’s both most familiar and, in my opinion, simplest: RGB (red, green, blue).</p>
<p>In the RGB model, a given color is modeled as the mix of specific fractions of full intensities of each of the three color primaries. For example, the brightest possible pure blue is 0.0*R, 0.0*G, 1.0*B. Half-bright cyan is 0.0*R, 0.5*G, 0.5*B. Quarter-bright gray is 0.25*R, 0.25*G, 0.25*B. You can think of RGB color space as being a cube, as shown in Figure 55.1, with any particular color lying somewhere inside or on the cube.</p>
<figure>
<img src="images/55-01.jpg" alt="Figure 55.1  The RGB color cube." /><figcaption><strong>Figure 55.1</strong>  <em>The RGB color cube.</em></figcaption>
</figure>
<p>RGB is good for modeling colors generated by light sources, because red, green, and blue are the additive primaries; that is, all other colors can be generated by mixing red, green, and blue light sources. They’re also the primaries for color computer displays, and the RGB model maps beautifully onto the display capabilities of 15- and 24-bpp display adapters, which tend to represent pixels as RGB combinations in display memory.</p>
<p>How, then, are RGB colors represented in X-Sharp? Each color is represented as an RGB triplet, with eight bits each of red, green, and blue resolution, using the structure shown in Listing 55.1.</p>
<p><strong>LISTING 55.1 L55-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> -ModelColor {
  <span class="dt">unsigned</span> <span class="dt">char</span> Red;   <span class="co">/* 255 = max red, 0 = no red */</span>
  <span class="dt">unsigned</span> <span class="dt">char</span> Green; <span class="co">/* 255 = max green, 0 = no green */</span>
  <span class="dt">unsigned</span> <span class="dt">char</span> Blue;  <span class="co">/* 255 = max blue, 0 = no blue */</span>
} ModelColor;</code></pre>
<p>Here, each color is described by three color components—one each for red, green, and blue—and each primary color component is represented by eight bits. Zero intensity of a color component is represented by the value 0, and full intensity is represented by the value 255. This gives us 256 levels of each primary color component, and a total of 16,772,216 possible colors.</p>
<p>Holy cow! Isn’t 16,000,000-plus colors a bit of overkill?</p>
<p>Actually, no, it isn’t. At the eighth Annual Computer Graphics Show in New York, Sheldon Linker, of Linker Systems, related an interesting tale about color perception research at the Jet Propulsion Lab back in the ’70s. The JPL color research folks had the capability to print more than 50,000,000 distinct and very precise colors on paper. As a test, they tried printing out words in various colors, with each word printed on a background that differed by only one color index from the word’s color. No one expected the human eye to be able to differentiate between two colors, out of 50,000,000-plus, that were so similar. It turned out, though, that everyone could read the words with no trouble at all; the human eye is surprisingly sensitive to color gradations, and also happens to be wonderful at detecting edges.</p>
<p>When the JPL team went to test the eye’s sensitivity to color on the screen, they found that only about 16,000,000 colors could be distinguished, because the color-sensing mechanism of the human eye is more compatible with reflective sources such as paper and ink than with emissive sources such as CRTs. Still, the human eye can distinguish about 16,000,000 colors on the screen. That’s not so hard to believe, if you think about it; the eye senses each primary color separately, so we’re really only talking about detecting 256 levels of intensity per primary here. It’s the brain that does the amazing part; the 16,000,000-plus color capability actually comes not from extraordinary sensitivity in the eye, but rather from the brain’s ability to distinguish between all the mixes of 256 levels of each of three primaries.</p>
<p>So it’s perfectly reasonable to maintain 24 bits of color resolution, and X-Sharp represents colors internally as ideal, device-independent 24-bit RGB triplets. All shading calculations are performed on these triplets, with 24-bit color precision. It’s only after the final 24-bit RGB drawing color is calculated that the display adapter’s color capabilities come into play, as the X-Sharp function <code>ModelColorToColorIndex()</code> is called to map the desired RGB color to the closest match the adapter is capable of displaying. Of course, that mapping is adapter-dependent. On a 24-bpp device, it’s pretty obvious how the internal RGB color format maps to displayed pixel colors: directly. On VGAs with 15-bpp Sierra Hicolor DACS, the mapping is equally simple, with the five upper bits of each color component mapping straight to display pixels. But how on earth do we map those 16,000,000-plus RGB colors into the 256-color space of a standard VGA?</p>
<p>This is the “color definition” problem I mentioned at the start of this chapter. The VGA palette is arbitrarily programmable to any set of 256 colors, with each color defined by six bits each of red, green, and blue intensity. In X-Sharp, the function <code>InitializePalette()</code> can be customized to set up the palette however we wish; this gives us nearly complete flexibility in defining the working color set. Even with infinite flexibility, however, 256 out of 16,000,000 or so possible colors is a pretty puny selection. It’s easy to set up the palette to give yourself a good selection of just blue intensities, or of just greens; but for general color modeling there’s simply not enough palette to go around.</p>
<p>One way to deal with the limited simultaneous color capabilities of the VGA is to build an application that uses only a subset of RGB space, then bias the VGA’s palette toward that subspace. This is the approach used in the DEMO1 sample program in X-Sharp; Listings 55.2 and 55.3 show the versions of <code>InitializePalette()</code> and <code>ModelColorToColorIndex()</code> that set up and perform the color mapping for DEMO1.</p>
<p><strong>LISTING 55.2 L55-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Sets up the palette in mode X, to a 2-2-2 general R-G-B organization, with</span>
<span class="co">  64 separate levels each of pure red, green, and blue. This is very good</span>
<span class="co">  for pure colors, but mediocre at best for mixes.</span>

<span class="co">  ------------------------</span>
<span class="co">  |0  0 | Red|Green| Blue |</span>
<span class="co">  ------------------------</span>
<span class="co">   7  6  5  4  3  2  1  0</span>

<span class="co">  ------------------------</span>
<span class="co">  |0  1 |      Red        |</span>
<span class="co">  ------------------------</span>
<span class="co">   7  6  5  4  3  2  1  0</span>

<span class="co">  ------------------------</span>
<span class="co">  |1  0 |     Green       |</span>
<span class="co">  ------------------------</span>
<span class="co">   7  6  5  4  3  2  1  0</span>

<span class="co">  ------------------------</span>
<span class="co">  |1  1 |      Blue       |</span>
<span class="co">  ------------------------</span>
<span class="co">   7  6  5  4  3  2  1  0</span>

<span class="co">  Colors are gamma corrected for a gamma of 2.3 to provide approximately</span>
<span class="co">  even intensity steps on the screen.</span>
<span class="co">*/</span>

<span class="ot">#include &lt;dos.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>

<span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">char</span> Gamma4Levels[] = { <span class="dv">0</span>, <span class="dv">39</span>, <span class="dv">53</span>, <span class="dv">63</span> };
<span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">char</span> Gamma64Levels[] = {
   <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">14</span>, <span class="dv">17</span>, <span class="dv">19</span>, <span class="dv">21</span>, <span class="dv">23</span>, <span class="dv">24</span>, <span class="dv">26</span>, <span class="dv">27</span>, <span class="dv">28</span>, <span class="dv">29</span>, <span class="dv">31</span>, <span class="dv">32</span>, <span class="dv">33</span>, <span class="dv">34</span>,
  <span class="dv">35</span>, <span class="dv">36</span>, <span class="dv">37</span>, <span class="dv">37</span>, <span class="dv">38</span>, <span class="dv">39</span>, <span class="dv">40</span>, <span class="dv">41</span>, <span class="dv">41</span>, <span class="dv">42</span>, <span class="dv">43</span>, <span class="dv">44</span>, <span class="dv">44</span>, <span class="dv">45</span>, <span class="dv">46</span>, <span class="dv">46</span>,
  <span class="dv">47</span>, <span class="dv">48</span>, <span class="dv">48</span>, <span class="dv">49</span>, <span class="dv">49</span>, <span class="dv">50</span>, <span class="dv">51</span>, <span class="dv">51</span>, <span class="dv">52</span>, <span class="dv">52</span>, <span class="dv">53</span>, <span class="dv">53</span>, <span class="dv">54</span>, <span class="dv">54</span>, <span class="dv">55</span>, <span class="dv">55</span>,
  <span class="dv">56</span>, <span class="dv">56</span>, <span class="dv">57</span>, <span class="dv">57</span>, <span class="dv">58</span>, <span class="dv">58</span>, <span class="dv">59</span>, <span class="dv">59</span>, <span class="dv">60</span>, <span class="dv">60</span>, <span class="dv">61</span>, <span class="dv">61</span>, <span class="dv">62</span>, <span class="dv">62</span>, <span class="dv">63</span>, <span class="dv">63</span>,
};

<span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">char</span> PaletteBlock[<span class="dv">256</span>][<span class="dv">3</span>];   <span class="co">/* 256 RGB entries */</span>

<span class="dt">void</span> InitializePalette()
{
  <span class="dt">int</span> Red, Green, Blue, Index;
  <span class="kw">union</span> REGS regset;
  <span class="kw">struct</span> SREGS sregset;

  <span class="kw">for</span> (Red=<span class="dv">0</span>; Red&lt;<span class="dv">4</span>; Red++) {
     <span class="kw">for</span> (Green=<span class="dv">0</span>; Green&lt;<span class="dv">4</span>; Green++) {
        <span class="kw">for</span> (Blue=<span class="dv">0</span>; Blue&lt;<span class="dv">4</span>; Blue++) {
           Index = (Red&lt;&lt;<span class="dv">4</span>)+(Green&lt;&lt;<span class="dv">2</span>)+Blue;
           PaletteBlock[Index][<span class="dv">0</span>] = Gamma4Levels[Red];
           PaletteBlock[Index][<span class="dv">1</span>] = Gamma4Levels[Green];
           PaletteBlock[Index][<span class="dv">2</span>] = Gamma4Levels[Blue];
        }
     }
  }

  <span class="kw">for</span> (Red=<span class="dv">0</span>; Red&lt;<span class="dv">64</span>; Red++) {
     PaletteBlock[<span class="dv">64</span>+Red][<span class="dv">0</span>] = Gamma64Levels[Red];
     PaletteBlock[<span class="dv">64</span>+Red][<span class="dv">1</span>] = <span class="dv">0</span>;
     PaletteBlock[<span class="dv">64</span>+Red][<span class="dv">2</span>] = <span class="dv">0</span>;
  }

  <span class="kw">for</span> (Green=<span class="dv">0</span>; Green&lt;<span class="dv">64</span>; Green++) {
     PaletteBlock[<span class="dv">128</span>+Green][<span class="dv">0</span>] = <span class="dv">0</span>;
     PaletteBlock[<span class="dv">128</span>+Green][<span class="dv">1</span>] = Gamma64Levels[Green];
     PaletteBlock[<span class="dv">128</span>+Green][<span class="dv">2</span>] = <span class="dv">0</span>;
  }

  <span class="kw">for</span> (Blue=<span class="dv">0</span>; Blue&lt;<span class="dv">64</span>; Blue++) {
     PaletteBlock[<span class="dv">192</span>+Blue][<span class="dv">0</span>] = <span class="dv">0</span>;
     PaletteBlock[<span class="dv">192</span>+Blue][<span class="dv">1</span>] = <span class="dv">0</span>;
     PaletteBlock[<span class="dv">192</span>+Blue][<span class="dv">2</span>] = Gamma64Levels[Blue];
  }

  <span class="co">/* Now set up the palette */</span>
  regset.x.ax = <span class="bn">0x1012</span>;   <span class="co">/* set block of DAC registers function */</span>
  regset.x.bx = <span class="dv">0</span>;        <span class="co">/* first DAC location to load */</span>
  regset.x.cx = <span class="dv">256</span>;      <span class="co">/* # of DAC locations to load */</span>
  regset.x.dx = (<span class="dt">unsigned</span> <span class="dt">int</span>)PaletteBlock; <span class="co">/* offset of array from which</span>
<span class="co">                                               to load RGB settings */</span>
  sregset.es = DS; <span class="co">/* segment of array from which to load settings */</span>
  int86x(<span class="bn">0x10</span>, &amp;regset, &amp;regset, &amp;sregset); <span class="co">/* load the palette block */</span>
}</code></pre>
<p><strong>LISTING 55.3 L55-3.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Converts a model color (a color in the RGB color cube, in the current</span>
<span class="co">  color model) to a color index for mode X. Pure primary colors are</span>
<span class="co">  special-cased, and everything else is handled by a 2-2-2 model. */</span>
<span class="dt">int</span> ModelColorToColorIndex(ModelColor * Color)
{
  <span class="kw">if</span> (Color-&gt;Red == <span class="dv">0</span>) {
     <span class="kw">if</span> (Color-&gt;Green == <span class="dv">0</span>) {
        <span class="co">/* Pure blue */</span>
        <span class="kw">return</span>(<span class="dv">192</span>+(Color-&gt;Blue &gt;&gt; <span class="dv">2</span>));
     } <span class="kw">else</span> <span class="kw">if</span> (Color-&gt;Blue == <span class="dv">0</span>) {
        <span class="co">/* Pure green */</span>
        <span class="kw">return</span>(<span class="dv">128</span>+(Color-&gt;Green &gt;&gt; <span class="dv">2</span>));
     }
  } <span class="kw">else</span> <span class="kw">if</span> ((Color-&gt;Green == <span class="dv">0</span>) &amp;&amp; (Color-&gt;Blue == <span class="dv">0</span>)) {
     <span class="co">/* Pure red */</span>
     <span class="kw">return</span>(<span class="dv">64</span>+(Color-&gt;Red &gt;&gt; <span class="dv">2</span>));
  }
  <span class="co">/* Multi-color mix; look up the index with the two most significant bits</span>
<span class="co">     of each color component */</span>
  <span class="kw">return</span>(((Color-&gt;Red &amp; <span class="bn">0xC0</span>) &gt;&gt; <span class="dv">2</span>) | ((Color-&gt;Green &amp; <span class="bn">0xC0</span>) &gt;&gt; <span class="dv">4</span>) |
        ((Color-&gt;Blue &amp; <span class="bn">0xC0</span>) &gt;&gt; <span class="dv">6</span>));
}</code></pre>
<p>In DEMO1, three-quarters of the palette is set up with 64 intensity levels of each of the three pure primary colors (red, green, and blue), and then most drawing is done with only pure primary colors. The resulting rendering quality is very good because there are so many levels of each primary.</p>
<p>The downside is that this excellent quality is available for only three colors: red, green, and blue. What about all the other colors that are mixes of the primaries, like cyan or yellow, to say nothing of gray? In the DEMO1 color model, any RGB color that is not a pure primary is mapped into a 2-2-2 RGB space that the remaining quarter of the VGA’s palette is set up to display; that is, there are exactly two bits of precision for each color component, or 64 general RGB colors in all. This is genuinely lousy color resolution, being only 1/64th of the resolution we really need for each color component. In this model, a staggering 262,144 colors from the 24-bit RGB cube map to <em>each</em> color in the 2-2-2 VGA palette. The results are not impressive; the colors of mixed-primary surfaces jump abruptly, badly damaging the illusion of real illumination. To see how poor a 2-2-2 RGB selection can look, run DEMO1, and press the ‘2’ key to turn on spotlight 2, the blue spotlight. Because the ambient lighting is green, turning on the blue spotlight causes mixed-primary colors to be displayed—and the result looks terrible, because there just isn’t enough color resolution. Unfortunately, 2-2-2 RGB is close to the best general color resolution the VGA can display; 3-3-2 is as good as it gets.</p>
<p>Another approach would be to set up the palette with reasonably good mixes of two primaries but no mixes of three primaries, then use only two-primary colors in your applications (no grays or whites or other three-primary mixes). Or you could choose to shade only selected objects, using part of the palette for a good range of the colors of those objects, and reserving the rest of the palette for the fixed colors of the other, nonshaded objects. Jim Kent, author of Autodesk Animator, suggests dynamically adjusting the palette to the needs of each frame, for example by allocating the colors for each frame on a first-come, first-served basis. That wouldn’t be trivial to do in real time, but it would make for extremely efficient use of the palette.</p>
<p>Another widely used solution is to set up a 2-2-2, 3-3-2, or 2.6-2.6-2.6 (6 levels per primary) palette, and dither colors. Dithering is an excellent solution, but outside the scope of this book. Take a look at Chapter 13 of Foley and Van Dam (cited in “Further Readings”) for an introduction to color perception and approximation.</p>
<p>The sad truth is that the VGA’s 256-color palette is an inadequate resource for general RGB shading. The good news is that clever workarounds can make VGA graphics look nearly as good as 24-bpp graphics; but the burden falls on you, the programmer, to design your applications and color mapping to compensate for the VGA’s limitations. To experiment with a different 256-color model in X-Sharp, just change <code>InitializePalette()</code> to set up the desired palette and <code>ModelColorToColorIndex()</code> to map 24-bit RGB triplets into the palette you’ve set up. It’s that simple, and the results can be striking indeed.</p>
</section>
<section id="a-bonus-from-the-bitman" class="level4">
<h4><a href="#a-bonus-from-the-bitman">A Bonus from the BitMan</a></h4>
<p>Finally, a note on fast VGA text, which came in from a correspondent who asked to be referred to simply as the BitMan. The BitMan passed along a nifty application of the VGA’s under-appreciated write mode 3 that is, under the proper circumstances, the fastest possible way to draw text in any 16-color VGA mode.</p>
<p>The task at hand is illustrated by Figure 55.2. We want to draw what’s known as solid text, in which the effect is the same as if the cell around each character was drawn in the background color, and then each character was drawn on top of the background box. (This is in contrast to transparent text, where each character is drawn in the foreground color without disturbing the background.) Assume that each character fits in an eight-wide cell (as is the case with the standard VGA fonts), and that we’re drawing text at byte-aligned locations in display memory.</p>
<p>Solid text is useful for drawing menus, text areas, and the like; basically, it can be used whenever you want to display text on a solid-color background. The obvious way to implement solid text is to fill the rectangle representing the background box, then draw transparent text on top of the background box. However, there are two problems with doing solid text this way. First, there’s some flicker, because for a little while the box is there but the text hasn’t yet arrived. More important is that the background-followed-by-foreground approach accesses display memory three times for each byte of font data: once to draw the background box, once to read display memory to load the latches, and once to actually draw the font pattern. Display memory is incredibly slow, so we’d like to reduce the number of accesses as much as possible. With the BitMan’s approach, we can reduce the number of accesses to just one per font byte, and eliminate flicker, too.</p>
<figure>
<img src="images/55-02.jpg" alt="Figure 55.2  Drawing solid text." /><figcaption><strong>Figure 55.2</strong>  <em>Drawing solid text.</em></figcaption>
</figure>
<p>The keys to fast solid text are the latches and write mode 3. The latches, as you may recall from earlier discussions in this book, are four internal VGA registers that hold the last bytes read from the VGA’s four planes; every read from VGA memory loads the latches with the values stored at that display memory address across the four planes. Whenever a write is performed to VGA memory, the latches can provide some, none, or all of the bits written to memory, depending on the bit mask, which selects between the latched data and the drawing data on a bit-by-bit basis. The latches solve half our problem; we can fill the latches with the background color, then use them to draw the background box. The trick now is drawing the text pixels in the foreground color at the same time.</p>
<p>This is where it gets a little complicated. In write mode 3 (which incidentally is not available on the EGA), each byte value that the CPU writes to the VGA does not get written to display memory. Instead, it turns into the bit mask. (Actually, it’s ANDed with the Bit Mask register, and the result becomes the bit mask, but we’ll leave the Bit Mask register set to 0xFF, so the CPU value will become the bit mask.) The bit mask selects, on a bit-by-bit basis, between the data in the latches for each plane (the previously loaded background color, in this case) and the foreground color. Where does the foreground color come from, if not from the CPU? From the Set/Reset register, as shown in Figure 55.3. Thus, each byte written by the CPU (font data, presumably) selects foreground or background color for each of eight pixels, all done with a single write to display memory.</p>
<figure>
<img src="images/55-03.jpg" alt="Figure 55.3  The data path in write mode 3." /><figcaption><strong>Figure 55.3</strong>  <em>The data path in write mode 3.</em></figcaption>
</figure>
<p>I know this sounds pretty esoteric, but think of it this way: The latches hold the background color in a form suitable for writing eight background pixels (one full byte) at a pop. Write mode 3 allows each CPU byte to punch holes in the background color provided by the latches, holes through which the foreground color from the Set/Reset register can flow. The result is that a single write draws exactly the combination of foreground and background pixels described by each font byte written by the CPU. It may help to look at Listing 55.4, which shows The BitMan’s technique in action. And yes, this technique is absolutely worth the trouble; it’s about three times faster than the fill-then-draw approach described above, and about twice as fast as transparent text. So far as I know, there is no faster way to draw text on a VGA.</p>
<p>It’s important to note that the BitMan’s technique only works on full bytes of display memory. There’s no way to clip to finer precision; the background color will inevitably flood all of the eight destination pixels that aren’t selected as foreground pixels. This makes The BitMan’s technique most suitable for monospaced fonts with characters that are multiples of eight pixels in width, and for drawing to byte-aligned addresses; the technique can be used in other situations, but is considerably more difficult to apply.</p>
<p><strong>LISTING 55.4 L55-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"> <span class="co">; Demonstrates drawing solid text on the VGA, using the BitMan&#39;s write mode</span>
 <span class="co">; 3-based, one-pass technique.</span>

 CHAR_HEIGHT     <span class="dt">equ</span> <span class="dv">8</span>                <span class="co">;# of scan lines per character (must be &lt;256)</span>
 SCREEN_HEIGHT   <span class="dt">equ</span> <span class="dv">480</span>              <span class="co">;# of scan lines per screen</span>
 SCREEN_SEGMENT  <span class="dt">equ</span><span class="bn"> 0a000h           </span><span class="co">;where screen memory is</span>
 FG_COLOR        <span class="dt">equ</span> <span class="dv">14</span>               <span class="co">;text color</span>
 BG_COLOR        <span class="dt">equ</span> <span class="dv">1</span>                <span class="co">;background box color</span>
 GC_INDEX        <span class="dt">equ</span><span class="bn"> 3ceh             </span><span class="co">;Graphics Controller (GC) Index reg I/O port</span>
 SET_RESET       <span class="dt">equ</span> <span class="dv">0</span>                <span class="co">;Set/Reset register index in GC</span>
 G_MODE          <span class="dt">equ</span> <span class="dv">5</span>                <span class="co">;Graphics Mode register index in GC</span>
 BIT_MASK        <span class="dt">equ</span> <span class="dv">8</span>                <span class="co">;Bit Mask register index in GC</span>

       .model    small
       .stack<span class="bn">    200h</span>
       .data
 Line            <span class="dt">dw</span> ?                <span class="co">;current line #</span>
 CharHeight      <span class="dt">dw</span> ?                <span class="co">;# of scan lines in each character (must be &lt;256)</span>
 MaxLines        <span class="dt">dw</span> ?                <span class="co">;max # of scan lines of text that will fit on screen</span>
 LineWidthBytes  <span class="dt">dw</span> ?                <span class="co">;offset from one scan line to the next</span>
 FontPtr         <span class="dt">dd</span> ?                <span class="co">;pointer to font with which to draw</span>
 SampleString    label              <span class="dt">byte</span>
       <span class="dt">db</span>  ‘ABCDEFGHIJKLMNOPQRSTUVWXYZ<span class="st">&#39;</span>
       <span class="dt">db</span>  ‘abcdefghijklmnopqrstuvwxyz<span class="st">&#39;</span>
       <span class="dt">db</span>  ‘0123456789!@#<span class="dv">$</span><span class="ot">%^&amp;*(),&lt;.&gt;/?;:&#39;,0</span>

      .code
<span class="fu"> start:</span>
        <span class="kw">mov</span>  <span class="kw">ax</span>,@data
        <span class="kw">mov</span>  <span class="kw">ds</span>,<span class="kw">ax</span>

        <span class="kw">mov</span>  <span class="kw">ax</span><span class="bn">,12h</span>
        <span class="kw">int</span><span class="bn">  10h                        </span><span class="co">;select 640x480 16-color mode</span>

        <span class="kw">mov</span>  <span class="kw">ah</span><span class="bn">,11h                     </span><span class="co">;BIOS character generator function</span>
        <span class="kw">mov</span>  <span class="kw">al</span><span class="bn">,30h                     </span><span class="co">;BIOS get font pointer subfunction</span>
        <span class="kw">mov</span>  <span class="kw">bh</span>,<span class="dv">3</span>                       <span class="co">;get 8x8 ROM font subsubfunction</span>
        <span class="kw">int</span><span class="bn">  10h                        </span><span class="co">;get the pointer to the BIOS 8x8 font</span>
        <span class="kw">mov</span>  <span class="dt">word</span> <span class="dt">ptr</span> [FontPtr],<span class="kw">bp</span>
        <span class="kw">mov</span>  <span class="dt">word</span> <span class="dt">ptr</span> [FontPtr<span class="dv">+2</span>],<span class="kw">es</span>

        <span class="kw">mov</span>  <span class="kw">bx</span>,CHAR_HEIGHT
        <span class="kw">mov</span>  [CharHeight],<span class="kw">bx</span>            <span class="co">;# of scan lines per character</span>
        <span class="kw">mov</span>  <span class="kw">ax</span>,SCREEN_HEIGHT
        <span class="kw">sub</span>  <span class="kw">dx</span>,<span class="kw">dx</span>
        <span class="kw">div</span>  <span class="kw">bx</span>
        <span class="kw">mul</span>  <span class="kw">bx</span>                         <span class="co">;max # of full scan lines of text that</span>
        <span class="kw">mov</span>  [MaxLines],<span class="kw">ax</span>              <span class="co">; will fit on the screen</span>

        <span class="kw">mov</span>  <span class="kw">ah</span><span class="bn">,0fh                     </span><span class="co">;BIOS video status function</span>
        <span class="kw">int</span><span class="bn">  10h                        </span><span class="co">;get # of columns (bytes) per row</span>
        <span class="kw">mov</span>  <span class="kw">al</span>,<span class="kw">ah</span>                      <span class="co">;convert byte columns variable in</span>
        <span class="kw">sub</span>  <span class="kw">ah</span>,<span class="kw">ah</span>                      <span class="co">; AH to word in AX</span>
        <span class="kw">mov</span>  [LineWidthBytes],<span class="kw">ax</span>        <span class="co">;width of scan line in bytes</span>
                                        <span class="co">;now draw the text</span>
        <span class="kw">sub</span>  <span class="kw">bx</span>,<span class="kw">bx</span>
        <span class="kw">mov</span>  [Line],<span class="kw">bx</span>                  <span class="co">;start at scan line 0</span>
<span class="fu">LineLoop:</span>
        <span class="kw">sub</span>  <span class="kw">ax</span>,<span class="kw">ax</span>                      <span class="co">;start at column 0; must be a multiple of 8</span>
        <span class="kw">mov</span>  <span class="kw">ch</span>,FG_COLOR                <span class="co">;color in which to draw text</span>
        <span class="kw">mov</span>  <span class="kw">cl</span>,BG_COLOR                <span class="co">;color in which to draw background box</span>
        <span class="kw">mov</span>  <span class="kw">si</span>,offset SampleString     <span class="co">;text to draw</span>
        <span class="kw">call</span> DrawTextString             <span class="co">;draw the sample text</span>
        <span class="kw">mov</span>  <span class="kw">bx</span>,[Line]
        <span class="kw">add</span>  <span class="kw">bx</span>,[CharHeight]            <span class="co">;# of next scan line to draw on</span>
        <span class="kw">mov</span>  [Line],<span class="kw">bx</span>
        <span class="kw">cmp</span>  <span class="kw">bx</span>,[MaxLines]              <span class="co">;done yet?</span>
        <span class="kw">jb</span>   LineLoop                   <span class="co">;not yet</span>

        <span class="kw">mov</span>  <span class="kw">ah</span>,<span class="dv">7</span>
        <span class="kw">int</span><span class="bn">  21h                        </span><span class="co">;wait for a key press, without echo</span>

        <span class="kw">mov</span>  <span class="kw">ax</span><span class="bn">,03h</span>
        <span class="kw">int</span><span class="bn">  10h                        </span><span class="co">;back to text mode</span>

        <span class="kw">mov</span>  <span class="kw">ah</span><span class="bn">,4ch</span>
        <span class="kw">int</span><span class="bn">  21h                        </span><span class="co">;exit to DOS</span>

<span class="co">; Draws a text string.</span>
<span class="co">; Input: AX = X coordinate at which to draw upper-left corner of first char</span>
<span class="co">;    BX = Y coordinate at which to draw upper-left corner of first char</span>
<span class="co">;    CH = foreground (text) color</span>
<span class="co">;    CL = background (box) color</span>
<span class="co">;    DS:SI = pointer to string to draw, zero terminated</span>
<span class="co">;    CharHeight must be set to the height of each character</span>
<span class="co">;    FontPtr must be set to the font with which to draw</span>
<span class="co">;        LineWidthBytes must be set to the scan line width in bytes</span>
<span class="co">; Don&#39;t count on any registers other than DS, SS, and SP being preserved.</span>
<span class="co">; The X coordinate is truncated to a multiple of 8. Characters are</span>
<span class="co">; assumed to be 8 pixels wide.</span>
     <span class="kw">align</span> <span class="dv">2</span>
    DrawTextString  proc    near
        <span class="kw">cld</span>
        <span class="kw">shr</span>  <span class="kw">ax</span>,<span class="dv">1</span>                 <span class="co">;byte address of starting X within scan line</span>
        <span class="kw">shr</span>  <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">shr</span>  <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">mov</span>  <span class="kw">di</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>  <span class="kw">ax</span>,[LineWidthBytes]
        <span class="kw">mul</span>  <span class="kw">bx</span>                  <span class="co">; start offset of initial scan line</span>
        <span class="kw">add</span>  <span class="kw">di</span>,<span class="kw">ax</span>               <span class="co">;start offset of initial byte</span>
        <span class="kw">mov</span>  <span class="kw">ax</span>,SCREEN_SEGMENT
        <span class="kw">mov</span>  <span class="kw">es</span>,<span class="kw">ax</span>               <span class="co">;ES:DI = offset of initial character&#39;s</span>
                                 <span class="co">; first scan line</span>
                                 <span class="co">;set up the VGA&#39;s hardware so that we can</span>
                                 <span class="co">; fill the latches with the background color</span>
        <span class="kw">mov</span>  <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>  <span class="kw">ax</span>,(0ffh <span class="kw">SHL</span> <span class="dv">8</span>) + BIT_MASK
        <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">ax</span>               <span class="co">;set Bit Mask register to 0xFF (that&#39;s the</span>
                                 <span class="co">; default, but I&#39;m doing this just to make sure</span>
                                 <span class="co">; you understand that Bit Mask register and</span>
                                 <span class="co">; CPU data are ANDed in write mode 3)</span>
        <span class="kw">mov</span>  <span class="kw">ax</span>,(003h <span class="kw">SHL</span> <span class="dv">8</span>) + G_MODE
        <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">ax</span>               <span class="co">;select write mode 3</span>
        <span class="kw">mov</span>  <span class="kw">ah</span>,<span class="kw">cl</span>               <span class="co">;background color</span>
        <span class="kw">mov</span>  <span class="kw">al</span>,SET_RESET
        <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">ax</span>               <span class="co">;set the drawing color to background color</span>
        <span class="kw">mov</span>  <span class="dt">byte</span> <span class="dt">ptr</span> <span class="kw">es</span>:[0ffffh]<span class="bn">,0ffh</span>
                                 <span class="co">;write 8 pixels of the background</span>
                                 <span class="co">; color to unused off-screen memory</span>
        <span class="kw">mov</span>  <span class="kw">cl</span>,<span class="kw">es</span>:[0ffffh]      <span class="co">;read the background color back into the</span>
                                 <span class="co">; latches; the latches are now filled with</span>
                                 <span class="co">; the background color. The value in CL</span>
                                 <span class="co">; doesn&#39;t matter, we just needed a target</span>
                                 <span class="co">; for the read, so we could load the latches</span>
        <span class="kw">mov</span>  <span class="kw">ah</span>,<span class="kw">ch</span>               <span class="co">;foreground color</span>
        <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">ax</span>               <span class="co">;set the Set/Reset (drawing) color to the</span>
                                 <span class="co">; foreground color</span>
                                 <span class="co">;we&#39;re ready to draw!</span>
<span class="fu">DrawTextLoop:</span>
        <span class="kw">lodsb</span>                    <span class="co">;next character to draw</span>
        <span class="kw">and</span>  <span class="kw">al</span>,<span class="kw">al</span>               <span class="co">;end of string?</span>
        <span class="kw">jz</span>   DrawTextDone                   <span class="co">;yes</span>
        <span class="kw">push</span> <span class="kw">ds</span>                  <span class="co">;remember string&#39;s segment</span>
        <span class="kw">push</span> <span class="kw">si</span>                  <span class="co">;remember offset of next character in string</span>
        <span class="kw">push</span> <span class="kw">di</span>                  <span class="co">;remember drawing offset</span>
                                 <span class="co">;load these variables before we wipe out DS</span>
        <span class="kw">mov</span>  <span class="kw">dx</span>,[LineWidthBytes] <span class="co">;offset from one line to next</span>
        <span class="kw">dec</span>  <span class="kw">dx</span>                  <span class="co">;compensate for STOSB</span>
        <span class="kw">mov</span>  <span class="kw">cx</span>,[CharHeight]<span class="co">;</span>
        <span class="kw">mul</span>  <span class="kw">cl</span>                  <span class="co">;offset of character in font table</span>
        <span class="kw">lds</span>  <span class="kw">si</span>,[FontPtr]        <span class="co">;point to font table</span>
        <span class="kw">add</span>  <span class="kw">si</span>,<span class="kw">ax</span>               <span class="co">;point to start of character to draw</span>
                                 <span class="co">;the following loop should be unrolled for</span>
                                 <span class="co">; maximum performance!</span>
<span class="fu">DrawCharLoop:</span>                    <span class="co">;draw all lines of the character</span>
        <span class="kw">mov</span>  sb                  <span class="co">;getthe next byte of the character and draw</span>
                                 <span class="co">; character; data is ANDed with Bit Mask</span>
                                 <span class="co">; register to become bit mask, and selects</span>
                                 <span class="co">; between latch (containing the background</span>
                                 <span class="co">; color) and Set/Reset register (containing</span>
                                 <span class="co">; foreground color)</span>
        <span class="kw">add</span> <span class="kw">di</span>,<span class="kw">dx</span>                <span class="co">;point to next line of destination</span>
        <span class="kw">loop</span> DrawCharLoop

        <span class="kw">pop</span>  <span class="kw">di</span>                  <span class="co">;retrieve initial drawing offset</span>
        <span class="kw">inc</span>  <span class="kw">di</span>                  <span class="co">;drawing offset for next char</span>
        <span class="kw">pop</span>  <span class="kw">si</span>                  <span class="co">;retrieve offset of next character in string</span>
        <span class="kw">pop</span>  <span class="kw">ds</span>                  <span class="co">;retrieve string&#39;s segment</span>
        <span class="kw">jmp</span>  DrawTextLoop        <span class="co">;draw next character, if any</span>

        align2
<span class="fu">  DrawTextDone:</span>                  <span class="co">;restore the Graphics Mode register to its</span>
                                 <span class="co">; default state of write mode 0</span>
        <span class="kw">mov</span>  <span class="kw">dx</span>,GC_INDEX
        <span class="kw">mov</span>  <span class="kw">ax</span>,(000h <span class="kw">SHL</span> <span class="dv">8</span>) + G_MODE
        <span class="kw">out</span>  <span class="kw">dx</span>,<span class="kw">ax</span>               <span class="co">;select write mode 0</span>
        <span class="kw">ret</span>
DrawTextString   endp
        end   start</code></pre>
</section>
</section>
</section>
<section id="chapter-56-pooh-and-the-space-station" class="level2">
<h2><a href="#chapter-56-pooh-and-the-space-station">Chapter 56 – Pooh and the Space Station</a></h2>
<section id="using-fast-texture-mapping-to-place-pooh-on-a-polygon" class="level3">
<h3><a href="#using-fast-texture-mapping-to-place-pooh-on-a-polygon">Using Fast Texture Mapping to Place Pooh on a Polygon</a></h3>
<p>So, here’s where Winnie the Pooh lives: in a space station orbiting Saturn. No, really; I have it straight from my daughter, and an eight-year-old wouldn’t make up something that important, would she? One day she wondered aloud, “Where is the Hundred Acre Wood, exactly?” and before I could give one of those boring parental responses about how it was imaginary—but A.A. Milne probably imagined it to be somewhere near London—my daughter announced that the Hundred Acre Wood was in a space station orbiting Saturn, and there you have it.</p>
<p>As it turns out, that’s a very good location for the Hundred Acre Wood, leading to many exciting adventures for Pooh and Piglet. Consider the time they went down to the Jupiter gravity level (we’re talking centrifugal force here; the station is spinning, of course) and nearly turned into pancakes of the Pooh and Piglet varieties, respectively. Or the time they drifted out into the free-fall area at the core and had to be rescued by humans with wings strapped on (a tip of the hat to Robert Heinlein here). Or the time they were caught up by the current in the river through the Wood and drifted for weeks around the circumference of the station, meeting many cultures and finding many adventures along the way. (Yes, Farmer’s Riverworld; no one said the stories you tell your children need to be purely original, just interesting.)</p>
<p>(If you think Pooh and Piglet in a space station is a tad peculiar, then I won’t even mention Karla, the woman who invented agriculture, medicine, sanitation, reading and writing, peace, and just about everything else while travelling the length of the Americas with her mountain lion during the last Ice Age; or the Mars Cats and their trip in suspended animation to the Lesser Magellenic Cloud and beyond; or most assuredly Little Whale, the baby Universe Whale that is naughty enough to eat inhabited universes. But I digress.)</p>
<p>Anyway, I bring up Pooh and the space station because the time has come to discuss fast texture mapping. <em>Texture mapping</em> is the process of mapping an image (in our case, a bitmap) onto the surface of a polygon that’s been transformed in the process of 3-D drawing. Up to this point, each polygon we’ve drawn in X-Sharp has been a single, solid color. Over the last couple of chapters we added the ability to shade polygons according to lighting, but each polygon was still a single color. Thus, in order to produce any sort of intricate design, a great many tiny polygons would have to be drawn. That would be very slow, so we need another approach. One such approach is texture mapping; that is, mapping the bitmap containing the desired image onto the pixels contained within the transformed polygon. Done properly, this should make it possible to change X-Sharp’s output from a bland collection of monocolor facets to a lively, detailed, and much more realistic scene.</p>
<p>“What sort of scene?” you may well ask. This is where Pooh and the space station came in. When I sat down to think of a sample texture-mapping application, it occurred to me that the shaded ball demo we added to X-Sharp recently looked at least a bit like a spinning, spherical space station, and that the single unshaded, yellow polygon looked somewhat like a window in the space station, and it might be a nice example if someone were standing in the window….</p>
<p>The rest is history.</p>
</section>
<section id="principles-of-quick-and-dirty-texture-mapping" class="level3">
<h3><a href="#principles-of-quick-and-dirty-texture-mapping">Principles of Quick-and-Dirty Texture Mapping</a></h3>
<p>The key to our texture-mapping approach will be to quickly determine what pixel value to draw for each pixel in the transformed destination polygon. These polygon pixel values will be determined by mapping each destination pixel in the transformed polygon back to the image bitmap, via a reverse transformation, and seeing what color resides at the corresponding location in the image bitmap, as shown in Figure 56.1. It might seem more intuitive to map pixels the other way, from the image bitmap to the transformed polygon, but in fact it’s crucial that the mapping proceed backward from the destination to avoid gaps in the final image. With the approach of finding the right value for each destination pixel in turn, via a backward mapping, there’s no way we can miss any destination pixels. On the other hand, with the forward-mapping method, some destination pixels may be skipped or double-drawn, because this is not necessarily a one-to-one or one-to-many mapping. Although we’re not going to take advantage of it now, mapping back to the source makes it possible to average several neighboring image pixels together to calculate the value for each destination pixel; that is, to antialias the image. This can greatly improve texture quality, although it is slower.</p>
<figure>
<img src="images/56-01.jpg" alt="Figure 56.1  Using reverse transformation to find the source pixel color." /><figcaption><strong>Figure 56.1</strong>  <em>Using reverse transformation to find the source pixel color.</em></figcaption>
</figure>
<section id="mapping-textures-made-easy" class="level4">
<h4><a href="#mapping-textures-made-easy">Mapping Textures Made Easy</a></h4>
<p>To understand how we’re going to map textures, consider Figure 56.2, which maps a bitmapped image directly onto an untransformed polygon. Here, we simply map the origin of the polygon’s untransformed coordinate system somewhere within the image, then map the vertices to the corresponding image pixels. (For simplicity, I’ll assume in this discussion that the polygon’s coordinate system is in units of pixels, but scaling images to polygons is eminently doable. This will become clearer when we look at mapping images onto transformed polygons, next.) Mapping the image to the polygon is then a simple matter of stepping one scan line at a time in both the image and the polygon, each time advancing the X coordinates of the edges according to the slopes of the lines, just as is normally done when filling a polygon. Since the polygon is untransformed, the stepping is identical in both the image and the polygon, and the pixel mapping is one-to-one, so the appropriate part of each scan line of the image can simply be block copied to the destination.</p>
<figure>
<img src="images/56-02.jpg" alt="Figure 56.2  Mapping a texture onto an untransformed polygon." /><figcaption><strong>Figure 56.2</strong>  <em>Mapping a texture onto an untransformed polygon.</em></figcaption>
</figure>
<p>Now, matters get more complicated. What if the destination polygon is rotated in two dimensions? We no longer have a neat direct mapping from image scan lines to destination polygon scan lines. We still want to draw across each destination scan line, but the proper source pixels for each destination scan line may now track across the source bitmap at an angle, as shown in Figure 56.3. What can we do?</p>
<p>The solution is remarkably simple. We’ll just map each transformed vertex to the corresponding vertex in the bitmap; this is easy, because the vertices are at the same indices in the original and transformed vertex lists. Each time we select a new edge to scan for the destination polygon, we’ll select the corresponding edge in the source bitmap, as well. Then—and this is crucial—each time we step a destination edge one scan line, we’ll step the corresponding source image edge an equivalent amount.</p>
<p>Ah, but what is an “equivalent amount”? Think of it this way. If a destination edge is 100 scan lines high, it will be stepped 100 times. Then, we’ll divide the <code>SourceXWidth</code> and <code>SourceYHeight</code> lengths of the source edge by 100, and add those amounts to the source edge’s coordinates each time the destination is stepped one scan line. Put another way, we have, as usual, arranged things so that in the destination polygon we step <code>DestYHeight</code> times, where <code>DestYHeight</code> is the height of the destination edge. The this approach arranges to step the source image edge <code>DestYHeight</code> times also, to match what the destination is doing.</p>
<figure>
<img src="images/56-03.jpg" alt="Figure 56.3  Mapping a texture onto a 2-D rotated polygon." /><figcaption><strong>Figure 56.3</strong>  <em>Mapping a texture onto a 2-D rotated polygon.</em></figcaption>
</figure>
<p>Now we’re able to track the coordinates of the polygon edges through the source image in tandem with the destination edges. Stepping across each destination scan line uses precisely the same technique, as shown in Figure 56.4. In the destination, we step <code>DestXWidth</code> times across each scan line of the polygon, once for each pixel on the scan line. (<code>DestXWidth</code> is the horizontal distance between the two edges being scanned on any given scan line.) To match this, we divide <code>SourceXWidth</code> and <code>SourceYHeight</code> (the lengths of the scan line in the source image, as determined by the source edge points we’ve been tracking, as just described) by the width of the destination scan line, <code>DestXWidth</code>, to produce <code>SourceXStep</code> and <code>SourceYStep</code>. Then, we just step <code>DestXWidth</code> times, adding <code>SourceXStep</code> and <code>SourceYStep</code> to <code>SourceX</code> and <code>SourceY</code> each time, and choose the nearest image pixel to (<code>SourceX</code>,<code>SourceY</code>) to copy to (<code>DestX</code>, <code>DestY</code>). (Note that the names used above, such as <code>SourceXWidth</code>, are used for descriptive purposes, and don’t necessarily correspond to the actual variable names used in Listing 56.2.)</p>
<p>That’s a workable approach for 2-D rotated polygons—but what about 3-D rotated polygons, where the visible dimensions of the polygon can vary with 3-D rotation and perspective projection? First, I’d like to make it clear that texture mapping takes place from the source image to the destination polygon after the destination polygon is projected to the screen. That is, the image will be mapped after the destination polygon is in its final, drawable form. Given that, it should be apparent that the above approach automatically compensates for all changes in the dimensions of a polygon. You see, this approach divides source edges and scan lines into however many steps the destination polygon requires. If the destination polygon is much narrower than the source polygon, as a result of 3-D rotation and perspective projection, we just end up taking bigger steps through the source image and skipping a lot of source image pixels, as shown in Figure 56.5. The upshot is that the above approach handles all transformations and projections effortlessly. It could also be used to scale source images up to fit in larger polygons; all that’s needed is a list of where the polygon’s vertices map into the source image, and everything else happens automatically. In fact, mapping from any polygonal area of a bitmap to any destination polygon will work, given only that the two polygons have the same number of vertices.</p>
<figure>
<img src="images/56-04.jpg" alt="Figure 56.4  Mapping a horizontal destination scan line back to the source image." /><figcaption><strong>Figure 56.4</strong>  <em>Mapping a horizontal destination scan line back to the source image.</em></figcaption>
</figure>
<figure>
<img src="images/56-05.jpg" alt="Figure 56.5  Mapping a texture onto a narrower polygon." /><figcaption><strong>Figure 56.5</strong>  <em>Mapping a texture onto a narrower polygon.</em></figcaption>
</figure>
</section>
<section id="notes-on-dda-texture-mapping" class="level4">
<h4><a href="#notes-on-dda-texture-mapping">Notes on DDA Texture Mapping</a></h4>
<p>That’s all there is to quick-and-dirty texture mapping. This technique basically uses a two-stage digital differential analyzer (DDA) approach to step through the appropriate part of the source image in tandem with the normal scan-line stepping through the destination polygon, so I’ll call it “DDA texture mapping.” It’s worth noting that there is no need for any trigonometric functions at all, and only two divides are required per scan line.</p>
<p>This isn’t a perfect approach, of course. For one thing, it isn’t anywhere near as fast as drawing solid polygons; the speed is more comparable to drawing each polygon as a series of lines. Also, the DDA approach results in far from perfect image quality, since source pixels may be skipped or selected twice. I trust, however, that you can see how easy it would be to improve image quality by antialiasing with the DDA approach. For example, we could simply average the four surrounding pixels as we did for simple, unweighted antialiasing in Chapters F, G,Chapter K on the companion CD-ROM. Or, we could take a Wu antialiasing approach (see Chapter 57) and average the two bracketing pixels along each axis according to proximity. If we had cycles to waste (which, given that this is real-time animation on a PC, we don’t), we could improve image quality by putting the source pixels through a low-pass filter sized in X and Y according to the ratio of the source and destination dimensions (that is, how much the destination is scaled up or down from the source).</p>
<p>Even more important is that the sort of texture mapping I’ll do in X-Sharp doesn’t correct for perspective. That doesn’t much matter for small polygons or polygons that are nearly parallel to the screen in 3-space, but it can produce very noticeable bowing of textures on large polygons at an angle to the screen. Perspective texture mapping is a complex subject that’s outside the scope of this book, but you should be aware of its existence, because perspective texture mapping is a key element of many games these days.</p>
<p>Finally, I’d like to point out that this sort of DDA texture mapping is display-hardware dependent, because the bitmap for each image must be compatible with the number of bits per pixel in the destination. That’s actually a fairly serious issue. One of the nice things about X-Sharp’s polygon orientation is that, until now, the only display dependent part of X-Sharp has been the transformation from RGB color space to the adapter’s color space. Compensation for aspect ratio, resolution, and the like all happens automatically in the course of projection. Still, we need the ability to display detailed surfaces, and it’s hard to conceive of a fast way to do so that’s totally hardware independent. (If you know of one, let me know care of the publisher.)</p>
<p>For now, all we need is fast texture mapping of adequate quality, which the straightforward, non-antialiased DDA approach supplies. I’m sure there are many other fast approaches, and, as I’ve said, there are more accurate approaches, but DDA texture mapping works well, given the constraints of the PC’s horsepower. Next, we’ll look at code that performs DDA texture mapping. First, though, I’d like to take a moment to thank Jim Kent, author of Autodesk Animator and a frequent correspondent, for getting me started with the DDA approach.</p>
</section>
</section>
<section id="fast-texture-mapping-an-implementation" class="level3">
<h3><a href="#fast-texture-mapping-an-implementation">Fast Texture Mapping: An Implementation</a></h3>
<p>As you might expect, I’ve implemented DDA texture mapping in X-Sharp, and the changes are reflected in the X-Sharp archive in this chapter’s subdirectory on the listings disk. Listing 56.1 shows the new header file entries, and Listing 56.2 shows the actual texture-mapped polygon drawer. The set-pixel routine that Listing 56.2 calls is a slight modification of the Mode X set-pixel routine from Chapter 47. In addition, INITBALL.C has been modified to create three texture-mapped polygons and define the texture bitmaps, and modifications have been made to allow the user to flip the axis of rotation. You will of course need the complete X-Sharp library to see texture mapping in action, but Listings 56.1 and 56.2 are the actual texture mapping code in its entirety.</p>
<blockquote>
<p><img src="images/i.jpg" /> Here’s a major tip: DDA texture mapping looks best on fast-moving surfaces, where the eye doesn’t have time to pick nits with the shearing and aliasing that’s an inevi table by-product of such a crude approach. Compile DEMO1 from the X-Sharp archive in this chapter’s subdirectory of the listings disk, and run it. The initial display looks okay, but certainly not great, because the rotational speed is so slow. Now press the S key a few times to speed up the rotation and flip between different rotation axes. I think you’ll be amazed at how much better DDA texture mapping looks at high speed. This technique would be great for mapping textures onto hurtling asteroids or jets, but would come up short for slow, finely detailed movements.</p>
</blockquote>
<p><strong>LISTING 56.1 L56-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* New header file entries related to texture-mapped polygons */</span>

<span class="co">/* Draws the polygon described by the point list PointList with a bitmap</span>
<span class="co">   texture mapped onto it */</span>
<span class="ot">#define DRAW_TEXTURED_POLYGON(PointList,NumPoints,TexVerts,TexMap) \</span>
   Polygon.Length = NumPoints; Polygon.PointPtr = PointList;       \
   DrawTexturedPolygon(&amp;Polygon, TexVerts, TexMap);
<span class="ot">#define FIXED_TO_INT(FixedVal) ((int) (FixedVal &gt;&gt; 16))</span>
<span class="ot">#define ROUND_FIXED_TO_INT(FixedVal) \</span>
   ((<span class="dt">int</span>) ((FixedVal + DOUBLE_TO_FIXED(<span class="fl">0.5</span>)) &gt;&gt; <span class="dv">16</span>))
<span class="co">/* Retrieves specified pixel from specified image bitmap of specified width. */</span>
<span class="ot">#define GET_IMAGE_PIXEL(TexMapBits, TexMapWidth, X, Y) \</span>
   TexMapBits[(Y * TexMapWidth) + X]
<span class="co">/* Masks to mark shading types in Face structure */</span>
<span class="ot">#define NO_SHADING      0x0000</span>
<span class="ot">#define AMBIENT_SHADING 0x0001</span>
<span class="ot">#define DIFFUSE_SHADING 0x0002</span>
<span class="ot">#define TEXTURE_MAPPED_SHADING 0x0004</span>
<span class="co">/* Describes a texture map */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
   <span class="dt">int</span> TexMapWidth;  <span class="co">/* texture map width in bytes */</span>
   <span class="dt">char</span> *TexMapBits; <span class="co">/* pointer to texture bitmap */</span>
} TextureMap;

<span class="co">/* Structure describing one face of an object (one polygon) */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
   <span class="dt">int</span> * VertNums;   <span class="co">/* pointer to list of indexes of this polygon&#39;s vertices</span>
<span class="co">                        in the object&#39;s vertex list. The first two indexes</span>
<span class="co">                        must select end and start points, respectively, of this</span>
<span class="co">                        polygon&#39;s unit normal vector. Second point should also</span>
<span class="co">                        be an active polygon vertex */</span>
   <span class="dt">int</span> NumVerts;     <span class="co">/* # of verts in face, not including the initial</span>
<span class="co">                        vertex, which must be the end of a unit normal vector</span>
<span class="co">                        that starts at the second index in VertNums */</span>
   <span class="dt">int</span> ColorIndex;   <span class="co">/* direct palette index; used only for non-shaded faces */</span>
   ModelColor FullColor; <span class="co">/* polygon&#39;s color */</span>
   <span class="dt">int</span> ShadingType;  <span class="co">/* none, ambient, diffuse, texture mapped, etc. */</span>
   TextureMap * TexMap; <span class="co">/* pointer to bitmap for texture mapping, if any */</span>
   Point * TexVerts; <span class="co">/* pointer to list of this polygon&#39;s vertices, in</span>
<span class="co">                        TextureMap coordinates. Index n must map to index</span>
<span class="co">                        n + 1 in VertNums, (the + 1 is to skip over the unit</span>
<span class="co">                        normal endpoint in VertNums) */</span>
} Face;
<span class="kw">extern</span> <span class="dt">void</span> DrawTexturedPolygon(PointListHeader *, Point *, TextureMap *);</code></pre>
<p><strong>LISTING 56.2 L56-2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Draws a bitmap, mapped to a convex polygon (draws a texture-mapped polygon).</span>
<span class="co">   &quot;Convex&quot; means that every horizontal line drawn through the polygon at any</span>
<span class="co">   point would cross exactly two active edges (neither horizontal lines nor </span>
<span class="co">   zero-length edges count as active edges; both are acceptable anywhere in </span>
<span class="co">   the polygon), and that the right &amp; left edges never cross. Nonconvex </span>
<span class="co">   polygons won&#39;t be drawn properly. Can&#39;t fail. */</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &quot;polygon.h&quot;</span>
<span class="co">/* Describes the current location and stepping, in both the source and</span>
<span class="co">   the destination, of an edge */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
   <span class="dt">int</span> Direction;         <span class="co">/* through edge list; 1 for a right edge (forward</span>
<span class="co">                             through vertex list), -1 for a left edge (backward</span>
<span class="co">                             through vertex list) */</span>
   <span class="dt">int</span> RemainingScans;    <span class="co">/* height left to scan out in dest */</span>
   <span class="dt">int</span> CurrentEnd;        <span class="co">/* vertex # of end of current edge */</span>
   Fixedpoint SourceX;    <span class="co">/* current X location in source for this edge */</span>
   Fixedpoint SourceY;    <span class="co">/* current Y location in source for this edge */</span>
   Fixedpoint SourceStepX;<span class="co">/* X step in source for Y step in dest of 1 */</span>
   Fixedpoint SourceStepY;<span class="co">/* Y step in source for Y step in dest of 1 */</span>
                          <span class="co">/* variables used for all-integer Bresenham&#39;s-type</span>
<span class="co">                             X stepping through the dest, needed for precise</span>
<span class="co">                             pixel placement to avoid gaps */</span>
   <span class="dt">int</span> DestX;             <span class="co">/* current X location in dest for this edge */</span>
   <span class="dt">int</span> DestXIntStep;      <span class="co">/* whole part of dest X step per scan-line Y step */</span>
   <span class="dt">int</span> DestXDirection;    <span class="co">/* -1 or 1 to indicate way X steps (left/right) */</span>
   <span class="dt">int</span> DestXErrTerm;      <span class="co">/* current error term for dest X stepping */</span>
   <span class="dt">int</span> DestXAdjUp;        <span class="co">/* amount to add to error term per scan line move */</span>
   <span class="dt">int</span> DestXAdjDown;      <span class="co">/* amount to subtract from error term when the</span>
<span class="co">                             error term turns over */</span>
} EdgeScan;
<span class="dt">int</span> StepEdge(EdgeScan *);
<span class="dt">int</span> SetUpEdge(EdgeScan *, <span class="dt">int</span>);
<span class="dt">void</span> ScanOutLine(EdgeScan *, EdgeScan *);
<span class="dt">int</span> GetImagePixel(<span class="dt">char</span> *, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>);
<span class="co">/* Statics to save time that would otherwise pass them to subroutines. */</span>
<span class="dt">static</span> <span class="dt">int</span> MaxVert, NumVerts, DestY;
<span class="dt">static</span> Point * VertexPtr;
<span class="dt">static</span> Point * TexVertsPtr;
<span class="dt">static</span> <span class="dt">char</span> * TexMapBits;
<span class="dt">static</span> <span class="dt">int</span> TexMapWidth;
<span class="co">/* Draws a texture-mapped polygon, given a list of destination polygon</span>
<span class="co">   vertices, a list of corresponding source texture polygon vertices, and a</span>
<span class="co">   pointer to the source texture&#39;s descriptor. */</span>
<span class="dt">void</span> DrawTexturedPolygon(PointListHeader * Polygon, Point * TexVerts,
   TextureMap * TexMap)
{
   <span class="dt">int</span> MinY, MaxY, MinVert, i;
   EdgeScan LeftEdge, RightEdge;
   NumVerts = Polygon-&gt;Length;
   VertexPtr = Polygon-&gt;PointPtr;
   TexVertsPtr = TexVerts;
   TexMapBits = TexMap-&gt;TexMapBits;
   TexMapWidth = TexMap-&gt;TexMapWidth;
   <span class="co">/* Nothing to draw if less than 3 vertices */</span>
   <span class="kw">if</span> (NumVerts &lt; <span class="dv">3</span>) {
      <span class="kw">return</span>;
   }
   <span class="co">/* Scan through the destination polygon vertices and find the top of the</span>
<span class="co">      left and right edges, taking advantage of our knowledge that vertices run</span>
<span class="co">      in a clockwise direction (else this polygon wouldn&#39;t be visible due to </span>
<span class="co">      backface removal) */</span>
   MinY = <span class="dv">32767</span>;
   MaxY = -<span class="dv">32768</span>;
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;NumVerts; i++) {
      <span class="kw">if</span> (VertexPtr[i].Y &lt; MinY) {
         MinY = VertexPtr[i].Y;
         MinVert = i;
      }
      <span class="kw">if</span> (VertexPtr[i].Y &gt; MaxY) {
         MaxY = VertexPtr[i].Y;
         MaxVert = i;
      }
   }
   <span class="co">/* Reject flat (0-pixel-high) polygons */</span>
   <span class="kw">if</span> (MinY &gt;= MaxY) {
      <span class="kw">return</span>;
   }
   <span class="co">/* The destination Y coordinate is not edge specific; it applies to</span>
<span class="co">      both edges, since we always step Y by 1 */</span>
   DestY = MinY;
   <span class="co">/* Set up to scan the initial left and right edges of the source and</span>
<span class="co">      destination polygons. We always step the destination polygon edges</span>
<span class="co">      by one in Y, so calculate the corresponding destination X step for</span>
<span class="co">      each edge, and then the corresponding source image X and Y steps */</span>
   LeftEdge.Direction = -<span class="dv">1</span>;   <span class="co">/* set up left edge first */</span>
   SetUpEdge(&amp;LeftEdge, MinVert);
   RightEdge.Direction = <span class="dv">1</span>;   <span class="co">/* set up right edge */</span>
   SetUpEdge(&amp;RightEdge, MinVert);
   <span class="co">/* Step down destination edges one scan line at a time. At each scan</span>
<span class="co">      line, find the corresponding edge points in the source image. Scan</span>
<span class="co">      between the edge points in the source, drawing the corresponding</span>
<span class="co">      pixels across the current scan line in the destination polygon. (We</span>
<span class="co">      know which way the left and right edges run through the vertex list</span>
<span class="co">      because visible (non-backface-culled) polygons always have the vertices</span>
<span class="co">      in clockwise order as seen from the viewpoint) */</span>
   <span class="kw">for</span> (;;) {
      <span class="co">/* Done if off bottom of clip rectangle */</span>
      <span class="kw">if</span> (DestY &gt;= ClipMaxY) {
         <span class="kw">return</span>;
      }
      <span class="co">/* Draw only if inside Y bounds of clip rectangle */</span>
      <span class="kw">if</span> (DestY &gt;= ClipMinY) {
         <span class="co">/* Draw the scan line between the two current edges */</span>
         ScanOutLine(&amp;LeftEdge, &amp;RightEdge);
      }
      <span class="co">/* Advance the source and destination polygon edges, ending if we&#39;ve</span>
<span class="co">         scanned all the way to the bottom of the polygon */</span>
      <span class="kw">if</span> (!StepEdge(&amp;LeftEdge)) {
         <span class="kw">break</span>;
      }
      <span class="kw">if</span> (!StepEdge(&amp;RightEdge)) {
         <span class="kw">break</span>;
      }
      DestY++;
   }
}
<span class="co">/* Steps an edge one scan line in the destination, and the corresponding</span>
<span class="co">   distance in the source. If an edge runs out, starts a new edge if there</span>
<span class="co">   is one. Returns 1 for success, or 0 if there are no more edges to scan. */</span>
<span class="dt">int</span> StepEdge(EdgeScan * Edge)
{
   <span class="co">/* Count off the scan line we stepped last time; if this edge is</span>
<span class="co">      finished, try to start another one */</span>
   <span class="kw">if</span> (--Edge-&gt;RemainingScans == <span class="dv">0</span>) {
      <span class="co">/* Set up the next edge; done if there is no next edge */</span>
      <span class="kw">if</span> (SetUpEdge(Edge, Edge-&gt;CurrentEnd) == <span class="dv">0</span>) {
         <span class="kw">return</span>(<span class="dv">0</span>);  <span class="co">/* no more edges; done drawing polygon */</span>
      }
      <span class="kw">return</span>(<span class="dv">1</span>);     <span class="co">/* all set to draw the new edge */</span>
   }
   <span class="co">/* Step the current source edge */</span>
   Edge-&gt;SourceX += Edge-&gt;SourceStepX;
   Edge-&gt;SourceY += Edge-&gt;SourceStepY;
   <span class="co">/* Step dest X with Bresenham-style variables, to get precise dest pixel</span>
<span class="co">      placement and avoid gaps */</span>
   Edge-&gt;DestX += Edge-&gt;DestXIntStep;  <span class="co">/* whole pixel step */</span>
   <span class="co">/* Do error term stuff for fractional pixel X step handling */</span>
   <span class="kw">if</span> ((Edge-&gt;DestXErrTerm += Edge-&gt;DestXAdjUp) &gt; <span class="dv">0</span>) {
      Edge-&gt;DestX += Edge-&gt;DestXDirection;
      Edge-&gt;DestXErrTerm -= Edge-&gt;DestXAdjDown;
   }
   <span class="kw">return</span>(<span class="dv">1</span>);
}
<span class="co">/* Sets up an edge to be scanned; the edge starts at StartVert and proceeds</span>
<span class="co">   in direction Edge-&gt;Direction through the vertex list. Edge-&gt;Direction must</span>
<span class="co">   be set prior to call; -1 to scan a left edge (backward through the vertex</span>
<span class="co">   list), 1 to scan a right edge (forward through the vertex list).</span>
<span class="co">   Automatically skips over 0-height edges. Returns 1 for success, or 0 if</span>
<span class="co">   there are no more edges to scan. */</span>
<span class="dt">int</span> SetUpEdge(EdgeScan * Edge, <span class="dt">int</span> StartVert)
{
   <span class="dt">int</span> NextVert, DestXWidth;
   Fixedpoint DestYHeight;
   <span class="kw">for</span> (;;) {
      <span class="co">/* Done if this edge starts at the bottom vertex */</span>
      <span class="kw">if</span> (StartVert == MaxVert) {
         <span class="kw">return</span>(<span class="dv">0</span>);
      }
      <span class="co">/* Advance to the next vertex, wrapping if we run off the start or end</span>
<span class="co">         of the vertex list */</span>
      NextVert = StartVert + Edge-&gt;Direction;
      <span class="kw">if</span> (NextVert &gt;= NumVerts) {
         NextVert = <span class="dv">0</span>;
      } <span class="kw">else</span> <span class="kw">if</span> (NextVert &lt; <span class="dv">0</span>) {
         NextVert = NumVerts - <span class="dv">1</span>;
      }
      <span class="co">/* Calculate the variables for this edge and done if this is not a</span>
<span class="co">         zero-height edge */</span>
      <span class="kw">if</span> ((Edge-&gt;RemainingScans =
            VertexPtr[NextVert].Y - VertexPtr[StartVert].Y) != <span class="dv">0</span>) {
         DestYHeight = INT_TO_FIXED(Edge-&gt;RemainingScans);
         Edge-&gt;CurrentEnd = NextVert;
         Edge-&gt;SourceX = INT_TO_FIXED(TexVertsPtr[StartVert].X);
         Edge-&gt;SourceY = INT_TO_FIXED(TexVertsPtr[StartVert].Y);
         Edge-&gt;SourceStepX = FixedDiv(INT_TO_FIXED(TexVertsPtr[NextVert].X) -
               Edge-&gt;SourceX, DestYHeight);
         Edge-&gt;SourceStepY = FixedDiv(INT_TO_FIXED(TexVertsPtr[NextVert].Y) -
               Edge-&gt;SourceY, DestYHeight);
         <span class="co">/* Set up Bresenham-style variables for dest X stepping */</span>
         Edge-&gt;DestX = VertexPtr[StartVert].X;
         <span class="kw">if</span> ((DestXWidth =
               (VertexPtr[NextVert].X - VertexPtr[StartVert].X)) &lt; <span class="dv">0</span>) {
            <span class="co">/* Set up for drawing right to left */</span>
            Edge-&gt;DestXDirection = -<span class="dv">1</span>;
            DestXWidth = -DestXWidth;
            Edge-&gt;DestXErrTerm = <span class="dv">1</span> - Edge-&gt;RemainingScans;
            Edge-&gt;DestXIntStep = -(DestXWidth / Edge-&gt;RemainingScans);
         } <span class="kw">else</span> {
            <span class="co">/* Set up for drawing left to right */</span>
            Edge-&gt;DestXDirection = <span class="dv">1</span>;
            Edge-&gt;DestXErrTerm = <span class="dv">0</span>;
            Edge-&gt;DestXIntStep = DestXWidth / Edge-&gt;RemainingScans;
         }
         Edge-&gt;DestXAdjUp = DestXWidth % Edge-&gt;RemainingScans;
         Edge-&gt;DestXAdjDown = Edge-&gt;RemainingScans;
         <span class="kw">return</span>(<span class="dv">1</span>);  <span class="co">/* success */</span>
      }
      StartVert = NextVert;   <span class="co">/* keep looking for a non-0-height edge */</span>
   }
}
<span class="co">/* Texture-map-draw the scan line between two edges. */</span>
<span class="dt">void</span> ScanOutLine(EdgeScan * LeftEdge, EdgeScan * RightEdge)
{
   Fixedpoint SourceX = LeftEdge-&gt;SourceX;
   Fixedpoint SourceY = LeftEdge-&gt;SourceY;
   <span class="dt">int</span> DestX = LeftEdge-&gt;DestX;
   <span class="dt">int</span> DestXMax = RightEdge-&gt;DestX;
   Fixedpoint DestWidth;
   Fixedpoint SourceXStep, SourceYStep;
   <span class="co">/* Nothing to do if fully X clipped */</span>
   <span class="kw">if</span> ((DestXMax &lt;= ClipMinX) || (DestX &gt;= ClipMaxX)) {
      <span class="kw">return</span>;
   }
   <span class="kw">if</span> ((DestXMax - DestX) &lt;= <span class="dv">0</span>) {
      <span class="kw">return</span>;  <span class="co">/* nothing to draw */</span>
   }
   <span class="co">/* Width of destination scan line, for scaling. Note: because this is an</span>
<span class="co">      integer-based scaling, it can have a total error of as much as nearly</span>
<span class="co">      one pixel. For more precise scaling, also maintain a fixed-point DestX</span>
<span class="co">      in each edge, and use it for scaling. If this is done, it will also</span>
<span class="co">      be necessary to nudge the source start coordinates to the right by an</span>
<span class="co">      amount corresponding to the distance from the the real (fixed-point)</span>
<span class="co">      DestX and the first pixel (at an integer X) to be drawn) */</span>
   DestWidth = INT_TO_FIXED(DestXMax - DestX);
   <span class="co">/* Calculate source steps that correspond to each dest X step (across</span>
<span class="co">      the scan line) */</span>
   SourceXStep = FixedDiv(RightEdge-&gt;SourceX - SourceX, DestWidth);
   SourceYStep = FixedDiv(RightEdge-&gt;SourceY - SourceY, DestWidth);
   <span class="co">/* Clip right edge if necessary */</span>
   <span class="kw">if</span> (DestXMax &gt; ClipMaxX) {
      DestXMax = ClipMaxX;
   }
   <span class="co">/* Clip left edge if necssary */</span>
   <span class="kw">if</span> (DestX &lt; ClipMinX) {
      SourceX += SourceXStep * (ClipMinX - DestX);
      SourceY += SourceYStep * (ClipMinX - DestX);
      DestX = ClipMinX;
   }
   <span class="co">/* Scan across the destination scan line, updating the source image</span>
<span class="co">      position accordingly */</span>
   <span class="kw">for</span> (; DestX&lt;DestXMax; DestX++) {
      <span class="co">/* Get currently mapped pixel out of image and draw it to screen */</span>
      WritePixelX(DestX, DestY,
            GET_IMAGE_PIXEL(TexMapBits, TexMapWidth,
            FIXED_TO_INT(SourceX), FIXED_TO_INT(SourceY)) );
      <span class="co">/* Point to the next source pixel */</span>
      SourceX += SourceXStep;
      SourceY += SourceYStep;
   }
}</code></pre>
<p>No matter how you slice it, DDA texture mapping beats boring, single-color polygons nine ways to Sunday. The big downside is that it’s much slower than a normal polygon fill; move the ball close to the screen in DEMO1, and watch things slow down when one of those big texture maps comes around. Of course, that’s partly because the code is all in C; some well-chosen optimizations would work wonders. In the next chapter we’ll discuss texture mapping further, crank up the speed of our texture mapper, and attend to some rough spots that remain in the DDA texture mapping implementation, most notably in the area of exactly which texture pixels map to which destination pixels as a polygon rotates.</p>
<p>And, in case you’re curious, yes, there is a bear in DEMO1. I wouldn’t say he looks much like a Pooh-type bear, but he’s a bear nonetheless. He does tend to look a little startled when you flip the ball around so that he’s zipping by on his head, but, heck, you would too in the same situation. And remember, when you buy the next VGA megahit, <em>Bears in Space</em>, you saw it here first.</p>
</section>
</section>
<section id="chapter-57-10000-freshly-sheared-sheep-on-the-screen" class="level2">
<h2><a href="#chapter-57-10000-freshly-sheared-sheep-on-the-screen">Chapter 57 – 10,000 Freshly Sheared Sheep on the Screen</a></h2>
<section id="the-critical-role-of-experience-in-implementing-fast-smooth-texture-mapping" class="level3">
<h3><a href="#the-critical-role-of-experience-in-implementing-fast-smooth-texture-mapping">The Critical Role of Experience in Implementing Fast, Smooth Texture Mapping</a></h3>
<p>I recently spent an hour or so learning how to shear a sheep. Among other things, I learned—in great detail—about the importance of selecting the proper comb for your shears, heard about the man who holds the world’s record for sheep sheared in a day (more than 600, if memory serves), and discovered, Lord help me, the many and varied ways in which the New Zealand Sheep Shearing Board improves the approved sheep-shearing method every year. The fellow giving the presentation did his best, but let’s face it, sheep just aren’t very interesting. If you have children, you’ll know why I was there; if you don’t, there’s no use explaining.</p>
<p>The chap doing the shearing did say one thing that stuck with me, although it may not sound particularly profound. (Actually, it sounds pretty silly, but bear with me.) He said, “You don’t get really good at sheep shearing for 10 years, or 10,000 sheep.” I’ll buy that. In fact, to extend that morsel of wisdom to the greater, non-ovine-centric universe, it actually takes a good chunk of experience before you get good at anything worthwhile—especially graphics, for a couple of reasons. First, performance matters a lot in graphics, and performance programming is largely a matter of experience. You can’t speed up PC graphics simply by looking in a book for a better algorithm; you have to understand the code C compilers generate, assembly language optimization, VGA hardware, and the performance implications of various graphics-programming approaches and algorithms. Second, computer graphics is a matter of illusion, of convincing the eye to see what you want it to see, and that’s very much a black art based on experience.</p>
<section id="visual-quality-a-black-hole-er-art" class="level4">
<h4><a href="#visual-quality-a-black-hole-er-art">Visual Quality: A Black Hole … Er, Art</a></h4>
<p>Pleasing the eye with realtime computer animation is something less than a science, at least at the PC level, where there’s a limited color palette and no time for antialiasing; in fact, sometimes it can be more than a little frustrating. As you may recall, in the previous chapter I implemented texture mapping in X-Sharp. There was plenty of experience involved there, some of which I didn’t mention. My first implementation was disappointing; the texture maps shimmied and sheared badly, like a loosely affiliated flock of pixels, each marching to its own drummer. Then, I added a control key to speed up the rotation; what a difference! The aliasing problems were still there, but with the faster rotation, the pixels moved too quickly for the eye to pick up on the aliasing; the rotating texture maps, and the rotating ball as a whole, crossed the threshold into being accepted by the eye as a viewed object, rather than simply a collection of pixels.</p>
<p>The obvious lesson here is that adequate speed is important to convincing animation. There’s another, less obvious side to this lesson, though. I’d been running the texture-mapping demo on a 20 MHz 386 with a slow VGA when I discovered the beneficial effects of greater animation speed. When, some time later, I ran the demo on a 33 MHz 486 with a fast VGA, I found that the faster rotation was too fast! The ball spun so rapidly that the eye couldn’t blend successive images together into continuous motion, much like watching a badly flickering movie.</p>
<blockquote>
<p><img src="images/i.jpg" /> So the second lesson is that either too little or too much speed can destroy the illusion. Unless you’re antialiasing, you need to tune the shifting of your images so that they’re in the “sweet spot” of apparent motion, in which the eye is willing to ignore the jumping and aliasing, and blend the images together into continuous motion. Only experience can give you a feel for that sweet spot.</p>
</blockquote>
</section>
<section id="fixed-point-arithmetic-redux" class="level4">
<h4><a href="#fixed-point-arithmetic-redux">Fixed-Point Arithmetic, Redux</a></h4>
<p>In the previous chapter I added texture mapping to X-Sharp, but lacked space to explain some of its finer points. I’ll pick up the thread now and cover some of those points here, and discuss the visual and performance enhancements that previous chapter’s code needed—and which are now present in the version of X-Sharp in this chapter’s subdirectory on the CD-ROM.</p>
<p>Back in Chapter 38, I spent a good bit of time explaining exactly which pixels were inside a polygon and which were outside, and how to draw those pixels accordingly. This was important, I said, because only with a precise, consistent way of defining inside and outside would it be possible to draw adjacent polygons without either overlap or gaps between them.</p>
<p>As a corollary, I added that only an all-integer, edge-stepping approach would do for polygon filling. Fixed-point arithmetic, although alluring for speed and ease of use, would be unacceptable because round-off error would result in imprecise pixel placement.</p>
<p>More than a year then passed between the time I wrote that statement and the time I implemented X-Sharp’s texture mapper, during which time my long-term memory apparently suffered at least partial failure. When I went to implement texture mapping for the previous chapter, I decided that since transformed destination vertices can fall at fractional pixel locations, the cleanest way to do the texture mapping would be to use fixed-point coordinates for both the source texture and the destination screen polygon. That way, there would be a minimum of distortion as the polygon rotated and moved. Theoretically, that made sense; but there was one small problem: gaps between polygons.</p>
<p>Yes, folks, I had ignored the voice of experience (my own voice, at that) at my own peril. You can be assured I will not forget this particular lesson again: Fixed-point arithmetic is not precise. That’s not to say that it’s impossible to use fixed-point for drawing polygons; if all adjacent edges share common start and end vertices and common edges are always stepped in the same direction, all polygons should share the same fixed-point imprecision, and edges should fit properly (although polygons may not include exactly the right pixels). What you absolutely cannot do is mix fixed-point and all-integer polygon-filling approaches when drawing, as shown in Figure 57.1. Consequently, I ended up using an all-integer approach in X-Sharp for stepping through the destination polygon. However, I kept the fixed-point approach, which is faster and much simpler, for stepping through the source.</p>
<p>Why was it all right to mix approaches in this case? Precise pixel placement only matters when drawing; otherwise, we can get gaps, which are very visible. When selecting a pixel to copy from the source texture, however, the worst that happens is that we pick the source pixel next to the one we really want, causing the mapped texture to appear to have shifted by one pixel at the corresponding destination pixel; given all the aliasing and shearing already going on in the texture-mapping process, a one-pixel mapping error is insignificant.</p>
<p>Experience again: It’s the difference between knowing which flaws (like small texture shifts) can reasonably be ignored, and which (like those that produce gaps between polygons) must be avoided at all costs.</p>
</section>
<section id="texture-mapping-orientation-independence" class="level4">
<h4><a href="#texture-mapping-orientation-independence">Texture Mapping: Orientation Independence</a></h4>
<p>The double-DDA texture-mapping code presented in the previous chapter worked adequately, but there were two things about it that left me less than satisfied. One flaw was performance; I’ll address that shortly. The other flaw was the way textures shifted noticeably as the orientations of the polygons onto which they were mapped changed.</p>
<p>The previous chapter’s code followed the standard polygon inside/outside rule for determining which pixels in the source texture map were to be mapped: Pixels that mapped exactly to the left and top destination edges were considered to be inside, and pixels that mapped exactly to the right and bottom destination edges were considered to be outside. That’s fine for filling polygons, but when copying texture maps, it causes different edges of the texture map to be omitted, depending on the destination orientation, because different edges of the texture map correspond to the right and bottom destination edges, depending on the current rotation. Also, the previous chapter’s code truncated to get integer source coordinates. This, together with the orientation problem, meant that when a texture turned upside down, it slowed one new row and one new column of pixels from the next row and column of the texture map. This asymmetry was quite visible, and not at all the desired effect.</p>
<figure>
<img src="images/57-01.jpg" alt="Figure 57.1  Gaps caused by mixing fixed-point and all-integer math." /><figcaption><strong>Figure 57.1</strong>  <em>Gaps caused by mixing fixed-point and all-integer math.</em></figcaption>
</figure>
<p>Listing 57.1 is one solution to these problems. This code, which replaces the equivalently named function presented in the previous chapter (and, of course, is present in the X-Sharp archive in this chapter’s subdirectory of the listings disk), makes no attempt to follow the standard polygon inside/outside rules when mapping the source. Instead, it advances a half-step into the texture map before drawing the first pixel, so pixels along all edges are half included. Rounding rather than truncation to texture-map coordinates is also performed. The result is that the texture map stays pretty much centered within the destination polygon as the destination rotates, with a much-reduced level of orientation-dependent asymmetry.</p>
<p><strong>LISTING 57.1 L57-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Texture-map-draw the scan line between two edges. Uses approach of</span>
<span class="co">   pre-stepping 1/2 pixel into the source image and rounding to the nearest</span>
<span class="co">   source pixel at each step, so that texture maps will appear</span>
<span class="co">   reasonably similar at all angles. */</span>

<span class="dt">void</span> ScanOutLine(EdgeScan * LeftEdge, EdgeScan * RightEdge)
{
   Fixedpoint SourceX;
   Fixedpoint SourceY;
   <span class="dt">int</span> DestX = LeftEdge-&gt;DestX;
   <span class="dt">int</span> DestXMax = RightEdge-&gt;DestX;
   Fixedpoint DestWidth;
   Fixedpoint SourceStepX, SourceStepY;

   <span class="co">/* Nothing to do if fully X clipped */</span>
   <span class="kw">if</span> ((DestXMax &lt;= ClipMinX) || (DestX &gt;= ClipMaxX)) {
      <span class="kw">return</span>;
   }

   <span class="kw">if</span> ((DestXMax - DestX) &lt;= <span class="dv">0</span>) {
      <span class="kw">return</span>;  <span class="co">/* nothing to draw */</span>
   }
   SourceX = LeftEdge-&gt;SourceX;
   SourceY = LeftEdge-&gt;SourceY;

   <span class="co">/* Width of destination scan line, for scaling. Note: because this is an</span>
<span class="co">      integer-based scaling, it can have a total error of as much as nearly</span>
<span class="co">      one pixel. For more precise scaling, also maintain a fixed-point DestX</span>
<span class="co">      in each edge, and use it for scaling. If this is done, it will also</span>
<span class="co">      be necessary to nudge the source start coordinates to the right by an</span>
<span class="co">      amount corresponding to the distance from the the real (fixed-point)</span>
<span class="co">      DestX and the first pixel (at an integer X) to be drawn). */</span>
   DestWidth = INT-TO-FIXED(DestXMax - DestX);

   <span class="co">/* Calculate source steps that correspond to each dest X step (across</span>
<span class="co">      the scan line) */</span>
   SourceStepX = FixedDiv(RightEdge-&gt;SourceX - SourceX, DestWidth);
   SourceStepY = FixedDiv(RightEdge-&gt;SourceY - SourceY, DestWidth);

   <span class="co">/* Advance 1/2 step in the stepping direction, to space scanned pixels</span>
<span class="co">      evenly between the left and right edges. (There&#39;s a slight inaccuracy</span>
<span class="co">      in dividing negative numbers by 2 by shifting rather than dividing,</span>
<span class="co">      but the inaccuracy is in the least significant bit, and we&#39;ll just</span>
<span class="co">      live with it.) */</span>
   SourceX += SourceStepX &gt;&gt; <span class="dv">1</span>;
   SourceY += SourceStepY &gt;&gt; <span class="dv">1</span>;

   <span class="co">/* Clip right edge if necssary */</span>
   <span class="kw">if</span> (DestXMax &gt; ClipMaxX)
      DestXMax = ClipMaxX;

   <span class="co">/* Clip left edge if necssary */</span>
   <span class="kw">if</span> (DestX &lt; ClipMinX) {
      SourceX += FixedMul(SourceStepX, INT-TO-FIXED(ClipMinX - DestX));
      SourceY += FixedMul(SourceStepY, INT-TO-FIXED(ClipMinX - DestX));
      DestX = ClipMinX;
   }
   <span class="co">/* Scan across the destination scan line, updating the source image</span>
<span class="co">      position accordingly */</span>
   <span class="kw">for</span> (; DestX&lt;DestXMax; DestX++) {
      <span class="co">/* Get the currently mapped pixel out of the image and draw it to</span>
<span class="co">         the screen */</span>
      WritePixelX(DestX, DestY,
            GET-IMAGE-PIXEL(TexMapBits, TexMapWidth,
            ROUND-FIXED-TO-INT(SourceX), ROUND-FIXED-TO-INT(SourceY)) );
      <span class="co">/* Point to the next source pixel */</span>
      SourceX += SourceStepX;
      SourceY += SourceStepY;
   }
}</code></pre>
</section>
<section id="mapping-textures-across-multiple-polygons" class="level4">
<h4><a href="#mapping-textures-across-multiple-polygons">Mapping Textures across Multiple Polygons</a></h4>
<p>One of the truly nifty things about double-DDA texture mapping is that it is not limited to mapping a texture onto a single polygon. A single texture can be mapped across any number of adjacent polygons simply by having polygons that share vertices in 3-space also share vertices in the texture map. In fact, the demonstration program DEMO1 in the X-Sharp archive maps a single texture across two polygons; this is the blue-on-green pattern that stretches across two panels of the spinning ball. This capability makes it easy to produce polygon-based objects with complex surfaces (such as banding and insignia on spaceships, or even human figures). Just map the desired texture onto the underlying polygonal framework of an object, and let double-DDA texture mapping do the rest.</p>
</section>
<section id="fast-texture-mapping" class="level4">
<h4><a href="#fast-texture-mapping">Fast Texture Mapping</a></h4>
<p>Of course, there’s a problem with mapping a texture across many polygons: Texture mapping is slow. If you run DEMO1 and move the ball up close to the screen, you’ll see that the ball slows considerably whenever a texture swings around into view. To some extent that can’t be helped, because each pixel of a texture-mapped polygon has to be calculated and drawn independently. Nonetheless, we can certainly improve the performance of texture mapping a good deal over what I presented in the previous chapter.</p>
<p>By and large, there are two keys to improving PC graphics performance. The first—no surprise—is assembly language. The second, without which assembly language is far less effective, is understanding exactly where the cycles go in inner loops. In our case, that means understanding where the bottlenecks are in Listing 57.1.</p>
<p>Listing 57.2 is a high-performance assembly language implementation of Listing 57.1. Apart from the conversion to assembly language, this implementation improves performance by focusing on reducing inner loop bottlenecks. In fact, the whole of Listing 57.2 is nothing more than the inner loop for texture-mapped polygon drawing; Listing 57.2 is only the code to draw a single scan line. Most of the work in drawing a texture-mapped polygon comes in scanning out individual lines, though, so this is the appropriate place to optimize.</p>
<p><strong>LISTING 57.2 L57-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Draws all pixels in the specified scan line, with the pixel colors</span>
<span class="co">; taken from the specified texture map.  Uses approach of pre-stepping</span>
<span class="co">; 1/2 pixel into the source image and rounding to the nearest source</span>
<span class="co">; pixel at each step, so that texture maps will appear reasonably similar</span>
<span class="co">; at all angles.  This routine is specific to 320-pixel-wide planar</span>
<span class="co">; (non-chain4) 256-color modes, such as mode X, which is a planar</span>
<span class="co">; (non-chain4) 256-color mode with a resolution of 320x240.</span>
<span class="co">; C near-callable as: </span>
<span class="co">;   void ScanOutLine(EdgeScan * LeftEdge, EdgeScan * RightEdge);</span>
<span class="co">; Tested with TASM 3.0.</span>

SC-INDEX     <span class="dt">equ</span><span class="bn">    03c4h     </span><span class="co">;Sequence Controller Index</span>
MAP-MASK     <span class="dt">equ</span><span class="bn">    02h       </span><span class="co">;index in SC of Map Mask register</span>
SCREEN-<span class="kw">SEG</span>   <span class="dt">equ</span><span class="bn">    0a000h    </span><span class="co">;segment of display memory in mode X</span>
SCREEN-WIDTH <span class="dt">equ</span>    <span class="dv">80</span>        <span class="co">;width of screen in bytes from one scan line</span>
                              <span class="co">; to the next</span>

        .model  small
        .data
        extrn   -TexMapBits:<span class="dt">word</span>, -TexMapWidth:<span class="dt">word</span>, -DestY:<span class="dt">word</span>
        extrn   -CurrentPageBase:<span class="dt">word</span>, -ClipMinX:<span class="dt">word</span>
        extrn   -ClipMinY:<span class="dt">word</span>, -ClipMaxX:<span class="dt">word</span>, -ClipMaxY:<span class="dt">word</span>

<span class="co">; Describes the current location and stepping, in both the source and</span>
<span class="co">; the destination, of an edge. Mirrors structure in DRAWTEXP.C.</span>
EdgeScan <span class="kw">struc</span>
Direction      <span class="dt">dw</span>    ?        <span class="co">;through edge list; 1 for a right edge (forward</span>
                              <span class="co">; through vertex list), -1 for a left edge (backward</span>
                              <span class="co">; through vertex list)</span>
RemainingScans <span class="dt">dw</span>    ?        <span class="co">;height left to scan out in dest</span>
CurrentEnd     <span class="dt">dw</span>    ?        <span class="co">;vertex # of end of current edge</span>
SourceX        <span class="dt">dd</span>    ?        <span class="co">;X location in source for this edge</span>
SourceY        <span class="dt">dd</span>    ?        <span class="co">;Y location in source for this edge</span>
SourceStepX    <span class="dt">dd</span>    ?        <span class="co">;X step in source for Y step in dest of 1</span>
SourceStepY    <span class="dt">dd</span>    ?        <span class="co">;Y step in source for Y step in dest of 1</span>
                              <span class="co">;variables used for all-integer Bresenham&#39;s-type</span>
                              <span class="co">; X stepping through the dest, needed for precise</span>
                              <span class="co">; pixel placement to avoid gaps</span>
DestX          <span class="dt">dw</span>    ?        <span class="co">;current X location in dest for this edge</span>
DestXIntStep   <span class="dt">dw</span>    ?        <span class="co">;whole part of dest X step per scan-line Y step</span>
DestXDirection <span class="dt">dw</span>    ?        <span class="co">;-1 or 1 to indicate which way X steps (left/right)</span>
DestXErrTerm   <span class="dt">dw</span>    ?        <span class="co">;current error term for dest X stepping</span>
DestXAdjUp     <span class="dt">dw</span>    ?        <span class="co">;amount to add to error term per scan line move</span>
DestXAdjDown   <span class="dt">dw</span>    ?        <span class="co">;amount to subtract from error term when the</span>
                              <span class="co">; error term turns over</span>
EdgeScan ends

Parms   <span class="kw">struc</span>
               <span class="dt">dw</span>    <span class="dv">2</span> dup(?) <span class="co">;return address &amp; pushed BP</span>
LeftEdge       <span class="dt">dw</span>    ?        <span class="co">;pointer to EdgeScan structure for left edge</span>
RightEdge      <span class="dt">dw</span>    ?        <span class="co">;pointer to EdgeScan structure for right edge</span>
Parms   ends

<span class="co">;Offsets from BP in stack frame of local variables.</span>
lSourceX       <span class="dt">equ</span>   -<span class="dv">4</span>       <span class="co">;current X coordinate in source image</span>
lSourceY       <span class="dt">equ</span>   -<span class="dv">8</span>       <span class="co">;current Y coordinate in source image</span>
lSourceStepX   <span class="dt">equ</span>   -<span class="dv">12</span>      <span class="co">;X step in source image for X dest step of 1</span>
lSourceStepY   <span class="dt">equ</span>   -<span class="dv">16</span>      <span class="co">;Y step in source image for X dest step of 1</span>
lXAdvanceByOne <span class="dt">equ</span>   -<span class="dv">18</span>      <span class="co">;used to step source pointer 1 pixel</span>
                              <span class="co">; incrementally in X</span>
lXBaseAdvance  <span class="dt">equ</span>   -<span class="dv">20</span>      <span class="co">;use to step source pointer minimum number of</span>
                              <span class="co">; pixels incrementally in X</span>
lYAdvanceByOne <span class="dt">equ</span>   -<span class="dv">22</span>      <span class="co">;used to step source pointer 1 pixel</span>
                              <span class="co">; incrementally in Y</span>
lYBaseAdvance  <span class="dt">equ</span>   -<span class="dv">24</span>      <span class="co">;use to step source pointer minimum number of</span>
                              <span class="co">; pixels incrementally in Y</span>
LOCAL-SIZE     <span class="dt">equ</span>    <span class="dv">24</span>      <span class="co">;total size of local variables</span>
        .code
        extrn   -FixedMul:near, -FixedDiv:near
        <span class="kw">align</span>   <span class="dv">2</span>
<span class="fu">ToScanDone:</span>
        <span class="kw">jmp</span>     ScanDone
        public  -ScanOutLine
        <span class="kw">align</span>   <span class="dv">2</span>
-ScanOutLine    proc    near
        <span class="kw">push</span>    <span class="kw">bp</span>              <span class="co">;preserve caller&#39;s stack frame</span>
        <span class="kw">mov</span>     <span class="kw">bp</span>,<span class="kw">sp</span>           <span class="co">;point to our stack frame</span>
        <span class="kw">sub</span>     <span class="kw">sp</span>,LOCAL-SIZE   <span class="co">;allocate space for local variables</span>
        <span class="kw">push</span>    <span class="kw">si</span>              <span class="co">;preserve caller&#39;s register variables</span>
        <span class="kw">push</span>    <span class="kw">di</span>
<span class="co">; Nothing to do if destination is fully X clipped.</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bp</span>].RightEdge
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">di</span>].DestX
        <span class="kw">cmp</span>     <span class="kw">si</span>,[-ClipMinX]
        <span class="kw">jle</span>     ToScanDone      <span class="co">;right edge is to left of clip rect, so done</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].LeftEdge
        <span class="kw">mov</span>     <span class="kw">dx</span>,[<span class="kw">bx</span>].DestX
        <span class="kw">cmp</span>     <span class="kw">dx</span>,[-ClipMaxX]
        <span class="kw">jge</span>     ToScanDone      <span class="co">;left edge is to right of clip rect, so done</span>
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">dx</span>           <span class="co">;destination fill width</span>
        <span class="kw">jle</span>     ToScanDone      <span class="co">;null or negative full width, so done</span>

        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bx</span>].SourceX        <span class="co">;initial source X coordinate</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bx</span>].SourceX<span class="dv">+2</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX<span class="dv">+2</span>,<span class="kw">ax</span>

        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bx</span>].SourceY        <span class="co">;initial source Y coordinate</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bx</span>].SourceY<span class="dv">+2</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY<span class="dv">+2</span>,<span class="kw">ax</span>
<span class="co">; Calculate source steps that correspond to each 1-pixel destination X step</span>
<span class="co">; (across the destination scan line).</span>
        <span class="kw">push</span>    <span class="kw">si</span>              <span class="co">;push dest X width, in fixedpoint form</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>
        <span class="kw">push</span>    <span class="kw">ax</span>              <span class="co">;push 0 as fractional part of dest X width</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>].SourceX
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX       <span class="co">;low word of source X width</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>].SourceX<span class="dv">+2</span>
        <span class="kw">sbb</span>     <span class="kw">dx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX<span class="dv">+2</span>     <span class="co">;high word of source X width</span>
        <span class="kw">push</span>    <span class="kw">dx</span>              <span class="co">;push source X width, in fixedpoint form</span>
        <span class="kw">push</span>    <span class="kw">ax</span>
        <span class="kw">call</span>    -FixedDiv       <span class="co">;scale source X width to dest X width</span>
        <span class="kw">add</span>     <span class="kw">sp</span>,<span class="dv">8</span>            <span class="co">;clear parameters from stack</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepX,<span class="kw">ax</span>   <span class="co">;remember source X step for</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepX<span class="dv">+2</span>,<span class="kw">dx</span> <span class="co">; 1-pixel destination X step</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dv">1</span>            <span class="co">;assume source X advances non-negative</span>
        <span class="kw">and</span>     <span class="kw">dx</span>,<span class="kw">dx</span>           <span class="co">;which way does source X advance?</span>
        <span class="kw">jns</span>     SourceXNonNeg   <span class="co">;non-negative</span>
        <span class="kw">neg</span>     <span class="kw">cx</span>              <span class="co">;negative</span>
        <span class="kw">cmp</span>     <span class="kw">ax</span>,<span class="dv">0</span>            <span class="co">;is the whole step exactly an integer?</span>
        <span class="kw">jz</span>      SourceXNonNeg   <span class="co">;yes</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>              <span class="co">;no, truncate to integer in the direction of</span>
                                <span class="co">; 0, because otherwise we&#39;ll end up with a</span>
                                <span class="co">; whole step of 1-too-large magnitude</span>
<span class="fu">SourceXNonNeg:</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>].lXAdvanceByOne,<span class="kw">cx</span>  <span class="co">;amount to add to source pointer to</span>
                                        <span class="co">; move by one in X</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>].lXBaseAdvance,<span class="kw">dx</span>   <span class="co">;minimum amount to add to source</span>
                                        <span class="co">; pointer to advance in X each time</span>
                                        <span class="co">; the dest advances one in X</span>
        <span class="kw">push</span>    <span class="kw">si</span>              <span class="co">;push dest Y height, in fixedpoint form</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>
        <span class="kw">push</span>    <span class="kw">ax</span>              <span class="co">;push 0 as fractional part of dest Y height</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>].SourceY
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY       <span class="co">;low word of source Y height</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">di</span>].SourceY<span class="dv">+2</span>
        <span class="kw">sbb</span>     <span class="kw">dx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY<span class="dv">+2</span>     <span class="co">;high word of source Y height</span>
        <span class="kw">push</span>    <span class="kw">dx</span>              <span class="co">;push source Y height, in fixedpoint form</span>
        <span class="kw">push</span>    <span class="kw">ax</span>
        <span class="kw">call</span>    -FixedDiv       <span class="co">;scale source Y height to dest X width</span>
        <span class="kw">add</span>     <span class="kw">sp</span>,<span class="dv">8</span>            <span class="co">;clear parameters from stack</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepY,<span class="kw">ax</span>   <span class="co">;remember source Y step for</span>
        <span class="kw">mov</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepY<span class="dv">+2</span>,<span class="kw">dx</span> <span class="co">; 1-pixel destination X step</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,[-TexMapWidth] <span class="co">;assume source Y advances non-negative</span>
        <span class="kw">and</span>     <span class="kw">dx</span>,<span class="kw">dx</span>           <span class="co">;which way does source Y advance?</span>
        <span class="kw">jns</span>     SourceYNonNeg   <span class="co">;non-negative</span>
        <span class="kw">neg</span>     <span class="kw">cx</span>              <span class="co">;negative</span>
        <span class="kw">cmp</span>     <span class="kw">ax</span>,<span class="dv">0</span>            <span class="co">;is the whole step exactly an integer?</span>
        <span class="kw">jz</span>      SourceYNonNeg   <span class="co">;yes</span>
        <span class="kw">inc</span>     <span class="kw">dx</span>              <span class="co">;no, truncate to integer in the direction of</span>
                                <span class="co">; 0, because otherwise we&#39;ll end up with a</span>
                                <span class="co">; whole step of 1-too-large magnitude</span>
<span class="fu">SourceYNonNeg:</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>].lYAdvanceByOne,<span class="kw">cx</span>  <span class="co">;amount to add to source pointer to</span>
                                        <span class="co">; move by one in Y</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,[-TexMapWidth]       <span class="co">;minimum distance skipped in source</span>
        <span class="kw">imul</span>    <span class="kw">dx</span>                      <span class="co">; image bitmap when Y steps (ignoring</span>
        <span class="kw">mov</span>     [<span class="kw">bp</span>].lYBaseAdvance,<span class="kw">ax</span>   <span class="co">; carry from the fractional part)</span>
<span class="co">; Advance 1/2 step in the stepping direction, to space scanned pixels evenly</span>
<span class="co">; between the left and right edges. (There&#39;s a slight inaccuracy in dividing</span>
<span class="co">; negative numbers by 2 by shifting rather than dividing, but the inaccuracy</span>
<span class="co">; is in the least significant bit, and we&#39;ll just live with it.)</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepX
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepX<span class="dv">+2</span>
        <span class="kw">sar</span>     <span class="kw">dx</span>,<span class="dv">1</span>
        <span class="kw">rcr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">add</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX,<span class="kw">ax</span>
        <span class="kw">adc</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX<span class="dv">+2</span>,<span class="kw">dx</span>

        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepY
        <span class="kw">mov</span>     <span class="kw">dx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepY<span class="dv">+2</span>
        <span class="kw">sar</span>     <span class="kw">dx</span>,<span class="dv">1</span>
        <span class="kw">rcr</span>     <span class="kw">ax</span>,<span class="dv">1</span>
        <span class="kw">add</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY,<span class="kw">ax</span>
        <span class="kw">adc</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY<span class="dv">+2</span>,<span class="kw">dx</span>
<span class="co">; Clip right edge if necessary.</span>
        <span class="kw">mov</span>     <span class="kw">si</span>,[<span class="kw">di</span>].DestX
        <span class="kw">cmp</span>     <span class="kw">si</span>,[-ClipMaxX]
        <span class="kw">jl</span>      RightEdgeClipped
        <span class="kw">mov</span>     <span class="kw">si</span>,[-ClipMaxX]
<span class="fu">RightEdgeClipped:</span>
<span class="co">; Clip left edge if necssary</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].LeftEdge
        <span class="kw">mov</span>     <span class="kw">di</span>,[<span class="kw">bx</span>].DestX
        <span class="kw">cmp</span>     <span class="kw">di</span>,[-ClipMinX]
        <span class="kw">jge</span>     LeftEdgeClipped
<span class="co">; Left clipping is necessary; advance the source accordingly</span>
        <span class="kw">neg</span>     <span class="kw">di</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[-ClipMinX]  <span class="co">;ClipMinX - DestX</span>
                                <span class="co">;first, advance the source in X</span>
        <span class="kw">push</span>    <span class="kw">di</span>              <span class="co">;push ClipMinX - DestX, in fixedpoint form</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>
        <span class="kw">push</span>    <span class="kw">ax</span>              <span class="co">;push 0 as fractional part of ClipMinX-DestX</span>
        <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepX<span class="dv">+2</span>
        <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepX
        <span class="kw">call</span>    -FixedMul       <span class="co">;total source X stepping in clipped area</span>
        <span class="kw">add</span>     <span class="kw">sp</span>,<span class="dv">8</span>            <span class="co">;clear parameters from stack</span>
        <span class="kw">add</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX,<span class="kw">ax</span><span class="co">;step the source X past clipping</span>
        <span class="kw">adc</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX<span class="dv">+2</span>,<span class="kw">dx</span>
                                <span class="co">;now advance the source in Y</span>
        <span class="kw">push</span>    <span class="kw">di</span>              <span class="co">;push ClipMinX - DestX, in fixedpoint form</span>
        <span class="kw">sub</span>     <span class="kw">ax</span>,<span class="kw">ax</span>
        <span class="kw">push</span>    <span class="kw">ax</span>              <span class="co">;push 0 as fractional part of ClipMinX-DestX</span>
        <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepY<span class="dv">+2</span>
        <span class="kw">push</span>    <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepY
        <span class="kw">call</span>    -FixedMul       <span class="co">;total source Y stepping in clipped area</span>
        <span class="kw">add</span>     <span class="kw">sp</span>,<span class="dv">8</span>            <span class="co">;clear parameters from stack</span>
        <span class="kw">add</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY,<span class="kw">ax</span><span class="co">;step the source Y past clipping</span>
        <span class="kw">adc</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY<span class="dv">+2</span>,<span class="kw">dx</span>
        <span class="kw">mov</span>     <span class="kw">di</span>,[-ClipMinX]  <span class="co">;start X coordinate in dest after clipping</span>
<span class="fu">LeftEdgeClipped:</span>
<span class="co">; Calculate actual clipped destination drawing width.</span>
        <span class="kw">sub</span>     <span class="kw">si</span>,<span class="kw">di</span>
<span class="co">; Scan across the destination scan line, updating the source image position</span>
<span class="co">; accordingly.</span>
<span class="co">; Point to the initial source image pixel, adding 0.5 to both X and Y so that</span>
<span class="co">; we can truncate to integers from now on but effectively get rounding.</span>
        <span class="kw">add</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY,8000h<span class="co">;add 0.5</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY<span class="dv">+2</span>
        <span class="kw">adc</span>     <span class="kw">ax</span>,<span class="dv">0</span>
        <span class="kw">mul</span>     [-TexMapWidth]   <span class="co">;initial scan line in source image</span>
        <span class="kw">add</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX,8000h<span class="co">;add 0.5</span>
        <span class="kw">mov</span>     <span class="kw">bx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX<span class="dv">+2</span> <span class="co">;offset into source scan line</span>
        <span class="kw">adc</span>     <span class="kw">bx</span>,<span class="kw">ax</span>            <span class="co">;initial source offset in source image</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,[-TexMapBits] <span class="co">;DS:BX points to the initial image pixel</span>
<span class="co">; Point to initial destination pixel.</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN-<span class="kw">SEG</span>
        <span class="kw">mov</span>     <span class="kw">es</span>,<span class="kw">ax</span>
        <span class="kw">mov</span>     <span class="kw">ax</span>,SCREEN-WIDTH
        <span class="kw">mul</span>     [-DestY] <span class="co">;offset of initial dest scan line</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="kw">di</span>   <span class="co">;initial destination X</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>
        <span class="kw">shr</span>     <span class="kw">di</span>,<span class="dv">1</span>    <span class="co">;X/4 = offset of pixel in scan line</span>
        <span class="kw">add</span>     <span class="kw">di</span>,<span class="kw">ax</span>   <span class="co">;offset of pixel in page</span>
        <span class="kw">add</span>     <span class="kw">di</span>,[-CurrentPageBase] <span class="co">;offset of pixel in display memory</span>
<span class="co">;ES:DI now points to the first destination pixel</span>

        <span class="kw">and</span>     <span class="kw">cl</span><span class="bn">,011b </span><span class="co">;CL = pixel&#39;s plane</span>
        <span class="kw">mov</span>     <span class="kw">al</span>,MAP-MASK
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC-INDEX
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>   <span class="co">;point the SC Index register to the Map Mask</span>
        <span class="kw">mov</span>     <span class="kw">al</span><span class="bn">,11h  </span><span class="co">;one plane bit in each nibble, so we&#39;ll get carry</span>
                        <span class="co">; automatically when going from plane 3 to plane 0</span>
        <span class="kw">shl</span>     <span class="kw">al</span>,<span class="kw">cl</span>   <span class="co">;set the bit for the first pixel&#39;s plane to 1</span>
<span class="co">; If source X step is negative, change over to working with non-negative</span>
<span class="co">; values.</span>
        <span class="kw">cmp</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lXAdvanceByOne,<span class="dv">0</span>
        <span class="kw">jge</span>     SXStepSet
        <span class="kw">neg</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepX
        <span class="kw">not</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX
<span class="fu">SXStepSet:</span>
<span class="co">; If source Y step is negative, change over to working with non-negative</span>
<span class="co">; values.</span>
        <span class="kw">cmp</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lYAdvanceByOne,<span class="dv">0</span>
        <span class="kw">jge</span>     SYStepSet
        <span class="kw">neg</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepY
        <span class="kw">not</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY
<span class="fu">SYStepSet:</span>
<span class="co">; At this point:</span>
<span class="co">;       AL = initial pixel&#39;s plane mask</span>
<span class="co">;       BX = pointer to initial image pixel</span>
<span class="co">;       SI = # of pixels to fill</span>
<span class="co">;       DI = pointer to initial destination pixel</span>
        <span class="kw">mov</span>     <span class="kw">dx</span>,SC-INDEX<span class="dv">+1</span>   <span class="co">;point to SC Data; Index points to Map Mask</span>
<span class="fu">TexScanLoop:</span>
<span class="co">; Set the Map Mask for this pixel&#39;s plane, then draw the pixel.</span>
        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,[<span class="kw">bx</span>]         <span class="co">;get image pixel</span>
        <span class="kw">mov</span>     <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">ah</span>      <span class="co">;set image pixel</span>
<span class="co">; Point to the next source pixel.</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].lXBaseAdvance   <span class="co">;advance the minimum # of pixels in X</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepX
        <span class="kw">add</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX,<span class="kw">cx</span><span class="co">;step the source X fractional part</span>
        <span class="kw">jnc</span>     NoExtraXAdvance          <span class="co">;didn&#39;t turn over; no extra advance</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].lXAdvanceByOne   <span class="co">;did turn over; advance X one extra</span>
<span class="fu">NoExtraXAdvance:</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].lYBaseAdvance<span class="co">;advance the minimum # of pixels in Y</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepY
        <span class="kw">add</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY,<span class="kw">cx</span><span class="co">;step the source Y fractional part</span>
        <span class="kw">jnc</span>     NoExtraYAdvance<span class="co">;didn&#39;t turn over; no extra advance</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].lYAdvanceByOne<span class="co">;did turn over; advance Y one extra</span>
<span class="fu">NoExtraYAdvance:</span>
<span class="co">; Point to the next destination pixel, by cycling to the next plane, and</span>
<span class="co">; advancing to the next address if the plane wraps from 3 to 0.</span>
        <span class="kw">rol</span>     <span class="kw">al</span>,<span class="dv">1</span>
        <span class="kw">adc</span>     <span class="kw">di</span>,<span class="dv">0</span>
<span class="co">; Continue if there are any more dest pixels to draw.</span>
        <span class="kw">dec</span>     <span class="kw">si</span>
        <span class="kw">jnz</span>     TexScanLoop
<span class="fu">ScanDone:</span>
        <span class="kw">pop</span>     <span class="kw">di</span>              <span class="co">;restore caller&#39;s register variables</span>
        <span class="kw">pop</span>     <span class="kw">si</span>
        <span class="kw">mov</span>     <span class="kw">sp</span>,<span class="kw">bp</span>           <span class="co">;deallocate local variables</span>
        <span class="kw">pop</span>     <span class="kw">bp</span>              <span class="co">;restore caller&#39;s stack frame</span>
        <span class="kw">ret</span>
-ScanOutLine    endp
        end</code></pre>
<p>Within Listing 57.2, all the important optimization is in the loop that draws across each destination scan line, near the end of the listing. One optimization is elimination of the call to the set-pixel routine used to draw each pixel in Listing 57.1. Function calls are expensive operations, to be avoided when performance matters. Also, although Mode X (the undocumented 320x240 256-color VGA mode X-Sharp runs in) doesn’t lend itself well to pixel-oriented operations like line drawing or texture mapping, the inner loop has been set up to minimize Mode X’s overhead. A rotating plane mask is maintained in AL, with DX pointing to the Map Mask register; thus, only a rotate and an <code>OUT</code> are required to select the plane to which to write, cycling from plane 0 through plane 3 and wrapping back to 0. Better yet, because we know that we’re simply stepping horizontally across the destination scan line, we can use a clever optimization to both step the destination and reduce the overhead of maintaining the mask. Two copies of the current plane mask are maintained, one in each nibble of AL. (The Map Mask register pays attention only to the lower nibble.) Then, when one copy rotates out of the lower nibble, the other copy rotates into the lower nibble and is ready to be used. This approach eliminates the need to test for the mask wrapping from plane 3 to plane 0, all the more so because a carry is generated when wrapping occurs, and that carry can be added to DI to advance the screen pointer. (Check out the next chapter, however, to see the best Map Mask optimization of all—setting it once and leaving it unchanged.)</p>
<p>In all, the overhead of drawing each pixel is reduced from a call to the set-pixel routine and full calculation of the screen address and plane mask to five instructions and no branches. This is an excellent example of converting full, from-scratch calculations to incremental processing, whereby only information that has changed since the last operation (the plane mask moving one pixel, for example) is recalculated.</p>
<p>Incremental processing and knowing where the cycles go are both important in the final optimization in Listing 57.2, speeding up the retrieval of pixels from the texture map. This operation looks very efficient in Listing 57.1, consisting of only two adds and the macro <strong>GET- IMAGE-PIXEL</strong>. However, those adds are fixed-point adds, so they take four instructions apiece, and the macro hides not only conversion from fixed-point to integer, but also a time-consuming multiplication. Incremental approaches are excellent at avoiding multiplication, because cumulative additions can often replace multiplication. That’s the case with stepping through the source texture in Listing 57.2; ten instructions, with a maximum of two branches, replace all the texture calculations of Listing 57.1. Listing 57.2 simply detects when the fractional part of the source x or y coordinate turns over and advances the source texture pointer accordingly.</p>
<p>As you might expect, all this optimization is pretty hard to implement, and makes Listing 57.2 much more complicated than Listing 57.1. Is it worth the trouble? Indeed it is. Listing 57.2 is more than twice as fast as Listing 57.1, and the difference is very noticeable when large, texture-mapped areas are animated. Whether more than doubling performance is significant is a matter of opinion, I suppose, but imagine that you’re in William Gibson’s <em>Neuromancer</em>, trying to crack a corporate database. Which texture-mapping routine would you rather have interfacing you to Cyberspace?</p>
<p>I’m always interested in getting your feedback on and hearing about potential improvements to X-Sharp. Contact me through the publisher. There is no truth to the rumor that I can be reached under the alias “sheep-shearer,” at least not for another 9,999 sheep.</p>
</section>
</section>
</section>
<section id="chapter-58-heinleins-crystal-ball-spocks-brain-and-the-9-cycle-dare" class="level2">
<h2><a href="#chapter-58-heinleins-crystal-ball-spocks-brain-and-the-9-cycle-dare">Chapter 58 – Heinlein’s Crystal Ball, Spock’s Brain, and the 9-Cycle Dare</a></h2>
<section id="using-the-whole-brain-approach-to-accelerate-texture-mapping" class="level3">
<h3><a href="#using-the-whole-brain-approach-to-accelerate-texture-mapping">Using the Whole-Brain Approach to Accelerate Texture Mapping</a></h3>
<p>I’ve had the pleasure recently of rereading several of the works of Robert A. Heinlein, and I’m as impressed as I was as a teenager—but in a different way. The first time around, I was wowed by the sheer romance of technology married to powerful stories; this time, I’m struck most of all by The Master’s remarkable prescience. “Blowups Happen” is about the risks of nuclear power, and their effects on human psychology—written before a chain reaction had ever happened on this planet. “Solution Unsatisfactory” is about the unsolvable dilemma—ultimate offense, no defense—posed by atomic weapons; this in 1941. And in <em>Between Planets</em> (1951), consider this minor bit of action:</p>
<blockquote>
<p>The doctor’s phone regretted politely that Dr. Jefferson was not at home and requested him to leave a message. He was dictating it when a warm voice interrupted: ‘I’m at home to you, Donald. Where are you, lad?’</p>
</blockquote>
<p>Predicting the widespread use of answering machines is perhaps not so remarkable, but foreseeing that they would be used for call screening is; technology is much easier to extrapolate than are social patterns.</p>
<p>Even so, Heinlein was no prophet; his crystal ball was just a little less fuzzy than ours. The aforementioned call in <em>Between Planets</em> was placed on a viewphone; while that technology has indeed come to pass, its widespread use has not. The ultimate weapon in “Solution Unsatisfactory” was radioactive dust, not nuclear bombs, and we have somehow survived nearly 50 years of nuclear weapons without either acquiring a world dictator or destroying ourselves. Slide rules are all over the place in Heinlein’s works, and in one story (the name now lost to memory), an astronaut straps himself into a massive integral calculator; computers are nowhere to be found.</p>
<p>Most telling, I think, is that in “Blowups Happen,” the engineers running the nuclear power plant—at considerable risk to both body and sanity—are the best of the best, highly skilled in math and required to ride the nuclear reaction on a second-to-second basis, with the risk of an explosion that might end life on Earth, and would surely kill them, if they slip. Contrast that with our present-day reality of nuclear plants run by generally competent technicians, with the occasional report of shoddy maintenance and bored power-plant employees using drugs, playing games, and falling asleep while on duty. Heinlein’s universe makes for a better story, of course, but, more than that, it shows the filters and biases through which he viewed the world. At least in print, Heinlein was an unwavering believer in science, technology, and rationality, and in his stories it is usually the engineers and scientists who are the heroes and push civilization forward, often kicking and screaming. In the real world, I have rarely observed that to be the case.</p>
<p>But of course Heinlein was hardly the only person to have his or her perceptions of the universe, past, present, or future, blurred by his built-in assumptions; you and I, as programmers, are also on that list—and probably pretty near the top, at that. Performance programming is basically a process of going from the general to the specific, special-casing the code so that it does just what it has to, and no more. The greatest impediment to this process is seeing the problem in terms of what the code currently does, or what you already know, thereby ignoring many possible solutions. Put another way, how you look at an optimization problem determines how you’ll solve it; your assumptions may speed and simplify the process, but they are also your limitations. Consider, for example, how a seemingly intractable problem becomes eminently tractable the instant you learn that someone else has solved it.</p>
<p>As Exhibit #1, I present my experience with speeding up the texture mapper in X-Sharp.</p>
</section>
<section id="texture-mapping-redux" class="level3">
<h3><a href="#texture-mapping-redux">Texture Mapping Redux</a></h3>
<p>We’ve spent the previous several chapters exploring the X Sharp graphics library, something I built over time as a serious exercise in 3-D graphics. When X-Sharp reached the point at which we left it at the end of the previous chapter, I was rather pleased with it—with one exception.</p>
<p>My last addition to X-Sharp was a <em>texture mapper,</em> a routine that warped and rotated any desired bitmap to map onto an arbitrary convex polygon. Texture mappers are critical to good 3-D games; just a few texture-mapped polygons, backed with well-drawn bitmaps, can represent more detail and look more realistic than dozens or even hundreds of solid-color polygons. My X-Sharp texture mapper was in reasonable assembly—pretty good code, by most standards!—and I felt comfortable with my implementation; but then I got a letter from John Miles, who was at the time getting seriously into 3-D and is now the author of a 3-D game library. (Yes, you can license it from his company, Non-Linear Arts, if you’d like; John can be reached at 70322.2457@compuserve.com.) John wrote me as follows: “Hmm, so <em>that’s</em> how texture-mapping works. But 3 jumps <em>per pixel?</em> Hmph!”</p>
<p>It was the “Hmph” that really got to me.</p>
<section id="left-brain-optimization" class="level4">
<h4><a href="#left-brain-optimization">Left-Brain Optimization</a></h4>
<p>That was the first shot of juice for my optimizer (or at least blow to my ego, which can be just as productive). John went on to say he had gotten texture mapping down to 9 cycles per pixel and one jump per <em>scanline</em> on a 486 (all cycle times will be for the 486 unless otherwise noted); given that my code took, on average, about 44 cycles and 2 taken jumps (plus 1 not taken) per pixel, I had a long way to go.</p>
<p>The inner loop of my original texture-mapping code is shown in Listing 58.1. All this code does is draw a single texture-mapped scanline, as shown in Figure 58.1; an outer loop runs through all the scanlines in whatever polygon is being drawn. I immediately saw that I could eliminate nearly 10 percent of the cycles by unrolling the loop; obviously, John had done that, else there’s no way he could branch only once per scanline. (By the way, branching only once per scanline via a fully unrolled loop is not generally recommended. A branch every few pixels costs relatively little, and the cache effects of fully unrolled code are <em>not</em> good.) I quickly came up with several other ways to speed up the code, but soon realized that all the clever coding in the world wasn’t going to get me within 100 percent of John’s performance so long as I had to cycle from one plane to the next for every pixel.</p>
<figure>
<img src="images/58-01.jpg" alt="Figure 58.1  Texture mapping a single horizontal scanline." /><figcaption><strong>Figure 58.1</strong>  <em>Texture mapping a single horizontal scanline.</em></figcaption>
</figure>
<p><strong>LISTING 58.1 L58-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Inner loop to draw a single texture-mapped horizontal scanline in</span>
<span class="co">; Mode X, the VGA&#39;s page-flipped 256-color mode. Because adjacent</span>
<span class="co">; pixels lie in different planes in Mode X, an OUT must be performed</span>
<span class="co">; to select the proper plane before drawing each pixel.</span>
<span class="co">;</span>
<span class="co">; At this point:</span>
<span class="co">;       AL = initial pixel&#39;s plane mask</span>
<span class="co">;       DS:BX = initial source texture pointer</span>
<span class="co">;       DX = pointer to VGA&#39;s Sequencer Data register</span>
<span class="co">;       SI = # of pixels to fill</span>
<span class="co">;       ES:DI = pointer to initial destination pixel</span>

<span class="fu">TexScanLoop:</span>

<span class="co">; Set the Map Mask for this pixel&#39;s plane, then draw the pixel.</span>

        <span class="kw">out</span>     <span class="kw">dx</span>,<span class="kw">al</span>
        <span class="kw">mov</span>     <span class="kw">ah</span>,[<span class="kw">bx</span>]         <span class="co">;get texture pixel</span>
        <span class="kw">mov</span>     <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">ah</span>      <span class="co">;set screen pixel</span>

<span class="co">; Point to the next source pixel.</span>

        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].lXBaseAdvance     <span class="co">;advance the minimum # of pixels in X</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepX
        <span class="kw">add</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX,<span class="kw">cx</span> <span class="co">;step the source X fractional part</span>
        <span class="kw">jnc</span>     NoExtraXAdvance           <span class="co">;didn&#39;t turn over; no extra advance</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].lXAdvanceByOne    <span class="co">;did turn over; advance X one extra</span>
<span class="fu">NoExtraXAdvance:</span>

        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].lYBaseAdvance     <span class="co">;advance the minimum # of pixels in Y</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepY
        <span class="kw">add</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY,<span class="kw">cx</span> <span class="co">;step the source Y fractional part</span>
        <span class="kw">jnc</span>     NoExtraYAdvance           <span class="co">;didn&#39;t turn over; no extra advance</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].lYAdvanceByOne    <span class="co">;did turn over; advance Y one extra</span>
<span class="fu">NoExtraYAdvance:</span>

<span class="co">; Point to the next destination pixel, by cycling to the next plane, and</span>
<span class="co">; advancing to the next address if the plane wraps from 3 to 0.</span>

        <span class="kw">rol</span>     <span class="kw">al</span>,<span class="dv">1</span>
        <span class="kw">adc</span>     <span class="kw">di</span>,<span class="dv">0</span>

<span class="co">; Continue if there are any more dest pixels to draw.</span>

        <span class="kw">dec</span>     <span class="kw">si</span>
        <span class="kw">jnz</span>     TexScanLoop</code></pre>
<p>Figure 58.2 shows why this cycling is necessary. In Mode X, the page-flipped 256-color mode of the VGA, each successive pixel across a scanline is stored in a different hardware plane, and an <code>OUT</code> to the VGA’s hardware is needed to select the plane being drawn to. (See Chapters 47, 48, and 49 for details.) An <code>OUT</code> instruction <em>by itself</em> takes 16 cycles (and in the neighborhood of 30 cycles in virtual-86 or non-privileged protected mode), and an <code>ROL</code> takes 2 more, for a total of 18 cycles, double John’s 9 cycles, just to handle plane management. Clearly, getting plane control out of the inner loop was absolutely necessary.</p>
<figure>
<img src="images/58-02.jpg" alt="Figure 58.2  Display memory organization in Mode X." /><figcaption><strong>Figure 58.2</strong>  <em>Display memory organization in Mode X.</em></figcaption>
</figure>
<p>I must confess, with some embarrassment, that at this point I threw myself into designing a solution that involved executing the texture mapping code up to four times per scanline, once for the pixels in each plane. It’s hard to overstate the complexity of this approach, which involves quadrupling the normal pixel-to-pixel increments, adjusting the start value for each of the passes, and dealing with some nasty boundary cases. Make no mistake, the code was perfectly doable, and would in fact have gotten plane control out of the inner loop, but would have been very difficult to get exactly right, and would have suffered from substantial overhead.</p>
<p>Fortunately, in the last sentence I was able to say “would have,” not “was,” because my friend Chris Hecker (checker@bix.com) came along to toss a figurative bucket of cold water on my right brain, which was evidently asleep. (Or possibly stolen by scantily-clad, attractive aliens; remember “Spock’s Brain”?) Chris is the author of the WinG Windows game graphics package, available from Microsoft via FTP, CompuServe, or MSDN Level 2; if, like me, you were at the Game Developers Conference in April 1994, you, along with everyone else, were stunned to see Id’s megahit DOOM running at full speed in a window, thanks to WinG. If you write games for a living, run, don’t walk, to check WinG out!</p>
<p>Chris listened to my proposed design for all of maybe 30 seconds, growing visibly more horrified by the moment, before he said, “But why don’t you just draw vertical rather than horizontal scanlines?”</p>
<p>Why indeed?</p>
</section>
<section id="a-90-degree-shift-in-perspective" class="level4">
<h4><a href="#a-90-degree-shift-in-perspective">A 90-Degree Shift in Perspective</a></h4>
<p>As I said earlier, how you look at an optimization problem defines how you’ll be able to solve it. In order to boost performance, sometimes it’s necessary to look at things from a different angle—and for texture mapping this was literally as well as figuratively true. Chris suggested nothing more nor less than scanning out polygons at a 90-degree angle to normal, starting, say, at the left edge of the polygon, and texture-mapping vertically along each column of pixels, as shown in Figure 58.3. That way, all the pixels in each texture-mapped column would be in the same plane, and I would need to change planes only between columns—outside the inner loop. A trivial change, not fundamental in any sense—and yet just that one change, plus unrolling the loop, reduced the inner loop to the 22-cycles-per-pixel version shown in Listing 58.2. That’s exactly twice as fast as Listing 58.1—and given how incredibly slow most VGAs are at completing <code>OUT</code>s, the real-world speedup should be considerably greater still. (The fastest byte <code>OUT</code> I’ve ever measured for a VGA is 29 cycles, the slowest more than 60 cycles; in the latter case, Listing 58.2 would be on the order of <em>four</em> times faster than Listing 58.1.)</p>
<p><strong>LISTING 58.2 L58-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Inner loop to draw a single texture-mapped vertical column, rather</span>
<span class="co">; than a horizontal scanline. This allows all pixels handled</span>
<span class="co">; by this code to reside in the same plane, so the time-consuming</span>
<span class="co">; plane switching can be moved out of the inner loop.</span>
<span class="co">;</span>
<span class="co">; At this point:</span>
<span class="co">;       DS:BX = initial source texture pointer</span>
<span class="co">;       DX = offset to advance to the next pixel in the dest column</span>
<span class="co">;            (either positive or negative scanline width)</span>
<span class="co">;       SI = # of pixels to fill</span>
<span class="co">;       ES:DI = pointer to initial destination pixel</span>
<span class="co">;       VGA set up to draw to the correct plane for this column</span>

     REPTLOOP_UNROLL

<span class="co">; Set the Map Mask for this pixel&#39;s plane, then draw the pixel.</span>

        <span class="kw">mov</span>     <span class="kw">ah</span>,[<span class="kw">bx</span>]         <span class="co">;get texture pixel</span>
        <span class="kw">mov</span>     <span class="kw">es</span>:[<span class="kw">di</span>],<span class="kw">ah</span>      <span class="co">;set screen pixel</span>

<span class="co">; Point to the next source pixel.</span>

        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].lXBaseAdvance     <span class="co">;advance the minimum # of pixels in X</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepX
        <span class="kw">add</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceX,<span class="kw">cx</span> <span class="co">;step the source X fractional part</span>
        <span class="kw">jnc</span>     NoExtraXAdvance           <span class="co">;didn&#39;t turn over; no extra advance</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].lXAdvanceByOne    <span class="co">;did turn over; advance X one extra</span>
<span class="fu">NoExtraXAdvance:</span>

        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].lYBaseAdvance     <span class="co">;advance the minimum # of pixels in Y</span>
        <span class="kw">mov</span>     <span class="kw">cx</span>,<span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceStepY
        <span class="kw">add</span>     <span class="dt">word</span> <span class="dt">ptr</span> [<span class="kw">bp</span>].lSourceY,<span class="kw">cx</span> <span class="co">;step the source Y fractional part</span>
        <span class="kw">jnc</span>     NoExtraYAdvance           <span class="co">;didn&#39;t turn over; no extra advance</span>
        <span class="kw">add</span>     <span class="kw">bx</span>,[<span class="kw">bp</span>].lYAdvanceByOne    <span class="co">;did turn over; advance Y one extra</span>
<span class="fu">NoExtraYAdvance:</span>

<span class="co">; Point to the next destination pixel, which is on the next scan line.</span>

        <span class="kw">adc</span>     <span class="kw">di</span>,<span class="kw">dx</span>

ENDM</code></pre>
<p>I’d like to emphasize that algorithmically and conceptually, there is <em>no</em> difference between scanning out a polygon top to bottom and scanning it out left to right; it is only in conjunction with the hardware organization of Mode X that the scanning direction matters in the least.</p>
<blockquote>
<p><img src="images/i.jpg" /> That’s what Zen programming is all about, though; tying together two pieces of seemingly unrelated information to good effect—and that’s what I had failed to do. Like Robert Heinlein—like all of us—I had viewed the world through a filter composed of my ingrained assumptions, and one of those assumptions, based on all my past experience, was that pixel processing proceeds left to right. Eventually, I might have come up with Chris’s approach; but I would only have come up with it when and if I relaxed and stepped back a little, and allowed myself—almost dared myself—to think of it. When you’re optimizing, be sure to leave quiet, nondirected time in which to conjure up those less obvious solutions, and periodically try to figure out what assumptions you’re making—and then question them!</p>
</blockquote>
<figure>
<img src="images/58-03.jpg" alt="Figure 58.3  Texture mapping a single vertical column." /><figcaption><strong>Figure 58.3</strong>  <em>Texture mapping a single vertical column.</em></figcaption>
</figure>
<p>There are a few complications with Chris’s approach, not least that X-Sharp’s polygon-filling convention (top and left edges included, bottom and right edges excluded) is hard to reproduce for column-oriented texture mapping. I solved this in X-Sharp version 22 by tweaking the edge-scanning code to allow column-oriented texture mapping to match the current convention. (You’ll find X-Sharp 22 on the listings diskette in the directory for this chapter.)</p>
<p>Chris also illustrated another important principle of optimization: A second pair of eyes is invaluable. Even the best of us have blind spots and get caught up in particular implementations; if you bounce your ideas off someone, you may well find them coming back with an unexpected—and welcome—spin.</p>
</section>
</section>
<section id="thats-nicebut-it-sure-as-heck-aint-9-cycles" class="level3">
<h3><a href="#thats-nicebut-it-sure-as-heck-aint-9-cycles">That’s Nice—But it Sure as Heck Ain’t 9 Cycles</a></h3>
<p>Excellent as Chris’s suggestion was, I still had work to do: Listing 58.2 is still more than twice as slow as John Miles’s code. Traditionally, I start the optimization process with algorithmic optimization, then try to tie the algorithm and the hardware together for maximum efficiency, and finish up with instruction-by-instruction, take-no-prisoners optimization. We’ve already done the first two steps, so it’s time to get down to the bare metal.</p>
<p>Listing 58.2 contains three functional parts: Drawing the pixel, advancing the destination pointer, and advancing the source texture pointer. Each of the three parts is amenable to further acceleration.</p>
<p>Drawing the pixel is difficult to speed up, given that it consists of only two instructions—difficult, but not impossible. True, the instructions themselves are indeed irreducible, but if we can get rid of the ES: prefix (and, as we shall see, we can), we can rearrange the code to make it run faster on the Pentium. Without a prefix, the instructions execute as follows on the Pentium:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">MOV</span>  <span class="kw">AH</span>,[<span class="kw">BX</span>]    <span class="co">;cycle 1 U-pipe</span>
                <span class="co">;cycle 1 V-pipe idle; reg contention</span>
<span class="kw">MOV</span>  [<span class="kw">DI</span>],<span class="kw">AH</span>    <span class="co">;cycle 2 U-pipe</span></code></pre>
<p>The second <code>MOV</code>, being dependent on the value loaded into AH by the first <code>MOV</code>, can’t execute until the first <code>MOV</code> is finished, so the Pentium’s second pipe, the V-pipe, lies idle for a cycle. We can reclaim that cycle simply by shuffling another instruction between the two <code>MOV</code>s.</p>
<p>Advancing the destination pointer is easy to speed up: Just build the offset from one scanline to the next into each pixel-drawing instruction as a constant, as in</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">MOV</span> [<span class="kw">EDI</span>+SCANOFFSET],<span class="kw">AH</span></code></pre>
<p>and advance EDI only once per unrolled loop iteration.</p>
<p>Advancing the source texture pointer is more complex, but correspondingly more rewarding. Listing 58.2 uses a variant form of 32-bit fixed-point arithmetic to advance the source pointer, with the source texture coordinates and increments stored in 16.16 (16 bits of integer, 16 bits of fraction) format. The source coordinates are stored in a slightly unusual format, whereby the fractional X and Y coordinates are stored and advanced separately, but a single integer value, the source pointer, is used to reflect both the X and Y coordinates. In Listing 58.2, the integer and fractional parts are added into the current coordinates with four separate 16-bit operations, and carries from fractional to integer parts are detected via conditional jumps, as shown in Figure 58.4. There’s quite a lot we can do to improve this.</p>
<figure>
<img src="images/58-04.jpg" alt="Figure 58.4  Original method for advancing the source texture pointer." /><figcaption><strong>Figure 58.4</strong>  <em>Original method for advancing the source texture pointer.</em></figcaption>
</figure>
<p>First, we can sum the X and Y integer advance amounts outside the loop, then add them both to the source pointer with a single instruction. Second, we can recognize that X advances exactly one extra byte when its fractional part carries, and use <code>ADC</code> to account for X carries, as shown in Figure 58.5. That single <code>ADC</code> can add in not only any X carry, but both the X and Y integer advance amounts as well, thereby eliminating a good chunk of the source-advance code in Listing 58.2. Furthermore, we should somehow be able to use 32-bit registers and instructions to help with the 32-bit fixed-point arithmetic; true, the size override prefix (because we’re in a 16-bit segment) will cost a cycle per 32-bit instruction, but that’s better than the 3 cycles it takes to do 32-bit arithmetic with 16-bit instructions. It isn’t obvious, but there’s a nifty trick we can use here, again courtesy of Chris Hecker (who, as you can tell, has done a fair amount of thinking about the complexities of texture mapping).</p>
<p>We can store the current fractional parts of both the X <em>and</em> Y source coordinates in a single 32-bit register, EDX, as shown in Figure 58.6. It’s important to note that the Y fraction is actually only 15 bits, with bit 15 of EDX always kept at zero; this allows bit 15 to store the carry status from each Y advance. We can similarly store the fractional X and Y advance amounts in ECX, and can store the sum of the integer parts of the X and Y advance amounts in BP. With this arrangement, the single instruction <code>ADD EDX,ECX</code> advances the fractional parts of both X and Y, and the following instruction <code>ADC SI,BP</code> finishes advancing the source pointer in X. That’s a mere 3 cycles, and all that remains is to finish advancing the source pointer in Y.</p>
<figure>
<img src="images/58-05.jpg" alt="Figure 58.5  Efficient method for advancing source texture pointer." /><figcaption><strong>Figure 58.5</strong>  <em>Efficient method for advancing source texture pointer.</em></figcaption>
</figure>
<figure>
<img src="images/58-06.jpg" alt="Figure 58.6  Storing both X and Y fractional coordinates in one register." /><figcaption><strong>Figure 58.6</strong>  <em>Storing both X and Y fractional coordinates in one register.</em></figcaption>
</figure>
<p>Actually, we also advanced the source pointer by the Y integer amount back when we added BP to SI; all that’s left is to detect whether our addition to the Y fractional current coordinate produced a carry. That’s easily done by testing bit 15 of EDX; if it’s zero, there was no carry and we’re done; otherwise, Y carried, so we have to reset bit 15 and advance the source pointer by one scanline. The resulting program flow is shown in Figure 58.7. Note that unlike the X fractional addition, we can’t get away with just adding in the carry from the Y fractional addition, because when the Y fraction carries, it indicates a move not from one pixel to the next on a scanline (a single byte), but rather from one scanline to the next (a full scanline width).</p>
<p>All of the above optimizations together get us to 10 cycles—<em>very</em> close to John Miles, but not there yet. We have one more trick up our sleeve, though: Suppose we point SS to the segment containing our textures, and point DS to the screen? (This requires either setting up a stack in the texture segment or ensuring that interrupts and other stack activity can’t happen while SS points to that segment.) Then, we could swap the functions of SI and BP; that would let us use BP, which accesses SS by default, to get at the textures, and DI to access the screen—all with no segment prefixes at all. By gosh, that would get us exactly one more cycle, and would bring us down to the same 9 cycles John Miles attained; Listing 58.3 shows that code. At long last, the Holy Grail attained and our honor defended, we can rest.</p>
<p>Or can we?</p>
<p><strong>LISTING 58.3 L58-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Inner loop to draw a single texture-mapped vertical column,</span>
<span class="co">; rather than a horizontal scanline. Maxed-out 16-bit version.</span>
<span class="co">;</span>
<span class="co">; At this point:</span>
<span class="co">;       AX = source pointer increment to advance one in Y</span>
<span class="co">;       ECX = fractional Y advance in lower 15 bits of CX,</span>
<span class="co">;             fractional X advance in high word of ECX, bit</span>
<span class="co">;             15 set to 0</span></code></pre>
<figure>
<img src="images/58-07.jpg" alt="Figure 58.7  Final method for advancing source texture pointer." /><figcaption><strong>Figure 58.7</strong>  <em>Final method for advancing source texture pointer.</em></figcaption>
</figure>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">;       EDX = fractional source texture Y coordinate in lower</span>
<span class="co">;             15 bits of CX, fractional source texture X coord</span>
<span class="co">;             in high word of ECX, bit 15 set to 0</span>
<span class="co">;       SI = sum of integral X &amp; Y source pointer advances</span>
<span class="co">;       DS:DI = initial destination pointer</span>
<span class="co">;       SS:BP = initial source texture pointer</span>

SCANOFFSET=<span class="dv">0</span>

     REPT LOOP_UNROLL

     <span class="kw">mov</span>   <span class="kw">bl</span>,[<span class="kw">bp</span>]                        <span class="co">;get texture pixel</span>
     <span class="kw">mov</span>   [<span class="kw">di</span>+SCANOFFSET],<span class="kw">bl</span>             <span class="co">;set screen pixel</span>

     <span class="kw">add</span>   <span class="kw">edx</span>,<span class="kw">ecx</span>                        <span class="co">;advance frac Y in DX,</span>
                                          <span class="co">; frac X in high word of EDX</span>
     <span class="kw">adc</span>   <span class="kw">bp</span>,<span class="kw">si</span>                          <span class="co">;advance source pointer by integral</span>
                                          <span class="co">; X &amp; Y amount, also accounting for</span>
                                          <span class="co">; carry from X fractional addition</span>
     <span class="kw">test</span>  <span class="kw">dh</span><span class="bn">,80h                         </span><span class="co">;carry from Y fractional addition?</span>
     <span class="kw">jz</span>    @F                             <span class="co">;no</span>
     <span class="kw">add</span>   <span class="kw">bp</span>,<span class="kw">ax</span>                          <span class="co">;yes, advance Y by one</span>
     <span class="kw">and</span>   <span class="kw">dh</span>,<span class="kw">not</span><span class="bn"> 80h                     </span><span class="co">;reset the Y fractional carry bit</span>
@@:

SCANOFFSET = SCANOFFSET + SCANWIDTH

     ENDM</code></pre>
<section id="dont-stop-thinking-about-those-cycles" class="level4">
<h4><a href="#dont-stop-thinking-about-those-cycles">Don’t Stop Thinking about Those Cycles</a></h4>
<p>Remember what I said at the outset, that knowing something has been done makes it much easier to do? A corollary is that pushing past that point, once attained, is very difficult. It’s only natural to want to relax in the satisfaction of a job well done; then, too, the very nature of the work changes. Getting from 44 cycles down to John’s 9 cycles was a huge leap, but we knew it could be done—therefore the nature of the problem was to figure out <em>how</em> it was done; in cases like this, if we’re sharp enough (and of course we are!), we’re guaranteed eventual gratification. Now that we’ve reached John’s level of performance, the problem becomes <em>whether</em> the code can be made faster yet, and that’s a different kettle of fish altogether, for it may well be that after thinking about it for a while, we’ll conclude that it can’t. Not only will we have wasted time, but we’ll also never be sure we were right; we’ll know only that <em>we</em> couldn’t find a solution. That way lies madness.</p>
<p>And yet—<em>someone</em> has to blaze the trail to higher performance, and that someone might as well be us. Let’s look for weaknesses in Listing 58.3. None are readily apparent; the only cycle that looks even slightly wasted is the size prefix on <code>ADD EDX,ECX</code>. As it turns out, that cycle really <em>is</em> wasted, for there’s a way to make the size prefix vanish without losing the benefits of 32-bit instructions: Move the code into a 32-bit segment and make <em>all</em> the instructions 32-bit. That’s what Listing 58.4 does; this code is similar to Listing 58.3, but runs in 8 cycles per pixel, a 12.5 percent speedup over Listing 58.3. Whether Listing 58.4 actually draws more pixels per second than Listing 58.3 depends on whether display memory is fast enough to handle pixels as rapidly as Listing 58.4 can deliver them. That speed, one pixel every 122 nanoseconds on a 486/66, is one that ISA adapters can’t hope to match, but fast VLB and PCI adapters can handle with ease. Be aware, too, that cache misses when reading the source texture will generally reduce performance below the calculated 8-cycles-per-pixel level, especially because textures, which can be scanned across at any angle, are rarely accessed at consecutive addresses, which is the arrangement that would make for the fewest cache misses.</p>
<p><strong>LISTING 58.4 L58-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Inner loop to draw a single texture-mapped vertical column,</span>
<span class="co">; rather than a horizontal scanline. Maxed-out 32-bit version.</span>
<span class="co">;</span>
<span class="co">; At this point:</span>
<span class="co">;       EAX = sum of integral X &amp; Y source pointer advances</span>
<span class="co">;       ECX = source pointer increment to advance one in Y</span>
<span class="co">;       EDX = fractional source texture Y coordinate in lower</span>
<span class="co">;             15 bits of DX, fractional source texture X coord</span>
<span class="co">;             in high word of EDX, bit 15 set to 0</span>
<span class="co">;       ESI = initial source texture pointer</span>
<span class="co">;       EDI = initial destination pointer</span>
<span class="co">;       EBP = fractional Y advance in lower 15 bits of BP,</span>
<span class="co">;             fractional X advance in high word of EBP, bit</span>
<span class="co">;             15 set to 0</span>

SCANOFFSET=<span class="dv">0</span>

     REPT LOOP_UNROLL

     <span class="kw">mov</span>   <span class="kw">bl</span>,[<span class="kw">esi</span>]                    <span class="co">;get image pixel</span>
     <span class="kw">add</span>   <span class="kw">edx</span>,<span class="kw">ebp</span>                     <span class="co">;advance frac Y in DX,</span>
                                       <span class="co">; frac X in high word of EDX</span>
     <span class="kw">adc</span>   <span class="kw">esi</span>,<span class="kw">eax</span>                     <span class="co">;advance source pointer by integral</span>
                                       <span class="co">; X &amp; Y amount, also accounting for</span>
                                       <span class="co">; carry from X fractional addition</span>
     <span class="kw">mov</span>   [<span class="kw">edi</span>+SCANOFFSET],<span class="kw">bl</span>         <span class="co">;set screen pixel</span>
                                       <span class="co">; (located here to avoid 486</span>
                                       <span class="co">; AGI from previous byte op)</span>
     <span class="kw">test</span>  <span class="kw">dh</span><span class="bn">,80h                      </span><span class="co">;carry from Y fractional addition?</span>
     <span class="kw">jz</span>    <span class="dt">short</span> @F                    <span class="co">;no</span>
     <span class="kw">add</span>   <span class="kw">esi</span>,<span class="kw">ecx</span>                     <span class="co">;yes, advance Y by one</span>
                                       <span class="co">; (produces Pentium AGI for MOV BL,[ESI])</span>
     <span class="kw">and</span>   <span class="kw">dh</span>,<span class="kw">not</span><span class="bn"> 80h                  </span><span class="co">;reset the Y fractional carry bit</span>
@@:

SCANOFFSET = SCANOFFSET + SCANWIDTH

     ENDM</code></pre>
<p>And there you have it: A five to 10-times speedup of a decent assembly language texture mapper. All it took was some help from my friends, a good, stiff jolt of right-brain thinking, and some solid left-brain polishing—plus the knowledge that such a speedup was possible. Treat every optimization task as if John Miles has just written to inform you that he’s made it faster than your wildest dreams, and you’ll be amazed at what you can do!</p>
</section>
</section>
<section id="texture-mapping-notes" class="level3">
<h3><a href="#texture-mapping-notes">Texture Mapping Notes</a></h3>
<p>Listing 58.3 contains no 486 pipeline stalls; it has Pentium stalls, but not much can be done for them because of the size prefix on <code>ADD EDX,ECX</code>, which takes 1 cycle to go through the U-pipe, and shuts down the V-pipe for that cycle. Listing 58.4, on the other hand, has been rearranged to eliminate all Pentium stalls save one. When the Y coordinate fractional part carries and ESI advances, the code executes as follows:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">ADD</span> <span class="kw">ESI</span>,<span class="kw">ECX</span>     <span class="co">;cycle 1 U-pipe</span>
<span class="kw">AND</span> <span class="kw">DH</span>,<span class="kw">NOT</span> 80H  <span class="co">;cycle 1 V-pipe</span>
                <span class="co">;cycle 2 idle AGI on ESI</span>
<span class="kw">MOV</span> <span class="kw">BL</span>,[<span class="kw">ESI</span>]    <span class="co">;cycle 3 U-pipe</span>
<span class="kw">ADD</span> <span class="kw">EDX</span>,<span class="kw">EBP</span>     <span class="co">;cycle 3 V-pipe</span></code></pre>
<p>However, I don’t see any way to eliminate this last AGI, which happens about half the time; even with it, the Pentium execution time for Listing 58.4 is 5.5 cycles. That’s 61 nanoseconds—a highly respectable 16 million texture-mapped pixels per second—on a 90 MHz Pentium.</p>
<p>The type of texture mapping discussed in both this and earlier chapters doesn’t do perspective correction when mapping textures. Why that is and how to handle perspective correction is a topic for a whole separate book, but be aware that the textures on some large polygons (not the polygon edges themselves) drawn with the code in this chapter will appear to be unnaturally bowed, although small polygons should look fine.</p>
<p>Finally, we never did get rid of the last jump in the texture mapper, yet John Miles claimed no jumps at all. How did he do it? I’m not sure, but I’d guess that he used a two-entry look-up table, based on the Y carry, to decide how much to advance the source pointer in Y. However, I couldn’t come up with any implementation of this approach that didn’t take 0.5 to 1 cycle more than the test-and-jump approach, so either I didn’t come up with an adequately efficient implementation of the table, John saved a cycle somewhere else, or perhaps John implemented his code in a 32-bit segment, but used the less-efficient table in his fervor to get rid of the final jump. The knowledge that I apparently came up with a different solution than John highlights that the technical aspects of John’s implementation were, in truth, totally irrelevant to my optimization efforts; the only actual effect John’s code had on me was to make me <em>believe</em> a texture mapper could run that fast.</p>
<p>Believe it! And while you’re at it, give both halves of your brain equal time—and watch out for aliens in short skirts, 60’s bouffant hairdos, and an undue interest in either half.</p>
</section>
</section>
<section id="chapter-59-the-idea-of-bsp-trees" class="level2">
<h2><a href="#chapter-59-the-idea-of-bsp-trees">Chapter 59 – The Idea of BSP Trees</a></h2>
<section id="what-bsp-trees-are-and-how-to-walk-them" class="level3">
<h3><a href="#what-bsp-trees-are-and-how-to-walk-them">What BSP Trees Are and How to Walk Them</a></h3>
<p>The answer is: Wendy Tucker.</p>
<p>The question that goes with that answer isn’t particularly interesting to anyone but me—but the manner in which I came up with the answer is.</p>
<p>I spent many of my childhood summers at Camp Chingacook, on Lake George in New York. It was a great place to have fun and do some growing up, with swimming and sailing and hiking and lots more.</p>
<p>When I was 14, Camp Chingacook had a mixer with a nearby girls’ camp. As best I can recall, I had never had any interest in girls before, but after the older kids had paired up, I noticed a pretty girl looking at me and, with considerable trepidation, I crossed the room to talk to her. To my amazement, we hit it off terrifically. We talked non-stop for the rest of the evening, and I walked back to my cabin floating on air. I had taken a first, tentative step into adulthood, and my world would never be quite the same.</p>
<p>That was the only time I ever saw her, although I would occasionally remember that warm glow and call up an image of her smiling face. That happened less frequently as the years passed and I had real girlfriends, and by the time I got married, that particular memory was stashed in some back storeroom of my mind. I didn’t think of her again for more than a decade.</p>
<p>A few days ago, for some reason, that mixer popped into my mind as I was trying to fall asleep. And I wondered, for the first time in 20 years, what that girl’s name was. The name was there in my mind, somewhere; I could feel the shape of it, in that same back storeroom, if only I could figure out how to retrieve it.</p>
<p>I poked and worried at that memory, trying to get it to come to the surface. I concentrated on it as hard as I could, and even started going through the alphabet one letter at a time, trying to remember if her name started with each letter. After 15 minutes, I was wide awake and totally frustrated. I was also farther than ever from answering the question; all the focusing on the memory was beginning to blur the original imprint.</p>
<p>At this point, I consciously relaxed and made myself think about something completely different. Every time my mind returned to the mystery girl, I gently shifted it to something else. After a while, I began to drift off to sleep, and as I did a connection was made, and a name popped, unbidden, into my mind.</p>
<p>Wendy Tucker.</p>
<p>There are many problems that are amenable to the straight-ahead, purely conscious sort of approach that I first tried to use to retrieve Wendy’s name. Writing code (once it’s designed) is often like that, as are some sorts of debugging, technical writing, and balancing your checkbook. I personally find these left-brain activities to be very appealing because they’re finite and controllable; when I start one, I know I’ll be able to deal with whatever comes up and make good progress, just by plowing along. Inspiration and intuitive leaps are sometimes useful, but not required.</p>
<p>The problem is, though, that neither you nor I will ever do anything great without inspiration and intuitive leaps, and especially not without stepping away from what’s known and venturing into territories beyond. The way to do that is not by trying harder but, paradoxically, by trying less hard, stepping back, and giving your right brain room to work, then listening for and nurturing whatever comes of that. On a small scale, that’s how I remembered Wendy’s name, and on a larger scale, that’s how programmers come up with products that are more than me-too, checklist-oriented software.</p>
<p>Which, for a couple of reasons, brings us neatly to this chapter’s topic, Binary Space Partitioning (BSP) trees. First, games are probably the sort of software in which the right-brain element is most important—blockbuster games are almost always breakthroughs in one way or another—and some very successful games use BSP trees, most notably id Software’s megahit DOOM. Second, BSP trees aren’t intuitively easy to grasp, and considerable ingenuity and inventiveness is required to get the most from them.</p>
<p>Before we begin, I’d like to thank John Carmack, the technical wizard behind DOOM, for generously sharing his knowledge of BSP trees with me.</p>
</section>
<section id="bsp-trees" class="level3">
<h3><a href="#bsp-trees">BSP Trees</a></h3>
<p>A BSP tree is, at heart, nothing more than a tree that subdivides space in order to isolate features of interest. Each node of a BSP tree splits an area or a volume (in 2-D or 3-D, respectively) into two parts along a line or a plane; thus the name “Binary Space Partitioning.” The subdivision is hierarchical; the root node splits the world into two subspaces, then each of the root’s two children splits one of those two subspaces into two more parts. This continues with each subspace being further subdivided, until each component of interest (each line segment or polygon, for example) has been assigned its own unique subspace. This is, admittedly, a pretty abstract description, but the workings of BSP trees will become clearer shortly; it may help to glance ahead to this chapter’s figures.</p>
<p>Building a tree that subdivides space doesn’t sound particularly profound, but there’s a lot that can be done with such a structure. BSP trees can be used to represent shapes, and operating on those shapes is a simple matter of combining trees as needed; this makes BSP trees a powerful way to implement Constructive Solid Geometry (CSG). BSP trees can also be used for hit testing, line-of-sight determination, and collision detection.</p>
<section id="visibility-determination" class="level4">
<h4><a href="#visibility-determination">Visibility Determination</a></h4>
<p>For the time being, I’m going to discuss only one of the many uses of BSP trees: The ability of a BSP tree to allow you to traverse a set of line segments or polygons in back-to-front or front-to-back order as seen from any arbitrary viewpoint. This sort of traversal can be very helpful in determining which parts of each line segment or polygon are visible and which are occluded from the current viewpoint in a 3-D scene. Thus, a BSP tree makes possible an efficient implementation of the painter’s algorithm, whereby polygons are drawn in back-to-front order, with closer polygons overwriting more distant ones that overlap, as shown in Figure 59.1. (The line segments in Figure 1(a) and in other figures in this chapter, represent vertical walls, viewed from directly above.) Alternatively, visibility determination can be performed by front-to-back traversal working in conjunction with some method for remembering which pixels have already been drawn. The latter approach is more complex, but has the potential benefit of allowing you to early-out from traversal of the scene database when all the pixels on the screen have been drawn.</p>
<p>Back-to-front or front-to-back traversal in itself wouldn’t be so impressive—there are many ways to do that—were it not for one additional detail: The traversal can always be performed in linear time, as we’ll see later on. For instance, you can traverse, a polygon list back-to-front from any viewpoint simply by walking through the corresponding BSP tree once, visiting each node one and only one time, and performing only one relatively inexpensive test at each node.</p>
<p>It’s hard to get cheaper sorting than linear time, and BSP-based rendering stacks up well against alternatives such as z-buffering, octrees, z-scan sorting, and polygon sorting. Better yet, a scene database represented as a BSP tree can be clipped to the view pyramid very efficiently; huge chunks of a BSP tree can be lopped off when clipping to the view pyramid, because if the entire area or volume of a node lies entirely outside the view volume, then <em>all</em> nodes and leaves that are children of that node must likewise be outside the view volume, for reasons that will become clear as we delve into the workings of BSP trees.</p>
<figure>
<img src="images/59-01.jpg" alt="Figure 59.1  The painter’s algorithm." /><figcaption><strong>Figure 59.1</strong>  <em>The painter’s algorithm.</em></figcaption>
</figure>
</section>
<section id="limitations-of-bsp-trees" class="level4">
<h4><a href="#limitations-of-bsp-trees">Limitations of BSP Trees</a></h4>
<p>Powerful as they are, BSP trees aren’t perfect. By far the greatest limitation of BSP trees is that they’re time-consuming to build, enough so that, for all practical purposes, BSP trees must be precalculated, and cannot be built dynamically at runtime. In fact, a BSP-tree compiler that attempts to perform some optimization (limiting the number of surfaces that need to be split, for example) can easily take minutes or even hours to process large world databases.</p>
<p>A fixed world database is fine for walkthrough or flythrough applications (where the viewpoint moves through a static scene), but not much use for games or virtual reality, where objects constantly move relative to one another. Consequently, various workarounds have been developed to allow moving objects to appear in BSP tree-based scenes. DOOM, for example, uses 2-D sprites mixed into BSP-based 3-D scenes; note, though, that this approach requires maintaining z information so that sprites can be drawn and occluded properly. Alternatively, movable objects could be represented as separate BSP trees and merged anew into the world BSP tree with each move. Dynamic merging may or may not be fast enough, depending on the scene, but merging BSP trees tends to be quicker than building them, because the BSP trees being merged are already spatially sorted.</p>
<p>Another possibility would be to generate a per-pixel z-buffer for each frame as it’s rendered, to allow dynamically changing objects to be drawn into the BSP-based world. In this scheme, the BSP tree would allow fast traversal and clipping of the complex, static world, and the z-buffer would handle the relatively localized visibility determination involving moving objects. The drawback of this is the need for a memory-hungry z-buffer; a typical 640x480 z-buffer requires a fairly appalling 600K, with equally appalling cache-miss implications for performance.</p>
<p>Yet another possibility would be to build the world so that each dynamic object falls entirely within a single subspace of the static BSP tree, rather than straddling splitting lines or planes. In this case, dynamic objects can be treated as points, which are then just sorted into the BSP tree on the fly as they move.</p>
<p>The only other drawbacks of BSP trees that I know of are the memory required to store the tree, which amounts to a few pointers per node, and the relative complexity of debugging BSP-tree compilation and usage; debugging a large data set being processed by recursive code (which BSP code tends to be) can be quite a challenge. Tools like the BSP compiler I’ll present in the next chapter, which visually depicts the process of spatial subdivision as a BSP tree is constructed, help a great deal with BSP debugging.</p>
</section>
</section>
<section id="building-a-bsp-tree" class="level3">
<h3><a href="#building-a-bsp-tree">Building a BSP Tree</a></h3>
<p>Now that we know a good bit about what a BSP tree is, how it helps in visible surface determination, and what its strengths and weaknesses are, let’s take a look at how a BSP tree actually works to provide front-to-back or back-to-front ordering. This chapter’s discussion will be at a conceptual level, with plenty of figures; in the next chapter we’ll get into mechanisms and implementation details.</p>
<p>I’m going to discuss only 2-D BSP trees from here on out, because they’re much easier to draw and to grasp than their 3-D counterparts. Don’t worry, though; the principles of 2-D BSP trees using line segments generalize directly to 3-D BSP trees using polygons. Also, 2-D BSP trees are quite powerful in their own right, as evidenced by DOOM, which is built around 2-D BSP trees.</p>
<p>First, let’s construct a simple BSP tree. Figure 59.2 shows a set of four lines that will constitute our sample world. I’ll refer to these as walls, because that’s one easily-visualized context in which a 2-D BSP tree would be useful in a game. Think of Figure 59.2 as depicting vertical walls viewed from directly above, so they’re lines for the purpose of the BSP tree. Note that each wall has a front side, denoted by a normal (perpendicular) vector, and a back side. To make a BSP tree for this sample set, we need to split the world in two, then each part into two again, and so on, until each wall resides in its own unique subspace. An obvious question, then, is how should we carve up the world of Figure 59.2?</p>
<figure>
<img src="images/59-02.jpg" alt="Figure 59.2  A sample set of walls, viewed from above." /><figcaption><strong>Figure 59.2</strong>  <em>A sample set of walls, viewed from above.</em></figcaption>
</figure>
<p>There are infinitely valid ways to carve up Figure 59.2, but the simplest is just to carve along the lines of the walls themselves, with each node containing one wall. This is not necessarily optimal, in the sense of producing the smallest tree, but it has the virtue of generating the splitting lines without expensive analysis. It also saves on data storage, because the data for the walls can do double duty in describing the splitting lines as well. (Putting one wall on each splitting line doesn’t actually create a unique subspace for each wall, but it does create a unique subspace <em>boundary</em> for each wall; as we’ll see, that spatial organization provides for the same unambiguous visibility ordering as a unique subspace would.)</p>
<p>Creating a BSP tree is a recursive process, so we’ll perform the first split and go from there. Figure 59.3 shows the world carved along the line of wall C into two parts: walls that are in front of wall C, and walls that are behind. (Any of the walls would have been an equally valid choice for the initial split; we’ll return to the issue of choosing splitting walls in the next chapter.) This splitting into front and back is the essential dualism of BSP trees.</p>
<figure>
<img src="images/59-03.jpg" alt="Figure 59.3  Initial split along the line of wall C." /><figcaption><strong>Figure 59.3</strong>  <em>Initial split along the line of wall C.</em></figcaption>
</figure>
<p>Next, in Figure 59.4, the front subspace of wall C is split by wall D. This is the only wall in that subspace, so we’re done with wall C’s front subspace.</p>
<p>Figure 59.5 shows the back subspace of wall C being split by wall B. There’s a difference here, though: Wall A straddles the splitting line generated from wall B. Does wall A belong in the front or back subspace of wall B?</p>
<figure>
<img src="images/59-04.jpg" alt="Figure 59.4  Split of wall C’s front subspace along the line of wall D." /><figcaption><strong>Figure 59.4</strong>  <em>Split of wall C’s front subspace along the line of wall D.</em></figcaption>
</figure>
<figure>
<img src="images/59-05.jpg" alt="Figure 59.5  Split of wall C’s back subspace along the line of wall B." /><figcaption><strong>Figure 59.5</strong>  <em>Split of wall C’s back subspace along the line of wall B.</em></figcaption>
</figure>
<p>Both, actually. Wall A gets split into two pieces, which I’ll call wall A and wall E; each piece is assigned to the appropriate subspace and treated as a separate wall. As shown in Figure 59.6, each of the split pieces then has a subspace to itself, and each becomes a leaf of the tree. The BSP tree is now complete.</p>
<section id="visibility-ordering" class="level4">
<h4><a href="#visibility-ordering">Visibility Ordering</a></h4>
<p>Now that we’ve successfully built a BSP tree, you might justifiably be a little puzzled as to how any of this helps with visibility ordering. The answer is that each BSP node can definitively determine which of its child trees is nearer and which is farther from any and all viewpoints; applied throughout the tree, this principle makes it possible to establish visibility ordering for all the line segments or planes in a BSP tree, no matter what the viewing angle.</p>
<p>Consider the world of Figure 59.2 viewed from an arbitrary angle, as shown in Figure 59.7. The viewpoint is in front of wall C; this tells us that all walls belonging to the front tree that descends from wall C are nearer along every ray from the viewpoint than wall C is (that is, they can’t be occluded by wall C). All the walls in wall C’s back tree are likewise farther away than wall C along any ray. Thus, for this viewpoint, we know for sure that if we’re using the painter’s algorithm, we want to draw all the walls in the back tree first, then wall C, and then the walls in the front tree. If the viewpoint had been on the back side of wall C, this order would have been reversed.</p>
<p>Of course, we need more ordering information than wall C alone can give us, but we get that by traversing the tree recursively, making the same far-near decision at each node. Figure 59.8 shows the painter’s algorithm (back-to-front) traversal order of the tree for the viewpoint of Figure 59.7. At each node, we decide whether we’re seeing the front or back side of that node’s wall, then visit whichever of the wall’s children is on the far side from the viewpoint, draw the wall, and then visit the node’s nearer child, in that order. Visiting a child is recursive, involving the same far-near visiting order.</p>
<figure>
<img src="images/59-06.jpg" alt="Figure 59.6  The final BSP tree." /><figcaption><strong>Figure 59.6</strong>  <em>The final BSP tree.</em></figcaption>
</figure>
<figure>
<img src="images/59-07.jpg" alt="Figure 59.7  Viewing the BSP tree from an arbitrary angle." /><figcaption><strong>Figure 59.7</strong>  <em>Viewing the BSP tree from an arbitrary angle.</em></figcaption>
</figure>
<p>The key is that each BSP splitting line separates all the walls in the current subspace into two groups relative to the viewpoint, and every single member of the farther group is guaranteed not to occlude every single member of the nearer. By applying this ordering recursively, the BSP tree can be traversed to provide back-to-front or front-to-back ordering, with each node being visited only once.</p>
<figure>
<img src="images/59-08.jpg" alt="Figure 59.8  Back-to-front traversal of the BSP tree as viewed in Figure 59.7." /><figcaption><strong>Figure 59.8</strong>  <em>Back-to-front traversal of the BSP tree as viewed in Figure 59.7.</em></figcaption>
</figure>
<p>The type of tree walk used to produce front-to-back or back-to-front BSP traversal is known as an <em>inorder</em> walk. More on this very shortly; you’re also likely to find a discussion of inorder walking in any good data structures book. The only special aspect of BSP walks is that a decision has to be made at each node about which way the node’s wall is facing relative to the viewpoint, so we know which child tree is nearer and which is farther.</p>
<p>Listing 59.1 shows a function that draws a BSP tree back-to-front. The decision whether a node’s wall is facing forward, made by <code>WallFacingForward()</code> in Listing 59.1, can, in general, be made by generating a normal to the node’s wall in screenspace (perspective-corrected space as seen from the viewpoint) and checking whether the z component of the normal is positive or negative, or by checking the sign of the dot product of a viewspace (non-perspective corrected space as seen from the viewpoint) normal and a ray from the viewpoint to the wall. In 2-D, the decision can be made by enforcing the convention that when a wall is viewed from the front, the start vertex is leftmost; then a simple screenspace comparison of the x coordinates of the left and right vertices indicates which way the wall is facing.</p>
<p><strong>Listing 59.1 L59_1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> WalkBSPTree(NODE *pNode)
{
   <span class="kw">if</span> (WallFacingForward(pNode) {
      <span class="kw">if</span> (pNode-&gt;BackChild) {
         WalkBSPTree(pNode-&gt;BackChild);
      }
      Draw(pNode);
      <span class="kw">if</span> (pNode-&gt;FrontChild) {
         WalkBSPTree(pNode-&gt;FrontChild);
      }
   } <span class="kw">else</span> {
      <span class="kw">if</span> (pNode-&gt;FrontChild) {
         WalkBSPTree(pNode-&gt;FrontChild);
      }
      Draw(pNode);
      <span class="kw">if</span> (pNode-&gt;BackChild) {
         WalkBSPTree(pNode-&gt;BackChild);
      }
   }
}</code></pre>
<blockquote>
<p><img src="images/i.jpg" /> Be aware that BSP trees can often be made smaller and more efficient by detecting collinear surfaces (like aligned wall segments) and generating only one BSP node for each collinear set, with the collinear surfaces stored in, say, a linked list attached to that node. Collinear surfaces partition space identically and can’t occlude one another, so it suffices to generate one splitting node for each collinear set.</p>
</blockquote>
</section>
</section>
<section id="inorder-walks-of-bsp-trees" class="level3">
<h3><a href="#inorder-walks-of-bsp-trees">Inorder Walks of BSP Trees</a></h3>
<p>It was implementing BSP trees that got me to thinking about inorder tree traversal. In inorder traversal, the left subtree of each node gets visited first, then the node, and then the right subtree. You apply this sequence recursively to each node and its children until the entire tree has been visited, as shown in Figure 59.9. Walking a BSP tree is basically an inorder tree walk; the only difference is that with a BSP tree a decision is made before each descent as to which subtree to visit first, rather than simply visiting whatever’s pointed to by the left-subtree pointer. Conceptually, however, an inorder walk is what’s used to traverse a BSP tree; from now on I’ll discuss normal inorder walking, with the understanding that the same principles apply to BSP trees.</p>
<p>As I’ve said again and again in my printed works over the years, you have to dig deep below the surface to <em>really</em> understand something if you want to get it right, and inorder walking turns out to be an excellent example of this. In fact, it’s such a good example that I routinely use it as an interview question for programmer candidates, and, to my astonishment, not one interviewee has done a good job with this one yet. I ask the question in two stages, and I get remarkably consistent results.</p>
<p>First, I ask for an implementation of a function <code>WalkTree()</code> that visits each node in a passed-in tree in inorder sequence. Each candidate unhesitatingly writes something like the perfectly good code in Listings 59.2 and 59.3 shown next.</p>
<figure>
<img src="images/59-09.jpg" alt="Figure 59.9  An inorder walk of a BSP tree." /><figcaption><strong>Figure 59.9</strong>  <em>An inorder walk of a BSP tree.</em></figcaption>
</figure>
<p><strong>Listing 59.2 L59_2.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Function to inorder walk a tree, using code recursion.</span>
<span class="co">// Tested with 32-bit Visual C++ 1.10.</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &quot;tree.h&quot;</span>
<span class="kw">extern</span> <span class="dt">void</span> Visit(NODE *pNode);
<span class="dt">void</span> WalkTree(NODE *pNode)
{
   <span class="co">// Make sure the tree isn&#39;t empty</span>
   <span class="kw">if</span> (pNode != NULL)
   {
      <span class="co">// Traverse the left subtree, if there is one</span>
      <span class="kw">if</span> (pNode-&gt;pLeftChild != NULL)
      {
         WalkTree(pNode-&gt;pLeftChild);
      }
      <span class="co">// Visit this node</span>
      Visit(pNode);
      <span class="co">// Traverse the right subtree, if there is one</span>
      <span class="kw">if</span> (pNode-&gt;pRightChild != NULL)
      {
         WalkTree(pNode-&gt;pRightChild);
      }
   }
}</code></pre>
<p><strong>Listing 59.3 L59_3.H</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Header file TREE.H for tree-walking code.</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _NODE {
  <span class="kw">struct</span> _NODE *pLeftChild;
  <span class="kw">struct</span> _NODE *pRightChild;
} NODE;</code></pre>
<p>Then I ask if they have any idea how to make the code faster; some don’t, but most point out that function calls are pretty expensive. Either way, I then ask them to rewrite the function without code recursion.</p>
<p>And then I sit back and squirm for a minimum of 15 minutes.</p>
<p>I have never had <em>anyone</em> write a functional data-recursion inorder walk function in less time than that, and several people have simply never gotten the code to work at all. Even the best of them have fumbled their way through the code, sticking in a push here or a pop there, then working through sample scenarios in their head to see what’s broken, programming by trial and error until the errors seem to be gone. No one is ever sure they have it right; instead, when they can’t find any more bugs, they look at me hopefully to see if it’s thumbs-up or thumbs-down.</p>
<p>And yet, a data-recursive inorder walk implementation has exactly the same flowchart and <em>exactly</em> the same functionality as the code-recursive version they’ve already written. They already have a fully functional model to follow, with all the problems solved, but they can’t make the connection between that model and the code they’re trying to implement. Why is this?</p>
<section id="know-it-cold" class="level4">
<h4><a href="#know-it-cold">Know It <em>Cold</em></a></h4>
<p>The problem is that these people don’t understand inorder walking through and through. They understand the concepts of visiting left and right subtrees, and they have a general picture of how traversal moves about the tree, but they do not understand exactly what the code-recursive version does. If they really comprehended everything that happens in each iteration of <code>WalkTree()</code>—how each call saves the state, and what that implies for the order in which operations are performed—they would simply and without fuss implement code like that in Listing 59.4, working with the code-recursive version as a model.</p>
<p><strong>Listing 59.4 L59_4.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Function to inorder walk a tree, using data recursion.</span>
<span class="co">// No stack overflow testing is performed.</span>
<span class="co">// Tested with 32-bit Visual C++ 1.10.</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &quot;tree.h&quot;</span>
<span class="ot">#define MAX_PUSHED_NODES   100</span>
<span class="kw">extern</span> <span class="dt">void</span> Visit(NODE *pNode);
<span class="dt">void</span> WalkTree(NODE *pNode)
{
   NODE *NodeStack[MAX_PUSHED_NODES];
   NODE **pNodeStack;
   <span class="co">// Make sure the tree isn&#39;t empty</span>
   <span class="kw">if</span> (pNode != NULL)
   {
      NodeStack[<span class="dv">0</span>] = NULL;  <span class="co">// push &quot;stack empty&quot; value</span>
      pNodeStack = NodeStack + <span class="dv">1</span>;
      <span class="kw">for</span> (;;)
      {
         <span class="co">// If the current node has a left child, push</span>
         <span class="co">// the current node and descend to the left</span>
         <span class="co">// child to start traversing the left subtree.</span>
         <span class="co">// Keep doing this until we come to a node</span>
         <span class="co">// with no left child; that&#39;s the next node to</span>
         <span class="co">// visit in inorder sequence</span>
         <span class="kw">while</span> (pNode-&gt;pLeftChild != NULL)
         {
            *pNodeStack++ = pNode;
            pNode = pNode-&gt;pLeftChild;
         }
         <span class="co">// We&#39;re at a node that has no left child, so</span>
         <span class="co">// visit the node, then visit the right</span>
         <span class="co">// subtree if there is one, or the last-</span>
         <span class="co">// pushed node otherwise; repeat for each</span>
         <span class="co">// popped node until one with a right</span>
         <span class="co">// subtree is found or we run out of pushed</span>
         <span class="co">// nodes (note that the left subtrees of</span>
         <span class="co">// pushed nodes have already been visited, so</span>
         <span class="co">// they&#39;re equivalent at this point to nodes</span>
         <span class="co">// with no left children)</span>
         <span class="kw">for</span> (;;)
         {
            Visit(pNode);
            <span class="co">// If the node has a right child, make</span>
            <span class="co">// the child the current node and start</span>
            <span class="co">// traversing that subtree; otherwise, pop</span>
            <span class="co">// back up the tree, visiting nodes we</span>
            <span class="co">// passed on the way down, until we find a</span>
            <span class="co">// node with a right subtree to traverse</span>
            <span class="co">// or run out of pushed nodes and are done</span>
            <span class="kw">if</span> (pNode-&gt;pRightChild != NULL)
            {
               <span class="co">// Current node has a right child;</span>
               <span class="co">// traverse the right subtree</span>
               pNode = pNode-&gt;pRightChild;
               <span class="kw">break</span>;
            }
            <span class="co">// Pop the next node from the stack so</span>
            <span class="co">// we can visit it and see if it has a</span>
            <span class="co">// right subtree to be traversed</span>
            <span class="kw">if</span> ((pNode = *—pNodeStack) == NULL)
            {
               <span class="co">// Stack is empty and the current node</span>
               <span class="co">// has no right child; we&#39;re done</span>
               <span class="kw">return</span>;
            }
         }
      }
   }
}</code></pre>
<p>Take a few minutes to look over Listing 59.4 and relate it to Listing 59.2. The structure is different, but upon examination it becomes clear that both listings reflect the same underlying model: For each node, visit the left subtree, visit the node, visit the right subtree. And although Listing 59.4 is longer, that’s mostly because I commented it heavily to make sure its workings are understood; there are only 13 lines that actually do anything in Listing 59.4.</p>
<p>Let’s look at it another way. All the code in Listing 59.2 does is say: “Here I am at a node. First I’ll visit the left subtree if there is one, then I’ll visit this node, then I’ll visit the right subtree if there is one. While I’m visiting the left subtree, I’ll just push a marker on a stack that tells me to come back here when the left subtree is done. If, after visiting a node, there are no right children to visit and nothing left on the stack, I’m finished. The code does this at each node—and that’s <em>all</em> it does. That’s all Listing 59.4 does, too, but people tend to get tangled up in pushes and pops and <code>while</code> loops when they use data recursion. When the implementation model changes to one with which they are unfamiliar, they abandon the perfectly good model they used before and try to rederive it in the new context by the seat of their pants.</p>
<blockquote>
<p><img src="images/i.jpg" /> Here’s a secret when you’re faced with a situation like this: Step back and get a clear picture of what your code has to do. Omit no steps. You should build a model that is so consistent and solid that you can instantly answer any question about how the code should behave in any situation. For example, my interviewees often decide, by trial and error, that there are two distinct types of right children: Right children visited after popping back to visit a node after the left subtree has been visited, and right children visited after descending to a node that has no left child. This makes the traversal code a mass of special cases, each of which has to be detected by the programmer by trying out scenarios. Worse, you can never be sure with this approach that you’ve caught all the special cases.</p>
<p>The alternative is to develop and apply a unifying model. There aren’t really two types of right children; the rule is that all right children are visited after their parents are visited, period. The presence or absence of a left child is irrelevant. The possibility that a right child may be reached via different code paths depending on the presence of a left child does not affect the overall model. While this distinction may seem trivial it is in fact crucial, because if you have the model down cold, you can always tell if the implementation is correct by comparing it with the model.</p>
</blockquote>
</section>
<section id="measure-and-learn" class="level4">
<h4><a href="#measure-and-learn">Measure and Learn</a></h4>
<p>How much difference does all this fuss make, anyway? Listing 59.5 is a sample program that builds a tree, then calls <code>WalkTree</code> () to walk it 1,000 times, and times how long this takes. Using 32-bit Visual C++ 1.10 running on Windows NT, with default optimization selected, Listing 59.5 reports that Listing 59.4 is about 20 percent faster than Listing 59.2 on a 486/33, a reasonable return for a little code rearrangement, especially when you consider that the speedup is diluted by calling the <code>Visit()</code> function and by the cache miss that happens on virtually every node access. (Listing 59.5 builds a rather unique tree, one in which every node has exactly two children. Different sorts of trees can and do produce different performance results. Always know what you’re measuring!)</p>
<p><strong>Listing 59.5 L59_5.C</strong></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Sample program to exercise and time the performance of</span>
<span class="co">// implementations of WalkTree().</span>
<span class="co">// Tested with 32-bit Visual C++ 1.10 under Windows NT.</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;conio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;time.h&gt;</span>
<span class="ot">#include &quot;tree.h&quot;</span>
<span class="dt">long</span> VisitCount = <span class="dv">0</span>;
<span class="dt">void</span> main(<span class="dt">void</span>);
<span class="dt">void</span> BuildTree(NODE *pNode, <span class="dt">int</span> RemainingDepth);
<span class="kw">extern</span> <span class="dt">void</span> WalkTree(NODE *pRootNode);
<span class="dt">void</span> main()
{
   NODE RootNode;
   <span class="dt">int</span> i;
   <span class="dt">long</span> StartTime;
   <span class="co">// Build a sample tree</span>
   BuildTree(&amp;RootNode, <span class="dv">14</span>);
   <span class="co">// Walk the tree 1000 times and see how long it takes</span>
   StartTime = time(NULL);
   <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">1000</span>; i++)
   {
      WalkTree(&amp;RootNode);
   }
   printf(<span class="st">&quot;Seconds elapsed: %ld</span><span class="ch">\n</span><span class="st">&quot;</span>,
           time(NULL) - StartTime);
   getch();
}
<span class="co">//</span>
<span class="co">// Function to add right and left subtrees of the</span>
<span class="co">// specified depth off the passed-in node.</span>
<span class="co">//</span>
<span class="dt">void</span> BuildTree(NODE *pNode, <span class="dt">int</span> RemainingDepth)
{
   <span class="kw">if</span> (RemainingDepth == <span class="dv">0</span>)
   {
      pNode-&gt;pLeftChild = NULL;
      pNode-&gt;pRightChild = NULL;
   }
   <span class="kw">else</span>
   {
      pNode-&gt;pLeftChild = malloc(<span class="kw">sizeof</span>(NODE));
      <span class="kw">if</span> (pNode-&gt;pLeftChild == NULL)
      {
         printf(<span class="st">&quot;Out of memory</span><span class="ch">\n</span><span class="st">&quot;</span>);
         exit(<span class="dv">1</span>);
      }
      pNode-&gt;pRightChild = malloc(<span class="kw">sizeof</span>(NODE));
      <span class="kw">if</span> (pNode-&gt;pRightChild == NULL)
      {
         printf(<span class="st">&quot;Out of memory</span><span class="ch">\n</span><span class="st">&quot;</span>);
         exit(<span class="dv">1</span>);
      }
      BuildTree(pNode-&gt;pLeftChild, RemainingDepth - <span class="dv">1</span>);
      BuildTree(pNode-&gt;pRightChild, RemainingDepth - <span class="dv">1</span>);
   }
}
<span class="co">//</span>
<span class="co">// Node-visiting function so WalkTree() has something to</span>
<span class="co">// call.</span>
<span class="co">//</span>
<span class="dt">void</span> Visit(NODE *pNode)
{
   VisitCount++;
}</code></pre>
<p>Things change when maximum optimization is selected, however: The performance of the two implementations becomes virtually identical! How can this be? Part of the answer is that the compiler does an amazingly good job with Listing 59.2. Most impressively, when compiling Listing 59.2, the compiler actually converts all right-subtree descents from code recursion to data recursion, by simply jumping back to the left-subtree handling code instead of recursively calling <code>WalkTree()</code>. This means that half the time Listing 59.4 has no advantage over Listing 59.2; in fact, it’s at a disadvantage because the code that the compiler generates for handling right-subtree descent in Listing 59.4 is somewhat inefficient, but the right-subtree code in Listing 59.2 is a marvel of code generation, at just 3 instructions.</p>
<p>What’s more, although left-subtree traversal is more efficient with data recursion than with code recursion, the advantage is only four instructions, because only one parameter is passed and because the compiler doesn’t bother setting up an EBP-based stack frame, instead it uses ESP to address the stack. (And, in fact, this cost could be reduced still further by eliminating the check for a NULL <code>pNode</code> at all but the top level.) There are other interesting aspects to what the compiler does with Listings 59.2 and 59.4 but that’s enough to give you the idea. It’s worth noting that the compiler might not do as well with code recursion in a more complex function, and that a good assembly language implementation could probably speed up Listing 59.4 enough to make it measurably faster than Listing 59.2, but not even close to being <em>enough</em> faster to be worth the effort.</p>
<p>The moral of this story (apart from it being a good idea to enable compiler optimization) is:</p>
<ol type="1">
<li><p>Understand what you’re doing, through and through.</p></li>
<li><p>Build a complete and consistent model in your head.</p></li>
<li><p>Design from the principles that the model provides.</p></li>
<li><p>Implement the design.</p></li>
<li><p>Measure to learn what you’ve wrought.</p></li>
<li><p>Go back to step 1 and apply what you’ve just learned.</p></li>
</ol>
<p>With each iteration you’ll dig deeper, learn more, and improve your ability to know where and how to focus your design and programming efforts. For example, with the C compilers I used five to 10 years ago, back when I learned about the relative strengths and weaknesses of code and data recursion, and with the processors then in use, Listing 59.4 would have blown away Listing 59.2. While doing this chapter, I’ve learned that given current processors and compiler technology, data recursion isn’t going to get me any big wins; and yes, that was news to me. That’s <em>good</em>; this information saves me from wasted effort in the future and tells me what to concentrate on when I use recursion.</p>
<p>Assume nothing, keep digging deeper, and never stop learning and growing. The world won’t hold still for you, but fortunately you <em>can</em> run fast enough to keep up if you just keep at it.</p>
<p>Depths within depths indeed!</p>
</section>
</section>
<section id="surfing-amidst-the-trees" class="level3">
<h3><a href="#surfing-amidst-the-trees">Surfing Amidst the Trees</a></h3>
<p>In the next chapter, we’ll build a BSP-tree compiler, and after that, we’ll put together a rendering system built around the BSP trees the compiler generates. If the subject of BSP trees really grabs your fancy (as it should if you care at all about performance graphics) there is at this writing (February 1996) a World Wide Web page on BSP trees that you must investigate at <a href="http://www.qualia.com/bspfaq/">http://www.qualia.com/bspfaq/</a>. It’s set up in the familiar Internet Frequently Asked Questions (FAQ) style, and is very good stuff.</p>
<section id="related-reading" class="level4">
<h4><a href="#related-reading">Related Reading</a></h4>
<p>Foley, J., A. van Dam, S. Feiner, and J. Hughes, <em>Computer Graphics: Principles and Practice (Second Edition)</em>, Addison Wesley, 1990, pp. 555-557, 675-680.</p>
<p>Fuchs, H., Z. Kedem, and B. Naylor, “On Visible Surface Generation by A Priori Tree Structures,” <em>Computer Graphics</em> Vol. 17(3), June 1980, pp. 124-133.</p>
<p>Gordon, D., and S. Chen, “Front-to-Back Display of BSP Trees,” <em>IEEE Computer Graphics and Applications,</em> September 1991, pp. 79-85.</p>
<p>Naylor, B., “Binary Space Partitioning Trees as an Alternative Representation of Polytopes,” <em>Computer Aided Design</em>, Vol. 22(4), May 1990, pp. 250-253.</p>
</section>
</section>
</section>
<section id="chapter-60-compiling-bsp-trees" class="level2">
<h2><a href="#chapter-60-compiling-bsp-trees">Chapter 60 – Compiling BSP Trees</a></h2>
<section id="taking-bsp-trees-from-concept-to-reality" class="level3">
<h3><a href="#taking-bsp-trees-from-concept-to-reality">Taking BSP Trees from Concept to Reality</a></h3>
<p>As long-time readers of my columns know, I tend to move my family around the country quite a bit. Change doesn’t come out of the blue, so there’s some interesting history to every move, but the roots of the latest move go back even farther than usual. To wit:</p>
<p>In 1986, just after we moved from Pennsylvania to California, I started writing a column for <em>Programmer’s Journal</em>. I was paid peanuts for writing it, and I doubt if even 5,000 people saw some of the first issues the columns appeared in, but I had a lot of fun exploring fast graphics for the EGA and VGA.</p>
<p>By 1991, we were in Vermont, and I was writing the <em>Graphics Programming</em> column for <em>Dr. Dobb’s Journal</em> (and having a great time doing it, even though it took all my spare nights and weekends to stay ahead of the deadlines). In those days I received a lot of unsolicited evaluation software, including a PC shareware game called Commander Keen, a side-scrolling game that was every bit as good as the hot Nintendo games of the day. I loved the way the game looked, and actually drafted a column opening about how for years I’d been claiming that the PC could be a great game machine in the hands of great programmers, and here, finally, was the proof, in the form of Commander Keen. In the end, though, I decided that would be too close to a product review, an area that I’ve observed inflames passions in nonconstructive ways, so I went with a different opening.</p>
<p>In 1992, I did a series of columns about my X-Sharp 3-D library, and hung out on <em>DDJ</em>’s bulletin board. There was another guy who hung out there who knew a lot about 3-D, a fellow named John Carmack who was surely the only game programmer I’d ever heard of who developed under NEXTSTEP. When we moved to Redmond, I didn’t have time for BBSs anymore, though.</p>
<p>In early 1993, I hired Chris Hecker. Later that year, Chris showed me an alpha copy of DOOM, and I nearly fell out of my chair. About a year later, Chris forwarded me a newsgroup post about NEXTSTEP, and said, “Isn’t this the guy you used to know on the <em>DDJ</em> bulletin board?” Indeed it was John Carmack; what’s more, it turned out that John was the guy who had written DOOM. I sent him a congratulatory piece of mail, and he sent back some thoughts about what he was working on, and somewhere in there I asked if he ever came up my way. It turned out he had family in Seattle, so he stopped in and visited, and we had a great time.</p>
<p>Over the next year, we exchanged some fascinating mail, and I became steadily more impressed with John’s company, id Software. Eventually, John asked if I’d be interested in joining id, and after a good bit of consideration I couldn’t think of anything else that would be as much fun or teach me as much. The upshot is that here we all are in Dallas, our fourth move of 2,000 miles or more since I’ve starting writing in the computer field, and now I’m writing some seriously cool 3-D software.</p>
<p>Now that I’m here, it’s an eye-opener to look back and see how events fit together over the last decade. You see, when John started doing PC game programming he learned fast graphics programming from those early <em>Programmer’s Journal</em> articles of mine. The copy of Commander Keen that validated my faith in the PC as a game machine was the fruit of those articles, for that was an id game (although I didn’t know that then). When John was hanging out on the <em>DDJ</em> BBS, he had just done Castle Wolfenstein 3-D, the first great indoor 3-D game, and was thinking about how to do DOOM. (If only I’d known that then!) And had I not hired Chris, or had he not somehow remembered me talking about that guy who used NEXTSTEP, I’d never have gotten back in touch with John, and things would surely be different. (At the very least, I wouldn’t be hearing jokes about how my daughter’s going to grow up saying “y’all”.)</p>
<p>I think there’s a worthwhile lesson to be learned from all this, a lesson that I’ve seen hold true for many other people, as well. If you do what you love, and do it as well as you can, good things will eventually come of it. Not necessarily quickly or easily, but if you stick with it, they will come. There are threads that run through our lives, and by the time we’ve been adults for a while, practically everything that happens has roots that run far back in time. The implication should be clear: If you want good things to happen in your future, stretch yourself and put in the extra effort now at whatever you care passionately about, so those roots will have plenty to work with down the road.</p>
<p>All this is surprisingly closely related to this chapter’s topic, BSP trees, because John is the fellow who brought BSP trees into the spotlight by building DOOM around them. He also got me started with BSP trees by explaining how DOOM worked and getting me interested enough to want to experiment; the BSP compiler in this article is the direct result. Finally, John has been an invaluable help to me as I’ve learned about BSP trees, as will become evident when we discuss BSP optimization.</p>
<p>Onward to compiling BSP trees.</p>
</section>
<section id="compiling-bsp-trees" class="level3">
<h3><a href="#compiling-bsp-trees">Compiling BSP Trees</a></h3>
<p>As you’ll recall from the previous chapter, a BSP tree is nothing more than a series of binary subdivisions that partion space into ever-smaller pieces. That’s a simple data structure, and a BSP compiler is a correspondingly simple tool. First, it groups all the surfaces (lines in 2-D, or polygons in 3-D) together into a single subspace that encompasses the entire world of the database. Then, it chooses one of the surfaces as the root node, and uses its line or plane to divide the remaining surfaces into two subspaces, splitting surfaces into two parts if they cross the line or plane of the root. Each of the two resultant subspaces is then processed in the same fashion, and so on, recursively, until the point is reached where all surfaces have been assigned to nodes, and each leaf surface subdivides a subspace that is empty except for that surface. Put another way, the root node carves space into two parts, and the root’s children carve each of those parts into two more parts, and so on, with each surface carving ever smaller subspaces, until all surfaces have been used. (Actually, there are many other lines or planes that a BSP tree can use to carve up space, but this is the approach we’ll use in the current discussion.)</p>
<p>If you find any of the above confusing (and it would be understandable if that were the case; BSP trees are not easy to get the hang of), you might want to refer back to the previous chapter. It would also be a good idea to get hold of the visual BSP compiler I’ll discuss shortly; when it comes to understanding BSP trees, there’s nothing quite like seeing one being built.</p>
<p>So there are really only two interesting operations in building a BSP tree: choosing a root node for the current subspace (a “splitter”) and assigning surfaces to one side or another of the current root node, splitting any that straddle the splitter. We’ll get to the issue of choosing splitters shortly, but first let’s look at the process of splitting and assigning. To do that, we need to understand parametric lines.</p>
<section id="parametric-lines" class="level4">
<h4><a href="#parametric-lines">Parametric Lines</a></h4>
<p>We’re all familiar with lines described in slope-intercept form, with y as a function of x</p>
<p>y = mx + b</p>
<p>but there’s another sort of line description that’s very useful for clipping (and for a variety of 3-D purposes, such as curved surfaces and texture mapping): <em>parametric lines</em>. In parametric lines, x and y are decoupled from one another, and are instead described as a function of the parameter t:</p>
<p>x = x<sub>start</sub> + t(x<sub>end</sub> - x<sub>start</sub>)<br /> y = y<sub>start</sub> + t(y<sub>end</sub> - y<sub>start</sub>)</p>
<p>This can be summarized as</p>
<p>L = L<sub>start</sub> + t(L<sub>end</sub> - L<sub>start</sub>)</p>
<p>where L = (x, y).</p>
<p>Figure 60.1 shows how a parametric line works. The t parameter describes how far along a line segment the current x and y coordinates are. Note that this description is valid not only for the line segment, but also for the entire infinite line; however, only points with t values between 0 and 1 are actually on the line segment.</p>
<p>In our 2-D BSP compiler (as you’ll recall from the previous chapter, we’re working with 2-D trees for simplicity, but the principles generalize to 3-D), we’ll represent our walls (all vertical) as line segments viewed from above. The segments will be stored in parametric form, with the endpoints of the original line segment and two t values describing the endpoints of the current (possibly clipped) segment providing a complete specification for each segment, as shown in Figure 60.2.</p>
<p>What does that do for us? For one thing, it keeps clipping errors from creeping in, because clipped line segments are always based on the original line segment, not derived from clipped versions. Also, it’s potentially a more compact format, because we need to store the endpoints only for the original line segments; for clipped line segments, we can just store pairs of t values, along with a pointer to the original line segment. The biggest win, however, is that it allows us to use parametric line clipping, a very clean form of clipping, indeed.</p>
<figure>
<img src="images/60-01.jpg" alt="Figure 60.1  A sample parametric line." /><figcaption><strong>Figure 60.1</strong>  <em>A sample parametric line.</em></figcaption>
</figure>
<figure>
<img src="images/60-02.jpg" alt="Figure 60.2  Line segment storage in the BSP compiler." /><figcaption><strong>Figure 60.2</strong>  <em>Line segment storage in the BSP compiler.</em></figcaption>
</figure>
</section>
<section id="parametric-line-clipping" class="level4">
<h4><a href="#parametric-line-clipping">Parametric Line Clipping</a></h4>
<p>In order to assign a line segment to one subspace or the other of a splitter, we must somehow figure out whether the line segment straddles the splitter or falls on one side or the other. In order to determine that, we first plug the line segment and splitter into the following parametric line intersection equation</p>
<p>number = N (L<sub>start</sub> - S<sub>start</sub>) (Equation 1)<br /> denom = -N (L<sub>end</sub> - L<sub>start</sub>) (Equation 2)<br /> t<sub>intersect</sub> = number / denom (Equation 3)</p>
<p>where N is the normal of the splitter, S<sub>start</sub> is the start point of the splitting line segment in standard (x,y) form, and L<sub>start</sub> and L<sub>end</sub> are the endpoints of the line segment being split, again in (x,y) form. Figure 60.3 illustrates the intersection calculation. Due to lack of space, I’m just going to present this equation and its implications as fact, rather than deriving them; if you want to know more, there’s an excellent explanation on page 117 of <em>Computer Graphics: Principles and Practice,</em> by Foley and van Dam (Addison Wesley, ISBN 0-201-12110-7), a book that you should certainly have in your library.</p>
<p>If the denominator is zero, we know that the lines are parallel and don’t intersect, so we don’t divide, but rather check the sign of the numerator, which tells us which side of the splitter the line segment is on. Otherwise, we do the division, and the result is the t value for the intersection point, as shown in Figure 60.3. We then simply compare the t value to the t values of the endpoints of the line segment being split. If it’s between them, that’s where we split the line segment, otherwise, we can tell which side of the splitter the line segment is on by which side of the line segment’s t range it’s on. Simple comparisons do all the work, and there’s no need to do the work of generating actual x and y values. If you look closely at Listing 60.1, the core of the BSP compiler, you’ll see that the parametric clipping code itself is exceedingly short and simple.</p>
<figure>
<img src="images/60-03.jpg" alt="Figure 60.3  How line intersection is calculated." /><figcaption><strong>Figure 60.3</strong>  <em>How line intersection is calculated.</em></figcaption>
</figure>
<p>One interesting point about Listing 60.1 is that it generates normals to splitting surfaces simply by exchanging the x and y lengths of the splitting line segment and negating the resultant y value, thereby rotating the line 90 degrees. In 3-D, it’s not that simple to come by a normal; you could calculate the normal as the cross-product of two of the polygon’s edges, or precalculate it when you build the world database.</p>
</section>
<section id="the-bsp-compiler" class="level4">
<h4><a href="#the-bsp-compiler">The BSP Compiler</a></h4>
<p>Listing 60.1 shows the core of a BSP compiler—the code that actually builds the BSP tree. (Note that Listing 60.1 is excerpted from a C++ .CPP file, but in fact what I show here is very close to straight C. It may even compile as a .C file, though I haven’t checked.) The compiler begins by setting up an empty tree, then passes that tree and the complete set of line segments from which a BSP tree is to be generated to <code>SelectBSPTree()</code>, which chooses a root node and calls <code>BuildBSPTree()</code> to add that node to the tree and generate child trees for each of the node’s two subspaces. <code>BuildBSPTree()</code> calls <code>SelectBSPTree()</code> recursively to select a root node for each of those child trees, and this continues until all lines have been assigned nodes. <code>SelectBSP()</code> uses parametric clipping to decide on the splitter, as described below, and <code>BuildBSPTree()</code> uses parametric clipping to decide which subspace of the splitter each line belongs in, and to split lines, if necessary.</p>
<p><strong>Listing 60.1 L60_1.CPP</strong></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAX_NUM_LINESEGS 1000</span>
<span class="ot">#define MAX_INT          0x7FFFFFFF</span>
<span class="ot">#define MATCH_TOLERANCE  0.00001</span>
<span class="co">// A vertex</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _VERTEX
{
   <span class="dt">double</span> x;
   <span class="dt">double</span> y;
} VERTEX;
<span class="co">// A potentially split piece of a line segment, as processed from the</span>
<span class="co">// base line in the original list</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _LINESEG
{
   _LINESEG *pnextlineseg;
    <span class="dt">int</span> startvertex;
    <span class="dt">int</span> endvertex;
    <span class="dt">double</span> walltop;
    <span class="dt">double</span> wallbottom;
    <span class="dt">double</span> tstart;
    <span class="dt">double</span> tend;
    <span class="dt">int</span> color;
    _LINESEG *pfronttree;
    _LINESEG *pbacktree;
} LINESEG, *PLINESEG;
<span class="dt">static</span> VERTEX *pvertexlist;
<span class="dt">static</span> <span class="dt">int</span> NumCompiledLinesegs = <span class="dv">0</span>;
<span class="dt">static</span> LINESEG *pCompiledLinesegs;
<span class="co">// Builds a BSP tree from the specified line list. List must contain</span>
<span class="co">// at least one entry. If pCurrentTree is NULL, then this is the root</span>
<span class="co">// node, otherwise pCurrentTree is the tree that&#39;s been build so far.</span>
<span class="co">// Returns NULL for errors.</span>
LINESEG * SelectBSPTree(LINESEG * plineseghead,
    LINESEG * pCurrentTree, LINESEG ** pParentsChildPointer)
{
    LINESEG *pminsplit;
    <span class="dt">int</span> minsplits;
    <span class="dt">int</span> tempsplitcount;
    LINESEG *prootline;
    LINESEG *pcurrentline;
    <span class="dt">double</span> nx, ny, numer, denom, t;
    <span class="co">// Pick a line as the root, and remove it from the list of lines</span>
    <span class="co">// to be categorized. The line we&#39;ll select is the one of those in</span>
    <span class="co">// the list that splits the fewest of the other lines in the list</span>
    minsplits = MAX_INT;
    prootline = plineseghead;
    <span class="kw">while</span> (prootline != NULL) {
        pcurrentline = plineseghead;
        tempsplitcount = <span class="dv">0</span>;
        <span class="kw">while</span> (pcurrentline != NULL) {
            <span class="co">// See how many other lines the current line splits</span>
            nx = pvertexlist[prootline-&gt;startvertex].y -
                    pvertexlist[prootline-&gt;endvertex].y;
            ny = -(pvertexlist[prootline-&gt;startvertex].x -
                    pvertexlist[prootline-&gt;endvertex].x);
            <span class="co">// Calculate the dot products we&#39;ll need for line</span>
            <span class="co">// intersection and spatial relationship</span>
            numer = (nx * (pvertexlist[pcurrentline-&gt;startvertex].x -
                    pvertexlist[prootline-&gt;startvertex].x)) +
                    (ny * (pvertexlist[pcurrentline-&gt;startvertex].y -
                    pvertexlist[prootline-&gt;startvertex].y));
            denom = ((-nx) * (pvertexlist[pcurrentline-&gt;endvertex].x -
                    pvertexlist[pcurrentline-&gt;startvertex].x)) +
                    ((-ny) * (pvertexlist[pcurrentline-&gt;endvertex].y -
                    pvertexlist[pcurrentline-&gt;startvertex].y));
            <span class="co">// Figure out if the infinite lines of the current line</span>
            <span class="co">// and the root intersect; if so, figure out if the</span>
            <span class="co">// current line segment is actually split, split if so,</span>
            <span class="co">// and add front/back polygons as appropriate</span>
            <span class="kw">if</span> (denom == <span class="fl">0.0</span>) {
                <span class="co">// No intersection, because lines are parallel; no</span>
                <span class="co">// split, so nothing to do</span>
            } <span class="kw">else</span> {
                <span class="co">// Infinite lines intersect; figure out whether the</span>
                <span class="co">// actual line segment intersects the infinite line</span>
                <span class="co">// of the root, and split if so</span>
                t =  numer / denom;
                <span class="kw">if</span> ((t &gt; pcurrentline-&gt;tstart) &amp;&amp;
                        (t &lt; pcurrentline-&gt;tend)) {
                    <span class="co">// The root splits the current line</span>
                    tempsplitcount++;
                } <span class="kw">else</span> {
                    <span class="co">// Intersection outside segment limits, so no</span>
                    <span class="co">// split, nothing to do</span>
                }
            }
            pcurrentline = pcurrentline-&gt;pnextlineseg;
        }
        <span class="kw">if</span> (tempsplitcount &lt; minsplits) {
            pminsplit = prootline;
            minsplits = tempsplitcount;
        }
        prootline = prootline-&gt;pnextlineseg;
    }
    <span class="co">// For now, make this a leaf node so we can traverse the tree</span>
    <span class="co">// as it is at this point. BuildBSPTree() will add children as</span>
    <span class="co">// appropriate</span>
    pminsplit-&gt;pfronttree = NULL;
    pminsplit-&gt;pbacktree = NULL;
    <span class="co">// Point the parent&#39;s child pointer to this node, so we can</span>
    <span class="co">// track the currently-build tree</span>
    *pParentsChildPointer = pminsplit;
    <span class="kw">return</span> BuildBSPTree(plineseghead, pminsplit, pCurrentTree);
}
<span class="co">// Builds a BSP tree given the specified root, by creating front and</span>
<span class="co">// back lists from the remaining lines, and calling itself recursively</span>
LINESEG * BuildBSPTree(LINESEG * plineseghead, LINESEG * prootline,
    LINESEG * pCurrentTree)
{
    LINESEG *pfrontlines;
    LINESEG *pbacklines;
    LINESEG *pcurrentline;
    LINESEG *pnextlineseg;
    LINESEG *psplitline;
    <span class="dt">double</span> nx, ny, numer, denom, t;
    <span class="dt">int</span> Done;
    <span class="co">// Categorize all non-root lines as either in front of the root&#39;s</span>
    <span class="co">// infinite line, behind the root&#39;s infinite line, or split by the</span>
    <span class="co">// root&#39;s infinite line, in which case we split it into two lines</span>
    pfrontlines = NULL;
    pbacklines = NULL;
    pcurrentline = plineseghead;
    <span class="kw">while</span> (pcurrentline != NULL)
    {
      <span class="co">// Skip the root line when encountered</span>
      <span class="kw">if</span> (pcurrentline == prootline) {
        pcurrentline = pcurrentline-&gt;pnextlineseg;
      } <span class="kw">else</span>  {
        nx = pvertexlist[prootline-&gt;startvertex].y -
                pvertexlist[prootline-&gt;endvertex].y;
        ny = -(pvertexlist[prootline-&gt;startvertex].x -
                pvertexlist[prootline-&gt;endvertex].x);
        <span class="co">// Calculate the dot products we&#39;ll need for line intersection</span>
        <span class="co">// and spatial relationship</span>
        numer = (nx * (pvertexlist[pcurrentline-&gt;startvertex].x -
                 pvertexlist[prootline-&gt;startvertex].x)) +
                (ny * (pvertexlist[pcurrentline-&gt;startvertex].y -
                 pvertexlist[prootline-&gt;startvertex].y));
        denom = ((-nx) * (pvertexlist[pcurrentline-&gt;endvertex].x -
                 pvertexlist[pcurrentline-&gt;startvertex].x)) +
                (-(ny) * (pvertexlist[pcurrentline-&gt;endvertex].y -
                 pvertexlist[pcurrentline-&gt;startvertex].y));
        <span class="co">// Figure out if the infinite lines of the current line and</span>
        <span class="co">// the root intersect; if so, figure out if the current line</span>
        <span class="co">// segment is actually split, split if so, and add front/back</span>
        <span class="co">// polygons as appropriate</span>
        <span class="kw">if</span> (denom == <span class="fl">0.0</span>) {
            <span class="co">// No intersection, because lines are parallel; just add</span>
            <span class="co">// to appropriate list</span>
            pnextlineseg = pcurrentline-&gt;pnextlineseg;
            <span class="kw">if</span> (numer &lt; <span class="fl">0.0</span>) {
                <span class="co">// Current line is in front of root line; link into</span>
                <span class="co">// front list</span>
                pcurrentline-&gt;pnextlineseg = pfrontlines;
                pfrontlines = pcurrentline;
            } <span class="kw">else</span> {
                <span class="co">// Current line behind root line; link into back list</span>
                pcurrentline-&gt;pnextlineseg = pbacklines;
                pbacklines = pcurrentline;
            }
            pcurrentline = pnextlineseg;
        } <span class="kw">else</span> {
            <span class="co">// Infinite lines intersect; figure out whether the actual</span>
            <span class="co">// line segment intersects the infinite line of the root,</span>
            <span class="co">// and split if so</span>
            t =  numer / denom;
            <span class="kw">if</span> ((t &gt; pcurrentline-&gt;tstart) &amp;&amp;
                    (t &lt; pcurrentline-&gt;tend)) {
                <span class="co">// The line segment must be split; add one split</span>
                <span class="co">// segment to each list</span>
                <span class="kw">if</span> (NumCompiledLinesegs &gt; (MAX_NUM_LINESEGS - <span class="dv">1</span>)) {
                    DisplayMessageBox(<span class="st">&quot;Out of space for line segs;&quot;</span>
                                 <span class="st">&quot;increase MAX_NUM_LINESEGS&quot;</span>);
                    <span class="kw">return</span> NULL;
                }
                <span class="co">// Make a new line entry for the split part of line</span>
                psplitline = &amp;pCompiledLinesegs[NumCompiledLinesegs];
                NumCompiledLinesegs++;
                *psplitline = *pcurrentline;
                psplitline-&gt;tstart = t;
                pcurrentline-&gt;tend = t;

                pnextlineseg = pcurrentline-&gt;pnextlineseg;
                <span class="kw">if</span> (numer &lt; <span class="fl">0.0</span>) {
                    <span class="co">// Presplit part is in front of root line; link</span>
                    <span class="co">// into front list and put postsplit part in back</span>
                    <span class="co">// list</span>
                    pcurrentline-&gt;pnextlineseg = pfrontlines;
                    pfrontlines = pcurrentline;
                    psplitline-&gt;pnextlineseg = pbacklines;
                    pbacklines = psplitline;
                } <span class="kw">else</span> {
                    <span class="co">// Presplit part is in back of root line; link</span>
                    <span class="co">// into back list and put postsplit part in front</span>
                    <span class="co">// list</span>
                    psplitline-&gt;pnextlineseg = pfrontlines;
                    pfrontlines = psplitline;
                    pcurrentline-&gt;pnextlineseg = pbacklines;
                    pbacklines = pcurrentline;
                }
                pcurrentline = pnextlineseg;
            } <span class="kw">else</span> {
                <span class="co">// Intersection outside segment limits, so no need to</span>
                <span class="co">// split; just add to proper list</span>
                pnextlineseg = pcurrentline-&gt;pnextlineseg;
                Done = <span class="dv">0</span>;
                <span class="kw">while</span> (!Done) {
                    <span class="kw">if</span> (numer &lt; -MATCH_TOLERANCE) {
                        <span class="co">// Current line is in front of root line;</span>
                        <span class="co">// link into front list</span>
                        pcurrentline-&gt;pnextlineseg = pfrontlines;
                        pfrontlines = pcurrentline;
                        Done = <span class="dv">1</span>;
                    } <span class="kw">else</span> <span class="kw">if</span> (numer &gt; MATCH_TOLERANCE) {
                        <span class="co">// Current line is behind root line; link</span>
                        <span class="co">// into back list</span>
                        pcurrentline-&gt;pnextlineseg = pbacklines;
                        pbacklines = pcurrentline;
                        Done = <span class="dv">1</span>;
                    } <span class="kw">else</span> {
                        <span class="co">// The point on the current line we picked to</span>
                        <span class="co">// do front/back evaluation happens to be</span>
                        <span class="co">// collinear with the root, so use the other</span>
                        <span class="co">// end of the current line and try again</span>
                        numer =
                            (nx *
                             (pvertexlist[pcurrentline-&gt;endvertex].x -
                              pvertexlist[prootline-&gt;startvertex].x))+
                            (ny *
                             (pvertexlist[pcurrentline-&gt;endvertex].y -
                              pvertexlist[prootline-&gt;startvertex].y));
                    }
                }
                pcurrentline = pnextlineseg;
            }
        }
      }
    }
    <span class="co">// Make a node out of the root line, with the front and back trees</span>
    <span class="co">// attached</span>
    <span class="kw">if</span> (pfrontlines == NULL) {
        prootline-&gt;pfronttree = NULL;
    } <span class="kw">else</span> {
        <span class="kw">if</span> (!SelectBSPTree(pfrontlines, pCurrentTree,
                          &amp;prootline-&gt;pfronttree)) {
            <span class="kw">return</span> NULL;
        }
    }
    <span class="kw">if</span> (pbacklines == NULL) {
        prootline-&gt;pbacktree = NULL;
    } <span class="kw">else</span> {
        <span class="kw">if</span> (!SelectBSPTree(pbacklines, pCurrentTree,
                          &amp;prootline-&gt;pbacktree)) {
            <span class="kw">return</span> NULL;
        }
    }
    <span class="kw">return</span>(prootline);
}</code></pre>
<p>Listing 60.1 isn’t very long or complex, but it’s somewhat more complicated than it could be because it’s structured to allow visual display of the ongoing compilation process. That’s because Listing 60.1 is actually just a part of a BSP compiler for Win32 that visually depicts the progressive subdivision of space as the BSP tree is built. (Note that Listing 60.1 might not compile as printed; I may have missed copying some global variables that it uses.) The complete code is too large to print here in its entirety, but it’s on the CD-ROM in file DDJBSP.ZIP.</p>
</section>
</section>
<section id="optimizing-the-bsp-tree" class="level3">
<h3><a href="#optimizing-the-bsp-tree">Optimizing the BSP Tree</a></h3>
<p>In the previous chapter, I promised that I’d discuss how to go about deciding which wall to use as the splitter at each node in constructing a BSP tree. That turns out to be a far more difficult problem than one might think, but we can’t ignore it, because the choice of splitter can make a huge difference.</p>
<p>Consider, for example, a BSP in which the line or plane of the splitter at the root node splits every single other surface in the world, doubling the total number of surfaces to be dealt with. Contrast that with a BSP built from the same surface set in which the initial splitter doesn’t split anything. Both trees provide a valid ordering, but one tree is much larger than the other, with twice as many polygons after the selection of just one node. Apply the same difference again to each node, and the relative difference in size (and, correspondingly, in traversal and rendering time) soon balloons astronomically. So we need to do <em>something</em> to optimize the BSP tree—but what? Before we can try to answer that, we need to know exactly what we’d like to optimize.</p>
<p>There are several possible optimization objectives in BSP compilation. We might choose to balance the tree as evenly as possible, thereby reducing the average depth to which the tree must be traversed. Alternatively, we might try to approximately balance the area or volume on either side of each splitter. That way we don’t end up with huge chunks of space in some tree branches and tiny slivers in others, and the overall processing time will be more consistent. Or, we might choose to select planes aligned with the major axes, because such planes can help speed up our BSP traversal.</p>
<p>The BSP metric that seems most useful to me, however, is the number of polygons that are split into two polygons in the course of building a BSP tree. Fewer splits is better; the tree is smaller with fewer polygons, and drawing will go faster with fewer polygons to draw, due to per-polygon overhead. There’s a problem with the fewest-splits metric, though: There’s no sure way to achieve it.</p>
<p>The obvious approach to minimizing polygon splits would be to try all possible trees to find the best one. Unfortunately, the order of that particular problem is N!, as I found to my dismay when I implemented brute-force optimization in the first version of my BSP compiler. Take a moment to calculate the number of operations for the 20-polygon set I originally tried brute-force optimization on. I’ll give you a hint: There are 19 digits in 20!, and if each operation takes only one microsecond, that’s over 70,000 years (or, if you prefer, over 500,000 dog years). Now consider that a single game level might have 5,000 to 10,000 polygons; there aren’t anywhere near enough dog years in the lifetime of the universe to handle that. We’re going to have to give up on optimal compilation and come up with a decent heuristic approach, no matter what optimization objective we select.</p>
<p>In Listing 60.1, I’ve applied the popular heuristic of choosing as the splitter at each node the surface that splits the fewest of the other surfaces that are being considered for that node. In other words, I choose the wall that splits the fewest of the walls in the subspace it’s subdividing.</p>
</section>
<section id="bsp-optimization-an-undiscovered-country" class="level3">
<h3><a href="#bsp-optimization-an-undiscovered-country">BSP Optimization: an Undiscovered Country</a></h3>
<p>Although BSP trees have been around for at least 15 years now, they’re still only partially understood and are a ripe area for applied research and general ingenuity. You might want to try your hand at inventing new BSP optimization approaches; it’s an interesting problem, and you might strike paydirt. There are many things that BSP trees can’t do well, because it takes so long to build them—but what they do, they do exceedingly well, so a better compilation approach that allowed BSP trees to be used for more purposes would be valuable, indeed.</p>
</section>
</section>
<section id="chapter-61-frames-of-reference" class="level2">
<h2><a href="#chapter-61-frames-of-reference">Chapter 61 – Frames of Reference</a></h2>
<section id="the-fundamentals-of-the-math-behind-3-d-graphics" class="level3">
<h3><a href="#the-fundamentals-of-the-math-behind-3-d-graphics">The Fundamentals of the Math behind 3-D Graphics</a></h3>
<p>Several years ago, I opened a column in <em>Dr. Dobb’s Journal</em> with a story about singing my daughter to sleep with Beatles’ songs. Beatles’ songs, at least the earlier ones, tend to be bouncy and pleasant, which makes them suitable goodnight fodder—and there are a <em>lot</em> of them, a useful hedge against terminal boredom. So for many good reasons, “Can’t Buy Me Love” and “A Hard Day’s Night” and “Help!” and the rest were evening staples for years.</p>
<p>No longer, though. You see, I got my wife some Beatles tapes for Christmas, and we’ve all been listening to them in the car, and now that my daughter has heard the real thing, she can barely stand to be in the same room, much less fall asleep, when I sing those songs.</p>
<p>What’s noteworthy is that the only variable involved in this change was my daughter’s frame of reference. My singing hasn’t gotten any worse over the last four years. (I’m not sure it’s <em>possible</em> for my singing to get worse.) All that changed was my daughter’s frame of reference for those songs. The rest of the universe stayed the same; the change was in her mind, lock, stock, and barrel.</p>
<p>Often, the key to solving a problem, or to working on a problem efficiently, is having a proper frame of reference. The model you have of a problem you’re tackling often determines how deeply you can understand the problem, and how flexible and innovative you’ll be able to be in solving it.</p>
<p>An excellent example of this, and one that I’ll discuss toward the end of this chapter, is that of <em>3-D transformation</em>—the process of converting coordinates from one coordinate space to another, for example from worldspace to viewspace. The way this is traditionally explained is functional, but not particularly intuitive, and fairly hard to visualize. Recently, I’ve come across another way of looking at transforms that seems to me to be far easier to grasp. The two approaches are technically equivalent, so the difference is purely a matter of how we choose to view things—but sometimes that’s the most important sort of difference.</p>
<p>Before we can talk about transforming between coordinate spaces, however, we need two building blocks: dot products and cross products.</p>
<section id="d-math" class="level4">
<h4><a href="#d-math">3-D Math</a></h4>
<p>At this point in the book, I was originally going to present a BSP-based renderer, to complement the BSP compiler I presented in the previous chapter. What changed my plans was the considerable amount of mail about 3-D math that I’ve gotten in recent months. In every case, the writer has bemoaned his/her lack of expertise with 3-D math, and has asked what books about 3-D math I’d recommend, and how else he/she could learn more.</p>
<p>That’s a commendable attitude, but the truth is, there’s not all that much to 3-D math, at least not when it comes to the sort of polygon-based, realtime 3-D that’s done on PCs. You really need only two basic math tools beyond simple arithmetic: dot products and cross products, and really mostly just the former. My friend Chris Hecker points out that this is an oversimplification; he notes that lots more math-related stuff, like BSP trees, graphs, discrete math for edge stepping, and affine and perspective texture mappings, goes into a production-quality game. While that’s surely true, dot and cross products, together with matrix math and perspective projection, constitute the bulk of what most people are asking about when they inquire about “3-D math,” and, as we’ll see, are key tools for a lot of useful 3-D operations.</p>
<p>The other thing the mail made clear was that there are a lot of people out there who don’t understand either type of product, at least insofar as they apply to 3-D. Since much or even most advanced 3-D graphics machinery relies to a greater or lesser extent on dot products and cross products (even the line intersection formula I discussed in the last chapter is actually a quotient of dot products), I’m going to spend this chapter examining these basic tools and some of their 3-D applications. If this is old hat to you, my apologies, and I’ll return to BSP-based rendering in the next chapter.</p>
</section>
<section id="foundation-definitions" class="level4">
<h4><a href="#foundation-definitions">Foundation Definitions</a></h4>
<p>The dot and cross products themselves are straightforward and require almost no context to understand, but I need to define some terms I’ll use when describing applications of the products, so I’ll do that now, and then get started with dot products.</p>
<p>I’m going to have to assume you have <em>some</em> math background, or we’ll never get to the good stuff. So, I’m just going to quickly define a <em>vector</em> as a direction and a magnitude, represented as a coordinate pair (in 2-D) or triplet (in 3-D), relative to the origin. That’s a pretty sloppy definition, but it’ll do for our purposes; if you want the Real McCoy, I suggest you check out <em>Calculus and Analytic Geometry</em>, by Thomas and Finney (Addison-Wesley: ISBN 0-201-52929-7).</p>
<p>So, for example, in 3-D, the vector <code>V</code> = [5 0 5] has a length, or magnitude, by the Pythagorean theorem, of</p>
<figure>
<img src="images/61-01d.jpg" />
</figure>
<p>(eq. 1)</p>
<p>(where vertical double bars denote vector length), and a direction in the plane of the x and z axes, exactly halfway between those two axes.</p>
<p>I’ll be working in a left-handed coordinate system, whereby if you wrap the fingers of your left hand around the z axis with your thumb pointing in the positive z direction, your fingers will curl from the positive x axis to the positive y axis. The positive x axis runs left to right across the screen, the positive y axis runs bottom to top across the screen, and the positive z axis runs into the screen.</p>
<p>For our purposes, <em>projection</em> is the process of mapping coordinates onto a line or surface. <em>Perspective projection</em> projects 3-D coordinates onto a viewplane, scaling coordinates according to their z distance from the viewpoint in order to provide proper perspective. <em>Objectspace</em> is the coordinate space in which an object is defined, independent of other objects and the world itself. <em>Worldspace</em> is the absolute frame of reference for a 3-D world; all objects’ locations and orientations are with respect to worldspace, and this is the frame of reference around which the viewpoint and view direction move. <em>Viewspace</em> is worldspace as seen from the viewpoint, looking in the view direction. <em>Screenspace</em> is viewspace after perspective projection and scaling to the screen.</p>
<p>Finally, <em>transformation</em> is the process of converting points from one coordinate space into another; in our case, that’ll mean rotating and translating (moving) points from objectspace or worldspace to viewspace.</p>
<p>For additional information, you might want to check out Foley &amp; van Dam’s <em>Computer Graphics</em> (ISBN 0-201-12110-7), or the chapters in this book dealing with my X-Sharp 3-D graphics library.</p>
</section>
</section>
<section id="the-dot-product" class="level3">
<h3><a href="#the-dot-product">The Dot Product</a></h3>
<p>Now we’re ready to move on to the dot product. Given two vectors <code>U</code> = [u<sub>1</sub> u<sub>2</sub> u<sub>3</sub>] and <code>V</code> = [v<sub>1</sub> v<sub>2</sub> v<sub>3</sub>], their dot product, denoted by the symbol •, is calculated as:</p>
<figure>
<img src="images/61-02d.jpg" />
</figure>
<p>(eq. 2)</p>
<p>As you can see, the result is a scalar value (a single real-valued number), <em>not</em> another vector.</p>
<p>Now that we know how to calculate a dot product, what does that get us? Not much. The dot product isn’t of much use for graphics until you start thinking of it this way</p>
<figure>
<img src="images/61-03d.jpg" />
</figure>
<p>(eq. 3)</p>
<p>where q is the angle between the two vectors, and the other two terms are the lengths of the vectors, as shown in Figure 61.1. Although it’s not immediately obvious, equation 3 has a wide variety of applications in 3-D graphics.</p>
<section id="dot-products-of-unit-vectors" class="level4">
<h4><a href="#dot-products-of-unit-vectors">Dot Products of Unit Vectors</a></h4>
<p>The simplest case of the dot product is when both vectors are <em>unit vectors</em>; that is, when their lengths are both one, as calculated as in Equation 1. In this case, equation 3 simplifies to:</p>
<figure>
<img src="images/61-04d.jpg" />
</figure>
<p>(eq. 4)</p>
<p>In other words, the dot product of two unit vectors is the cosine of the angle between them.</p>
<p>One obvious use of this is to find angles between unit vectors, in conjunction with an inverse cosine function or lookup table. A more useful application in 3-D graphics lies in lighting surfaces, where the cosine of the angle between incident light and the normal (perpendicular vector) of a surface determines the fraction of the light’s full intensity at which the surface is illuminated, as in</p>
<figure>
<img src="images/61-05d.jpg" />
</figure>
<p>(eq. 5)</p>
<figure>
<img src="images/61-01.jpg" alt="Figure 61.1  The dot product." /><figcaption><strong>Figure 61.1</strong>  <em>The dot product.</em></figcaption>
</figure>
<p>where <code>I</code><sub>s</sub> is the intensity of illumination of the surface, <code>I</code><sub>l</sub> is the intensity of the light, and q is the angle between <strong>-D</strong><sub>l</sub> (where <code>D</code><sub>l</sub> is the light direction vector) and the surface normal. If the inverse light vector and the surface normal are both unit vectors, then this calculation can be performed with four multiplies and three additions—and no explicit cosine calculations—as</p>
<figure>
<img src="images/61-06d.jpg" />
</figure>
<p>(eq. 6)</p>
<p>where <code>N</code><sub>s</sub> is the surface unit normal and <code>D</code><sub>l</sub> is the light unit direction vector, as shown in Figure 61.2.</p>
</section>
</section>
<section id="cross-products-and-the-generation-of-polygon-normals" class="level3">
<h3><a href="#cross-products-and-the-generation-of-polygon-normals">Cross Products and the Generation of Polygon Normals</a></h3>
<p>One question equation 6 begs is where the surface unit normal comes from. One approach is to store the end of a surface normal as an extra data point with each polygon (with the start being some point that’s already in the polygon), and transform it along with the rest of the points. This has the advantage that if the normal starts out as a unit normal, it will end up that way too, if only rotations and translations (but not scaling and shears) are performed.</p>
<p>The problem with having an explicit normal is that it will remain a normal—that is, perpendicular to the surface—only through viewspace. Rotation, translation, and scaling preserve right angles, which is why normals are still normals in viewspace, but perspective projection does not preserve angles, so vectors that were surface normals in viewspace are no longer normals in screenspace.</p>
<figure>
<img src="images/61-02.jpg" alt="Figure 61.2  The dot product as used in calculating lighting intensity." /><figcaption><strong>Figure 61.2</strong>  <em>The dot product as used in calculating lighting intensity.</em></figcaption>
</figure>
<p>Why does this matter? It matters because, on average, half the polygons in any scene are facing away from the viewer, and hence shouldn’t be drawn. One way to identify such polygons is to see whether they’re facing toward or away from the viewer; that is, whether their normals have negative z values (so they’re visible) or positive z values (so they should be culled). However, we’re talking about screenspace normals here, because the perspective projection can shift a polygon relative to the viewpoint so that although its viewspace normal has a negative z, its screenspace normal has a positive z, and vice-versa, as shown in Figure 61.3. So we need screenspace normals, but those can’t readily be generated by transformation from worldspace.</p>
<figure>
<img src="images/61-03.jpg" alt="Figure 61.3  A problem with determining front/back visibility." /><figcaption><strong>Figure 61.3</strong>  <em>A problem with determining front/back visibility.</em></figcaption>
</figure>
<p>The solution is to use the cross product of two of the polygon’s edges to generate a normal. The formula for the cross product is:</p>
<figure>
<img src="images/61-07d.jpg" />
</figure>
<p>(eq. 7)</p>
<p>(Note that the cross product operation is denoted by an X.) Unlike the dot product, the result of the cross product is a vector. Not just any vector, either; the vector generated by the cross product is perpendicular to both of the original vectors. Thus, the cross product can be used to generate a normal to any surface for which you have two vectors that lie within the surface. This means that we can generate the screenspace normals we need by taking the cross product of two adjacent polygon edges, as shown in Figure 61.4.</p>
<blockquote>
<p><img src="images/i.jpg" /> In fact, we can cull with only one-third the work needed to generate a full cross product; because we’re interested only in the sign of the z component of the normal, we can skip entirely calculating the x and y components. The only caveat is to be careful that neither edge you choose is zero-length and that the edges aren’t collinear, because the dot product can’t produce a normal in those cases.</p>
</blockquote>
<figure>
<img src="images/61-04.jpg" alt="Figure 61.4  How the cross product of polygon edge vectors generates a polygon normal." /><figcaption><strong>Figure 61.4</strong>  <em>How the cross product of polygon edge vectors generates a polygon normal.</em></figcaption>
</figure>
<p>Perhaps the most often asked question about cross products is “Which way do normals generated by cross products go?” In a left-handed coordinate system, curl the fingers of your left hand so the fingers curl through an angle of less than 180 degrees from the first vector in the cross product to the second vector. Your thumb now points in the direction of the normal.</p>
<p>If you take the cross product of two orthogonal (right-angle) unit vectors, the result will be a unit vector that’s orthogonal to both of them. This means that if you’re generating a new coordinate space—such as a new viewing frame of reference—you only need to come up with unit vectors for two of the axes for the new coordinate space, and can then use their cross product to generate the unit vector for the third axis. If you need unit normals, and the two vectors being crossed aren’t orthogonal unit vectors, you’ll have to normalize the resulting vector; that is, divide each of the vector’s components by the length of the vector, to make it a unit long.</p>
</section>
<section id="using-the-sign-of-the-dot-product" class="level3">
<h3><a href="#using-the-sign-of-the-dot-product">Using the Sign of the Dot Product</a></h3>
<p>The dot product is the cosine of the angle between two vectors, scaled by the magnitudes of the vectors. Magnitudes are always positive, so the sign of the cosine determines the sign of the result. The dot product is positive if the angle between the vectors is less than 90 degrees, negative if it’s greater than 90 degrees, and zero if the angle is exactly 90 degrees. This means that just the sign of the dot product suffices for tests involving comparisons of angles to 90 degrees, and there are more of those than you’d think.</p>
<p>Consider, for example, the process of backface culling, which we discussed above in the context of using screenspace normals to determine polygon orientation relative to the viewer. The problem with that approach is that it requires each polygon to be transformed into viewspace, then perspective projected into screenspace, before the test can be performed, and that involves a lot of time-consuming calculation. Instead, we can perform culling way back in worldspace (or even earlier, in objectspace, if we transform the viewpoint into that frame of reference), given only a vertex and a normal for each polygon and a location for the viewer.</p>
<p>Here’s the trick: Calculate the vector from the viewpoint to any vertex in the polygon and take its dot product with the polygon’s normal, as shown in Figure 61.5. If the polygon is facing the viewpoint, the result is negative, because the angle between the two vectors is greater than 90 degrees. If the polygon is facing away, the result is positive, and if the polygon is edge-on, the result is 0. That’s all there is to it—and this sort of backface culling happens before any transformation or projection at all is performed, saving a great deal of work for the half of all polygons, on average, that are culled.</p>
<p>Backface culling with the dot product is just a special case of determining which side of a plane any point (in this case, the viewpoint) is on. The same trick can be applied whenever you want to determine whether a point is in front of or behind a plane, where a plane is described by any point that’s on the plane (which I’ll call the plane origin), plus a plane normal. One such application is in clipping a line (such as a polygon edge) to a plane. Just do a dot product between the plane normal and the vector from one line endpoint to the plane origin, and repeat for the other line endpoint. If the signs of the dot products are the same, no clipping is needed; if they differ, clipping is needed. And yes, the dot product is also the way to do the actual clipping; but before we can talk about that, we need to understand the use of the dot product for projection.</p>
<figure>
<img src="images/61-05.jpg" alt="Figure 61.5  Backface culling with the dot product." /><figcaption><strong>Figure 61.5</strong>  <em>Backface culling with the dot product.</em></figcaption>
</figure>
</section>
<section id="using-the-dot-product-for-projection" class="level3">
<h3><a href="#using-the-dot-product-for-projection">Using the Dot Product for Projection</a></h3>
<p>Consider Equation 3 again, but this time make one of the vectors, say <code>V</code>, a unit vector. Now the equation reduces to:</p>
<figure>
<img src="images/61-08d.jpg" />
</figure>
<p>(eq. 8)</p>
<p>In other words, the result is the cosine of the angle between the two vectors, scaled by the magnitude of the non-unit vector. Now, consider that cosine is really just the length of the adjacent leg of a right triangle, and think of the non-unit vector as the hypotenuse of a right triangle, and remember that all sides of similar triangles scale equally. What it all works out to is that the value of the dot product of any vector with a unit vector is the length of the first vector projected onto the unit vector, as shown in Figure 61.6.</p>
<figure>
<img src="images/61-06.jpg" alt="Figure 61.6  How the dot product with a unit vector performs a projection." /><figcaption><strong>Figure 61.6</strong>  <em>How the dot product with a unit vector performs a projection.</em></figcaption>
</figure>
<p>This unlocks all sorts of neat stuff. Want to know the distance from a point to a plane? Just dot the vector from the point <code>P</code> to the plane origin <code>O</code><sub>p</sub> with the plane unit normal <code>N</code><sub>p</sub>, to project the vector onto the normal, then take the absolute value</p>
<pre><code>distance = |(P - Op) • Np|</code></pre>
<p>as shown in Figure 61.7.</p>
<p>Want to clip a line to a plane? Calculate the distance from one endpoint to the plane, as just described, and dot the whole line segment with the plane normal, to get the full length of the line along the plane normal. The ratio of the two dot products is then how far along the line from the endpoint the intersection point is; just move along the line segment by that distance from the endpoint, and you’re at the intersection point, as shown in Listing 61.1.</p>
<p><strong>LISTING 61.1 L61_1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Given two line endpoints, a point on a plane, and a unit normal</span>
<span class="co">// for the plane, returns the point of intersection of the line</span>
<span class="co">// and the plane in intersectpoint.</span>
<span class="ot">#define DOT_PRODUCT(x,y)   (x[0]*y[0]+x[1]*y[1]+x[2]*y[2])</span>
<span class="dt">void</span> LineIntersectPlane (<span class="dt">float</span> *linestart, <span class="dt">float</span> *lineend,
   <span class="dt">float</span> *planeorigin, <span class="dt">float</span> *planenormal, <span class="dt">float</span> *intersectpoint)
{
   <span class="dt">float</span> vec1[<span class="dv">3</span>], projectedlinelength, startdistfromplane, scale;
   vec1[<span class="dv">0</span>] = linestart[<span class="dv">0</span>] - planeorigin[<span class="dv">0</span>];
   vec1[<span class="dv">1</span>] = linestart[<span class="dv">1</span>] - planeorigin[<span class="dv">1</span>];
   vec1[<span class="dv">2</span>] = linestart[<span class="dv">2</span>] - planeorigin[<span class="dv">2</span>];
   startdistfromplane = DOT_PRODUCT(vec1, planenormal);
   <span class="kw">if</span> (startdistfromplane == <span class="dv">0</span>)
   {
        <span class="co">// point is in plane</span>
        intersectpoint[<span class="dv">0</span>] = linestart[<span class="dv">0</span>];
        intersectpoint[<span class="dv">1</span>] = linestart[<span class="dv">1</span>];
        intersectpoint[<span class="dv">2</span>] = linestart[<span class="dv">1</span>];
        <span class="kw">return</span>;
   }
   vec1[<span class="dv">0</span>] = linestart[<span class="dv">0</span>] - lineend[<span class="dv">0</span>];
   vec1[<span class="dv">1</span>] = linestart[<span class="dv">1</span>] - lineend[<span class="dv">1</span>];
   vec1[<span class="dv">2</span>] = linestart[<span class="dv">2</span>] - lineend[<span class="dv">2</span>];
   projectedlinelength = DOT_PRODUCT(vec1, planenormal);
   scale = startdistfromplane / projectedlinelength;
   intersectpoint[<span class="dv">0</span>] = linestart[<span class="dv">0</span>] - vec1[<span class="dv">0</span>] * scale;
   intersectpoint[<span class="dv">1</span>] = linestart[<span class="dv">1</span>] - vec1[<span class="dv">1</span>] * scale;
   intersectpoint[<span class="dv">2</span>] = linestart[<span class="dv">1</span>] - vec1[<span class="dv">2</span>] * scale;
}</code></pre>
</section>
<section id="rotation-by-projection" class="level3">
<h3><a href="#rotation-by-projection">Rotation by Projection</a></h3>
<p>We can use the dot product’s projection capability to look at rotation in an interesting way. Typically, rotations are represented by matrices. This is certainly a workable representation that encapsulates all aspects of transformation in a single object, and is ideal for concatenations of rotations and translations. One problem with matrices, though, is that many people, myself included, have a hard time looking at a matrix of sines and cosines and visualizing what’s actually going on. So when two 3-D experts, John Carmack and Billy Zelsnack, mentioned that they think of rotation differently, in a way that seemed more intuitive to me, I thought it was worth passing on.</p>
<figure>
<img src="images/61-07.jpg" alt="Figure 61.7  Using the dot product to get the distance from a point to a plane." /><figcaption><strong>Figure 61.7</strong>  <em>Using the dot product to get the distance from a point to a plane.</em></figcaption>
</figure>
<p>Their approach is this: Think of rotation as projecting coordinates onto new axes. That is, given that you have points in, say, worldspace, define the new coordinate space (viewspace, for example) you want to rotate to by a set of three orthogonal unit vectors defining the new axes, and then project each point onto each of the three axes to get the coordinates in the new coordinate space, as shown for the 2-D case in Figure 61.8. In 3-D, this involves three dot products per point, one to project the point onto each axis. Translation can be done separately from rotation by simple addition.</p>
<blockquote>
<p><img src="images/i.jpg" /> Rotation by projection is exactly the same as rotation via matrix multiplication; in fact, the rows of a rotation matrix are the orthogonal unit vectors pointing along the new axes. Rotation by projection buys us no technical advantages, so that’s not what’s important here; the key is that the concept of rotation by projection, together with a separate translation step, gives us a new way to look at transformation that I, for one, find easier to visualize and experiment with. A new frame of reference for how we think about 3-D frames of reference, if you will.</p>
</blockquote>
<p>Three things I’ve learned over the years are that it never hurts to learn a new way of looking at things, that it helps to have a clearer, more intuitive model in your head of whatever it is you’re working on, and that new tools, or new ways to use old tools, are Good Things. My experience has been that rotation by projection, and dot product tricks in general, offer those sorts of benefits for 3-D.</p>
<figure>
<img src="images/61-08.jpg" alt="Figure 61.8  Rotation to a new coordinate space by projection onto new axes." /><figcaption><strong>Figure 61.8</strong>  <em>Rotation to a new coordinate space by projection onto new axes.</em></figcaption>
</figure>
</section>
</section>
<section id="chapter-62-one-story-two-rules-and-a-bsp-renderer" class="level2">
<h2><a href="#chapter-62-one-story-two-rules-and-a-bsp-renderer">Chapter 62 – One Story, Two Rules, and a BSP Renderer</a></h2>
<section id="taking-a-compiled-bsp-tree-from-logical-to-visual-reality" class="level3">
<h3><a href="#taking-a-compiled-bsp-tree-from-logical-to-visual-reality">Taking a Compiled BSP Tree from Logical to Visual Reality</a></h3>
<p>As I’ve noted before, I’m working on Quake, id Software’s follow-up to DOOM. A month or so back, we added page flipping to Quake, and made the startling discovery that the program ran nearly twice as fast with page flipping as it did with the alternative method of drawing the whole frame to system memory, then copying it to the screen. We were delighted by this, but baffled. I did a few tests and came up with several possible explanations, including slow writes through the external cache, poor main memory performance, and cache misses when copying the frame from system memory to video memory. Although each of these can indeed affect performance, none seemed to account for the magnitude of the speedup, so I assumed there was some hidden hardware interaction at work. Anyway, “why” was secondary; what really mattered was that we had a way to double performance, which meant I had a lot of work to do to support page flipping as widely as possible.</p>
<p>A few days ago, I was using the Pentium’s built-in performance counters to seek out areas for improvement in Quake and, for no particular reason, checked the number of writes performed while copying the frame to the screen in non-page-flipped mode. The answer was 64,000. That seemed odd, since there were 64,000 byte-sized pixels to copy, and I was calling <code>memcpy()</code>, which of course performs copies a dword at a time whenever possible. I thought maybe the Pentium counters report the number of bytes written rather than the number of writes performed, but fortunately, this time I tested my assumptions by writing an ASM routine to copy the frame a dword at a time, without the help of <code>memcpy()</code>. This time the Pentium counters reported 16,000 writes.</p>
<p>Whoops.</p>
<p>As it turns out, the <code>memcpy()</code> routine in the DOS version of our compiler (gcc) inexplicably copies memory a byte at a time. With my new routine, the non-page-flipped approach suddenly became slightly <em>faster</em> than page flipping.</p>
<p>The first relevant rule is pretty obvious: <em>Assume nothing</em>. Measure early and often. Know what’s really going on when your program runs, if you catch my drift. To do otherwise is to risk looking mighty foolish.</p>
<p>The second rule: When you do look foolish (and trust me, it <em>will</em> happen if you do challenging work) have a good laugh at yourself, and use it as a reminder of Rule #1. I hadn’t done any extra page-flipping work yet, so I didn’t waste any time due to my faulty assumption that <code>memcpy()</code> performed a maximum-speed copy, but that was just luck. I should have done experiments until I was sure I knew what was going on before drawing any conclusions and acting on them.</p>
<blockquote>
<p><img src="images/i.jpg" /> In general, make it a point not to fall into a tightly focused rut; stay loose and think of alternative possibilities and new approaches, and always, always, always keep asking questions. It’ll pay off big in the long run. If I hadn’t indulged my curiosity by running the Pentium counter test on the copy to the screen, even though there was no specific reason to do so, I would never have discovered the <code>memcpy()</code> problem—and by so doing I doubled the performance of the entire program in five minutes, a rare accomplishment indeed.</p>
</blockquote>
<p>By the way, I have found the Pentium’s performance counters to be very useful in of information on the performance counters and other aspects of the Pentium is Mike Schmit’s book, <em>Pentium Processor Optimization Tools</em>, AP Professional, ISBN 0-12-627230-1.</p>
<p>Onward to rendering from a BSP tree.</p>
<section id="bsp-based-rendering" class="level4">
<h4><a href="#bsp-based-rendering">BSP-based Rendering</a></h4>
<p>For the last several chapters I’ve been discussing the nature of BSP (Binary Space Partitioning) trees, and in Chapter 60 I presented a compiler for 2-D BSP trees. Now we’re ready to use those compiled BSP trees to do realtime rendering.</p>
<p>As you’ll recall, the BSP compiler took a list of vertical walls and built a 2-D BSP tree from the walls, as viewed from above. The result is shown in Figure 62.1. The world is split into two pieces by the line of the root wall, and each half of the world is then split again by the root’s children, and so on, until the world is carved into subspaces along the lines of all the walls.</p>
<figure>
<img src="images/62-01.jpg" alt="Figure 62.1  Vertical walls and a BSP tree to represent them." /><figcaption><strong>Figure 62.1</strong>  <em>Vertical walls and a BSP tree to represent them.</em></figcaption>
</figure>
<p>Our objective is to draw the world so that whenever walls overlap we see the nearer wall at each overlapped pixel. The simplest way to do that is with the painter’s algorithm; that is, drawing the walls in back-to-front order, assuming no polygons interpenetrate or form cycles. BSP trees guarantee that no polygons interpenetrate (such polygons are automatically split), and make it easy to walk the polygons in back-to-front (or front-to-back) order.</p>
<p>Given a BSP tree, in order to render a view of that tree, all we have to do is descend the tree, deciding at each node whether we’re seeing the front or back of the wall at that node from the current viewpoint. We use that knowledge to first recursively descend and draw the farther subtree of that node, then draw that node, and finally draw the nearer subtree of that node. Applied recursively from the root of our BSP trees, this approach guarantees that overlapping polygons will always be drawn in back-to-front order. Listing 62.1 draws a BSP-based world in this fashion. (Because of the constraints of the printed page, Listing 62.1 is only the core of the BSP renderer, without the program framework, some math routines, and the polygon rasterizer; but, the entire program is on the CD-ROM as DDJBSP2.ZIP. Listing 62.1 is in a compressed format, with relatively little whitespace; the full version on the CD-ROM is formatted normally.)</p>
<p><strong>Listing 62.1 L62_1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Core renderer for Win32 program to demonstrate drawing from a 2-D</span>
<span class="co">   BSP tree; illustrate the use of BSP trees for surface visibility.</span>
<span class="co">   UpdateWorld() is the top-level function in this module.</span>
<span class="co">   Full source code for the BSP-based renderer, and for the</span>
<span class="co">   accompanying BSP compiler, may be downloaded from</span>
<span class="co">   ftp.idsoftware.com/mikeab, in the file ddjbsp2.zip.</span>
<span class="co">   Tested with VC++ 2.0 running on Windows NT 3.5. */</span>
<span class="ot">#define FIXEDPOINT(x)   ((FIXEDPOINT)(((long)x)*((long)0x10000)))</span>
<span class="ot">#define FIXTOINT(x)     ((int)(x &gt;&gt; 16))</span>
<span class="ot">#define ANGLE(x)        ((long)x)</span>
<span class="ot">#define STANDARD_SPEED  (FIXEDPOINT(20))</span>
<span class="ot">#define STANDARD_ROTATION (ANGLE(4))</span>
<span class="ot">#define MAX_NUM_NODES   2000</span>
<span class="ot">#define MAX_NUM_EXTRA_VERTICES   2000</span>
<span class="ot">#define WORLD_MIN_X  (FIXEDPOINT(-16000))</span>
<span class="ot">#define WORLD_MAX_X  (FIXEDPOINT(16000))</span>
<span class="ot">#define WORLD_MIN_Y  (FIXEDPOINT(-16000))</span>
<span class="ot">#define WORLD_MAX_Y  (FIXEDPOINT(16000))</span>
<span class="ot">#define WORLD_MIN_Z  (FIXEDPOINT(-16000))</span>
<span class="ot">#define WORLD_MAX_Z  (FIXEDPOINT(16000))</span>
<span class="ot">#define PROJECTION_RATIO (2.0/1.0)  </span><span class="co">// controls field of view; the</span>
                 <span class="co">// bigger this is, the narrower the field of view</span>
<span class="kw">typedef</span> <span class="dt">long</span> FIXEDPOINT;
<span class="kw">typedef</span> <span class="kw">struct</span> _VERTEX {
   FIXEDPOINT x, z, viewx, viewz;
} VERTEX, *PVERTEX;
<span class="kw">typedef</span> <span class="kw">struct</span> _POINT2 { FIXEDPOINT x, z; } POINT2, *PPOINT2;
<span class="kw">typedef</span> <span class="kw">struct</span> _POINT2INT { <span class="dt">int</span>  x; <span class="dt">int</span> y; } POINT2INT, *PPOINT2INT;
<span class="kw">typedef</span> <span class="dt">long</span> ANGLE;     <span class="co">// angles are stored in degrees</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _NODE {
   VERTEX *pstartvertex, *pendvertex;
   FIXEDPOINT  walltop, wallbottom, tstart, tend;
   FIXEDPOINT  clippedtstart, clippedtend;
   <span class="kw">struct</span> _NODE *fronttree, *backtree;
   <span class="dt">int</span>         color, isVisible;
   FIXEDPOINT  screenxstart, screenxend;
   FIXEDPOINT  screenytopstart, screenybottomstart;
   FIXEDPOINT  screenytopend, screenybottomend;
} NODE, *PNODE;
<span class="dt">char</span> * pDIB;            <span class="co">// pointer to DIB section we&#39;ll draw into</span>
HBITMAP hDIBSection;    <span class="co">// handle of DIB section</span>
HPALETTE hpalDIB;
<span class="dt">int</span> iteration = <span class="dv">0</span>, WorldIsRunning = <span class="dv">1</span>;
HWND hwndOutput;
<span class="dt">int</span> DIBWidth, DIBHeight, DIBPitch, numvertices, numnodes;
FIXEDPOINT fxHalfDIBWidth, fxHalfDIBHeight;
VERTEX *pvertexlist, *pextravertexlist;
NODE *pnodelist;
POINT2 currentlocation, currentdirection, currentorientation;
ANGLE currentangle;
FIXEDPOINT currentspeed, fxViewerY, currentYSpeed;
FIXEDPOINT FrontClipPlane = FIXEDPOINT(<span class="dv">10</span>);
FIXEDPOINT FixedMul(FIXEDPOINT x, FIXEDPOINT y);
FIXEDPOINT FixedDiv(FIXEDPOINT x, FIXEDPOINT y);
FIXEDPOINT FixedSin(ANGLE angle), FixedCos(ANGLE angle);
<span class="kw">extern</span> <span class="dt">int</span> FillConvexPolygon(POINT2INT * VertexPtr, <span class="dt">int</span> Color);
<span class="co">// Returns nonzero if a wall is facing the viewer, 0 else.</span>
<span class="dt">int</span> WallFacingViewer(NODE * pwall)
{
   FIXEDPOINT viewxstart = pwall-&gt;pstartvertex-&gt;viewx;
   FIXEDPOINT viewzstart = pwall-&gt;pstartvertex-&gt;viewz;
   FIXEDPOINT viewxend = pwall-&gt;pendvertex-&gt;viewx;
   FIXEDPOINT viewzend = pwall-&gt;pendvertex-&gt;viewz;
   <span class="dt">int</span> Temp;
<span class="co">/*  // equivalent C code</span>
<span class="co">   if (( ((pwall-&gt;pstartvertex-&gt;viewx &gt;&gt; 16) *</span>
<span class="co">         ((pwall-&gt;pendvertex-&gt;viewz -</span>
<span class="co">          pwall-&gt;pstartvertex-&gt;viewz) &gt;&gt; 16)) +</span>
<span class="co">         ((pwall-&gt;pstartvertex-&gt;viewz &gt;&gt; 16) *</span>
<span class="co">          ((pwall-&gt;pstartvertex-&gt;viewx -</span>
<span class="co">            pwall-&gt;pendvertex-&gt;viewx) &gt;&gt; 16)) )</span>
<span class="co">               &lt; 0)</span>
<span class="co">      return(1);</span>
<span class="co">   else</span>
<span class="co">      return(0);</span>
<span class="co">*/</span>
   _asm {
      mov   eax,viewzend
      sub   eax,viewzstart
      imul  viewxstart
      mov   ecx,edx
      mov   ebx,eax
      mov   eax,viewxstart
      sub   eax,viewxend
      imul  viewzstart
      add   eax,ebx
      adc   edx,ecx
      mov   eax,<span class="dv">0</span>
      jns   <span class="dt">short</span> WFVDone
      inc   eax
WFVDone:
      mov   Temp,eax
   }
   <span class="kw">return</span>(Temp);
}
<span class="co">// Update the viewpoint position as needed.</span>
<span class="dt">void</span> UpdateViewPos()
{
   <span class="kw">if</span> (currentspeed != <span class="dv">0</span>) {
      currentlocation.x += FixedMul(currentdirection.x,
                                    currentspeed);
      <span class="kw">if</span> (currentlocation.x &lt;= WORLD_MIN_X)
         currentlocation.x = WORLD_MIN_X;
      <span class="kw">if</span> (currentlocation.x &gt;= WORLD_MAX_X)
         currentlocation.x = WORLD_MAX_X - <span class="dv">1</span>;
      currentlocation.z += FixedMul(currentdirection.z,
                                    currentspeed);
      <span class="kw">if</span> (currentlocation.z &lt;= WORLD_MIN_Z)
         currentlocation.z = WORLD_MIN_Z;
      <span class="kw">if</span> (currentlocation.z &gt;= WORLD_MAX_Z)
         currentlocation.z = WORLD_MAX_Z - <span class="dv">1</span>;
   }
   <span class="kw">if</span> (currentYSpeed != <span class="dv">0</span>) {
      fxViewerY += currentYSpeed;
      <span class="kw">if</span> (fxViewerY &lt;= WORLD_MIN_Y)
         fxViewerY = WORLD_MIN_Y;
      <span class="kw">if</span> (fxViewerY &gt;= WORLD_MAX_Y)
         fxViewerY = WORLD_MAX_Y - <span class="dv">1</span>;
   }
}
<span class="co">// Transform all vertices into viewspace.</span>
<span class="dt">void</span> TransformVertices()
{
   VERTEX *pvertex;
   FIXEDPOINT tempx, tempz;
   <span class="dt">int</span> vertex;
   pvertex = pvertexlist;
   <span class="kw">for</span> (vertex = <span class="dv">0</span>; vertex &lt; numvertices; vertex++) {
      <span class="co">// Translate the vertex according to the viewpoint</span>
      tempx = pvertex-&gt;x - currentlocation.x;
      tempz = pvertex-&gt;z - currentlocation.z;
      <span class="co">// Rotate the vertex so viewpoint is looking down z axis</span>
      pvertex-&gt;viewx = FixedMul(FixedMul(tempx,
                                         currentorientation.z) +
                   FixedMul(tempz, -currentorientation.x),
                   FIXEDPOINT(PROJECTION_RATIO));
      pvertex-&gt;viewz = FixedMul(tempx, currentorientation.x) +
                   FixedMul(tempz, currentorientation.z);
      pvertex++;
   }
}
<span class="co">// 3-D clip all walls. If any part of each wall is still visible,</span>
<span class="co">// transform to perspective viewspace.</span>
<span class="dt">void</span> ClipWalls()
{
   NODE *pwall;
   <span class="dt">int</span> wall;
   FIXEDPOINT tempstartx, tempendx, tempstartz, tempendz;
   FIXEDPOINT tempstartwalltop, tempstartwallbottom;
   FIXEDPOINT tempendwalltop, tempendwallbottom;
   VERTEX *pstartvertex, *pendvertex;
   VERTEX *pextravertex = pextravertexlist;
   pwall = pnodelist;
   <span class="kw">for</span> (wall = <span class="dv">0</span>; wall &lt; numnodes; wall++) {
      <span class="co">// Assume the wall won&#39;t be visible</span>
      pwall-&gt;isVisible = <span class="dv">0</span>;
      <span class="co">// Generate the wall endpoints, accounting for t values and</span>
      <span class="co">// clipping</span>
      <span class="co">// Calculate the viewspace coordinates for this wall</span>
      pstartvertex = pwall-&gt;pstartvertex;
      pendvertex = pwall-&gt;pendvertex;
      <span class="co">// Look for z clipping first</span>
      <span class="co">// Calculate start and end z coordinates for this wall</span>
      <span class="kw">if</span> (pwall-&gt;tstart == FIXEDPOINT(<span class="dv">0</span>))
         tempstartz = pstartvertex-&gt;viewz;
      <span class="kw">else</span>
         tempstartz = pstartvertex-&gt;viewz +
               FixedMul((pendvertex-&gt;viewz-pstartvertex-&gt;viewz),
               pwall-&gt;tstart);
      <span class="kw">if</span> (pwall-&gt;tend == FIXEDPOINT(<span class="dv">1</span>))
         tempendz = pendvertex-&gt;viewz;
      <span class="kw">else</span>
         tempendz = pstartvertex-&gt;viewz +
               FixedMul((pendvertex-&gt;viewz-pstartvertex-&gt;viewz),
               pwall-&gt;tend);
      <span class="co">// Clip to the front plane</span>
      <span class="kw">if</span> (tempendz &lt; FrontClipPlane) {
         <span class="kw">if</span> (tempstartz &lt; FrontClipPlane) {
            <span class="co">// Fully front-clipped</span>
            <span class="kw">goto</span> NextWall;
         } <span class="kw">else</span> {
            pwall-&gt;clippedtstart = pwall-&gt;tstart;
            <span class="co">// Clip the end point to the front clip plane</span>
            pwall-&gt;clippedtend =
                  FixedDiv(pstartvertex-&gt;viewz - FrontClipPlane,
                        pstartvertex-&gt;viewz-pendvertex-&gt;viewz);
            tempendz = pstartvertex-&gt;viewz +
               FixedMul((pendvertex-&gt;viewz-pstartvertex-&gt;viewz),
               pwall-&gt;clippedtend);
         }
      } <span class="kw">else</span> {
         pwall-&gt;clippedtend = pwall-&gt;tend;
         <span class="kw">if</span> (tempstartz &lt; FrontClipPlane) {
            <span class="co">// Clip the start point to the front clip plane</span>
            pwall-&gt;clippedtstart =
                  FixedDiv(FrontClipPlane - pstartvertex-&gt;viewz,
                        pendvertex-&gt;viewz-pstartvertex-&gt;viewz);
            tempstartz = pstartvertex-&gt;viewz +
               FixedMul((pendvertex-&gt;viewz-pstartvertex-&gt;viewz),
               pwall-&gt;clippedtstart);
         } <span class="kw">else</span> {
            pwall-&gt;clippedtstart = pwall-&gt;tstart;
         }
      }
      <span class="co">// Calculate x coordinates</span>
      <span class="kw">if</span> (pwall-&gt;clippedtstart == FIXEDPOINT(<span class="dv">0</span>))
         tempstartx = pstartvertex-&gt;viewx;
      <span class="kw">else</span>
         tempstartx = pstartvertex-&gt;viewx +
               FixedMul((pendvertex-&gt;viewx-pstartvertex-&gt;viewx),
               pwall-&gt;clippedtstart);
      <span class="kw">if</span> (pwall-&gt;clippedtend == FIXEDPOINT(<span class="dv">1</span>))
         tempendx = pendvertex-&gt;viewx;
      <span class="kw">else</span>
         tempendx = pstartvertex-&gt;viewx +
               FixedMul((pendvertex-&gt;viewx-pstartvertex-&gt;viewx),
               pwall-&gt;clippedtend);
      <span class="co">// Clip in x as needed</span>
      <span class="kw">if</span> ((tempstartx &gt; tempstartz) || (tempstartx &lt; -tempstartz)) {
         <span class="co">// The start point is outside the view triangle in x;</span>
         <span class="co">// perform a quick test for trivial rejection by seeing if</span>
         <span class="co">// the end point is outside the view triangle on the same</span>
         <span class="co">// side as the start point</span>
         <span class="kw">if</span> (((tempstartx&gt;tempstartz) &amp;&amp; (tempendx&gt;tempendz)) ||
            ((tempstartx&lt;-tempstartz) &amp;&amp; (tempendx&lt;-tempendz)))
            <span class="co">// Fully clipped—trivially reject</span>
            <span class="kw">goto</span> NextWall;
         <span class="co">// Clip the start point</span>
         <span class="kw">if</span> (tempstartx &gt; tempstartz) {
            <span class="co">// Clip the start point on the right side</span>
            pwall-&gt;clippedtstart =
               FixedDiv(pstartvertex-&gt;viewx-pstartvertex-&gt;viewz,
                      pendvertex-&gt;viewz-pstartvertex-&gt;viewz -
                      pendvertex-&gt;viewx+pstartvertex-&gt;viewx);
            tempstartx = pstartvertex-&gt;viewx +
               FixedMul((pendvertex-&gt;viewx-pstartvertex-&gt;viewx),
                       pwall-&gt;clippedtstart);
            tempstartz = tempstartx;
         } <span class="kw">else</span> {
            <span class="co">// Clip the start point on the left side</span>
            pwall-&gt;clippedtstart =
               FixedDiv(-pstartvertex-&gt;viewx-pstartvertex-&gt;viewz,
                      pendvertex-&gt;viewx+pendvertex-&gt;viewz -
                      pstartvertex-&gt;viewz-pstartvertex-&gt;viewx);
            tempstartx = pstartvertex-&gt;viewx +
               FixedMul((pendvertex-&gt;viewx-pstartvertex-&gt;viewx),
                       pwall-&gt;clippedtstart);
            tempstartz = -tempstartx;
         }
      }
      <span class="co">// See if the end point needs clipping</span>
      <span class="kw">if</span> ((tempendx &gt; tempendz) || (tempendx &lt; -tempendz)) {
         <span class="co">// Clip the end point</span>
         <span class="kw">if</span> (tempendx &gt; tempendz) {
            <span class="co">// Clip the end point on the right side</span>
            pwall-&gt;clippedtend =
               FixedDiv(pstartvertex-&gt;viewx-pstartvertex-&gt;viewz,
                      pendvertex-&gt;viewz-pstartvertex-&gt;viewz -
                      pendvertex-&gt;viewx+pstartvertex-&gt;viewx);
            tempendx = pstartvertex-&gt;viewx +
               FixedMul((pendvertex-&gt;viewx-pstartvertex-&gt;viewx),
                       pwall-&gt;clippedtend);
            tempendz = tempendx;
         } <span class="kw">else</span> {
            <span class="co">// Clip the end point on the left side</span>
            pwall-&gt;clippedtend =
               FixedDiv(-pstartvertex-&gt;viewx-pstartvertex-&gt;viewz,
                      pendvertex-&gt;viewx+pendvertex-&gt;viewz -
                      pstartvertex-&gt;viewz-pstartvertex-&gt;viewx);
            tempendx = pstartvertex-&gt;viewx +
               FixedMul((pendvertex-&gt;viewx-pstartvertex-&gt;viewx),
                       pwall-&gt;clippedtend);
            tempendz = -tempendx;
         }
      }
      tempstartwalltop = FixedMul((pwall-&gt;walltop - fxViewerY),
            FIXEDPOINT(PROJECTION_RATIO));
      tempendwalltop = tempstartwalltop;
      tempstartwallbottom = FixedMul((pwall-&gt;wallbottom-fxViewerY),
            FIXEDPOINT(PROJECTION_RATIO));
      tempendwallbottom = tempstartwallbottom;
      <span class="co">// Partially clip in y (the rest is done later in 2D)</span>
      <span class="co">// Check for trivial accept</span>
      <span class="kw">if</span> ((tempstartwalltop &gt; tempstartz) ||
         (tempstartwallbottom &lt; -tempstartz) ||
         (tempendwalltop &gt; tempendz) ||
         (tempendwallbottom &lt; -tempendz)) {
         <span class="co">// Not trivially unclipped; check for fully clipped</span>
         <span class="kw">if</span> ((tempstartwallbottom &gt; tempstartz) &amp;&amp;
            (tempstartwalltop &lt; -tempstartz) &amp;&amp;
            (tempendwallbottom &gt; tempendz) &amp;&amp;
            (tempendwalltop &lt; -tempendz)) {
            <span class="co">// Outside view triangle, trivially clipped</span>
            <span class="kw">goto</span> NextWall;
         }
         <span class="co">// Partially clipped in Y; we&#39;ll do Y clipping at</span>
         <span class="co">// drawing time</span>
      }
      <span class="co">// The wall is visible; mark it as such and project it.</span>
      <span class="co">// +1 on scaling because of bottom/right exclusive polygon</span>
      <span class="co">// filling</span>
      pwall-&gt;isVisible = <span class="dv">1</span>;
      pwall-&gt;screenxstart =
         (FixedMulDiv(tempstartx, fxHalfDIBWidth+FIXEDPOINT(<span class="fl">0.5</span>),
            tempstartz) + fxHalfDIBWidth + FIXEDPOINT(<span class="fl">0.5</span>));
      pwall-&gt;screenytopstart =
            (FixedMulDiv(tempstartwalltop,
            fxHalfDIBHeight + FIXEDPOINT(<span class="fl">0.5</span>), tempstartz) +
            fxHalfDIBHeight + FIXEDPOINT(<span class="fl">0.5</span>));
      pwall-&gt;screenybottomstart =
            (FixedMulDiv(tempstartwallbottom,
            fxHalfDIBHeight + FIXEDPOINT(<span class="fl">0.5</span>), tempstartz) +
            fxHalfDIBHeight + FIXEDPOINT(<span class="fl">0.5</span>));
      pwall-&gt;screenxend =
            (FixedMulDiv(tempendx, fxHalfDIBWidth+FIXEDPOINT(<span class="fl">0.5</span>),
            tempendz) + fxHalfDIBWidth + FIXEDPOINT(<span class="fl">0.5</span>));
      pwall-&gt;screenytopend =
            (FixedMulDiv(tempendwalltop,
            fxHalfDIBHeight + FIXEDPOINT(<span class="fl">0.5</span>), tempendz) +
            fxHalfDIBHeight + FIXEDPOINT(<span class="fl">0.5</span>));
      pwall-&gt;screenybottomend =
            (FixedMulDiv(tempendwallbottom,
            fxHalfDIBHeight + FIXEDPOINT(<span class="fl">0.5</span>), tempendz) +
            fxHalfDIBHeight + FIXEDPOINT(<span class="fl">0.5</span>));
NextWall:
      pwall++;
   }
}
<span class="co">// Walk the tree back to front; backface cull whenever possible,</span>
<span class="co">// and draw front-facing walls in back-to-front order.</span>
<span class="dt">void</span> DrawWallsBackToFront()
{
   NODE *pFarChildren, *pNearChildren, *pwall;
   NODE *pendingnodes[MAX_NUM_NODES];
   NODE **pendingstackptr;
   POINT2INT apoint[<span class="dv">4</span>];
   pwall = pnodelist;
   pendingnodes[<span class="dv">0</span>] = (NODE *)NULL;
   pendingstackptr = pendingnodes + <span class="dv">1</span>;
   <span class="kw">for</span> (;;) {
      <span class="kw">for</span> (;;) {
         <span class="co">// Descend as far as possible toward the back,</span>
         <span class="co">// remembering the nodes we pass through on the way.</span>
         <span class="co">// Figure whether this wall is facing frontward or</span>
         <span class="co">// backward; do in viewspace because non-visible walls</span>
         <span class="co">// aren&#39;t projected into screenspace, and we need to</span>
         <span class="co">// traverse all walls in the BSP tree, visible or not,</span>
         <span class="co">// in order to find all the visible walls</span>
         <span class="kw">if</span> (WallFacingViewer(pwall)) {
            <span class="co">// We&#39;re on the forward side of this wall, do the back</span>
            <span class="co">// children first</span>
            pFarChildren = pwall-&gt;backtree;
         } <span class="kw">else</span> {
            <span class="co">// We&#39;re on the back side of this wall, do the front</span>
            <span class="co">// children first</span>
            pFarChildren = pwall-&gt;fronttree;
         }
         <span class="kw">if</span> (pFarChildren == NULL)
            <span class="kw">break</span>;
         *pendingstackptr = pwall;
         pendingstackptr++;
         pwall = pFarChildren;
      }
      <span class="kw">for</span> (;;) {
         <span class="co">// See if the wall is even visible</span>
         <span class="kw">if</span> (pwall-&gt;isVisible) {
            <span class="co">// See if we can backface cull this wall</span>
            <span class="kw">if</span> (pwall-&gt;screenxstart &lt; pwall-&gt;screenxend) {
               <span class="co">// Draw the wall</span>
               apoint[<span class="dv">0</span>].x = FIXTOINT(pwall-&gt;screenxstart);
               apoint[<span class="dv">1</span>].x = FIXTOINT(pwall-&gt;screenxstart);
               apoint[<span class="dv">2</span>].x = FIXTOINT(pwall-&gt;screenxend);
               apoint[<span class="dv">3</span>].x = FIXTOINT(pwall-&gt;screenxend);
               apoint[<span class="dv">0</span>].y = FIXTOINT(pwall-&gt;screenytopstart);
               apoint[<span class="dv">1</span>].y = FIXTOINT(pwall-&gt;screenybottomstart);
               apoint[<span class="dv">2</span>].y = FIXTOINT(pwall-&gt;screenybottomend);
               apoint[<span class="dv">3</span>].y = FIXTOINT(pwall-&gt;screenytopend);
               FillConvexPolygon(apoint, pwall-&gt;color);
            }
         }
         <span class="co">// If there&#39;s a near tree from this node, draw it;</span>
         <span class="co">// otherwise, work back up to the last-pushed parent</span>
         <span class="co">// node of the branch we just finished; we&#39;re done if</span>
         <span class="co">// there are no pending parent nodes.</span>
         <span class="co">// Figure whether this wall is facing frontward or</span>
         <span class="co">// backward; do in viewspace because non-visible walls</span>
         <span class="co">// aren&#39;t projected into screenspace, and we need to</span>
            <span class="co">// traverse all walls in the BSP tree, visible or not,</span>
            <span class="co">// in order to find all the visible walls</span>
         <span class="kw">if</span> (WallFacingViewer(pwall)) {
            <span class="co">// We&#39;re on the forward side of this wall, do the</span>
            <span class="co">// front children now</span>
            pNearChildren = pwall-&gt;fronttree;
         } <span class="kw">else</span> {
            <span class="co">// We&#39;re on the back side of this wall, do the back</span>
            <span class="co">// children now</span>
            pNearChildren = pwall-&gt;backtree;
         }
         <span class="co">// Walk the near subtree of this wall</span>
         <span class="kw">if</span> (pNearChildren != NULL)
            <span class="kw">goto</span> WalkNearTree;
         <span class="co">// Pop the last-pushed wall</span>
         pendingstackptr—;
         pwall = *pendingstackptr;
         <span class="kw">if</span> (pwall == NULL)
            <span class="kw">goto</span> NodesDone;
      }
WalkNearTree:
      pwall = pNearChildren;
   }
NodesDone:
;
}
<span class="co">// Render the current state of the world to the screen.</span>
<span class="dt">void</span> UpdateWorld()
{
   HPALETTE holdpal;
   HDC hdcScreen, hdcDIBSection;
   HBITMAP holdbitmap;
   <span class="co">// Draw the frame</span>
   UpdateViewPos();
   memset(pDIB, <span class="dv">0</span>, DIBPitch*DIBHeight);    <span class="co">// clear frame</span>
   TransformVertices();
   ClipWalls();
   DrawWallsBackToFront();
   <span class="co">// We&#39;ve drawn the frame; copy it to the screen</span>
   hdcScreen = GetDC(hwndOutput);
   holdpal = SelectPalette(hdcScreen, hpalDIB, FALSE);
   RealizePalette(hdcScreen);
   hdcDIBSection = CreateCompatibleDC(hdcScreen);
   holdbitmap = SelectObject(hdcDIBSection, hDIBSection);
   BitBlt(hdcScreen, <span class="dv">0</span>, <span class="dv">0</span>, DIBWidth, DIBHeight, hdcDIBSection,
          <span class="dv">0</span>, <span class="dv">0</span>, SRCCOPY);
   SelectPalette(hdcScreen, holdpal, FALSE);
   ReleaseDC(hwndOutput, hdcScreen);
   SelectObject(hdcDIBSection, holdbitmap);
   ReleaseDC(hwndOutput, hdcDIBSection);
   iteration++;
}</code></pre>
</section>
<section id="the-rendering-pipeline" class="level4">
<h4><a href="#the-rendering-pipeline">The Rendering Pipeline</a></h4>
<p>Conceptually rendering from a BSP tree really is that simple, but the implementation is a bit more complicated. The full rendering pipeline, as coordinated by <code>UpdateWorld()</code>, is this:</p>
<ul>
<li>Update the current location.</li>
<li>Transform all wall endpoints into viewspace (the world as seen from the current location with the current viewing angle).</li>
<li>Clip all walls to the view pyramid.</li>
<li>Project wall vertices to screen coordinates.</li>
<li>Walk the walls back to front, and for each wall that lies at least partially in the view pyramid, perform backface culling (skip walls facing away from the viewer), and draw the wall if it’s not culled.</li>
</ul>
<p>Next, we’ll look at each part of the pipeline more closely. The pipeline is too complex for me to be able to discuss each part in complete detail. Some sources for further reading are <em>Computer Graphics</em>, by Foley and van Dam (ISBN 0-201-12110-7), and the <em>DDJ Essential Books on Graphics Programming</em> CD.</p>
</section>
</section>
<section id="moving-the-viewer" class="level3">
<h3><a href="#moving-the-viewer">Moving the Viewer</a></h3>
<p>The sample BSP program performs first-person rendering; that is, it renders the world as seen from your eyes as you move about. The rate of movement is controlled by key-handling code that’s not shown in Listing 62.1; however, the variables set by the key-handling code are used in <code>UpdateViewPos()</code> to bring the current location up to date.</p>
<p>Note that the view position can change not only in x and z (movement around the but only viewing horizontally. Although the BSP tree is only 2-D, it is quite possible to support looking up and down to at least some extent, particularly if the world dataset is restricted so that, for example, there are never two rooms stacked on top of each other, or any tilted walls. For simplicity’s sake, I have chosen not to implement this in Listing 62.1, but you may find it educational to add it to the program yourself.</p>
</section>
<section id="transformation-into-viewspace" class="level3">
<h3><a href="#transformation-into-viewspace">Transformation into Viewspace</a></h3>
<p>The viewing angle (which controls direction of movement as well as view direction) can sweep through the full 360 degrees around the viewpoint, so long as it remains horizontal. The viewing angle is controlled by the key handler, and is used to define a unit vector stored in <code>currentorientation</code> that explicitly defines the view direction (the z axis of viewspace), and implicitly defines the x axis of viewspace, because that axis is at right angles to the z axis, where x increases to the right of the viewer.</p>
<p>As I discussed in the previous chapter, rotation to a new coordinate system can be performed by using the dot product to project points onto the axes of the new coordinate system, and that’s what <code>TransformVertices()</code> does, after first translating (moving) the coordinate system to have its origin at the viewpoint. (It’s necessary to perform the translation first so that the viewing rotation is around the viewpoint.) Note that this operation can equivalently be viewed as a matrix math operation, and that this is in fact the more common way to handle transformations.</p>
<p>At the same time, the points are scaled in x according to <code>PROJECTION_RATIO</code> to provide the desired field of view. Larger scale values result in narrower fields of view.</p>
<p>When this is done the walls are in viewspace, ready to be clipped.</p>
</section>
<section id="clipping" class="level3">
<h3><a href="#clipping">Clipping</a></h3>
<p>In viewspace, the walls may be anywhere relative to the viewpoint: in front, behind, off to the side. We only want to draw those parts of walls that properly belong on the screen; that is, those parts that lie in the view pyramid (view frustum), as shown in Figure 62.2. Unclipped walls—walls that lie entirely in the frustum—should be drawn in their entirety, fully clipped walls should not be drawn, and partially clipped walls must be trimmed before being drawn.</p>
<p>In Listing 62.1, <code>ClipWalls()</code> does this in three steps for each wall in turn. First, the z coordinates of the two ends of the wall are calculated. (Remember, walls are vertical and their ends go straight up and down, so the top and bottom of each end have the same x and z coordinates.) If both ends are on the near side of the front clip plane, then the polygon is fully clipped, and we’re done with it. If both ends are on the far side, then the polygon isn’t z-clipped, and we leave it unchanged. If the polygon straddles the near clip plane, then the wall is trimmed to stop at the near clip plane by adjusting the t value of the nearest endpoint appropriately; this calculation is a simple matter of scaling by z, because the near clip plane is at a constant z distance. (The use of t values for parametric lines was discussed in Chapter 60.) The process is further simplified because the walls can be treated as lines viewed from above, so we can perform 2-D clipping in z; this would not be the case if walls sloped or had sloping edges.</p>
<p>After clipping in z, we clip by viewspace x coordinate, to ensure that we draw only wall portions that lie between the left and right edges of the screen. Like z-clipping, x-clipping can be done as a 2-D clip, because the walls and the left and right sides of the frustum are all vertical. We compare both the start and endpoint of each wall to the left and right sides of the frustum, and reject, accept, or clip each wall’s t values accordingly. The test for x clipping is very simple, because the edges of the frustum are defined as the planes where x==z and -x==z.</p>
<figure>
<img src="images/62-02.jpg" alt="Figure 62.2  Clipping to the view pyramid." /><figcaption><strong>Figure 62.2</strong>  <em>Clipping to the view pyramid.</em></figcaption>
</figure>
<p>The final clip stage is clipping by y coordinate, and this is the most complicated, because vertical walls can be clipped at an angle in y, as shown in Figure 62.3, so true 3-D clipping of all four wall vertices is involved. We handle this in <code>ClipWalls()</code> by detecting trivial rejection in y, using y==z and ==z as the y boundaries of the frustum. However, we leave partial clipping to be handled as a 2-D clipping problem; we are able to do this only because our earlier z-clip to the near clip plane guarantees that no remaining polygon point can have z&lt;=0, ensuring that when we project we’ll always pass valid, y-clippable screenspace vertices to the polygon filler.</p>
</section>
<section id="projection-to-screenspace" class="level3">
<h3><a href="#projection-to-screenspace">Projection to Screenspace</a></h3>
<p>At this point, we have viewspace vertices for each wall that’s at least partially visible. All we have to do is project these vertices according to z distance—that is, perform perspective projection—and scale the results to the width of the screen, then we’ll be ready to draw. Although this step is logically separate from clipping, it is performed as the last step for visible walls in <code>ClipWalls()</code>.</p>
<figure>
<img src="images/62-03.jpg" alt="Figure 62.3  Why y clipping is more complex than x or z clipping." /><figcaption><strong>Figure 62.3</strong>  <em>Why y clipping is more complex than x or z clipping.</em></figcaption>
</figure>
</section>
<section id="walking-the-tree-backface-culling-and-drawing" class="level3">
<h3><a href="#walking-the-tree-backface-culling-and-drawing">Walking the Tree, Backface Culling and Drawing</a></h3>
<p>Now that we have all the walls clipped to the frustum, with vertices projected into screen coordinates, all we have to do is draw them back to front; that’s the job of <code>DrawWallsBackToFront()</code>. Basically, this routine walks the BSP tree, descending recursively from each node to draw the farther children of each node first, then the wall at the node, then the nearer children. In the interests of efficiency, this particular implementation performs a data-recursive walk of the tree, rather than the more familiar code recursion. Interestingly, the performance speedup from data recursion turned out to be more modest than I had expected, based on past experience; see Chapter 59 for further details.</p>
<p>As it comes to each wall, <code>DrawWallsBackToFront()</code> first descends to draw the farther subtree. Next, if the wall is both visible and pointing toward the viewer, it is drawn as a solid polygon. The polygon filler (not shown in Listing 62.1) is a modification of the polygon filler I presented in Chapters 38 and 39.</p>
<p>It’s worth noting how backface culling and front/back wall orientation testing are performed. (Note that walls are always one-sided, visible only from the front.) I discussed backface culling in general in the previous chapter, and mentioned two possible approaches: generating a screenspace normal (perpendicular vector) to the polygon and seeing which way that points, or taking the world or screenspace dot product between the vector from the viewpoint to any polygon point and the polygon’s normal and checking the sign. Listing 62.1 does both, but because our BSP tree is 2-D and the viewer is always upright, we can save some work.</p>
<p>Consider this: Walls are stored so that the left end, as viewed from the front side of the wall, is the start vertex, and the right end is the end vertex. There are only two possible ways that a wall can be positioned in screenspace, then: viewed from the front, in which case the start vertex is to the left of the end vertex, or viewed from the back, in which case the start vertex is to the right of the end vertex, as shown in Figure 62.4. So we can tell which side of a wall we’re seeing, and thus backface cull, simply by comparing the screenspace x coordinates of the start and end vertices, a simple 2-D version of checking the direction of the screenspace normal.</p>
<p>The wall orinetation test used for walking the BSP tree, performed in <code>WallFacingViewer()</code> takes the other approach, and checks the viewspace sign of the dot product of the wall’s normal with a vector from the viewpoint to the wall. Again, this code takes advantage of the 2-D nature of the tree to generate the wall normal by swapping x and z and altering signs. We can’t use the quicker screenspace x test here that we used for backface culling, because not all walls can be projected into screenspace; for example, trying to project a wall at z==0 would result in division by zero.</p>
<p>All the visible, front-facing walls are drawn into a buffer by <code>DrawWallsBackToFront()</code>, then <code>UpdateWorld()</code> calls Win32 to copy the new frame to the screen. The frame of animation is complete.</p>
<figure>
<img src="images/62-04.jpg" alt="Figure 62.4  Fast backspace culling test in screenspace." /><figcaption><strong>Figure 62.4</strong>  <em>Fast backspace culling test in screenspace.</em></figcaption>
</figure>
<section id="notes-on-the-bsp-renderer" class="level4">
<h4><a href="#notes-on-the-bsp-renderer">Notes on the BSP Renderer</a></h4>
<p>Listing 62.1 is far from complete or optimal. There is no such thing as a tiny BSP rendering demo, because 3D rendering, even when based on a 2-D BSP tree, requires a substantial amount of code and complexity. Listing 62.1 is reasonably close to a minimum rendering engine, and is specifically intended to illuminate basic BSP principles, given the space limitations of one chapter in a book that’s already larger than it should be. Think of Listing 62.1 as a learning tool and a starting point.</p>
<p>The most obvious lack in Listing 62.1 is that there is no support for floors and ceilings; the walls float in space, unsupported. Is it necessary to go to 3-D BSP trees to get a normal-looking world?</p>
<p>No. Although 3-D BSP trees offer many advantages in that they allow arbitrary datasets with viewing in any arbitrary direction and, in truth, aren’t much more complicated than 2-D BSP trees for back-to-front drawing, they do tend to be larger and more difficult to debug, and they aren’t necessary for floors and ceilings. One way to get floors and ceilings out of a 2-D BSP tree is to change the nature of the BSP tree so that polygons are no longer stored in the splitting nodes. Instead, each leaf of the tree—that is, each subspace carved out by the tree—would store the polygons for the walls, floors, and ceilings that lie on the boundaries of that space and face into that space. The subspace would be convex, because all BSP subspaces are automatically convex, so the polygons in that subspace can be drawn in any order. Thus, the subspaces in the BSP tree would each be drawn in turn as convex sets, back to front, just as Listing 62.1 draws polygons back to front.</p>
<p>This sort of BSP tree, organized around volumes rather than polygons, has some additional interesting advantages in simulating physics, detecting collisions, doing line-of-sight determination, and performing volume-based operations such as dynamic illumination and event triggering. However, that discussion will have to wait until another day.</p>
</section>
</section>
</section>
<section id="chapter-63-floating-point-for-real-time-3-d" class="level2">
<h2><a href="#chapter-63-floating-point-for-real-time-3-d">Chapter 63 – Floating-Point for Real-Time 3-D</a></h2>
<section id="knowing-when-to-hurl-conventional-math-wisdom-out-the-window" class="level3">
<h3><a href="#knowing-when-to-hurl-conventional-math-wisdom-out-the-window">Knowing When to Hurl Conventional Math Wisdom Out the Window</a></h3>
<p>In a crisis, sometimes it’s best to go with the first solution that comes into your head—but not very often.</p>
<p>When I turned 16, my mother had an aging, three-cylinder Saab—not one of the sporty Saabs that appeared in the late ’70s, but a blunt-nosed, ungainly little wagon that seated up to seven people in sardine-like comfort, with two of them perched on the gas tank. That was the car I learned to drive on, and the one I took whenever I wanted to go somewhere and my mother didn’t need it.</p>
<p>My father’s car, on the other hand, was a Volvo sedan, only a couple of years old and easily the classiest car my family had ever owned. To the best of my recollection, as of New Year’s of my senior year, I had never driven that car. However, I was going to a New Year’s party—in fact, I was going to chauffeur four other people—and for reasons lost in the mists of time, I was allowed to take the Volvo. So, one crystal clear, stunningly cold night, I picked up my passengers, who included Robin Viola, Kathy Smith, Jude Hawron…and Alan, whose last name I’ll omit in case he wants to run for president someday.</p>
<p>The party was at Craig Alexander’s house, way out in the middle of nowhere, and it was a good one. I heard Al Green for the first time, much beer was consumed (none by me, though), and around 2 a.m., we decided it was time to head home. So we piled into the Volvo, cranked the heat up to the max, and set off.</p>
<p>We had gone about five miles when I sensed Alan was trying to tell me something. As I turned toward him, he said, quite expressively, “BLEARGH!” and deposited a considerable volume of what had until recently been beer and chips into his lap.</p>
<p>Mind you, this wasn’t just any car Alan was tossing his cookies in—it was my father’s prized Volvo. My reactions were up to the task; without a moment’s hesitation, I shouted, “Do it out the window! Open the window!” Alan obligingly rolled the window down and, with flawless aim, sent some more erstwhile beer and chips on its way.</p>
<p>And it was here that I learned that fast decisions are not necessarily good decisions. A second after the liquid flew out the window, there was a loud smacking sound, and a yelp from Robin, as the sodden mass hit the slipstream and splattered along the length of the car. At that point, I did what I should have done in the first place; I stopped the car so Alan could get out and finish being sick in peace, while I assessed the full dimensions of the disaster. Not only was the rear half of the car on the passenger side—including Robin’s window, accounting for the yelp—covered, but the noxious substance had frozen solid. It looked like someone had melted an enormous candle, or possibly put cake frosting on the car.</p>
<p>The next morning, my father was remarkably good-natured about the whole thing, considering, although I don’t remember ever actually driving the Volvo again. My penance consisted of cleaning the car, no small punishment considering that I had to take a hair dryer out to our unheated garage and melt and clean the gunk one small piece at a time.</p>
<p>One thing I learned from this debacle is to pull over very, very quickly if anyone shows signed of being ill, a bit of wisdom that has proven useful a suprising number of times over the years. More important, though, is the lesson that it almost always pays to take at least a few seconds to size up a crisis situation and choose an effective response, and that’s served me well more times than I can count.</p>
<p>There’s a surprisingly close analog to this in programming. Often, when faced with a problem in his or her code, a programmer’s response is to come up with a solution as quickly as possible and immediately hack it in. For all but the simplest problems, though, there are side effects and design issues involved that should be thought through before any coding is done. I try to think of bugs and other problem situations as opportunities to reexamine how my code works, as well as chances to detect and correct structural defects I hadn’t previously suspected; in fact, I’m often able to simplify code as I fix a bug, thanks to the understanding I gain in the process.</p>
<p>Taking that a step farther, it’s useful to reexamine assumptions periodically even if no bugs are involved. You might be surprised at how quickly assumptions that once were completely valid can deteriorate.</p>
<p>For example, consider floating-point math.</p>
</section>
<section id="not-your-fathers-floating-point" class="level3">
<h3><a href="#not-your-fathers-floating-point">Not Your Father’s Floating-Point</a></h3>
<p>Until last year, I had never done any serious floating-point (FP) optimization, for the perfectly good reason that FP math had never been fast enough for any of the code I needed to write. It was an article of faith that FP, while undeniably convenient, because of its automatic support for constant precision over an enormous range of magnitudes, was just not fast enough for real-time programming, so I, like pretty much everyone else doing 3-D, expended a lot of time and effort in making fixed-point do the job.</p>
<p>That article of faith was true up through the 486, but all the old assumptions are out the window on the Pentium, for three reasons: faster FP instructions, a pipelined floating-point unit (FPU), and the magic of a parallel FXCH. Taken together, these mean that FP addition and subtraction are nearly as fast as integer operations, and FP multiplication and division have the potential to be much faster—all with the range and precision advantages of FP. Better yet, the FPU has its own set of eight registers, so the use of floating-point can help relieve pressure on the x86’s integer registers, as well.</p>
<p>One effect of all this is that with the Pentium, floating-point on the x86 has gone from being irrelevant to real-time 3-D to being a key element. Quake uses FP all the way down into the inner loop of the span rasterizer, performing several FP operations every 16 pixels.</p>
<p>Floating-point has not only become important for real-time 3-D on the PC, but will soon become even more crucial. Hardware accelerators will take care of texture mapping and will increase feasible scene complexity, meaning the CPU will do less bit-twiddling and will have far more vertices to transform and project, and far more motion physics and line-of-sight calculations and the like as well.</p>
<p>By way of getting you started with floating-point for real-time 3-D, in this chapter I’ll examine the basics of Pentium FP optimization, then look at how some key mathematical techniques for 3-D—dot product, cross product, transformation, and projection—can be accelerated.</p>
</section>
<section id="pentium-floating-point-optimization" class="level3">
<h3><a href="#pentium-floating-point-optimization">Pentium Floating-Point Optimization</a></h3>
<p>I’m going to assume you’re already familiar with x86 FP code in general; for additional information, check out Intel’s <em>Pentium Processor User’s Manual</em> (order #241430-001; 1-800-548-4725), a book that you should have if you’re doing Pentium programming of any sort. I’d also recommend taking a look around <a href="http://www.intel.com">http://www.intel.com</a>.</p>
<p>I’m going to focus on six core instructions in this section: FLD, FST, FADD, FSUB, FMUL, and FDIV. First, let’s look at cycle times for these instructions. FLD takes 1 cycle; the value is pushed onto the FP stack and ready for use on the next cycle. FST takes 2 cycles, although when storing to memory, there’s a potential extra cycle that can be lost, as I’ll describe shortly.</p>
<p>FDIV is a painfully slow instruction, taking 39 cycles at full precision and 33 cycles at double precision, which is the default precision for Visual C++ 2.0. While FDIV executes, the FPU is occupied, and can’t process subsequent FP instructions until FDIV finishes. However, during the cycles while FDIV is executing (with the exception of the one cycle during which FDIV starts), the integer unit can simultaneously execute instructions other than IMUL. (IMUL uses the FPU, and can only overlap with FDIV for a few cycles.) Since the integer unit can execute two instructions per cycle, this means it’s possible to have three instructions, an FDIV and two integer instructions, executing at the same time. That’s exactly what happens, for example, during the second cycle of this code:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">FDIV</span> <span class="kw">ST</span>(<span class="dv">0</span>),<span class="kw">ST</span>(<span class="dv">1</span>)
<span class="kw">ADD</span>  <span class="kw">EAX</span>,<span class="kw">ECX</span>
<span class="kw">INC</span>  <span class="kw">EDX</span></code></pre>
<p>There’s an important limitation, though; if the instruction stream following the FDIV reaches a FP instruction (or an IMUL), then that instruction and all subsequent instructions, both integer and FP, must wait to execute until FDIV has finished.</p>
<p>When a FADD, FSUB, or FMUL instruction is executed, it is 3 cycles before the result can be used by another instruction. (There’s an exception: If the instruction that attempts to use the result is an FST to memory, there’s an extra cycle lost, so it’s 4 cycles from the start of an arithmetic instruction until an FST of that value can begin, so</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">FMUL</span> <span class="kw">ST</span>(<span class="dv">0</span>),<span class="kw">ST</span>(<span class="dv">1</span>)
<span class="kw">FST</span>  [temp]</code></pre>
<p>takes 6 cycles in all.) Again, it’s possible to execute integer-unit instructions during the 2 (or 3, for FST) cycles after one of these FP instructions starts. There’s a more exciting possibility here, though: Given properly structured code, the FPU is capable of averaging 1 cycle per FADD, FSUB, or FMUL. The secret is pipelining.</p>
<section id="pipelining-latency-and-throughput" class="level4">
<h4><a href="#pipelining-latency-and-throughput">Pipelining, Latency, and Throughput</a></h4>
<p>The Pentium’s FPU is the first pipelined x86 FPU. <em>Pipelining</em> means that the FPU is capable of starting an instruction every cycle, and can simultaneously handle several instructions in various stages of completion. Only certain x86 FP instructions allow another instruction to start on the next cycle, though: FADD, FSUB, and FMUL are pipelined, but FST and FDIV are not. (FLD executes in a single cycle, so pipelining is not an issue.) Thus, in the code sequence</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">FADD1
<span class="kw">FSUB</span>
FADD2
<span class="kw">FMUL</span></code></pre>
<p>FADD<sub>1</sub> can start on cycle N, FSUB can start on cycle N+1, FADD<sub>2</sub> can start on cycle N+2, and FMUL can start on cycle N+3. At the start of cycle N+3, the result of FADD<sub>1</sub> is available in the destination operand, because it’s been 3 cycles since the instruction started; FSUB is starting the final cycle of calculation; FADD<sub>2</sub> is starting its second cycle, with one cycle yet to go after this; and FMUL is about to be issued. Each of the instructions takes 3 cycles to produce a result from the time it starts, but because they’re simultaneously processed at different pipeline stages, one instruction is issued and one instruction completes every cycle. Thus, the latency of these instructions—that is, the time until the result is available—is 3 cycles, but the throughput—the rate at which the FPU can start new instructions—is 1 cycle. An exception is that the FPU is capable of starting an FMUL only every 2 cycles, so between these two instructions</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">FMUL</span> <span class="kw">ST</span>(<span class="dv">1</span>),<span class="kw">ST</span>(<span class="dv">0</span>)
<span class="kw">FMUL</span> <span class="kw">ST</span>(<span class="dv">2</span>),<span class="kw">ST</span>(<span class="dv">0</span>)</code></pre>
<p>there’s a 1-cycle stall, and the following three instructions execute just as fast as the above pair:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">FMUL</span> <span class="kw">ST</span>(<span class="dv">1</span>),<span class="kw">ST</span>(<span class="dv">0</span>)
<span class="kw">FLD</span>  <span class="kw">ST</span>(<span class="dv">4</span>)
<span class="kw">FMUL</span> <span class="kw">ST</span>(<span class="dv">0</span>),<span class="kw">ST</span>(<span class="dv">1</span>)</code></pre>
<p>There’s a caveat here, though: A FP instruction can’t be issued until its operands are available. The FPU can reach a throughput of 1 cycle per instruction on this code</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">FADD</span> <span class="kw">ST</span>(<span class="dv">1</span>),<span class="kw">ST</span>(<span class="dv">0</span>)
<span class="kw">FLD</span>  [temp]
<span class="kw">FSUB</span> <span class="kw">ST</span>(<span class="dv">1</span>),<span class="kw">ST</span>(<span class="dv">0</span>)</code></pre>
<p>because neither the FLD nor the FSUB needs the result from the FADD. Consider, however</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">FADD</span> <span class="kw">ST</span>(<span class="dv">0</span>),<span class="kw">ST</span>(<span class="dv">2</span>)
<span class="kw">FSUB</span> <span class="kw">ST</span>(<span class="dv">0</span>),<span class="kw">ST</span>(<span class="dv">1</span>)</code></pre>
<p>where the ST(0) operand to FSUB is calculated by FADD. Here, FSUB can’t start until FADD has completed, so there are 2 stall cycles between the two instructions. When dependencies like this occur, the FPU runs at latency rather than throughput speeds, and performance can drop by as much as two-thirds.</p>
</section>
<section id="fxch" class="level4">
<h4><a href="#fxch">FXCH</a></h4>
<p>One piece of the puzzle is still missing. Clearly, to get maximum throughput, we need to interleave FP instructions, such that at any one time ideally three instructions are in the pipeline at once. Further, these instructions must not depend on one another for operands. But ST(0) must always be one of the operands; worse, FLD can only push into ST(0), and FST can only store from ST(0). How, then, can we keep three independent instructions going?</p>
<p>The easy answer would be for Intel to change the FP registers from a stack to a set of independent registers. Since they couldn’t do that, thanks to compatibility issues, they did the next best thing: They made the FXCH instruction, which swaps ST(0) and any other FP register, virtually free. In general, if FXCH is both preceded and followed by FP instructions, then it takes <em>no</em> cycles to execute. (Application Note 500, “Optimizations for Intel’s 32-bit Processors,” February 1994, available from <a href="http://www.intel.com">http://www.intel.com</a>, describes all .the conditions under which FXCH is free.) This allows you to move the target of a pending operation from ST(0) to another register, at the same time bringing another register into ST(0) where it can be used, all at no cost. So, for example, we can start three multiplications, then use FXCH to swap back to start adding the results of the first two multiplications, without incurring any stalls, as shown in Listing 63.1.</p>
<p><strong>Listing 63.1 L63-1.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; use of fxch to allow addition of first two; products to start while third : multiplication finishes</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+0</span>]        <span class="co">;starts &amp; ends on cycle 0</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+0</span>]        <span class="co">;starts on cycle 1</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+4</span>]        <span class="co">;starts &amp; ends on cycle 2</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+4</span>]        <span class="co">;starts on cycle 3</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+8</span>]        <span class="co">;starts &amp; ends on cycle 4</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+8</span>]        <span class="co">;starts on cycle 5</span>
        <span class="kw">fxch</span>    <span class="kw">st</span>(<span class="dv">1</span>)           <span class="co">;no cost</span>
        <span class="kw">faddp</span>   <span class="kw">st</span>(<span class="dv">2</span>),<span class="kw">st</span>(<span class="dv">0</span>)     <span class="co">;starts on cycle 6</span></code></pre>
</section>
</section>
<section id="the-dot-product-1" class="level3">
<h3><a href="#the-dot-product-1">The Dot Product</a></h3>
<p>Now we’re ready to look at fast FP for common 3-D operations; we’ll start by looking at how to speed up the dot product. As discussed in Chapter 30, the dot product is heavily used in 3-D to calculate cosines and to project points along vectors. The dot product is calculated as d = u<sub>1</sub>v<sub>1</sub> + u<sub>2</sub>v<sub>2</sub> + u<sub>3</sub>v<sub>3</sub>; with three loads, three multiplies, two adds, and a store, the theoretical minimum time for this calculation is 10 cycles.</p>
<p>Listing 63.2 shows a straightforward dot product implementation. This version loses 7 cycles to stalls. Listing 63.3 cuts the loss to 5 cycles by doing all three FMULs first, then using FXCH to set the third FXCH aside to complete while the results of the first two FMULs, which have completed, are added. Listing 43.3 still loses 50 percent to stalls, but unless some other code is available to be interleaved with the dot product code, that’s all we can do to speed things up. Fortunately, dot products are often used in contexts where there’s plenty of interleaving potential, as we’ll see when we discuss transformation.</p>
<p><strong>Listing 63.2 1 L63-2.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; unoptimized dot product; 17 cycles</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+0</span>]        <span class="co">;starts &amp; ends on cycle 0</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+0</span>]        <span class="co">;starts on cycle 1</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+4</span>]        <span class="co">;starts &amp; ends on cycle 2</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+4</span>]        <span class="co">;starts on cycle 3</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+8</span>]        <span class="co">;starts &amp; ends on cycle 4</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+8</span>]        <span class="co">;starts on cycle 5</span>
                                <span class="co">;stalls for cycles 6-7</span>
        <span class="kw">faddp</span>   <span class="kw">st</span>(<span class="dv">1</span>),<span class="kw">st</span>(<span class="dv">0</span>)     <span class="co">;starts on cycle 8</span>
                                <span class="co">;stalls for cycles 9-10</span>
        <span class="kw">faddp</span>   <span class="kw">st</span>(<span class="dv">1</span>),<span class="kw">st</span>(<span class="dv">0</span>)     <span class="co">;starts on cycle 11</span>
                                <span class="co">;stalls for cycles 12-14</span>
        <span class="kw">fstp</span>    [dot]           <span class="co">;starts on cycle 15,</span>
                                <span class="co">; ends on cycle 16</span></code></pre>
<p><strong>Listing 63.3 L63-3.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">;optimized dot product; 15 cycles</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+0</span>]        <span class="co">;starts &amp; ends on cycle 0</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+0</span>]        <span class="co">;starts on cycle 1</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+4</span>]        <span class="co">;starts &amp; ends on cycle 2</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+4</span>]        <span class="co">;starts on cycle 3</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+8</span>]        <span class="co">;starts &amp; ends on cycle 4</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+8</span>]        <span class="co">;starts on cycle 5</span>
        <span class="kw">fxch</span>    <span class="kw">st</span>(<span class="dv">1</span>)           <span class="co">;no cost</span>
        <span class="kw">faddp</span>   <span class="kw">st</span>(<span class="dv">2</span>),<span class="kw">st</span>(<span class="dv">0</span>)     <span class="co">;starts on cycle 6</span>
                                <span class="co">;stalls for cycles 7-8</span>
        <span class="kw">faddp</span>   <span class="kw">st</span>(<span class="dv">1</span>),<span class="kw">st</span>(<span class="dv">0</span>)     <span class="co">;starts on cycle 9</span>
                                <span class="co">;stalls for cycles 10-12</span>
        <span class="kw">fstp</span>    [dot]           <span class="co">;starts on cycle 13,</span>
                                <span class="co">; ends on cycle 14</span></code></pre>
</section>
<section id="the-cross-product" class="level3">
<h3><a href="#the-cross-product">The Cross Product</a></h3>
<p>When last we looked at the cross product, we found that it’s handy for generating a vector that’s normal to two other vectors. The cross product is calculated as [u<sub>2</sub>v<sub>3</sub>-u<sub>3</sub>v<sub>2</sub> u<sub>3</sub>v<sub>1</sub>-u<sub>1</sub>v<sub>3</sub> u<sub>1</sub>v<sub>2</sub>-u<sub>2</sub>v<sub>1</sub>]. The theoretical minimum cycle count for the cross product is 21 cycles. Listing 63.4 shows a straightforward implementation that calculates each component of the result separately, losing 15 cycles to stalls.</p>
<p><strong>Listing 63.4 L63-4.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">;unoptimized cross product; 36 cycles</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+4</span>]         <span class="co">;starts &amp; ends on cycle 0</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+8</span>]         <span class="co">;starts on cycle 1</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+8</span>]         <span class="co">;starts &amp; ends on cycle 2</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+4</span>]         <span class="co">;starts on cycle 3</span>
                                 <span class="co">;stalls for cycles 4-5</span>
        <span class="kw">fsubrp</span>  <span class="kw">st</span>(<span class="dv">1</span>),<span class="kw">st</span>(<span class="dv">0</span>)      <span class="co">;starts on cycle 6</span>
                                 <span class="co">;stalls for cycles 7-9</span>
        <span class="kw">fstp</span>    [vec2<span class="dv">+0</span>]         <span class="co">;starts on cycle 10,</span>
                                 <span class="co">; ends on cycle 11</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+8</span>]         <span class="co">;starts &amp; ends on cycle 12</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+0</span>]         <span class="co">;starts on cycle 13</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+0</span>]         <span class="co">;starts &amp; ends on cycle 14</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+8</span>]         <span class="co">;starts on cycle 15</span>
                                 <span class="co">;stalls for cycles 16-17</span>
        <span class="kw">fsubrp</span>  <span class="kw">st</span>(<span class="dv">1</span>),<span class="kw">st</span>(<span class="dv">0</span>)      <span class="co">;starts on cycle 18</span>
                                 <span class="co">;stalls for cycles 19-21</span>
        <span class="kw">fstp</span>    [vec2<span class="dv">+4</span>]         <span class="co">;starts on cycle 22,</span>
                                 <span class="co">; ends on cycle 23</span>

        <span class="kw">fld</span>     [vec0<span class="dv">+0</span>]         <span class="co">;starts &amp; ends on cycle 24</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+4</span>]         <span class="co">;starts on cycle 25</span>
        <span class="kw">fld</span>     [vec0<span class="dv">+4</span>]         <span class="co">;starts &amp; ends on cycle 26</span>
        <span class="kw">fmul</span>    [vec1<span class="dv">+0</span>]         <span class="co">;starts on cycle 27</span>
                                 <span class="co">;stalls for cycles 28-29</span>
        <span class="kw">fsubrp</span>  <span class="kw">st</span>(<span class="dv">1</span>),<span class="kw">st</span>(<span class="dv">0</span>)      <span class="co">;starts on cycle 30</span>
                                 <span class="co">;stalls for cycles 31-33</span>
        <span class="kw">fstp</span>    [vec2<span class="dv">+8</span>]         <span class="co">;starts on cycle 34,</span>
                                 <span class="co">; ends on cycle 35</span></code></pre>
<p>We couldn’t get rid of many of the stalls in the dot product code because with six inputs and one output, it was impossible to interleave all the operations. However, the cross product, with three outputs, is much more amenable to optimization. In fact, three is the magic number; because we have three calculation streams and the latency of FADD, FSUB, and FMUL is 3 cycles, we can eliminate almost every single stall in the cross-product calculation, as shown in Listing 63.5. Listing 63.5 loses only one cycle to a stall, the cycle before the first FST; the relevant FSUB has just finished on the preceding cycle, so we run into the extra cycle of latency associated with FST. Listing 63.5 is more than 60 percent faster than Listing 63.4, a striking illustration of the power of properly managing the Pentium’s FP pipeline.</p>
<p><strong>Listing 63.5 L63-5.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">;optimized cross product; 22 cycles</span>
        <span class="kw">fld</span>       [vec0<span class="dv">+4</span>]        <span class="co">;starts &amp; ends on cycle 0</span>
        <span class="kw">fmul</span>      [vec1<span class="dv">+8</span>]        <span class="co">;starts on cycle 1</span>
        <span class="kw">fld</span>       [vec0<span class="dv">+8</span>]        <span class="co">;starts &amp; ends on cycle 2</span>
        <span class="kw">fmul</span>      [vec1<span class="dv">+0</span>]        <span class="co">;starts on cycle 3</span>
        <span class="kw">fld</span>       [vec0<span class="dv">+0</span>]        <span class="co">;starts &amp; ends on cycle 4</span>
        <span class="kw">fmul</span>      [vec1<span class="dv">+4</span>]        <span class="co">;starts on cycle 5</span>
        <span class="kw">fld</span>       [vec0<span class="dv">+8</span>]        <span class="co">;starts &amp; ends on cycle 6</span>
        <span class="kw">fmul</span>      [vec1<span class="dv">+4</span>]        <span class="co">;starts on cycle 7</span>
        <span class="kw">fld</span>       [vec0<span class="dv">+0</span>]        <span class="co">;starts &amp; ends on cycle 8</span>
        <span class="kw">fmul</span>      [vec1<span class="dv">+8</span>]        <span class="co">;starts on cycle 9</span>
        <span class="kw">fld</span>       [vec0<span class="dv">+4</span>]        <span class="co">;starts &amp; ends on cycle 10</span>
        <span class="kw">fmul</span>      [vec1<span class="dv">+0</span>]        <span class="co">;starts on cycle 11</span>
        <span class="kw">fxch</span>      <span class="kw">st</span>(<span class="dv">2</span>)           <span class="co">;no cost</span>
        <span class="kw">fsubrp</span>    <span class="kw">st</span>(<span class="dv">5</span>),<span class="kw">st</span>(<span class="dv">0</span>)     <span class="co">;starts on cycle 12</span>
        <span class="kw">fsubrp</span>    <span class="kw">st</span>(<span class="dv">3</span>),<span class="kw">st</span>(<span class="dv">0</span>)     <span class="co">;starts on cycle 13</span>
        <span class="kw">fsubrp</span>    <span class="kw">st</span>(<span class="dv">1</span>),<span class="kw">st</span>(<span class="dv">0</span>)     <span class="co">;starts on cycle 14</span>
        <span class="kw">fxch</span>      <span class="kw">st</span>(<span class="dv">2</span>)           <span class="co">;no cost</span>
                                  <span class="co">;stalls for cycle 15</span>
        <span class="kw">fstp</span>      [vec2<span class="dv">+0</span>]        <span class="co">;starts on cycle 16,</span>
                                      <span class="co">; ends on cycle 17</span>
        <span class="kw">fstp</span>      [vec2<span class="dv">+4</span>]        <span class="co">;starts on cycle 18,</span>
                                  <span class="co">; ends on cycle 19</span>
        <span class="kw">fstp</span>      [vec2<span class="dv">+8</span>]        <span class="co">;starts on cycle 20,</span>
                                  <span class="co">; ends on cycle 21</span></code></pre>
</section>
<section id="transformation" class="level3">
<h3><a href="#transformation">Transformation</a></h3>
<p>Transforming a point, for example from worldspace to viewspace, is one of the most heavily used FP operations in realtime 3-D. Conceptually, transformation is nothing more than three dot products and three additions, as I will discuss in Chapter 61. (Note that I’m talking about a subset of a general 4x4 transformation matrix, where the fourth row is always implicitly [0 0 0 1]. This limited form suffices for common transformations, and does 25 percent less work than a full 4x4 transformation.)</p>
<p>Transformation is calculated as:</p>
<pre><code>v1      m11 m12 m13 m14    u1
v2  =   m21 m22 m23 m24    u2
v3      m31 m32 m33 m34    u3
1       0   0   0   1      1</code></pre>
<p>or</p>
<pre><code>v1 = m11u1 + m12u2 + m13u3 + m14
v2 = m21u1 + m22u2 + m23u3 + m24
v3 = m31u1 + m32u2 + m33u3 + m34.</code></pre>
<p>When it comes to implementation, however, transformation is quite different from three separate dot products and additions, because once again the magic number <em>three</em> is involved. Three separate dot products and additions would take 60 cycles if each were calculated using the unoptimized dot-product code of Listing 63.2, and would take 54 cycles if done one after the other using the faster dot-product code of Listing 63.3, in each case followed by the a final addition per dot product.</p>
<p>When fully interleaved, however, only a single cycle is lost (again to the extra cycle of FST latency), and the cycle count drops to 34, as shown in Listing 63.6. This means that on a 100 MHz Pentium, it’s theoretically possible to do nearly 3,000,000 transforms per second, although that’s a purely hypothetical number, due to cache effects and set-up costs. Still, more than 1,000,000 transforms per second is certainly feasible; at a frame rate of 30 Hz, that’s an impressive 30,000 transforms per frame.</p>
<p><strong>Listing 63.6 L63-6.ASM</strong></p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">  <span class="co">;optimized transformation: 34 cycles</span>
        <span class="kw">fld</span>      [vec0<span class="dv">+0</span>]           <span class="co">;starts &amp; ends on cycle 0</span>
        <span class="kw">fmul</span>     [matrix<span class="dv">+0</span>]         <span class="co">;starts on cycle 1</span>
        <span class="kw">fld</span>      [vec0<span class="dv">+0</span>]           <span class="co">;starts &amp; ends on cycle 2</span>
        <span class="kw">fmul</span>     [matrix<span class="dv">+16</span>]        <span class="co">;starts on cycle 3</span>
        <span class="kw">fld</span>      [vec0<span class="dv">+0</span>]           <span class="co">;starts &amp; ends on cycle 4</span>
        <span class="kw">fmul</span>     [matrix<span class="dv">+32</span>]        <span class="co">;starts on cycle 5</span>
        <span class="kw">fld</span>      [vec0<span class="dv">+4</span>]           <span class="co">;starts &amp; ends on cycle 6</span>
        <span class="kw">fmul</span>     [matrix<span class="dv">+4</span>]         <span class="co">;starts on cycle 7</span>
        <span class="kw">fld</span>      [vec0<span class="dv">+4</span>]           <span class="co">;starts &amp; ends on cycle 8</span>
        <span class="kw">fmul</span>     [matrix<span class="dv">+20</span>]        <span class="co">;starts on cycle 9</span>
        <span class="kw">fld</span>      [vec0<span class="dv">+4</span>]           <span class="co">;starts &amp; ends on cycle 10</span>
        <span class="kw">fmul</span>     [matrix<span class="dv">+36</span>]        <span class="co">;starts on cycle 11</span>
        <span class="kw">fxch</span>     <span class="kw">st</span>(<span class="dv">2</span>)              <span class="co">;no cost</span>
        <span class="kw">faddp</span>    <span class="kw">st</span>(<span class="dv">5</span>),<span class="kw">st</span>(<span class="dv">0</span>)        <span class="co">;starts on cycle 12</span>
        <span class="kw">faddp</span>    <span class="kw">st</span>(<span class="dv">3</span>),<span class="kw">st</span>(<span class="dv">0</span>)        <span class="co">;starts on cycle 13</span>
        <span class="kw">faddp</span>    <span class="kw">st</span>(<span class="dv">1</span>),<span class="kw">st</span>(<span class="dv">0</span>)        <span class="co">;starts on cycle 14</span>
        <span class="kw">fld</span>      [vec0<span class="dv">+8</span>]           <span class="co">;starts &amp; ends on cycle 15</span>
        <span class="kw">fmul</span>     [matrix<span class="dv">+8</span>]         <span class="co">;starts on cycle 16</span>
        <span class="kw">fld</span>      [vec0<span class="dv">+8</span>]           <span class="co">;starts &amp; ends on cycle 17</span>
        <span class="kw">fmul</span>     [matrix<span class="dv">+24</span>]        <span class="co">;starts on cycle 18</span>
        <span class="kw">fld</span>      [vec0<span class="dv">+8</span>]           <span class="co">;starts &amp; ends on cycle 19</span>
        <span class="kw">fmul</span>     [matrix<span class="dv">+40</span>]        <span class="co">;starts on cycle 20</span>
        <span class="kw">fxch</span>     <span class="kw">st</span>(<span class="dv">2</span>)              <span class="co">;no cost</span>
        <span class="kw">faddp</span>    <span class="kw">st</span>(<span class="dv">5</span>),<span class="kw">st</span>(<span class="dv">0</span>)        <span class="co">;starts on cycle 21</span>
        <span class="kw">faddp</span>    <span class="kw">st</span>(<span class="dv">3</span>),<span class="kw">st</span>(<span class="dv">0</span>)        <span class="co">;starts on cycle 22</span>
        <span class="kw">faddp</span>    <span class="kw">st</span>(<span class="dv">1</span>),<span class="kw">st</span>(<span class="dv">0</span>)        <span class="co">;starts on cycle 23</span>
        <span class="kw">fxch</span>     <span class="kw">st</span>(<span class="dv">2</span>)              <span class="co">;no cost</span>
        <span class="kw">fadd</span>     [matrix<span class="dv">+12</span>]        <span class="co">;starts on cycle 24</span>
        <span class="kw">fxch</span>     <span class="kw">st</span>(<span class="dv">1</span>)              <span class="co">;starts on cycle 25</span>
        <span class="kw">fadd</span>     [matrix<span class="dv">+28</span>]        <span class="co">;starts on cycle 26</span>
        <span class="kw">fxch</span>     <span class="kw">st</span>(<span class="dv">2</span>)              <span class="co">;no cost</span>
        <span class="kw">fadd</span>     [matrix<span class="dv">+44</span>]        <span class="co">;starts on cycle 27</span>
        <span class="kw">fxch</span>     <span class="kw">st</span>(<span class="dv">1</span>)              <span class="co">;no cost</span>
        <span class="kw">fstp</span>     [vec1<span class="dv">+0</span>]           <span class="co">;starts on cycle 28,</span>
                                    <span class="co">; ends on cycle 29</span>
        <span class="kw">fstp</span>     [vec1<span class="dv">+8</span>]           <span class="co">;starts on cycle 30,</span>
                                    <span class="co">; ends on cycle 31</span>
        <span class="kw">fstp</span>     [vec1<span class="dv">+4</span>]           <span class="co">;starts on cycle 32,</span>
                                    <span class="co">; ends on cycle 33</span></code></pre>
</section>
<section id="projection-1" class="level3">
<h3><a href="#projection-1">Projection</a></h3>
<p>The final optimization we’ll look at is projection to screenspace. Projection itself is basically nothing more than a divide (to get 1/z), followed by two multiplies (to get x/z and y/z), so there wouldn’t seem to be much in the way of FP optimization possibilities there. However, remember that although FDIV has a latency of up to 39 cycles, it can overlap with integer instructions for all but one of those cycles. That means that if we can find enough independent integer work to do before we need the 1/z result, we can effectively reduce the cost of the FDIV to one cycle. Projection by itself doesn’t offer much with which to overlap, but other work such as clamping, window-relative adjustments, or 2-D clipping could be interleaved with the FDIV for the next point.</p>
<p>Another dramatic speed-up is possible by setting the precision of the FPU down to single precision via FLDCW, thereby cutting the time FDIV takes to a mere 19 cycles. I don’t have the space to discuss reduced precision in detail in this book, but be aware that along with potentially greater performance, it carries certain risks, as well. The reduced precision, which affects FADD, FSUB, FMUL, FDIV, and FSQRT, can cause subtle differences from the results you’d get using compiler defaults. If you use reduced precision, you should be on the alert for precision-related problems, such as clipped values that vary more than you’d expect from the precise clip point, or the need for using larger epsilons in comparisons for point-on-plane tests.</p>
</section>
<section id="rounding-control" class="level3">
<h3><a href="#rounding-control">Rounding Control</a></h3>
<p>Another useful area that I can note only in passing here is that of leaving the FPU in a particular rounding mode while performing bulk operations of some sort. For example, conversion to int via the FIST instruction requires that the FPU be in chop mode. Unfortunately, the FLDCW instruction must be used to get the FPU into and out of chop mode, and each FLDCW takes 7 cycles, meaning that compilers often take at least 14 cycles for each float-&gt;int conversion. In assembly, you can just set the rounding state (or, likewise, the precision, for faster FDIVs) once at the start of the loop, and save all those FLDCW cycles each time through the loop. This is even more true for <code>ceil()</code>, which many compilers implement as horrendously inefficient subroutines, even though there are rounding modes for both <code>ceil()</code> and <code>floor()</code>. Again, though, be aware that results of FP calculations will be subtly different from compiler default behavior while chop, ceil, or floor mode is in effect.</p>
<p>A final note: There are some speed-ups to be had by manipulating FP variables with integer instructions. Check out Chris Hecker’s column in the February/March 1996 issue of <em>Game Developer</em> for details.</p>
</section>
<section id="a-farewell-to-3-d-fixed-point" class="level3">
<h3><a href="#a-farewell-to-3-d-fixed-point">A Farewell to 3-D Fixed-Point</a></h3>
<p>As with most optimizations, there are both benefits and hazards to floating-point acceleration, especially pedal-to-the-metal optimizations such as the last few I’ve mentioned. Nonetheless, I’ve found floating-point to be generally both more robust and easier to use than fixed-point even with those maximum optimizations. Now that floating-point is fast enough for real time, I don’t expect to be doing a whole lot of fixed-point 3-D math from here on out.</p>
<p>And I won’t miss it a bit.</p>
</section>
</section>
<section id="chapter-64-quakes-visible-surface-determination" class="level2">
<h2><a href="#chapter-64-quakes-visible-surface-determination">Chapter 64 – Quake’s Visible-Surface Determination</a></h2>
<section id="the-challenge-of-separating-all-things-seen-from-all-things-unseen" class="level3">
<h3><a href="#the-challenge-of-separating-all-things-seen-from-all-things-unseen">The Challenge of Separating All Things Seen from All Things Unseen</a></h3>
<p>Years ago, I was working at Video Seven, a now-vanished video adapter manufacturer, helping to develop a VGA clone. The fellow who was designing Video Seven’s VGA chip, Tom Wilson, had worked around the clock for months to make his VGA run as fast as possible, and was confident he had pretty much maxed out its performance. As Tom was putting the finishing touches on his chip design, however, news came fourth-hand that a competitor, Paradise, had juiced up the performance of the clone they were developing by putting in a FIFO.</p>
<p>That was all he knew; there was no information about what sort of FIFO, or how much it helped, or anything else. Nonetheless, Tom, normally an affable, laid-back sort, took on the wide-awake, haunted look of a man with too much caffeine in him and no answers to show for it, as he tried to figure out, from hopelessly thin information, what Paradise had done. Finally, he concluded that Paradise must have put a write FIFO between the system bus and the VGA, so that when the CPU wrote to video memory, the write immediately went into the FIFO, allowing the CPU to keep on processing instead of stalling each time it wrote to display memory.</p>
<p>Tom couldn’t spare the gates or the time to do a full FIFO, but he could implement a one-deep FIFO, allowing the CPU to get one write ahead of the VGA. He wasn’t sure how well it would work, but it was all he could do, so he put it in and taped out the chip.</p>
<p>The one-deep FIFO turned out to work astonishingly well; for a time, Video Seven’s VGAs were the fastest around, a testament to Tom’s ingenuity and creativity under pressure. However, the truly remarkable part of this story is that Paradise’s FIFO design turned out to bear not the slightest resemblance to Tom’s, and <em>didn’t work as well.</em> Paradise had stuck a <em>read</em> FIFO between display memory and the video output stage of the VGA, allowing the video output to read ahead, so that when the CPU wanted to access display memory, pixels could come from the FIFO while the CPU was serviced immediately. That did indeed help performance—but not as much as Tom’s write FIFO.</p>
<blockquote>
<p><img src="images/i.jpg" /> What we have here is as neat a parable about the nature of creative design as one could hope to find. The scrap of news about Paradise’s chip contained almost no actual information, but it forced Tom to push past the limits he had unconsciously set in coming up with his original design. And, in the end, I think that the single most important element of great design, whether it be hardware, software, or any creative endeavor, is precisely what the Paradise news triggered in Tom: the ability to detect the limits you have built into the way you think about your design, and then transcend those limits.</p>
</blockquote>
<p>The problem, of course, is how to go about transcending limits you don’t even know you’ve imposed. There’s no formula for success, but two principles can stand you in good stead: simplify and keep on trying new things.</p>
<p>Generally, if you find your code getting more complex, you’re fine-tuning a frozen design, and it’s likely you can get more of a speed-up, with less code, by rethinking the design. A really good design should bring with it a moment of immense satisfaction in which everything falls into place, and you’re amazed at how little code is needed and how all the boundary cases just work properly.</p>
<p>As for how to rethink the design, do it by pursuing whatever ideas occur to you, no matter how off-the-wall they seem. Many of the truly brilliant design ideas I’ve heard of over the years sounded like nonsense at first, because they didn’t fit my preconceived view of the world. Often, such ideas are in fact off-the-wall, but just as the news about Paradise’s chip sparked Tom’s imagination, aggressively pursuing seemingly outlandish ideas can open up new design possibilities for you.</p>
<p>Case in point: The evolution of Quake’s 3-D graphics engine.</p>
</section>
<section id="vsd-the-toughest-3-d-challenge-of-all" class="level3">
<h3><a href="#vsd-the-toughest-3-d-challenge-of-all">VSD: The Toughest 3-D Challenge of All</a></h3>
<p>I’ve spent most of my waking hours for the last several months working on Quake, id Software’s successor to DOOM, and I suspect I have a few more months to go. The very best things don’t happen easily, nor quickly—but when they happen, all the sweat becomes worthwhile.</p>
<p>In terms of graphics, Quake is to DOOM as DOOM was to its predecessor, Wolfenstein 3-D. Quake adds true, arbitrary 3-D (you can look up and down, lean, and even fall on your side), detailed lighting and shadows, and 3-D monsters and players in place of DOOM’s sprites. Someday I hope to talk about how all that works, but for the here and now I want to talk about what is, in my opinion, the toughest 3-D problem of all: visible surface determination (drawing the proper surface at each pixel), and its close relative, culling (discarding non-visible polygons as quickly as possible, a way of accelerating visible surface determination). In the interests of brevity, I’ll use the abbreviation VSD to mean both visible surface determination and culling from now on.</p>
<p>Why do I think VSD is the toughest 3-D challenge? Although rasterization issues such as texture mapping are fascinating and important, they are tasks of relatively finite scope, and are being moved into hardware as 3-D accelerators appear; also, they only scale with increases in screen resolution, which are relatively modest.</p>
<p>In contrast, VSD is an open-ended problem, and there are dozens of approaches currently in use. Even more significantly, the performance of VSD, done in an unsophisticated fashion, scales directly with scene complexity, which tends to increase as a square or cube function, so this very rapidly becomes the limiting factor in rendering realistic worlds. I expect VSD to be the increasingly dominant issue in realtime PC 3-D over the next few years, as 3-D worlds become increasingly detailed. Already, a good-sized Quake level contains on the order of 10,000 polygons, about three times as many polygons as a comparable DOOM level.</p>
</section>
<section id="the-structure-of-quake-levels" class="level3">
<h3><a href="#the-structure-of-quake-levels">The Structure of Quake Levels</a></h3>
<p>Before diving into VSD, let me note that each Quake level is stored as a single huge 3-D BSP tree. This BSP tree, like any BSP, subdivides space, in this case along the planes of the polygons. However, unlike the BSP tree I presented in Chapter 62, Quake’s BSP tree does not store polygons in the tree nodes, as part of the splitting planes, but rather in the empty (non-solid) leaves, as shown in overhead view in Figure 64.1.</p>
<p>Correct drawing order can be obtained by drawing the leaves in front-to-back or back-to-front BSP order, again as discussed in Chapter 62. Also, because BSP leaves are always convex and the polygons are on the boundaries of the BSP leaves, facing inward, the polygons in a given leaf can never obscure one another and can be drawn in any order. (This is a general property of convex polyhedra.)</p>
</section>
<section id="culling-and-visible-surface-determination" class="level3">
<h3><a href="#culling-and-visible-surface-determination">Culling and Visible Surface Determination</a></h3>
<p>The process of VSD would ideally work as follows: First, you would cull all polygons that are completely outside the view frustum (view pyramid), and would clip away the irrelevant portions of any polygons that are partially outside. Then, you would draw only those pixels of each polygon that are actually visible from the current viewpoint, as shown in overhead view in Figure 64.2, wasting no time overdrawing pixels multiple times; note how little of the polygon sets in Figure 64.2 actually need to be drawn. Finally, in a perfect world, the tests to figure out what parts of which polygons are visible would be free, and the processing time would be the same for all possible viewpoints, giving the game a smooth visual flow.</p>
<figure>
<img src="images/64-01.jpg" alt="Figure 64.1  Quake’s polygons are stored as empty leaves." /><figcaption><strong>Figure 64.1</strong>  <em>Quake’s polygons are stored as empty leaves.</em></figcaption>
</figure>
<figure>
<img src="images/64-02.jpg" alt="Figure 64.2  Pixels visible from the current viewpoint." /><figcaption><strong>Figure 64.2</strong>  <em>Pixels visible from the current viewpoint.</em></figcaption>
</figure>
<p>As it happens, it is easy to determine which polygons are outside the frustum or partially clipped, and it’s quite possible to figure out precisely which pixels need to be drawn. Alas, the world is far from perfect, and those tests are far from free, so the real trick is how to accelerate or skip various tests and still produce the desired result.</p>
<p>As I discussed at length in Chapter 62, given a BSP, it’s easy and inexpensive to walk the world in front-to-back or back-to-front order. The simplest VSD solution, which I in fact demonstrated earlier, is to simply walk the tree back-to-front, clip each polygon to the frustum, and draw it if it’s facing forward and not entirely clipped (the painter’s algorithm). Is that an adequate solution?</p>
<p>For relatively simple worlds, it is perfectly acceptable. It doesn’t scale very well, though. One problem is that as you add more polygons in the world, more transformations and tests have to be performed to cull polygons that aren’t visible; at some point, that will bog considerably performance down.</p>
<section id="nodes-inside-and-outside-the-view-frustum" class="level4">
<h4><a href="#nodes-inside-and-outside-the-view-frustum">Nodes Inside and Outside the View Frustum</a></h4>
<p>Happily, there’s a good workaround for this particular problem. As discussed earlier, each leaf of a BSP tree represents a convex subspace, with the nodes that bound the leaf delimiting the space. Perhaps less obvious is that each node in a BSP tree also describes a subspace—the subspace composed of all the node’s children, as shown in Figure 64.3. Another way of thinking of this is that each node splits the subspace into two pieces created by the nodes above it in the tree, and the node’s children then further carve that subspace into all the leaves that descend from the node.</p>
<figure>
<img src="images/64-03.jpg" alt="Figure 64.3  The substance described by node E." /><figcaption><strong>Figure 64.3</strong>  <em>The substance described by node E.</em></figcaption>
</figure>
<p>Since a node’s subspace is bounded and convex, it is possible to test whether it is entirely outside the frustum. If it is, <em>all</em> of the node’s children are certain to be fully clipped and can be rejected without any additional processing. Since most of the world is typically outside the frustum, many of the polygons in the world can be culled almost for free, in huge, node-subspace chunks. It’s relatively expensive to perform a perfect test for subspace clipping, so instead bounding spheres or boxes are often maintained for each node, specifically for culling tests.</p>
<p>So culling to the frustum isn’t a problem, and the BSP can be used to draw back-to- front. What, then, <em>is</em> the problem?</p>
</section>
</section>
<section id="overdraw" class="level3">
<h3><a href="#overdraw">Overdraw</a></h3>
<p>The problem John Carmack, the driving technical force behind DOOM and Quake, faced when he designed Quake was that in a complex world, many scenes have an awful lot of polygons in the frustum. Most of those polygons are partially or entirely obscured by other polygons, but the painter’s algorithm described earlier requires that every pixel of every polygon in the frustum be drawn, often only to be overdrawn. In a 10,000-polygon Quake level, it would be easy to get a worst-case overdraw level of 10 times or more; that is, in some frames each pixel could be drawn 10 times or more, on average. No rasterizer is fast enough to compensate for an order of such magnitude and more work than is actually necessary to show a scene; worse still, the painter’s algorithm will cause a vast difference between best-case and worst-case performance, so the frame rate can vary wildly as the viewer moves around.</p>
<p>So the problem John faced was how to keep overdraw down to a manageable level, preferably drawing each pixel exactly once, but certainly no more than two or three times in the worst case. As with frustum culling, it would be ideal if he could eliminate all invisible polygons in the frustum with virtually no work. It would also be a plus if he could manage to draw only the visible parts of partially-visible polygons, but that was a balancing act in that it had to be a lower-cost operation than the overdraw that would otherwise result.</p>
<p>When I arrived at id at the beginning of March 1995, John already had an engine prototyped and a plan in mind, and I assumed that our work was a simple matter of finishing and optimizing that engine. If I had been aware of id’s history, however, I would have known better. John had done not only DOOM, but also the engines for Wolfenstein 3-D and several earlier games, and had actually done several different versions of each engine in the course of development (once doing four engines in four weeks), for a total of perhaps 20 distinct engines over a four-year period. John’s tireless pursuit of new and better designs for Quake’s engine, from every angle he could think of, would end only when we shipped the product.</p>
<p>By three months after I arrived, only one element of the original VSD design was anywhere in sight, and John had taken the dictum of “try new things” farther than I’d ever seen it taken.</p>
</section>
<section id="the-beam-tree" class="level3">
<h3><a href="#the-beam-tree">The Beam Tree</a></h3>
<p>John’s original Quake design was to draw front-to-back, using a second BSP tree to keep track of what parts of the screen were already drawn and which were still empty and therefore drawable by the remaining polygons. Logically, you can think of this BSP tree as being a 2-D region describing solid and empty areas of the screen, as shown in Figure 64.4, but in fact it is a 3-D tree, of the sort known as a <em>beam tree.</em> A beam tree is a collection of 3-D wedges (beams), bounded by planes, projecting out from some center point, in this case the viewpoint, as shown in Figure 64.5.</p>
<p>In John’s design, the beam tree started out consisting of a single beam describing the frustum; everything outside that beam was marked solid (so nothing would draw there), and the inside of the beam was marked empty. As each new polygon was reached while walking the world BSP tree front-to-back, that polygon was converted to a beam by running planes from its edges through the viewpoint, and any part of the beam that intersected empty beams in the beam tree was considered drawable and added to the beam tree as a solid beam. This continued until either there were no more polygons or the beam tree became entirely solid. Once the beam tree was completed, the visible portions of the polygons that had contributed to the beam tree were drawn.</p>
<figure>
<img src="images/64-04.jpg" alt="Figure 64.4  Partitioning the screen into 2-D regions." /><figcaption><strong>Figure 64.4</strong>  <em>Partitioning the screen into 2-D regions.</em></figcaption>
</figure>
<figure>
<img src="images/64-05.jpg" alt="Figure 64.5  Beams as wedges projecting from the viewpoint to polygon edges." /><figcaption><strong>Figure 64.5</strong>  <em>Beams as wedges projecting from the viewpoint to polygon edges.</em></figcaption>
</figure>
<p>The advantage to working with a 3-D beam tree, rather than a 2-D region, is that determining which side of a beam plane a polygon vertex is on involves only checking the sign of the dot product of the ray to the vertex and the plane normal, because all beam planes run through the origin (the viewpoint). Also, because a beam plane is completely described by a single normal, generating a beam from a polygon edge requires only a cross-product of the edge and a ray from the edge to the viewpoint. Finally, bounding spheres of BSP nodes can be used to do the aforementioned bulk culling to the frustum.</p>
<p>The early-out feature of the beam tree—stopping when the beam tree becomes solid—seems appealing, because it appears to cap worst-case performance. Unfortunately, there are still scenes where it’s possible to see all the way to the sky or the back wall of the world, so in the worst case, all polygons in the frustum will still have to be tested against the beam tree. Similar problems can arise from tiny cracks due to numeric precision limitations. Beam-tree clipping is fairly time-consuming, and in scenes with long view distances, such as views across the top of a level, the total cost of beam processing slowed Quake’s frame rate to a crawl. So, in the end, the beam-tree approach proved to suffer from much the same malady as the painter’s algorithm: The worst case was much worse than the average case, and it didn’t scale well with increasing level complexity.</p>
</section>
<section id="d-engine-du-jour" class="level3">
<h3><a href="#d-engine-du-jour">3-D Engine du Jour</a></h3>
<p>Once the beam tree was working, John relentlessly worked at speeding up the 3-D engine, always trying to improve the design, rather than tweaking the implementation. At least once a week, and often every day, he would walk into my office and say “Last night I couldn’t get to sleep, so I was thinking…” and I’d know that I was about to get my mind stretched yet again. John tried many ways to improve the beam tree, with some success, but more interesting was the profusion of wildly different approaches that he generated, some of which were merely discussed, others of which were implemented in overnight or weekend-long bursts of coding, in both cases ultimately discarded or further evolved when they turned out not to meet the design criteria well enough. Here are some of those approaches, presented in minimal detail in the hopes that, like Tom Wilson with the Paradise FIFO, your imagination will be sparked.</p>
<section id="subdividing-raycast" class="level4">
<h4><a href="#subdividing-raycast">Subdividing Raycast</a></h4>
<p>Rays are cast in an 8x8 screen-pixel grid; this is a highly efficient operation because the first intersection with a surface can be found by simply clipping the ray into the BSP tree, starting at the viewpoint, until a solid leaf is reached. If adjacent rays don’t hit the same surface, then a ray is cast halfway between, and so on until all adjacent rays either hit the same surface or are on adjacent pixels; then the block around each ray is drawn from the polygon that was hit. This scales very well, being limited by the number of pixels, with no overdraw. The problem is dropouts; it’s quite possible for small polygons to fall between rays and vanish.</p>
</section>
<section id="vertex-free-surfaces" class="level4">
<h4><a href="#vertex-free-surfaces">Vertex-Free Surfaces</a></h4>
<p>The world is represented by a set of surface planes. The polygons are implicit in the plane intersections, and are extracted from the planes as a final step before drawing. This makes for fast clipping and a very small data set (planes are far more compact than polygons), but it’s time-consuming to extract polygons from planes.</p>
</section>
<section id="the-draw-buffer" class="level4">
<h4><a href="#the-draw-buffer">The Draw-Buffer</a></h4>
<p>Like a z-buffer, but with 1 bit per pixel, indicating whether the pixel has been drawn yet. This eliminates overdraw, but at the cost of an inner-loop buffer test, extra writes and cache misses, and, worst of all, considerable complexity. Variations include testing the draw-buffer a byte at a time and completely skipping fully-occluded bytes, or branching off each draw-buffer byte to one of 256 unrolled inner loops for drawing 0-8 pixels, in the process possibly taking advantage of the ability of the x86 to do the perspective floating-point divide in parallel while 8 pixels are processed.</p>
</section>
<section id="span-based-drawing" class="level4">
<h4><a href="#span-based-drawing">Span-Based Drawing</a></h4>
<p>Polygons are rasterized into spans, which are added to a global span list and clipped against that list so that only the nearest span at each pixel remains. Little sorting is needed with front-to-back walking, because if there’s any overlap, the span already in the list is nearer. This eliminates overdraw, but at the cost of a lot of span arithmetic; also, every polygon still has to be turned into spans.</p>
</section>
<section id="portals" class="level4">
<h4><a href="#portals">Portals</a></h4>
<p>The holes where polygons are missing on surfaces are tracked, because it’s only through such portals that line-of-sight can extend. Drawing goes front-to-back, and when a portal is encountered, polygons and portals behind it are clipped to its limits, until no polygons or portals remain visible. Applied recursively, this allows drawing only the visible portions of visible polygons, but at the cost of a considerable amount of portal clipping.</p>
</section>
</section>
<section id="breakthrough" class="level3">
<h3><a href="#breakthrough">Breakthrough!</a></h3>
<p>In the end, John decided that the beam tree was a sort of second-order structure, reflecting information already implicitly contained in the world BSP tree, so he tackled the problem of extracting visibility information directly from the world BSP tree. He spent a week on this, as a byproduct devising a perfect DOOM (2-D) visibility architecture, whereby a single, linear walk of a DOOM BSP tree produces zero-overdraw 2-D visibility. Doing the same in 3-D turned out to be a much more complex problem, though, and by the end of the week John was frustrated by the increasing complexity and persistent glitches in the visibility code. Although the direct-BSP approach was getting closer to working, it was taking more and more tweaking, and a simple, clean design didn’t seem to be falling out. When I left work one Friday, John was preparing to try to get the direct-BSP approach working properly over the weekend.</p>
<p>When I came in on Monday, John had the look of a man who had broken through to the other side—and also the look of a man who hadn’t had much sleep. He had worked all weekend on the direct-BSP approach, and had gotten it working reasonably well, with insights into how to finish it off. At 3:30 Monday morning, as he lay in bed, thinking about portals, he thought of precalculating and storing in each leaf a list of all leaves visible from that leaf, and then at runtime just drawing the visible leaves back-to-front for whatever leaf the viewpoint happens to be in, ignoring all other leaves entirely.</p>
<p>Size was a concern; initially, a raw, uncompressed potentially visible set (PVS) was several megabytes in size. However, the PVS could be stored as a bit vector, with 1 bit per leaf, a structure that shrunk a great deal with simple zero-byte compression. Those steps, along with changing the BSP heuristic to generate fewer leaves (choosing as the next splitter the polygon that splits the fewest other polygons appears to be the best heuristic) and sealing the outside of the levels so the BSPer can remove the outside surfaces, which can never be seen, eventually brought the PVS down to about 20 Kb for a good-size level.</p>
<p>In exchange for that 20 Kb, culling leaves outside the frustum is speeded up (because only leaves in the PVS are considered), and culling inside the frustum costs nothing more than a little overdraw (the PVS for a leaf includes all leaves visible from anywhere in the leaf, so some overdraw, typically on the order of 50 percent but ranging up to 150 percent, generally occurs). Better yet, precalculating the PVS results in a leveling of performance; worst case is no longer much worse than best case, because there’s no longer extra VSD processing—just more polygons and perhaps some extra overdraw—associated with complex scenes. The first time John showed me his working prototype, I went to the most complex scene I knew of, a place where the frame rate used to grind down into the single digits, and spun around smoothly, with no perceptible slowdown.</p>
<p>John says precalculating the PVS was a logical evolution of the approaches he had been considering, that there was no moment when he said “Eureka!” Nonetheless, it was clearly a breakthrough to a brand-new, superior design, a design that, together with a still-in-development sorted-edge rasterizer that completely eliminates overdraw, comes remarkably close to meeting the “perfect-world” specifications we laid out at the start.</p>
</section>
<section id="simplify-and-keep-on-trying-new-things" class="level3">
<h3><a href="#simplify-and-keep-on-trying-new-things">Simplify, and Keep on Trying New Things</a></h3>
<p>What does it all mean? Exactly what I said up front: Simplify, and keep trying new things. The precalculated PVS is simpler than any of the other schemes that had been considered (although precalculating the PVS is an interesting task that I’ll discuss another time). In fact, at runtime the precalculated PVS is just a constrained version of the painter’s algorithm. Does that mean it’s not particularly profound?</p>
<p>Not at all. All really great designs seem simple and even obvious—once they’ve been designed. But the process of getting there requires incredible persistence and a willingness to try lots of different ideas until the right one falls into place, as happened here.</p>
<blockquote>
<p><img src="images/i.jpg" /> My friend Chris Hecker has a theory that all approaches work out to the same thing in the end, since they all reflect the same underlying state and functionality. In terms of underlying theory, I’ve found that to be true; whether you do perspective texture mapping with a divide or with incremental hyperbolic calculations, the numbers do exactly the same thing. When it comes to implementation, however, my experience is that simply time-shifting an approach, or matching hardware capabilities better, or caching can make an astonishing difference.</p>
</blockquote>
<p>My friend Terje Mathisen likes to say that “almost all programming can be viewed as an exercise in caching,” and that’s exactly what John did. No matter how fast he made his VSD calculations, they could never be as fast as precalculating and looking up the visibility, and his most inspired move was to yank himself out of the “faster code” mindset and realize that it was in fact possible to precalculate (in effect, cache) and look up the PVS.</p>
<p>The hardest thing in the world is to step outside a familiar, pretty good solution to a difficult problem and look for a different, better solution. The best ways I know to do that are to keep trying new, wacky things, and always, always, always try to simplify. One of John’s goals is to have fewer lines of code in each 3-D game than in the previous game, on the assumption that as he learns more, he should be able to do things better with less code.</p>
<p>So far, it seems to have worked out pretty well for him.</p>
</section>
<section id="learn-now-pay-forward" class="level3">
<h3><a href="#learn-now-pay-forward">Learn Now, Pay Forward</a></h3>
<p>There’s one other thing I’d like to mention before I close this chapter. Much of what I’ve learned, and a great deal of what I’ve written, has been in the pages of <em>Dr. Dobb’s Journal.</em> As far back as I can remember, <em>DDJ</em> has epitomized the attitude that sharing programming information is A Good Thing. I know a lot of programmers who were able to leap ahead in their development because of Hendrix’s Tiny C, or Stevens’ D-Flat, or simply by browsing through <em>DDJ</em>’s annual collections. (Me, for one.) Understandably, most companies understandably view sharing information in a very different way, as potential profit lost—but that’s what makes <em>DDJ</em> so valuable to the programming community.</p>
<p>It is in that spirit that id Software is allowing me to describe in these pages (which also appeared in one of the <em>DDJ</em> special issues) how Quake works, even before Quake has shipped. That’s also why id has placed the full source code for Wolfenstein 3-D on <a href="ftp://ftp.idsoftware.com/idstuff/source">ftp.idsoftware.com/idstuff/source</a>; and although you can’t just recompile the code and sell it, you can learn how a full-blown, successful game works. Check wolfsrc.txt in the above-mentioned directory for details on how the code may be used.</p>
<p>So remember, when it’s legally possible, sharing information benefits us all in the long run. You can pay forward the debt for the information you gain here and elsewhere by sharing what you know whenever you can, by writing an article or book or posting on the Net. None of us learns in a vacuum; we all stand on the shoulders of giants such as Wirth and Knuth and thousands of others. Lend your shoulders to building the future!</p>
</section>
<section id="references" class="level3">
<h3><a href="#references">References</a></h3>
<p>Foley, James D., <em>et al.</em>, <em>Computer Graphics: Principles and Practice</em>, Addison Wesley, 1990, ISBN 0-201-12110-7 (beams, BSP trees, VSD).</p>
<p>Teller, Seth, <em>Visibility Computations in Densely Occluded Polyhedral Environments</em> (dissertation), available on <a href="http://theory.lcs.mit.edu/~seth/">http://theory.lcs.mit.edu/~seth/</a> along with several other papers relevant to visibility determination.</p>
<p>Teller, Seth, <em>Visibility Preprocessing for Interactive Walkthroughs</em>, SIGGRAPH 91 proceedings, pp. 61-69.</p>
</section>
</section>
<section id="chapter-65-3-d-clipping-and-other-thoughts" class="level2">
<h2><a href="#chapter-65-3-d-clipping-and-other-thoughts">Chapter 65 – 3-D Clipping and Other Thoughts</a></h2>
<section id="determining-whats-inside-your-field-of-view" class="level3">
<h3><a href="#determining-whats-inside-your-field-of-view">Determining What’s Inside Your Field of View</a></h3>
<p>Our part of the world is changing, and I’m concerned. By way of explanation, three anecdotes.</p>
<p>Anecdote the first: In the introduction to one of his books, Frank Herbert, author of <em>Dune</em>, told how he had once been approached by a friend who claimed he (the friend) had a killer idea for an SF story, and offered to tell it to Herbert. In return, Herbert had to agree that if he used the idea in a story, he’d split the money from the story with this fellow. Herbert’s response was that ideas were a dime a dozen; he had more story ideas than he could ever write in a lifetime. The hard part was the writing, not the ideas.</p>
<p>Anecdote the second: I’ve been programming micros for 15 years, and writing about them for more than a decade and, until about a year ago, I had never—not once!—had anyone offer to sell me a technical idea. In the last year, it’s happened multiple times, generally via unsolicited email along the lines of Herbert’s tale.</p>
<p>This trend toward selling ideas is one symptom of an attitude that I’ve noticed more and more among programmers over the past few years—an attitude of which software patents are the most obvious manifestation—a desire to think something up without breaking a sweat, then let someone else’s hard work make you money. It’s an attitude that says, “I’m so smart that my ideas alone set me apart.” Sorry, it doesn’t work that way in the real world. Ideas are a dime a dozen in programming, too; I have a lifetime’s worth of article and software ideas written neatly in a notebook, and I know several truly original thinkers who have far more yet. Folks, it’s not the ideas; it’s design, implementation, and especially hard work that make the difference.</p>
<p>Virtually every idea I’ve encountered in 3-D graphics was invented decades ago. You think you have a clever graphics idea? Sutherland, Sproull, Schumacker, Catmull, Smith, Blinn, Glassner, Kajiya, Heckbert, or Teller probably thought of your idea years ago. (I’m serious—spend a few weeks reading through the literature on 3-D graphics, and you’ll be amazed at what’s already been invented and published.) If they thought it was important enough, they wrote a paper about it, or tried to commercialize it, but what they didn’t do was try to charge people for the idea itself.</p>
<p>A closely related point is the astonishing lack of gratitude some programmers show for the hard work and sense of community that went into building the knowledge base with which they work. How about this? Anyone who thinks they have a unique idea that they want to “own” and milk for money can do so—but first they have to track down and appropriately compensate all the people who made possible the compilers, algorithms, programming courses, books, hardware, and so forth that put them in a position to have their brainstorm.</p>
<p>Put that way, it sounds like a silly idea, but the idea behind software patents is precisely that eventually everyone will own parts of our communal knowledge base, and that programming will become in large part a process of properly identifying and compensating each and every owner of the techniques you use. All I can say is that if we do go down that path, I guarantee that it will be a poorer profession for all of us—except the patent attorneys, I guess.</p>
<p>Anecdote the third: A while back, I had the good fortune to have lunch down by Seattle’s waterfront with Neal Stephenson, the author of <em>Snow Crash</em> and <em>The Diamond Age</em> (one of the best SF books I’ve come across in a long time). As he talked about the nature of networked technology and what he hoped to see emerge, he mentioned that a couple of blocks down the street was the pawn shop where Jimi Hendrix bought his first guitar. His point was that if a cheap guitar hadn’t been available, Hendrix’s unique talent would never have emerged. Similarly, he views the networking of society as a way to get affordable creative tools to many people, so as much talent as possible can be unearthed and developed.</p>
<p>Extend that to programming. The way it should work is that a steady flow of information circulates, so that everyone can do the best work they’re capable of. The idea is that I don’t gain by intellectually impoverishing you, and vice-versa; as we both compete and (intentionally or otherwise) share ideas, both our products become better, so the market grows larger and everyone benefits.</p>
<p>That’s the way things have worked with programming for a long time. So far as I can see it has worked remarkably well, and the recent signs of change make me concerned about the future of our profession.</p>
<p>Things aren’t changing <em>everywhere</em>, though; over the past year, I’ve circulated a good bit of info about 3-D graphics, and plan to keep on doing it as long as I can. Next, we’re going to take a look at 3-D clipping.</p>
</section>
<section id="d-clipping-basics" class="level3">
<h3><a href="#d-clipping-basics">3-D Clipping Basics</a></h3>
<p>Before I got deeply into 3-D, I kept hearing how difficult 3-D clipping was, so I was pleasantly surprised when I actually got around to doing it and found that it was quite straightforward, after all. At heart, 3-D clipping is nothing more than evaluating whether and where a line intersects a plane; in this context, the plane is considered to have an “inside” (a side on which points are to be kept) and an “outside” (a side on which points are to be removed or clipped). We can easily extend this single operation to polygon clipping, working with the line segments that form the edges of a polygon.</p>
<p>The most common application of 3-D clipping is as part of the process of hidden surface removal. In this application, the four planes that make up the view volume, or view frustum, are used to clip away parts of polygons that aren’t visible. Sometimes this process includes clipping to near and far plane, to restrict the depth of the scene. Other applications include clipping to splitting planes while building BSP trees, and clipping moving objects to convex sectors such as BSP leaves. The clipping principles I’ll cover apply to any sort of 3-D clipping task, but clipping to the frustum is the specific context in which I’ll discuss clipping below.</p>
<p>In a commercial application, you wouldn’t want to clip every single polygon in the scene database individually. As I mentioned in the last chapter, the use of bounding volumes to cull chunks of the scene database that fall entirely outside the frustum, without having to consider each polygon separately, is an important performance aspect of scene rendering. Once that’s done, however, you’re still left with a set of polygons that may be entirely inside, or partially or completely outside, the frustum. In this chapter, I’m going to talk about how to clip those remaining polygons. I’ll focus on the basics of 3-D clipping, the stuff I wish I’d known when I started doing 3-D. There are plenty of ways to speed up clipping under various circumstances, some of which I’ll mention, but the material covered below will give you the tools you need to implement functional 3-D clipping.</p>
<section id="intersecting-a-line-segment-with-a-plane" class="level4">
<h4><a href="#intersecting-a-line-segment-with-a-plane">Intersecting a Line Segment with a Plane</a></h4>
<p>The fundamental 3-D clipping operation is clipping a line segment to a plane. There are two parts to this operation: determining if the line is clipped by (intersects) the plane at all and, if it is clipped, calculating the point of intersection.</p>
<p>Before we can intersect a line segment with a plane, we must first define how we’ll represent the line segment and the plane. The segment will be represented in the obvious way by the (x,y,z) coordinates of its two endpoints; this extends well to polygons, where each vertex is an (x,y,z) point. Planes can be described in many ways, among them are three points on the plane, a point on the plane and a unit normal, or a unit normal and a distance from the origin along the normal; we’ll use the latter definition. Further, we’ll define the normal to point to the inside (unclipped side) of the plane. The structures for points, polygons, and planes are shown in Listing 65.1.</p>
<p><strong>LISTING 65.1 L65_1.h</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> {
    <span class="dt">double</span> v[<span class="dv">3</span>];
} point_t;

<span class="kw">typedef</span> <span class="kw">struct</span> {
    <span class="dt">double</span>   x, y;
} point2D_t;

<span class="kw">typedef</span> <span class="kw">struct</span> {
    <span class="dt">int</span>         color;
    <span class="dt">int</span>         numverts;
    point_t     verts[MAX_POLY_VERTS];
} polygon_t;

<span class="kw">typedef</span> <span class="kw">struct</span> {
    <span class="dt">int</span>         color;
    <span class="dt">int</span>         numverts;
    point2D_t   verts[MAX_POLY_VERTS];
} polygon2D_t;

<span class="kw">typedef</span> <span class="kw">struct</span> convexobject_s {
    <span class="kw">struct</span> convexobject_s   *pnext;
    point_t                 center;
    <span class="dt">double</span>                  vdist;
    <span class="dt">int</span>                     numpolys;
    polygon_t               *ppoly;
} convexobject_t;

<span class="kw">typedef</span> <span class="kw">struct</span> {
    <span class="dt">double</span>  distance;
    point_t normal;
} plane_t;</code></pre>
<p>Given a line segment, and a plane to which to clip the segment, the first question is whether the segment is entirely on the inside or the outside of the plane, or intersects the plane. If the segment is on the inside, then the segment is not clipped by the plane, and we’re done. If it’s on the outside, then it’s entirely clipped, and we’re likewise done. If it intersects the plane, then we have to remove the clipped portion of the line by replacing the endpoint on the outside of the plane with the point of intersection between the line and the plane.</p>
<p>The way to answer this question is to find out which side of the plane each endpoint is on, and the dot product is the right tool for the job. As you may recall from Chapter 61, dotting any vector with a unit normal returns the length of the projection of that vector onto the normal. Therefore, if we take any point and dot it with the plane normal we’ll find out how far from the origin the point is, as measured along the plane normal. Another way to think of this is to say that the dot product of a point and the plane normal returns how far from the origin along the normal the plane would have to be in order to have the point lie within the plane, as if we slid the plane along the normal until it touched the point.</p>
<p>Now, remember that our definition of a plane is a unit normal and a distance along the normal. That means that we have a distance for the plane as part of the plane structure, and we can get the distance at which the plane would have to be to touch the point from the dot product of the point and the normal; a simple comparison of the two values suffices to tell us which side of the plane the point is on. If the dot product of the point and the plane normal is greater than the plane distance, then the point is in front of the plane (inside the volume being clipped to); if it’s less, then the point is outside the volume and should be clipped.</p>
<p>After we do this twice, once for each line endpoint, we know everything necessary to categorize our line segment. If both endpoints are on the same side of the plane, there’s nothing more to do, because the line is either completely inside or completely outside; otherwise, it’s on to the next step, clipping the line to the plane by replacing the outside vertex with the point of intersection of the line and the plane. Happily, it turns out that we already have all of the information we need to do this.</p>
<p>From our earlier tests, we already know the length from the plane, measured along the normal, to the inside endpoint; that’s just the distance, along the normal, of the inside endpoint from the origin (the dot product of the endpoint with the normal), minus the plane distance, as shown in Figure 65.1. We also know the length of the line segment, again measured as projected onto the normal; that’s the difference between the distances along the normal of the inside and outside endpoints from the origin. The ratio of these two lengths is the fraction of the segment that remains after clipping. If we scale the x, y, and z lengths of the line segment by that fraction, and add the results to the inside endpoint, we get a new, clipped endpoint at the point of intersection.</p>
</section>
</section>
<section id="polygon-clipping" class="level3">
<h3><a href="#polygon-clipping">Polygon Clipping</a></h3>
<p>Line clipping is fine for wireframe rendering, but what we really want to do is polygon rendering of solid models, which requires polygon clipping. As with line segments, the clipping process with polygons is to determine if they’re inside, outside, or partially inside the clip volume, lopping off any vertices that are outside the clip volume and substituting vertices at the intersection between the polygon and the clip plane, as shown in Figure 65.2.</p>
<p>An easy way to clip a polygon is to decompose it into a set of edges, and clip each edge separately as a line segment. Let’s define a polygon as a set of vertices that wind clockwise around the outside of the polygonal area, as viewed from the front side of the polygon; the edges are implicitly defined by the order of the vertices. Thus, an edge is the line segment described by the two adjacent vertices that form its endpoints. We’ll clip a polygon by clipping each edge individually, emitting vertices for the resulting polygon as appropriate, depending on the clipping state of the edge. If the start point of the edge is inside, that point is added to the output polygon. Then, if the start and end points are in different states (one inside and one outside), we clip the edge to the plane, as described above, and add the point at which the line intersects the clip plane as the next polygon vertex, as shown in Figure 65.3. Listing 65.2 shows a polygon-clipping function.</p>
<figure>
<img src="images/65-01.jpg" alt="Figure 65.1  The distance from the plane to the inside endpoint, measured along the normal." /><figcaption><strong>Figure 65.1</strong>  <em>The distance from the plane to the inside endpoint, measured along the normal.</em></figcaption>
</figure>
<figure>
<img src="images/65-02.jpg" alt="Figure 65.2  Clipping a polygon." /><figcaption><strong>Figure 65.2</strong>  <em>Clipping a polygon.</em></figcaption>
</figure>
<p><strong>LISTING 65.2 L65_2.c</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> ClipToPlane(polygon_t *pin, plane_t *pplane, polygon_t *pout)
{
    <span class="dt">int</span>     i, j, nextvert, curin, nextin;
    <span class="dt">double</span>  curdot, nextdot, scale;
    point_t *pinvert, *poutvert;

    pinvert = pin-&gt;verts;
    poutvert = pout-&gt;verts;

    curdot = DotProduct(pinvert, &amp;pplane-&gt;normal);
    curin = (curdot &gt;= pplane-&gt;distance);

    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;pin-&gt;numverts ; i++)
    {
        nextvert = (i + <span class="dv">1</span>) % pin-&gt;numverts;

        <span class="co">// Keep the current vertex if it&#39;s inside the plane</span>
        <span class="kw">if</span> (curin)
            *poutvert++ = *pinvert;

        nextdot = DotProduct(&amp;pin-&gt;verts[nextvert], &amp;pplane-&gt;normal);
        nextin = (nextdot &gt;= pplane-&gt;distance);

        <span class="co">// Add a clipped vertex if one end of the current edge is</span>
        <span class="co">// inside the plane and the other is outside</span>
        <span class="kw">if</span> (curin != nextin)
        {
            scale = (pplane-&gt;distance - curdot) /
                    (nextdot - curdot);
            <span class="kw">for</span> (j=<span class="dv">0</span> ; j&lt;<span class="dv">3</span> ; j++)
            {
                poutvert-&gt;v[j] = pinvert-&gt;v[j] +
                    ((pin-&gt;verts[nextvert].v[j] - pinvert-&gt;v[j]) *
                     scale);
            }
            poutvert++;
        }

        curdot = nextdot;
        curin = nextin;
        pinvert++;
    }

    pout-&gt;numverts = poutvert - pout-&gt;verts;
    <span class="kw">if</span> (pout-&gt;numverts &lt; <span class="dv">3</span>)
        <span class="kw">return</span> <span class="dv">0</span>;

    pout-&gt;color = pin-&gt;color;
    <span class="kw">return</span> <span class="dv">1</span>;
}</code></pre>
<p>Believe it or not, this technique, applied in turn to each edge, is all that’s needed to clip a polygon to a plane. Better yet, a polygon can be clipped to multiple planes by repeating the above process once for each clip plane, with each interation trimming away any part of the polygon that’s clipped by that particular plane.</p>
<p>One particularly useful aspect of 3-D clipping is that if you’re drawing texture mapped polygons, texture coordinates can be clipped in exactly the same way as (x,y,z) coordinates. In fact, the very same fraction that’s used to advance x, y, and z from the inside point to the point of intersection with the clip plane can be used to advance the texture coordinates as well, so only one extra multiply and one extra add are required for each texture coordinate.</p>
<section id="clipping-to-the-frustum" class="level4">
<h4><a href="#clipping-to-the-frustum">Clipping to the Frustum</a></h4>
<p>Given a polygon-clipping function, it’s easy to clip to the frustum: set up the four planes for the sides of the frustum, with another one or two planes for near and far clipping, if desired; next, clip each potentially visible polygon to each plane in turn; then draw whatever polygons emerge from the clipping process. Listing 65.3 is the core code for a simple 3-D clipping example that allows you to move around and look at polygonal models from any angle. The full code for this program is available on the CD-ROM in the file DDJCLIP.ZIP.</p>
<figure>
<img src="images/65-03.jpg" alt="Figure 65.3  Clipping a polygon edge." /><figcaption><strong>Figure 65.3</strong>  <em>Clipping a polygon edge.</em></figcaption>
</figure>
<p><strong>LISTING 65.3 L65_3.c</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> DIBWidth, DIBHeight;
<span class="dt">int</span> DIBPitch;
<span class="dt">double</span>  roll, pitch, yaw;
<span class="dt">double</span>  currentspeed;
point_t currentpos;
<span class="dt">double</span>  fieldofview, xcenter, ycenter;
<span class="dt">double</span>  xscreenscale, yscreenscale, maxscale;
<span class="dt">int</span>     numobjects;
<span class="dt">double</span>  speedscale = <span class="fl">1.0</span>;
plane_t frustumplanes[NUM_FRUSTUM_PLANES];
<span class="dt">double</span>  mroll[<span class="dv">3</span>][<span class="dv">3</span>] = {{<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>}, {<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>}, {<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>}};
<span class="dt">double</span>  mpitch[<span class="dv">3</span>][<span class="dv">3</span>] = {{<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>}, {<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>}, {<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>}};
<span class="dt">double</span>  myaw[<span class="dv">3</span>][<span class="dv">3</span>] =  {{<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>}, {<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>}, {<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>}};
point_t vpn, vright, vup;
point_t xaxis = {<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>};
point_t zaxis = {<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>};
convexobject_t objecthead = {NULL, {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>}, -<span class="fl">999999.0</span>};

<span class="co">// Project viewspace polygon vertices into screen coordinates.</span>
<span class="co">// Note that the y axis goes up in worldspace and viewspace, but</span>
<span class="co">// goes down in screenspace.</span>
<span class="dt">void</span> ProjectPolygon (polygon_t *ppoly, polygon2D_t *ppoly2D)
{
    <span class="dt">int</span>     i;
    <span class="dt">double</span>  zrecip;

    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;ppoly-&gt;numverts ; i++)
    {
        zrecip = <span class="fl">1.0</span> / ppoly-&gt;verts[i].v[<span class="dv">2</span>];
        ppoly2D-&gt;verts[i].x =
               ppoly-&gt;verts[i].v[<span class="dv">0</span>] * zrecip * maxscale + xcenter;
        ppoly2D-&gt;verts[i].y = DIBHeight -
             (ppoly-&gt;verts[i].v[<span class="dv">1</span>] * zrecip * maxscale + ycenter);
    }
    ppoly2D-&gt;color = ppoly-&gt;color;
    ppoly2D-&gt;numverts = ppoly-&gt;numverts;
}

<span class="co">// Sort the objects according to z distance from viewpoint.</span>
<span class="dt">void</span> ZSortObjects(<span class="dt">void</span>)
{
    <span class="dt">int</span>             i, j;
    <span class="dt">double</span>          vdist;
    convexobject_t  *pobject;
    point_t         dist;

    objecthead.pnext = &amp;objecthead;
    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;numobjects ; i++)
    {
        <span class="kw">for</span> (j=<span class="dv">0</span> ; j&lt;<span class="dv">3</span> ; j++)
            dist.v[j] = objects[i].center.v[j] - currentpos.v[j];
        objects[i].vdist = sqrt(dist.v[<span class="dv">0</span>] * dist.v[<span class="dv">0</span>] +
                                dist.v[<span class="dv">1</span>] * dist.v[<span class="dv">1</span>] +
                                dist.v[<span class="dv">2</span>] * dist.v[<span class="dv">2</span>]);
        pobject = &amp;objecthead;
        vdist = objects[i].vdist;
        <span class="co">// Viewspace-distance-sort this object into the others.</span>
        <span class="co">// Guaranteed to terminate because of sentinel</span>
        <span class="kw">while</span> (vdist &lt; pobject-&gt;pnext-&gt;vdist)
            pobject = pobject-&gt;pnext;
        objects[i].pnext = pobject-&gt;pnext;
        pobject-&gt;pnext = &amp;objects[i];
    }
}

<span class="co">// Move the view position and set the world-&gt;view transform.</span>
<span class="dt">void</span> UpdateViewPos()
{
    <span class="dt">int</span>     i;
    point_t motionvec;
    <span class="dt">double</span>  s, c, mtemp1[<span class="dv">3</span>][<span class="dv">3</span>], mtemp2[<span class="dv">3</span>][<span class="dv">3</span>];

    <span class="co">// Move in the view direction, across the x-y plane, as if</span>
    <span class="co">// walking. This approach moves slower when looking up or</span>
    <span class="co">// down at more of an angle</span>
    motionvec.v[<span class="dv">0</span>] = DotProduct(&amp;vpn, &amp;xaxis);
    motionvec.v[<span class="dv">1</span>] = <span class="fl">0.0</span>;
    motionvec.v[<span class="dv">2</span>] = DotProduct(&amp;vpn, &amp;zaxis);
    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;<span class="dv">3</span> ; i++)
    {
        currentpos.v[i] += motionvec.v[i] * currentspeed;
        <span class="kw">if</span> (currentpos.v[i] &gt; MAX_COORD)
            currentpos.v[i] = MAX_COORD;
        <span class="kw">if</span> (currentpos.v[i] &lt; -MAX_COORD)
            currentpos.v[i] = -MAX_COORD;
    }
    <span class="co">// Set up the world-to-view rotation.</span>
    <span class="co">// Note: much of the work done in concatenating these matrices</span>
    <span class="co">// can be factored out, since it contributes nothing to the</span>
    <span class="co">// final result; multiply the three matrices together on paper</span>
    <span class="co">// to generate a minimum equation for each of the 9 final elements</span>
    s = sin(roll);
    c = cos(roll);
    mroll[<span class="dv">0</span>][<span class="dv">0</span>] = c;
    mroll[<span class="dv">0</span>][<span class="dv">1</span>] = s;
    mroll[<span class="dv">1</span>][<span class="dv">0</span>] = -s;
    mroll[<span class="dv">1</span>][<span class="dv">1</span>] = c;
    s = sin(pitch);
    c = cos(pitch);
    mpitch[<span class="dv">1</span>][<span class="dv">1</span>] = c;
    mpitch[<span class="dv">1</span>][<span class="dv">2</span>] = s;
    mpitch[<span class="dv">2</span>][<span class="dv">1</span>] = -s;
    mpitch[<span class="dv">2</span>][<span class="dv">2</span>] = c;
    s = sin(yaw);
    c = cos(yaw);
    myaw[<span class="dv">0</span>][<span class="dv">0</span>] = c;
    myaw[<span class="dv">0</span>][<span class="dv">2</span>] = -s;
    myaw[<span class="dv">2</span>][<span class="dv">0</span>] = s;
    myaw[<span class="dv">2</span>][<span class="dv">2</span>] = c;
    MConcat(mroll, myaw, mtemp1);
    MConcat(mpitch, mtemp1, mtemp2);
    <span class="co">// Break out the rotation matrix into vright, vup, and vpn.</span>
    <span class="co">// We could work directly with the matrix; breaking it out</span>
    <span class="co">// into three vectors is just to make things clearer</span>
    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;<span class="dv">3</span> ; i++)
    {
        vright.v[i] = mtemp2[<span class="dv">0</span>][i];
        vup.v[i] = mtemp2[<span class="dv">1</span>][i];
        vpn.v[i] = mtemp2[<span class="dv">2</span>][i];
    }
    <span class="co">// Simulate crude friction</span>
    <span class="kw">if</span> (currentspeed &gt; (MOVEMENT_SPEED * speedscale / <span class="fl">2.0</span>))
        currentspeed -= MOVEMENT_SPEED * speedscale / <span class="fl">2.0</span>;
    <span class="kw">else</span> <span class="kw">if</span> (currentspeed &lt; -(MOVEMENT_SPEED * speedscale / <span class="fl">2.0</span>))
        currentspeed += MOVEMENT_SPEED * speedscale / <span class="fl">2.0</span>;
    <span class="kw">else</span>
        currentspeed = <span class="fl">0.0</span>;
}

<span class="co">// Rotate a vector from viewspace to worldspace.</span>
<span class="dt">void</span> BackRotateVector(point_t *pin, point_t *pout)
{
    <span class="dt">int</span>     i;

    <span class="co">// Rotate into the world orientation</span>
    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;<span class="dv">3</span> ; i++)
        pout-&gt;v[i] = pin-&gt;v[<span class="dv">0</span>] * vright.v[i] +
                     pin-&gt;v[<span class="dv">1</span>] * vup.v[i] +
                     pin-&gt;v[<span class="dv">2</span>] * vpn.v[i];
}

<span class="co">// Transform a point from worldspace to viewspace.</span>
<span class="dt">void</span> TransformPoint(point_t *pin, point_t *pout)
{
    <span class="dt">int</span>     i;
    point_t tvert;

    <span class="co">// Translate into a viewpoint-relative coordinate</span>
    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;<span class="dv">3</span> ; i++)
        tvert.v[i] = pin-&gt;v[i] - currentpos.v[i];
    <span class="co">// Rotate into the view orientation</span>
    pout-&gt;v[<span class="dv">0</span>] = DotProduct(&amp;tvert, &amp;vright);
    pout-&gt;v[<span class="dv">1</span>] = DotProduct(&amp;tvert, &amp;vup);
    pout-&gt;v[<span class="dv">2</span>] = DotProduct(&amp;tvert, &amp;vpn);
}

<span class="co">// Transform a polygon from worldspace to viewspace.</span>
<span class="dt">void</span> TransformPolygon(polygon_t *pinpoly, polygon_t *poutpoly)
{
    <span class="dt">int</span>         i;

    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;pinpoly-&gt;numverts ; i++)
        TransformPoint(&amp;pinpoly-&gt;verts[i], &amp;poutpoly-&gt;verts[i]);
    poutpoly-&gt;color = pinpoly-&gt;color;
    poutpoly-&gt;numverts = pinpoly-&gt;numverts;
}

<span class="co">// Returns true if polygon faces the viewpoint, assuming a clockwise</span>
<span class="co">// winding of vertices as seen from the front.</span>
<span class="dt">int</span> PolyFacesViewer(polygon_t *ppoly)
{
    <span class="dt">int</span>     i;
    point_t viewvec, edge1, edge2, normal;

    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;<span class="dv">3</span> ; i++)
    {
        viewvec.v[i] = ppoly-&gt;verts[<span class="dv">0</span>].v[i] - currentpos.v[i];
        edge1.v[i] = ppoly-&gt;verts[<span class="dv">0</span>].v[i] - ppoly-&gt;verts[<span class="dv">1</span>].v[i];
        edge2.v[i] = ppoly-&gt;verts[<span class="dv">2</span>].v[i] - ppoly-&gt;verts[<span class="dv">1</span>].v[i];
    }
    CrossProduct(&amp;edge1, &amp;edge2, &amp;normal);
    <span class="kw">if</span> (DotProduct(&amp;viewvec, &amp;normal) &gt; <span class="dv">0</span>)
        <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">else</span>
        <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">// Set up a clip plane with the specified normal.</span>
<span class="dt">void</span> SetWorldspaceClipPlane(point_t *normal, plane_t *plane)
{

    <span class="co">// Rotate the plane normal into worldspace</span>
    BackRotateVector(normal, &amp;plane-&gt;normal);
    plane-&gt;distance = DotProduct(&amp;currentpos, &amp;plane-&gt;normal) +
            CLIP_PLANE_EPSILON;
}

<span class="co">// Set up the planes of the frustum, in worldspace coordinates.</span>
<span class="dt">void</span> SetUpFrustum(<span class="dt">void</span>)
{
    <span class="dt">double</span>  angle, s, c;
    point_t normal;

    angle = atan(<span class="fl">2.0</span> / fieldofview * maxscale / xscreenscale);
    s = sin(angle);
    c = cos(angle);
    <span class="co">// Left clip plane</span>
    normal.v[<span class="dv">0</span>] = s;
    normal.v[<span class="dv">1</span>] = <span class="dv">0</span>;
    normal.v[<span class="dv">2</span>] = c;
    SetWorldspaceClipPlane(&amp;normal, &amp;frustumplanes[<span class="dv">0</span>]);
    <span class="co">// Right clip plane</span>
    normal.v[<span class="dv">0</span>] = -s;
    SetWorldspaceClipPlane(&amp;normal, &amp;frustumplanes[<span class="dv">1</span>]);
    angle = atan(<span class="fl">2.0</span> / fieldofview * maxscale / yscreenscale);
    s = sin(angle);
    c = cos(angle);
    <span class="co">// Bottom clip plane</span>
    normal.v[<span class="dv">0</span>] = <span class="dv">0</span>;
    normal.v[<span class="dv">1</span>] = s;
    normal.v[<span class="dv">2</span>] = c;
    SetWorldspaceClipPlane(&amp;normal, &amp;frustumplanes[<span class="dv">2</span>]);
    <span class="co">// Top clip plane</span>
    normal.v[<span class="dv">1</span>] = -s;
    SetWorldspaceClipPlane(&amp;normal, &amp;frustumplanes[<span class="dv">3</span>]);
}

<span class="co">// Clip a polygon to the frustum.</span>
<span class="dt">int</span> ClipToFrustum(polygon_t *pin, polygon_t *pout)
{
    <span class="dt">int</span>         i, curpoly;
    polygon_t   tpoly[<span class="dv">2</span>], *ppoly;

    curpoly = <span class="dv">0</span>;
    ppoly = pin;
    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;(NUM_FRUSTUM_PLANES<span class="dv">-1</span>); i++)
    {
        <span class="kw">if</span> (!ClipToPlane(ppoly,
                         &amp;frustumplanes[i],
                         &amp;tpoly[curpoly]))
            <span class="kw">return</span> <span class="dv">0</span>;
        ppoly = &amp;tpoly[curpoly];
        curpoly ^= <span class="dv">1</span>;
    }
    <span class="kw">return</span> ClipToPlane(ppoly,
                       &amp;frustumplanes[NUM_FRUSTUM_PLANES<span class="dv">-1</span>],
                       pout);
}

<span class="co">// Render the current state of the world to the screen.</span>
<span class="dt">void</span> UpdateWorld()
{
    HPALETTE        holdpal;
    HDC             hdcScreen, hdcDIBSection;
    HBITMAP         holdbitmap;
    polygon2D_t     screenpoly;
    polygon_t       *ppoly, tpoly0, tpoly1, tpoly2;
    convexobject_t  *pobject;
    <span class="dt">int</span>             i, j, k;

    UpdateViewPos();
    memset(pDIBBase, <span class="dv">0</span>, DIBWidth*DIBHeight);    <span class="co">// clear frame</span>
    SetUpFrustum();
    ZSortObjects();
    <span class="co">// Draw all visible faces in all objects</span>
    pobject = objecthead.pnext;
    <span class="kw">while</span> (pobject != &amp;objecthead)
    {
        ppoly = pobject-&gt;ppoly;
        <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;pobject-&gt;numpolys ; i++)
        {
            <span class="co">// Move the polygon relative to the object center</span>
            tpoly0.color = ppoly-&gt;color;
            tpoly0.numverts = ppoly-&gt;numverts;
            <span class="kw">for</span> (j=<span class="dv">0</span> ; j&lt;tpoly0.numverts ; j++)
            {
                <span class="kw">for</span> (k=<span class="dv">0</span> ; k&lt;<span class="dv">3</span> ; k++)
                    tpoly0.verts[j].v[k] = ppoly-&gt;verts[j].v[k] +
                            pobject-&gt;center.v[k];
            }
            <span class="kw">if</span> (PolyFacesViewer(&amp;tpoly0))
            {
                <span class="kw">if</span> (ClipToFrustum(&amp;tpoly0, &amp;tpoly1))
                {
                    TransformPolygon (&amp;tpoly1, &amp;tpoly2);
                    ProjectPolygon (&amp;tpoly2, &amp;screenpoly);
                    FillPolygon2D (&amp;screenpoly);
                }
            }
            ppoly++;
        }
        pobject = pobject-&gt;pnext;
    }
    <span class="co">// We&#39;ve drawn the frame; copy it to the screen</span>
    hdcScreen = GetDC(hwndOutput);
    holdpal = SelectPalette(hdcScreen, hpalDIB, FALSE);
    RealizePalette(hdcScreen);
    hdcDIBSection = CreateCompatibleDC(hdcScreen);
    holdbitmap = SelectObject(hdcDIBSection, hDIBSection);
    BitBlt(hdcScreen, <span class="dv">0</span>, <span class="dv">0</span>, DIBWidth, DIBHeight, hdcDIBSection,
           <span class="dv">0</span>, <span class="dv">0</span>, SRCCOPY);
    SelectPalette(hdcScreen, holdpal, FALSE);
    ReleaseDC(hwndOutput, hdcScreen);
    SelectObject(hdcDIBSection, holdbitmap);
    ReleaseDC(hwndOutput, hdcDIBSection);
}</code></pre>
</section>
<section id="the-lessons-of-listing-65.3" class="level4">
<h4><a href="#the-lessons-of-listing-65.3">The Lessons of Listing 65.3</a></h4>
<p>There are several interesting points to Listing 65.3. First, floating-point arithmetic is used throughout the clipping process. While it is possible to use fixed-point, doing so requires considerable care regarding range and precision. Floating-point is much easier—and, with the Pentium generation of processors, is generally comparable in speed. In fact, for some operations, such as multiplication in general and division when the floating-point unit is in single-precision mode, floating-point is much faster. Check out Chris Hecker’s column in the February 1996 <em>Game Developer</em> for an interesting discussion along these lines.</p>
<p>Second, the planes that form the frustum are shifted ever so slightly inward from their proper positions at the edge of the field of view. This guarantees that it’s never possible to generate a visible vertex exactly at the eyepoint, averting the divide-by-zero error that such a vertex would cause when projected and at no performance cost.</p>
<p>Third, the orientation of the viewer relative to the world is specified via yaw, pitch, and roll angles, successively applied in that order. These angles are accumulated from frame to frame according to user input, and for each frame are used to rotate the view up, view right, and viewplane normal vectors, which define the world coordinate system, into the viewspace coordinate system; those transformed vectors in turn define the rotation from worldspace to viewspace. (See Chapter 61 for a discussion of coordinate systems and rotation, and take a look at Chapters 5 and 6 of <em>Computer Graphics</em>, by Foley and van Dam, for a broader overview.) One attractive aspect of accumulating angular rotations that are then applied to the coordinate system vectors is that there is no deterioration of the rotation matrix over time. This is in contrast to my X-Sharp package, in which I accumulated rotations by keeping a cumulative matrix of all the rotations ever performed; unfortunately, that approach caused roundoff error to accumulate, so objects began to warp visibly after many rotations.</p>
<p>Fourth, Listing 65.3 processes each input polygon into a clipped polygon, one line segment at a time. It would be more efficient to process all the vertices, categorizing whether and how they’re clipped, and then perform a test such as the Cohen-Sutherland outcode test to detect trivial acceptance (the polygon is entirely inside) and sometimes trivial rejection (the polygon is fully outside) without ever dealing with the edges, and to identify which planes actually need to be clipped against, as discussed in “Line-Segment Clipping Revisited,” <em>Dr. Dobb’s Journal</em>, January 1996. Some clipping approaches also minimize the number of intersection calculations when a segment is clipped by multiple planes. Further, Listing 65.3 clips a polygon against each plane in turn, generating a new output polygon for each plane; it is possible and can be more efficient to generate the final, clipped polygon without any intermediate representations. For further reading on advanced clipping techniques, see the discussion starting on page 271 of Foley and van Dam.</p>
<p>Finally, clipping in Listing 65.3 is performed in worldspace, rather than in viewspace. The frustum is backtransformed from viewspace (where it is defined, since it exists relative to the viewer) to worldspace for this purpose. Worldspace clipping allows us to transform only those vertices that are visible, rather than transforming all vertices into viewspace, then clipping them. However, the decision whether to clip in worldspace or viewspace is not clear-cut and is affected by several factors.</p>
</section>
</section>
<section id="advantages-of-viewspace-clipping" class="level3">
<h3><a href="#advantages-of-viewspace-clipping">Advantages of Viewspace Clipping</a></h3>
<p>Although viewspace clipping requires transforming vertices that may not be drawn, it has potential performance advantages. For example, in worldspace, near and far clip planes are just additional planes that have to be tested and clipped to, using dot products. In viewspace, near and far clip planes are typically planes with constant z coordinates, so testing whether a vertex is near or far-clipped can be performed with a single z compare, and the fractional distance along a line segment to a near or far clip intersection can be calculated with a couple of z subtractions and a divide; no dot products are needed.</p>
<p>Similarly, if the field of view is exactly 90 degrees, so the frustum planes go out at 45 degree angles relative to the viewplane, then x==z and y==z along the clip planes. This means that the clipping status of a vertex can be determined with a simple comparison, far more quickly than the standard dot-product test. This lends itself particularly well to outcode-based clipping algorithms, since each compare can set one outcode bit.</p>
<p>For a game, 90 degrees is a pretty good field of view, but can we get the same sort of efficient clipping if we need some other field of view? Sure. All we have to do is scale the x and y results of the world-to-view transformation to account for the field of view, so that the coordinates lie in a viewspace that’s normalized such that the frustum planes extend along lines of x==z and y==z. The resulting visible projected points span the range -1 to 1 (before scaling up to get pixel coordinates), just as with a 90-degree field of view, so the rest of the drawing pipeline remains unchanged. Better yet, there is no cost in performance because the adjustment can be added to the transformation matrix.</p>
<p>I didn’t implement normalized clipping in Listing 65.3 because I wanted to illustrate the general 3-D clipping mechanism without additional complications, and because for many applications the dot product (which, after all, takes only 10-20 cycles on a Pentium) is sufficient. However, the more frustum clipping you’re doing, especially if most of the polygons are trivially visible, the more attractive the performance advantages of normalized clipping become.</p>
</section>
<section id="further-reading-1" class="level3">
<h3><a href="#further-reading-1">Further Reading</a></h3>
<p>You now have the basics of 3-D clipping, but because fast clipping is central to high-performance 3-D, there’s a lot more to be learned. One good place for further reading is Foley and van Dam; another is <em>Procedural Elements of Computer Graphics</em>, by David F. Rogers. Read and understand either of these books, and you’ll know everything you need for world-class clipping.</p>
<p>And, as you read, you might take a moment to consider how wonderful it is that anyone who’s interested can tap into so much expert knowledge for the price of a book—or, on the Internet, for free—with no strings attached. Our part of the world is a pretty good place right now, isn’t it?</p>
</section>
</section>
<section id="chapter-66-quakes-hidden-surface-removal" class="level2">
<h2><a href="#chapter-66-quakes-hidden-surface-removal">Chapter 66 – Quake’s Hidden-Surface Removal</a></h2>
<section id="struggling-with-z-order-solutions-to-the-hidden-surface-problem" class="level3">
<h3><a href="#struggling-with-z-order-solutions-to-the-hidden-surface-problem">Struggling with Z-Order Solutions to the Hidden Surface Problem</a></h3>
<p>Okay, I admit it: I’m sick and tired of classic rock. Admittedly, it’s been a while, about 20 years, since I was last excited to hear anything by the Cars or Boston, and I was never particularly excited in the first place about Bob Seger or Queen, to say nothing of Elvis, so some things haven’t changed. But I knew something was up when I found myself changing the station on the Allman Brothers and Steely Dan and Pink Floyd and, God help me, the Beatles (just stuff like “Hello Goodbye” and “I’ll Cry Instead,” though, not “Ticket to Ride” or “A Day in the Life”; I’m not <em>that</em> far gone). It didn’t take long to figure out what the problem was; I’d been hearing the same songs for a quarter-century, and I was bored.</p>
<p>I tell you this by way of explaining why it was that when my daughter and I drove back from dinner the other night, the radio in my car was tuned, for the first time ever, to a station whose slogan is “There is no alternative.”</p>
<p>Now, we’re talking here about a 10-year-old who worships the Beatles and has been raised on a steady diet of oldies. She loves melodies, catchy songs, and good singers, none of which you’re likely to find on an alternative rock station. So it’s no surprise that when I turned on the radio, the first word out of her mouth was “Yuck!”</p>
<p>What did surprise me was that after listening for a while, she said, “You know, Dad, it’s actually kind of interesting.”</p>
<p>Apart from giving me a clue as to what sort of music I can expect to hear blasting through our house when she’s a teenager, her quick uptake on alternative rock (versus my decades-long devotion to the music of my youth) reminded me of something that it’s easy to forget as we become older and more set in our ways. It reminded me that it’s essential to keep an open mind, and to be willing, better yet, eager, to try new things. Programmers tend to become attached to familiar approaches, and are inclined to stick with whatever is currently doing the job adequately well, but in programming there are always alternatives, and I’ve found that they’re often worth considering.</p>
<p>Not that I should have needed any reminding, considering the ever-evolving nature of Quake.</p>
</section>
<section id="creative-flux-and-hidden-surfaces" class="level3">
<h3><a href="#creative-flux-and-hidden-surfaces">Creative Flux and Hidden Surfaces</a></h3>
<p>Back in Chapter 64, I described the creative flux that led to John Carmack’s decision to use a precalculated potentially visible set (PVS) of polygons for each possible viewpoint in Quake, the game we’re developing here at id Software. The precalculated PVS meant that instead of having to spend a lot of time searching through the world database to find out which polygons were visible from the current viewpoint, we could simply draw all the polygons in the PVS from back-to-front (getting the ordering courtesy of the world BSP tree) and get the correct scene drawn with no searching at all; letting the back-to-front drawing perform the final stage of hidden-surface removal (HSR). This was a terrific idea, but it was far from the end of the road for Quake’s design.</p>
<section id="drawing-moving-objects" class="level4">
<h4><a href="#drawing-moving-objects">Drawing Moving Objects</a></h4>
<p>For one thing, there was still the question of how to sort and draw moving objects properly; in fact, this is the single technical question I’ve been asked most often in recent months, so I’ll take a moment to address it here. The primary problem is that a moving model can span multiple BSP leaves, with the leaves that are touched varying as the model moves; that, together with the possibility of multiple models in one leaf, means there’s no easy way to use BSP order to draw the models in correctly sorted order. When I wrote Chapter 64, we were drawing sprites (such as explosions), moveable BSP models (such as doors), and polygon models (such as monsters) by clipping each into all the leaves it touched, then drawing the appropriate parts as each BSP leaf was reached in back-to-front traversal. However, this didn’t solve the issue of sorting multiple moving models in a single leaf against each other, and also left some ugly sorting problems with complex polygon models.</p>
<p>John solved the sorting issue for sprites and polygon models in a startlingly low-tech way: We now z-buffer them. (That is, before we draw each pixel, we compare its distance, or z, value with the z value of the pixel currently on the screen, drawing only if the new pixel is nearer than the current one.) First, we draw the basic world, walls, ceilings, and the like. No z-buffer <em>testing</em> is involved at this point (the world visible surface determination is done in a different way, as we’ll see soon); however, we do <em>fill</em> the z-buffer with the z values (actually, 1/z values, as discussed below) for all the world pixels. Z-filling is a much faster process than z-buffering the entire world would be, because no reads or compares are involved, just writes of z values. Once the drawing and z-filling of the world is done, we can simply draw the sprites and polygon models with z-buffering and get perfect sorting all around.</p>
</section>
<section id="performance-impact" class="level4">
<h4><a href="#performance-impact">Performance Impact</a></h4>
<p>Whenever a z-buffer is involved, the questions inevitably are: What’s the memory footprint and what’s the performance impact? Well, the memory footprint at 320x200 is 128K, not trivial but not a big deal for a game that requires 8 MB to run. The performance impact is about 10 percent for z-filling the world, and roughly 20 percent (with lots of variation) for drawing sprites and polygon models. In return, we get a perfectly sorted world, and also the ability to do additional effects, such as particle explosions and smoke, because the z-buffer lets us flawlessly sort such effects into the world. All in all, the use of the z-buffer vastly improved the visual quality and flexibility of the Quake engine, and also simplified the code quite a bit, at an acceptable memory and performance cost.</p>
</section>
<section id="leveling-and-improving-performance" class="level4">
<h4><a href="#leveling-and-improving-performance">Leveling and Improving Performance</a></h4>
<p>As I said above, in the Quake architecture, the world itself is drawn first, without z-buffer reads or compares, but filling the z-buffer with the world polygons’ z values, and then the moving objects are drawn atop the world, using full z-buffering. Thus far, I’ve discussed how to draw moving objects. For the rest of this chapter, I’m going to talk about the other part of the drawing equation; that is, how to draw the world itself, where the entire world is stored as a single BSP tree and never moves.</p>
<p>As you may recall from Chapter 64, we’re concerned with both raw performance and level performance. That is, we want the drawing code to run as fast as possible, but we also want the difference in drawing speed between the average scene and the slowest-drawing scene to be as small as possible.</p>
<blockquote>
<p><img src="images/i.jpg" /> It does little good to average 30 frames per second if 10 percent of the scenes draw at 5 fps, because the jerkiness in those scenes will be extremely obvious by comparison with the average scene, and highly objectionable. It would be better to average 15 fps 100 percent of the time, even though the average drawing speed is only half as much.</p>
</blockquote>
<p>The precalculated PVS was an important step toward both faster and more level performance, because it eliminated the need to identify visible polygons, a relatively slow step that tended to be at its worst in the most complex scenes. Nonetheless, in some spots in real game levels the precalculated PVS contains five times more polygons than are actually visible; together with the back-to-front HSR approach, this created hot spots in which the frame rate bogged down visibly as hundreds of polygons are drawn back-to- front, most of those immediately getting overdrawn by nearer polygons. Raw performance in general was also reduced by the typical 50% overdraw resulting from drawing everything in the PVS. So, although drawing the PVS back-to-front as the final HSR stage worked and was an improvement over previous designs, it was not ideal. Surely, John thought, there’s a better way to leverage the PVS than back-to-front drawing.</p>
<p>And indeed there is.</p>
</section>
</section>
<section id="sorted-spans" class="level3">
<h3><a href="#sorted-spans">Sorted Spans</a></h3>
<p>The ideal final HSR stage for Quake would reject all the polygons in the PVS that are actually invisible, and draw only the visible pixels of the remaining polygons, with no overdraw, that is, with every pixel drawn exactly once, all at no performance cost, of course. One way to do that (although certainly not at zero cost) would be to draw the polygons from front-to-back, maintaining a region describing the currently occluded portions of the screen and clipping each polygon to that region before drawing it. That sounds promising, but it is in fact nothing more or less than the beam tree approach I described in Chapter 64, an approach that we found to have considerable overhead and serious leveling problems.</p>
<p>We can do much better if we move the final HSR stage from the polygon level to the span level and use a sorted-spans approach. In essence, this approach consists of turning each polygon into a set of spans, as shown in Figure 66.1, and then sorting and clipping the spans against each other until only the visible portions of visible spans are left to be drawn, as shown in Figure 66.2. This may sound a lot like z-buffering (which is simply too slow for use in drawing the world, although it’s fine for smaller moving objects, as described earlier), but there are crucial differences.</p>
<figure>
<img src="images/66-01.jpg" alt="Figure 66.1  Span generation." /><figcaption><strong>Figure 66.1</strong>  <em>Span generation.</em></figcaption>
</figure>
<p>By contrast with z-buffering, only visible portions of visible spans are scanned out pixel by pixel (although all polygon edges must still be rasterized). Better yet, the sorting that z-buffering does at each pixel becomes a per-span operation with sorted spans, and because of the coherence implicit in a span list, each edge is sorted only against some of the spans on the same line and is clipped only to the few spans that it overlaps horizontally. Although complex scenes still take longer to process than simple scenes, the worst case isn’t as bad as with the beam tree or back-to-front approaches, because there’s no overdraw or scanning of hidden pixels, because complexity is limited to pixel resolution and because span coherence tends to limit the worst-case sorting in any one area of the screen. As a bonus, the output of sorted spans is in precisely the form that a low-level rasterizer needs, a set of span descriptors, each consisting of a start coordinate and a length.</p>
<p>In short, the sorted spans approach meets our original criteria pretty well; although it isn’t zero-cost, it’s not horribly expensive, it completely eliminates both overdraw and pixel scanning of obscured portions of polygons and it tends to level worst-case performance. We wouldn’t want to rely on sorted spans alone as our hidden-surface mechanism, but the precalculated PVS reduces the number of polygons to a level that sorted spans can handle quite nicely.</p>
<p>So we’ve found the approach we need; now it’s just a matter of writing some code and we’re on our way, right? Well, yes and no. Conceptually, the sorted-spans approach is simple, but it’s surprisingly difficult to implement, with a couple of major design choices to be made, a subtle mathematical element, and some tricky gotchas that I’ll have to defer until Chapter 67. Let’s look at the design choices first.</p>
</section>
<section id="edges-versus-spans" class="level3">
<h3><a href="#edges-versus-spans">Edges versus Spans</a></h3>
<p>The first design choice is whether to sort spans or edges (both of which fall into the general category of “sorted spans”). Although the results are the same both ways, a list of spans to be drawn, with no overdraw, the implementations and performance implications are quite different, because the sorting and clipping are performed using very different data structures.</p>
<p>With span-sorting, spans are stored in x-sorted, linked list buckets, typically with one bucket per scan line. Each polygon in turn is rasterized into spans, as shown in Figure 66.1, and each span is sorted and clipped into the bucket for the scan line the span is on, as shown in Figure 66.2, so that at any time each bucket contains the nearest spans encountered thus far, always with no overlap. This approach involves generating all spans for each polygon in turn, with each span immediately being sorted, clipped, and added to the appropriate bucket.</p>
<figure>
<img src="images/66-02.jpg" alt="Figure 66.2  Two sets of spans sorted and clipped against one another." /><figcaption><strong>Figure 66.2</strong>  <em>Two sets of spans sorted and clipped against one another.</em></figcaption>
</figure>
<p>With edge-sorting, edges are stored in x-sorted, linked list buckets according to their start scan line. Each polygon in turn is decomposed into edges, cumulatively building a list of all the edges in the scene. Once all edges for all polygons in the view frustum have been added to the edge list, the whole list is scanned out in a single top-to-bottom, left-to-right pass. An active edge list (AEL) is maintained. With each step to a new scan line, edges that end on that scan line are removed from the AEL, active edges are stepped to their new x coordinates, edges starting on the new scan line are added to the AEL, and the edges are sorted by current x coordinate.</p>
<p>For each scan line, a z-sorted active polygon list (APL) is maintained. The x-sorted AEL is stepped through in order. As each new edge is encountered (that is, as each polygon starts or ends as we move left to right), the associated polygon is activated and sorted into the APL, as shown in Figure 66.3, or deactivated and removed from the APL, as shown in Figure 66.4, for a leading or trailing edge, respectively. If the nearest polygon has changed (that is, if the new polygon is nearest, or if the nearest polygon just ended), a span is emitted for the polygon that just stopped being the nearest, starting at the point where the polygon first because nearest and ending at the x coordinate of the current edge, and the current x coordinate is recorded in the polygon that is now the nearest. This saved coordinate later serves as the start of the span emitted when the new nearest polygon ceases to be in front.</p>
<p>Don’t worry if you didn’t follow all of that; the above is just a quick overview of edge-sorting to help make the rest of this chapter a little clearer. My thorough discussion of the topic will be in Chapter 67.</p>
<p>The spans that are generated with edge-sorting are exactly the same spans that ultimately emerge from span-sorting; the difference lies in the intermediate data structures that are used to sort the spans in the scene. With edge-sorting, the spans are kept implicit in the edges until the final set of visible spans is generated, so the sorting, clipping, and span emission is done as each edge adds or removes a polygon, based on the span state implied by the edge and the set of active polygons. With span-sorting, spans are immediately made explicit when each polygon is rasterized, and those intermediate spans are then sorted and clipped against other the spans on the scan line to generate the final spans, so the states of the spans are explicit at all times, and all work is done directly with spans.</p>
<p>Both span-sorting and edge-sorting work well, and both have been employed successfully in commercial projects. We’ve chosen to use edge-sorting in Quake partly because it seems inherently more efficient, with excellent horizontal coherence that makes for minimal time spent sorting, in contrast with the potentially costly sorting into linked lists that span-sorting can involve. A more important reason, though, is that with edge-sorting we’re able to share edges between adjacent polygons, and that cuts the work involved in sorting, clipping, and rasterizing edges nearly in half, while also shrinking the world database quite a bit due to the sharing.</p>
<figure>
<img src="images/66-03.jpg" alt="Figure 66.3  Activating a polygon when a leading edge is encountered in the AEL." /><figcaption><strong>Figure 66.3</strong>  <em>Activating a polygon when a leading edge is encountered in the AEL.</em></figcaption>
</figure>
<p>One final advantage of edge-sorting is that it makes no distinction between convex and concave polygons. That’s not an important consideration for most graphics engines, but in Quake, edge clipping, transformation, projection, and sorting have become a major bottleneck, so we’re doing everything we can to get the polygon and edge counts down, and concave polygons help a lot in that regard. While it’s possible to handle concave polygons with span-sorting, that can involve significant performance penalties.</p>
<figure>
<img src="images/66-04.jpg" alt="Figure 66.4  Deactivating a polygon when a trailing edge is encountered in the AEL." /><figcaption><strong>Figure 66.4</strong>  <em>Deactivating a polygon when a trailing edge is encountered in the AEL.</em></figcaption>
</figure>
<p>Nonetheless, there’s no cut-and-dried answer as to which approach is better. In the end, span-sorting and edge-sorting amount to the same functionality, and the choice between them is a matter of whatever you feel most comfortable with. In Chapter 67, I’ll go into considerable detail about edge-sorting, complete with a full implementation. I’m going the spend the rest of this chapter laying the foundation for Chapter 67 by discussing sorting keys and 1/z calculation. In the process, I’m going to have to make a few forward references to aspects of edge-sorting that I haven’t yet covered in detail; my apologies, but it’s unavoidable, and all should become clear by the end of Chapter 67.</p>
</section>
<section id="edge-sorting-keys" class="level3">
<h3><a href="#edge-sorting-keys">Edge-Sorting Keys</a></h3>
<p>Now that we know we’re going to sort edges, using them to emit spans for the polygons nearest the viewer, the question becomes: How can we tell which polygons are nearest? Ideally, we’d just store a sorting key in each polygon, and whenever a new edge came along, we’d compare its surface’s key to the keys of other currently active polygons, and could easily tell which polygon was nearest.</p>
<p>That sounds too good to be true, but it is possible. If, for example, your world database is stored as a BSP tree, with all polygons clipped into the BSP leaves, then BSP walk order is a valid drawing order. So, for example, if you walk the BSP back-to-front, assigning each polygon an incrementally higher key as you reach it, polygons with higher keys are guaranteed to be in front of polygons with lower keys. This is the approach Quake used for a while, although a different approach is now being used, for reasons I’ll explain shortly.</p>
<p>If you don’t happen to have a BSP or similar data structure handy, or if you have lots of moving polygons (BSPs don’t handle moving polygons very efficiently), another way to accomplish your objectives would be to sort all the polygons against one another before drawing the scene, assigning appropriate keys based on their spatial relationships in viewspace. Unfortunately, this is generally an extremely slow task, because every polygon must be compared to every other polygon. There are techniques to improve the performance of polygon sorts, but I don’t know of anyone who’s doing general polygon sorts of complex scenes in realtime on a PC.</p>
<p>An alternative is to sort by z distance from the viewer in screenspace, an approach that dovetails nicely with the excellent spatial coherence of edge-sorting. As each new edge is encountered on a scan line, the corresponding polygon’s z distance can be calculated and compared to the other polygons’ distances, and the polygon can be sorted into the APL accordingly.</p>
<p>Getting z distances can be tricky, however. Remember that we need to be able to calculate z at any arbitrary point on a polygon, because an edge may occur and cause its polygon to be sorted into the APL at any point on the screen. We could calculate z directly from the screen x and y coordinates and the polygon’s plane equation, but unfortunately this can’t be done very quickly, because the z for a plane doesn’t vary linearly in screenspace; however, 1/z <em>does</em> vary linearly, so we’ll use that instead. (See Chris Hecker’s 1995 series of columns on texture mapping in <em>Game Developer</em> magazine for a discussion of screenspace linearity and gradients for 1/z.) Another advantage of using 1/z is that its resolution increases with decreasing distance, meaning that by using 1/z, we’ll have better depth resolution for nearby features, where it matters most.</p>
<p>The obvious way to get a 1/z value at any arbitrary point on a polygon is to calculate 1/z at the vertices, interpolate it down both edges of the polygon, and interpolate between the edges to get the value at the point of interest. Unfortunately, that requires doing a lot of work along each edge, and worse, requires division to calculate the 1/z step per pixel across each span.</p>
<p>A better solution is to calculate 1/z directly from the plane equation and the screen x and y of the pixel of interest. The equation is</p>
<p>1/z = (a/d)x’ - (b/d)y’ + c/d</p>
<p>where z is the viewspace z coordinate of the point on the plane that projects to screen coordinate (x’,y’) (the origin for this calculation is the center of projection, the point on the screen straight ahead of the viewpoint), [a b c] is the plane normal in viewspace, and d is the distance from the viewspace origin to the plane along the normal. Division is done only once per plane, because a, b, c, and d are per-plane constants.</p>
<p>The full 1/z calculation requires two multiplies and two adds, all of which should be floating-point to avoid range errors. That much floating-point math sounds expensive but really isn’t, especially on a Pentium, where a plane’s 1/z value at any point can be calculated in as little as six cycles in assembly language.</p>
<section id="where-that-1z-equation-comes-from" class="level4">
<h4><a href="#where-that-1z-equation-comes-from">Where That 1/Z Equation Comes From</a></h4>
<p>For those who are interested, here’s a quick derivation of the 1/z equation. The plane equation for a plane is</p>
<p>ax + by + cz - d = 0</p>
<p>where x and y are viewspace coordinates, and a, b, c, d, and z are defined above. If we substitute x=x’z and y=-y’z (from the definition of the perspective projection, with y inverted because y increases upward in viewspace but downward in screenspace), and do some rearrangement, we get:</p>
<p>z = d / (ax’ - by’ + c)</p>
<p>Inverting and distributing yields:</p>
<p>= ax’/d - by’/d + c/d</p>
<p>We’ll see 1/z sorting in action in Chapter 67.</p>
</section>
<section id="quake-and-z-sorting" class="level4">
<h4><a href="#quake-and-z-sorting">Quake and Z-Sorting</a></h4>
<p>I mentioned earlier that Quake no longer uses BSP order as the sorting key; in fact, it uses 1/z as the key now. Elegant as the gradients are, calculating 1/z from them is clearly slower than just doing a compare on a BSP-ordered key, so why have we switched Quake to 1/z?</p>
<p>The primary reason is to reduce the number of polygons. Drawing in BSP order means following certain rules, including the rule that polygons must be split if they cross BSP planes. This splitting increases the numbers of polygons and edges considerably. By sorting on 1/z, we’re able to leave polygons unsplit but still get correct drawing order, so we have far fewer edges to process and faster drawing overall, despite the added cost of 1/z sorting.</p>
<p>Another advantage of 1/z sorting is that it solves the sorting issues I mentioned at the start involving moving models that are themselves small BSP trees. Sorting in world BSP order wouldn’t work here, because these models are separate BSPs, and there’s no easy way to work them into the world BSP’s sequence order. We don’t want to use z-buffering for these models because they’re often large objects such as doors, and we don’t want to lose the overdraw-reduction benefits that closed doors provide when drawn through the edge list. With sorted spans, the edges of moving BSP models are simply placed in the edge list (first clipping polygons so they don’t cross any solid world surfaces, to avoid complications associated with interpenetration), along with all the world edges, and 1/z sorting takes care of the rest.</p>
</section>
</section>
<section id="decisions-deferred" class="level3">
<h3><a href="#decisions-deferred">Decisions Deferred</a></h3>
<p>There is, without a doubt, an awful lot of information in the preceding pages, and it may not all connect together yet in your mind. The code and accompanying explanation in the next chapter should help; if you want to peek ahead, the code is available on the CD-ROM as DDJZSORT.ZIP in the directory for Chapter 67. You may also want to take a look at Foley and van Dam’s <em>Computer Graphics</em> or Rogers’ <em>Procedural Elements for Computer Graphics</em>.</p>
<p>As I write this, it’s unclear whether Quake will end up sorting edges by BSP order or 1/z. Actually, there’s no guarantee that sorted spans in any form will be the final design. Sometimes it seems like we change graphics engines as often as they play Elvis on the ‘50s oldies stations (but, one would hope, with more aesthetically pleasing results!) and no doubt we’ll be considering the alternatives right up until the day we ship.</p>
</section>
</section>
<section id="chapter-67-sorted-spans-in-action" class="level2">
<h2><a href="#chapter-67-sorted-spans-in-action">Chapter 67 – Sorted Spans in Action</a></h2>
<section id="implementing-independent-span-sorting-for-rendering-without-overdraw" class="level3">
<h3><a href="#implementing-independent-span-sorting-for-rendering-without-overdraw">Implementing Independent Span Sorting for Rendering without Overdraw</a></h3>
<p>In Chapter 66, we dove headlong into the intricacies of hidden surface removal by way of z-sorted (actually, 1/z-sorted) spans. At the end of that chapter, I noted that we were currently using 1/z-sorted spans in Quake, but it was unclear whether we’d switch back to BSP order. Well, some time after that writing, it’s become clear: We’re back to sorting spans by BSP order.</p>
<p>In Robert A. Heinlein’s wonderful story “The Man Who Sold the Moon,” the chief engineer of the Moon rocket project tries to figure out how to get a payload of three astronauts to the Moon and back. He starts out with a four-stage rocket design, but finds that it won’t do the job, so he adds a fifth stage. The fifth stage helps, but not quite enough, “Because,” he explains, “I’ve had to add in too much dead weight, that’s why.” (The dead weight is the control and safety equipment that goes with the fifth stage.) He then tries adding yet another stage, only to find that the sixth stage actually results in a net slowdown. In the end, he has to give up on the three-person design and build a one-person spacecraft instead.</p>
<p>1/z-sorted spans in Quake turned out pretty much the same way, as we’ll see in a moment. First, though, I’d like to note up front that this chapter is very technical and builds heavily on material I covered earlier in this section of the book; if you haven’t already read Chapters 59 through 66, you really should. Make no mistake about it, this is commercial-quality stuff; in fact, the code in this chapter uses the same sorting technique as the test version of Quake, QTEST1.ZIP, that id Software placed on the Internet in early March 1996. This material is the Real McCoy, true reports from the leading edge, and I trust that you’ll be patient if careful rereading and some occasional catch-up reading of earlier chapters are required to absorb everything contained herein. Besides, the ultimate reference for any design is working code, which you’ll find, in part, in Listing 67.1, and in its entirety in the file DDJZSORT.ZIP on the CD-ROM.</p>
</section>
<section id="quake-and-sorted-spans" class="level3">
<h3><a href="#quake-and-sorted-spans">Quake and Sorted Spans</a></h3>
<p>As you’ll recall from Chapter 66, Quake uses sorted spans to get zero overdraw while rendering the world, thereby both improving overall performance and leveling frame rates by speeding up scenes that would otherwise experience heavy overdraw. Our original design used spans sorted by BSP order; because we traverse the world BSP tree from front-to-back relative to the viewpoint, the order in which BSP nodes are visited is a guaranteed front-to-back sorting order. We simply gave each node an increasing BSP sequence number as it was visited, set each polygon’s sort key to the BSP sequence number of the node (BSP splitting plane) it lay on, and used those sort keys when generating spans.</p>
<p>(In a change from earlier designs, polygons now are stored on nodes, rather than leaves, which are the convex subspaces carved out by the BSP tree. Visits to potentially visible leaves are used only to mark that the polygons that touch those leaves are visible and need to be drawn, and each marked-visible polygon is then drawn after everything in front of its node has been drawn. This results in less BSP splitting of polygons, which is A Good Thing, as explained below.)</p>
<p>This worked flawlessly for the world, but had a couple of downsides. First, it didn’t address the issue of sorting small, moving BSP models such as doors; those models could be clipped into the world BSP tree’s leaves and assigned sort keys corresponding to the leaves into which they fell, but there was still the question of how to sort multiple BSP models in the same world leaf against each other. Second, strict BSP order requires that polygons be split so that every polygon falls entirely within a single leaf. This can be stretched by putting polygons on nodes, allowing for larger polygons on average, but even then, polygons still need to be split so that every polygon falls within the bounding volume for the node on which it lies. The end result, in either case, is more and smaller polygons than if BSP order weren’t used—and that, in turn, means lower performance, because more polygons must be clipped, transformed, and projected, more sorting must be done, and more spans must be drawn.</p>
<p>We figured that if only we could avoid those BSP splits, Quake would get a lot faster. Accordingly, we switched from sorting on BSP order to sorting on 1/z, and left our polygons unsplit. Things did get faster at first, but not as much as we had expected, for two reasons.</p>
<p>First, as the world BSP tree is descended, we clip each node’s bounding box in turn to see if it’s inside or outside each plane of the view frustum. The clipping results can be remembered, and often allow the avoidance of some or all clipping for the node’s polygons. For example, all polygons in a node that has a trivially accepted bounding box are likewise guaranteed to be unclipped and in the frustum, since they all lie within the node’s volume and need no further clipping. This efficient clipping mechanism vanished as soon as we stepped out of BSP order, because a polygon was no longer necessarily confined to its node’s volume.</p>
<p>Second, sorting on 1/z isn’t as cheap as sorting on BSP order, because floating-point calculations and comparisons are involved, rather than integer compares. So Quake got faster but, like Heinlein’s fifth rocket stage, there was clear evidence of diminishing returns.</p>
<p>That wasn’t the bad part; after all, even a small speed increase is A Good Thing. The real problem was that our initial 1/z sorting proved to be unreliable. We first ran into problems when two forward-facing polygons started at a common edge, because it was hard to tell which one was really in front (as discussed below), and we had to do additional floating-point calculations to resolve these cases. This fixed the problems for a while, but then odd cases started popping up where just the right combination of polygon alignments caused new sorting errors. We tinkered with those too, adding more code and incurring additional slowdowns in the process. Finally, we had everything working smoothly again, although by this point Quake was back to pretty much the same speed it had been with BSP sorting.</p>
<p>And then yet another crop of sorting errors popped up.</p>
<p>We could have fixed those errors too; we’ll take a quick look at how to deal with such cases shortly. However, like the sixth rocket stage, the fixes would have made Quake <em>slower</em> than it had been with BSP sorting. So we gave up and went back to BSP order, and now the code is simpler and sorting works reliably. It’s too bad our experiment didn’t work out, but it wasn’t wasted time because in trying what we did we learned quite a bit. In particular, we learned that the information provided by a simple, reliable world ordering mechanism, such as a BSP tree, can do more good than is immediately apparent, in terms of both performance and solid code.</p>
<p>Nonetheless, sorting on 1/z can be a valuable tool, used in the right context; drawing a Quake world just doesn’t happen to be such a case. In fact, sorting on 1/z is how we’re now handling the sorting of multiple BSP models that lie within the same world leaf in Quake. In this case, we don’t have the option of using BSP order (because we’re drawing multiple independent trees), so we’ve set restrictions on the BSP models to avoid running into the types of 1/z sorting errors we encountered drawing the Quake world. Next, we’ll look at another application in which sorting on 1/z is quite useful, one where objects move freely through space. As is so often the case in 3-D, there is no one “right” technique, but rather a great many different techniques, each one handy in the right situations. Often, a combination of techniques is beneficial; for example, the combination in Quake of BSP sorting for the world and 1/z sorting for BSP models in the same world leaf.</p>
<p>For the remainder of this chapter, I’m going to look at the three main types of 1/z span sorting, then discuss a sample 3-D app built around 1/z span sorting.</p>
</section>
<section id="types-of-1z-span-sorting" class="level3">
<h3><a href="#types-of-1z-span-sorting">Types of 1/z Span Sorting</a></h3>
<p>As a quick refresher: With 1/z span sorting, all the polygons in a scene are treated as sets of screenspace pixel spans, and 1/z (where z is distance from the viewpoint in viewspace, as measured along the viewplane normal) is used to sort the spans so that the nearest span overlapping each pixel is drawn. As I discussed in Chapter 66, in the sample program we’re actually going to do all our sorting with polygon edges, which represent spans in an implicit form.</p>
<p>There are three types of 1/z span sorting, each requiring a different implementation. In order of increasing speed and decreasing complexity, they are: intersecting, abutting, and independent. (These are names of my own devising; I haven’t come across any standard nomenclature in the literature.)</p>
<section id="intersecting-span-sorting" class="level4">
<h4><a href="#intersecting-span-sorting">Intersecting Span Sorting</a></h4>
<p>Intersecting span sorting occurs when polygons can interpenetrate. Thus, two spans may cross such that part of each span is visible, in which case the spans have to be split and drawn appropriately, as shown in Figure 67.1.</p>
<figure>
<img src="images/67-01.jpg" alt="Figure 67.1  Intersecting span sorting." /><figcaption><strong>Figure 67.1</strong>  <em>Intersecting span sorting.</em></figcaption>
</figure>
<p>Intersecting is the slowest and most complicated type of span sorting, because it is necessary to compare 1/z values at two points in order to detect interpenetration, and additional work must be done to split the spans as necessary. Thus, although intersecting span sorting certainly works, it’s not the first choice for performance.</p>
</section>
<section id="abutting-span-sorting" class="level4">
<h4><a href="#abutting-span-sorting">Abutting Span Sorting</a></h4>
<p>Abutting span sorting occurs when polygons that are not part of a continuous surface can butt up against one another, but don’t interpenetrate, as shown in Figure 67.2. This is the sorting used in Quake, where objects like doors often abut walls and floors, and turns out to be more complicated than you might think. The problem is that when an abutting polygon starts on a given scan line, as with polygon B in Figure 67.2, it starts at exactly the same 1/z value as the polygon it abuts, in this case, polygon A, so additional sorting is needed when these ties happen. Of course, the two-point sorting used for intersecting polygons would work, but we’d like to find something faster.</p>
<p>As it turns out, the additional sorting for abutting polygons is actually quite simple; whichever polygon has a greater 1/z gradient with respect to screen x (that is, whichever polygon is heading fastest toward the viewer along the scan line) is the front one. The hard part is identifying <em>when</em> ties—that is, abutting polygons—occur; due to floating-point imprecision, as well as fixed-point edge-stepping imprecision that can move an edge slightly on the screen, calculations of 1/z from the combination of screen coordinates and 1/z gradients (as discussed last time) can be slightly off, so most tie cases will show up as near matches, not exact matches. This imprecision makes it necessary to perform two comparisons, one with an adjust-up by a small epsilon and one with an adjust-down, creating a range in which near-matches are considered matches. Fine-tuning this epsilon to catch all ties, without falsely reporting close-but-not-abutting edges as ties, proved to be troublesome in Quake, and the epsilon calculations and extra comparisons slowed things down.</p>
<figure>
<img src="images/67-02.jpg" alt="Figure 67.2  Abutting span sorting." /><figcaption><strong>Figure 67.2</strong>  <em>Abutting span sorting.</em></figcaption>
</figure>
<p>I do think that abutting 1/z span sorting could have been made reliable enough for production use in Quake, were it not that we share edges between adjacent polygons in Quake, so that the world is a large polygon mesh. When a polygon ends and is followed by an adjacent polygon that shares the edge that just ended, we simply assume that the adjacent polygon sorts relative to other active polygons in the same place as the one that ended (because the mesh is continuous and there’s no interpenetration), rather than doing a 1/z sort from scratch. This speeds things up by saving a lot of sorting, but it means that if there is a sorting error, a whole string of adjacent polygons can be sorted incorrectly, pulled in by the one missorted polygon. Missorting is a very real hazard when a polygon is very nearly perpendicular to the screen, so that the 1/z calculations push the limits of numeric precision, especially in single-precision floating point.</p>
<p>Many caching schemes are possible with abutting span sorting, because any given pair of polygons, being noninterpenetrating, will sort in the same order throughout a scene. However, in Quake at least, the benefits of caching sort results were outweighed by the additional overhead of maintaining the caching information, and every caching variant we tried actually slowed Quake down.</p>
</section>
<section id="independent-span-sorting" class="level4">
<h4><a href="#independent-span-sorting">Independent Span Sorting</a></h4>
<p>Finally, we come to independent span sorting, the simplest and fastest of the three, and the type the sample code in Listing 67.1 uses. Here, polygons never intersect or touch any other polygons except adjacent polygons with which they form a continuous mesh. This means that when a polygon starts on a scan line, a single 1/z comparison between that polygon and the polygons it overlaps on the screen is guaranteed to produce correct sorting, with no extra calculations or tricky cases to worry about.</p>
<p>Independent span sorting is ideal for scenes with lots of moving objects that never actually touch each other, such as a space battle. Next, we’ll look at an implementation of independent 1/z span sorting.</p>
</section>
</section>
<section id="z-span-sorting-in-action" class="level3">
<h3><a href="#z-span-sorting-in-action">1/z Span Sorting in Action</a></h3>
<p>Listing 67.1 is a portion of a program that demonstrates independent 1/z span sorting. This program is based on the sample 3-D clipping program from Chapter 65; however, the earlier program did hidden surface removal (HSR) by simply z-sorting whole objects and drawing them back-to-front, while Listing 67.1 draws all polygons by way of a 1/z-sorted edge list. Consequently, where the earlier program worked only so long as object centers correctly described sorting order, Listing 67.1 works properly for all combinations of non-intersecting and non-abutting polygons. In particular, Listing 67.1 correctly handles concave polyhedra; a new L-shaped object (the data for which is not included in Listing 67.1) has been added to the sample program to illustrate this capability. The ability to handle complex shapes makes Listing 67.1 vastly more useful for real-world applications than the 3-D clipping demo from Chapter 65.</p>
<p><strong>Listing 67.1 L67_1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Part of Win32 program to demonstrate z-sorted spans. Whitespace</span>
<span class="co">// removed for space reasons. Full source code, with whitespace,</span>
<span class="co">// available from ftp.idsoftware.com/mikeab/ddjzsort.zip.</span>

<span class="ot">#define MAX_SPANS           10000</span>
<span class="ot">#define MAX_SURFS           1000</span>
<span class="ot">#define MAX_EDGES           5000</span>

<span class="kw">typedef</span> <span class="kw">struct</span> surf_s {
    <span class="kw">struct</span> surf_s   *pnext, *pprev;
    <span class="dt">int</span>             color, visxstart, state;
    <span class="dt">double</span>          zinv00, zinvstepx, zinvstepy;
} surf_t;

<span class="kw">typedef</span> <span class="kw">struct</span> edge_s {
    <span class="dt">int</span>             x, xstep, leading;
    surf_t          *psurf;
    <span class="kw">struct</span> edge_s   *pnext, *pprev, *pnextremove;
} edge_t;

<span class="co">// Span, edge, and surface lists</span>
span_t  spans[MAX_SPANS];
edge_t  edges[MAX_EDGES];
surf_t  surfs[MAX_SURFS];

<span class="co">// Bucket list of new edges to add on each scan line</span>
edge_t  newedges[MAX_SCREEN_HEIGHT];

<span class="co">// Bucket list of edges to remove on each scan line</span>
edge_t  *removeedges[MAX_SCREEN_HEIGHT];

<span class="co">// Head and tail for the active edge list</span>
edge_t  edgehead, edgetail;

<span class="co">// Edge used as sentinel of new edge lists</span>
edge_t  maxedge = {<span class="bn">0x7FFFFFFF</span>};

<span class="co">// Head/tail/sentinel/background surface of active surface stack</span>
surf_t  surfstack;

<span class="co">// pointers to next available surface and edge</span>
surf_t  *pavailsurf;
edge_t  *pavailedge;


<span class="co">// Returns true if polygon faces the viewpoint, assuming a clockwise</span>
<span class="co">// winding of vertices as seen from the front.</span>
<span class="dt">int</span> PolyFacesViewer(polygon_t *ppoly, plane_t *pplane)
{
    <span class="dt">int</span>     i;
    point_t viewvec;

    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;<span class="dv">3</span> ; i++)
        viewvec.v[i] = ppoly-&gt;verts[<span class="dv">0</span>].v[i] - currentpos.v[i];
    <span class="co">// Use an epsilon here so we don&#39;t get polygons tilted so</span>
    <span class="co">// sharply that the gradients are unusable or invalid</span>
    <span class="kw">if</span> (DotProduct (&amp;viewvec, &amp;pplane-&gt;normal) &lt; -<span class="fl">0.01</span>)
        <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">return</span> <span class="dv">0</span>;
}


<span class="co">// Add the polygon&#39;s edges to the global edge table.</span>
<span class="dt">void</span> AddPolygonEdges (plane_t *plane, polygon2D_t *screenpoly)
{
    <span class="dt">double</span>  distinv, deltax, deltay, slope;
    <span class="dt">int</span>     i, nextvert, numverts, temp, topy, bottomy, height;
    edge_t  *pedge;

    numverts = screenpoly-&gt;numverts;

    <span class="co">// Clamp the polygon&#39;s vertices just in case some very near</span>
    <span class="co">// points have wandered out of range due to floating-point</span>
    <span class="co">// imprecision</span>
    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;numverts ; i++) {
        <span class="kw">if</span> (screenpoly-&gt;verts[i].x &lt; -<span class="fl">0.5</span>)
            screenpoly-&gt;verts[i].x = -<span class="fl">0.5</span>;
        <span class="kw">if</span> (screenpoly-&gt;verts[i].x &gt; ((<span class="dt">double</span>)DIBWidth - <span class="fl">0.5</span>))
            screenpoly-&gt;verts[i].x = (<span class="dt">double</span>)DIBWidth - <span class="fl">0.5</span>;
        <span class="kw">if</span> (screenpoly-&gt;verts[i].y &lt; -<span class="fl">0.5</span>)
            screenpoly-&gt;verts[i].y = -<span class="fl">0.5</span>;
        <span class="kw">if</span> (screenpoly-&gt;verts[i].y &gt; ((<span class="dt">double</span>)DIBHeight - <span class="fl">0.5</span>))
            screenpoly-&gt;verts[i].y = (<span class="dt">double</span>)DIBHeight - <span class="fl">0.5</span>;
    }

    <span class="co">// Add each edge in turn</span>
    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;numverts ; i++) {
        nextvert = i + <span class="dv">1</span>;
        <span class="kw">if</span> (nextvert &gt;= numverts)
            nextvert = <span class="dv">0</span>;
        topy = (<span class="dt">int</span>)ceil(screenpoly-&gt;verts[i].y);
        bottomy = (<span class="dt">int</span>)ceil(screenpoly-&gt;verts[nextvert].y);
        height = bottomy - topy;
        <span class="kw">if</span> (height == <span class="dv">0</span>)
            <span class="kw">continue</span>;       <span class="co">// doesn&#39;t cross any scan lines</span>
        <span class="kw">if</span> (height &lt; <span class="dv">0</span>) {
            <span class="co">// Leading edge</span>
            temp = topy;
            topy = bottomy;
            bottomy = temp;
            pavailedge-&gt;leading = <span class="dv">1</span>;
            deltax = screenpoly-&gt;verts[i].x -
                     screenpoly-&gt;verts[nextvert].x;
            deltay = screenpoly-&gt;verts[i].y -
                     screenpoly-&gt;verts[nextvert].y;
            slope = deltax / deltay;
            <span class="co">// Edge coordinates are in 16.16 fixed point</span>
            pavailedge-&gt;xstep = (<span class="dt">int</span>)(slope * (<span class="dt">float</span>)<span class="bn">0x10000</span>);
            pavailedge-&gt;x = (<span class="dt">int</span>)((screenpoly-&gt;verts[nextvert].x +
                ((<span class="dt">float</span>)topy - screenpoly-&gt;verts[nextvert].y) *
                slope) * (<span class="dt">float</span>)<span class="bn">0x10000</span>);
        } <span class="kw">else</span> {
            <span class="co">// Trailing edge</span>
            pavailedge-&gt;leading = <span class="dv">0</span>;
            deltax = screenpoly-&gt;verts[nextvert].x -
                     screenpoly-&gt;verts[i].x;
            deltay = screenpoly-&gt;verts[nextvert].y -
                     screenpoly-&gt;verts[i].y;
            slope = deltax / deltay;
            <span class="co">// Edge coordinates are in 16.16 fixed point</span>
            pavailedge-&gt;xstep = (<span class="dt">int</span>)(slope * (<span class="dt">float</span>)<span class="bn">0x10000</span>);
            pavailedge-&gt;x = (<span class="dt">int</span>)((screenpoly-&gt;verts[i].x +
                ((<span class="dt">float</span>)topy - screenpoly-&gt;verts[i].y) * slope) *
                (<span class="dt">float</span>)<span class="bn">0x10000</span>);
        }

        <span class="co">// Put the edge on the list to be added on top scan</span>
        pedge = &amp;newedges[topy];
        <span class="kw">while</span> (pedge-&gt;pnext-&gt;x &lt; pavailedge-&gt;x)
            pedge = pedge-&gt;pnext;
        pavailedge-&gt;pnext = pedge-&gt;pnext;
        pedge-&gt;pnext = pavailedge;

        <span class="co">// Put the edge on the list to be removed after final scan</span>
        pavailedge-&gt;pnextremove = removeedges[bottomy - <span class="dv">1</span>];
        removeedges[bottomy - <span class="dv">1</span>] = pavailedge;

        <span class="co">// Associate the edge with the surface we&#39;ll create for</span>
        <span class="co">// this polygon</span>
        pavailedge-&gt;psurf = pavailsurf;

        <span class="co">// Make sure we don&#39;t overflow the edge array</span>
        <span class="kw">if</span> (pavailedge &lt; &amp;edges[MAX_EDGES])
            pavailedge++;
    }

    <span class="co">// Create the surface, so we&#39;ll know how to sort and draw from</span>
    <span class="co">// the edges</span>
    pavailsurf-&gt;state = <span class="dv">0</span>;
    pavailsurf-&gt;color = currentcolor;

    <span class="co">// Set up the 1/z gradients from the polygon, calculating the</span>
    <span class="co">// base value at screen coordinate 0,0 so we can use screen</span>
    <span class="co">// coordinates directly when calculating 1/z from the gradients</span>
    distinv = <span class="fl">1.0</span> / plane-&gt;distance;
    pavailsurf-&gt;zinvstepx = plane-&gt;normal.v[<span class="dv">0</span>] * distinv *
            maxscreenscaleinv * (fieldofview / <span class="fl">2.0</span>);
    pavailsurf-&gt;zinvstepy = -plane-&gt;normal.v[<span class="dv">1</span>] * distinv *
            maxscreenscaleinv * (fieldofview / <span class="fl">2.0</span>);
    pavailsurf-&gt;zinv00 = plane-&gt;normal.v[<span class="dv">2</span>] * distinv -
            xcenter * pavailsurf-&gt;zinvstepx -
            ycenter * pavailsurf-&gt;zinvstepy;

    <span class="co">// Make sure we don&#39;t overflow the surface array</span>
    <span class="kw">if</span> (pavailsurf &lt; &amp;surfs[MAX_SURFS])
        pavailsurf++;
}


<span class="co">// Scan all the edges in the global edge table into spans.</span>
<span class="dt">void</span> ScanEdges (<span class="dt">void</span>)
{
    <span class="dt">int</span>     x, y;
    <span class="dt">double</span>  fx, fy, zinv, zinv2;
    edge_t  *pedge, *pedge2, *ptemp;
    span_t  *pspan;
    surf_t  *psurf, *psurf2;

    pspan = spans;

    <span class="co">// Set up the active edge list as initially empty, containing</span>
    <span class="co">// only the sentinels (which are also the background fill). Most</span>
    <span class="co">// of these fields could be set up just once at start-up</span>
    edgehead.pnext = &amp;edgetail;
    edgehead.pprev = NULL;
    edgehead.x = -<span class="bn">0xFFFF</span>;           <span class="co">// left edge of screen</span>
    edgehead.leading = <span class="dv">1</span>;
    edgehead.psurf = &amp;surfstack;
    edgetail.pnext = NULL;          <span class="co">// mark edge of list</span>
    edgetail.pprev = &amp;edgehead;
    edgetail.x = DIBWidth &lt;&lt; <span class="dv">16</span>;    <span class="co">// right edge of screen</span>
    edgetail.leading = <span class="dv">0</span>;
    edgetail.psurf = &amp;surfstack;

    <span class="co">// The background surface is the entire stack initially, and</span>
    <span class="co">// is infinitely far away, so everything sorts in front of it.</span>
    <span class="co">// This could be set just once at start-up</span>
    surfstack.pnext = surfstack.pprev = &amp;surfstack;
    surfstack.color = <span class="dv">0</span>;
    surfstack.zinv00 = -<span class="fl">999999.0</span>;
    surfstack.zinvstepx = surfstack.zinvstepy = <span class="fl">0.0</span>;
    <span class="kw">for</span> (y=<span class="dv">0</span> ; y&lt;DIBHeight ; y++) {
        fy = (<span class="dt">double</span>)y;
        <span class="co">// Sort in any edges that start on this scan</span>
        pedge = newedges[y].pnext;
        pedge2 = &amp;edgehead;
        <span class="kw">while</span> (pedge != &amp;maxedge) {
            <span class="kw">while</span> (pedge-&gt;x &gt; pedge2-&gt;pnext-&gt;x)
                pedge2 = pedge2-&gt;pnext;
            ptemp = pedge-&gt;pnext;
            pedge-&gt;pnext = pedge2-&gt;pnext;
            pedge-&gt;pprev = pedge2;
            pedge2-&gt;pnext-&gt;pprev = pedge;
            pedge2-&gt;pnext = pedge;
            pedge2 = pedge;
            pedge = ptemp;
        }

        <span class="co">// Scan out the active edges into spans</span>
        <span class="co">// Start out with the left background edge already inserted,</span>
        <span class="co">// and the surface stack containing only the background</span>
        surfstack.state = <span class="dv">1</span>;
        surfstack.visxstart = <span class="dv">0</span>;
        <span class="kw">for</span> (pedge=edgehead.pnext ; pedge ; pedge=pedge-&gt;pnext) {
            psurf = pedge-&gt;psurf;
            <span class="kw">if</span> (pedge-&gt;leading) {
                <span class="co">// It&#39;s a leading edge. Figure out where it is</span>
                <span class="co">// relative to the current surfaces and insert in</span>
                <span class="co">// the surface stack; if it&#39;s on top, emit the span</span>
                <span class="co">// for the current top.</span>
                <span class="co">// First, make sure the edges don&#39;t cross</span>
                <span class="kw">if</span> (++psurf-&gt;state == <span class="dv">1</span>) {
                    fx = (<span class="dt">double</span>)pedge-&gt;x * (<span class="fl">1.0</span> / (<span class="dt">double</span>)<span class="bn">0x10000</span>);
                    <span class="co">// Calculate the surface&#39;s 1/z value at this pixel</span>
                    zinv = psurf-&gt;zinv00 + psurf-&gt;zinvstepx * fx +
                            psurf-&gt;zinvstepy * fy;
                    <span class="co">// See if that makes it a new top surface</span>
                    psurf2 = surfstack.pnext;
                    zinv2 = psurf2-&gt;zinv00 + psurf2-&gt;zinvstepx * fx +
                            psurf2-&gt;zinvstepy * fy;
                    <span class="kw">if</span> (zinv &gt;= zinv2) {
                        <span class="co">// It&#39;s a new top surface</span>
                        <span class="co">// emit the span for the current top</span>
                        x = (pedge-&gt;x + <span class="bn">0xFFFF</span>) &gt;&gt; <span class="dv">16</span>;
                        pspan-&gt;count = x - psurf2-&gt;visxstart;
                        <span class="kw">if</span> (pspan-&gt;count &gt; <span class="dv">0</span>) {
                            pspan-&gt;y = y;
                            pspan-&gt;x = psurf2-&gt;visxstart;
                            pspan-&gt;color = psurf2-&gt;color;
                            <span class="co">// Make sure we don&#39;t overflow</span>
                            <span class="co">// the span array</span>
                            <span class="kw">if</span> (pspan &lt; &amp;spans[MAX_SPANS])
                                pspan++;
                        }
                        psurf-&gt;visxstart = x;
                        <span class="co">// Add the edge to the stack</span>
                        psurf-&gt;pnext = psurf2;
                        psurf2-&gt;pprev = psurf;
                        surfstack.pnext = psurf;
                        psurf-&gt;pprev = &amp;surfstack;
                    } <span class="kw">else</span> {
                        <span class="co">// Not a new top; sort into the surface stack.</span>
                        <span class="co">// Guaranteed to terminate due to sentinel</span>
                        <span class="co">// background surface</span>
                        <span class="kw">do</span> {
                            psurf2 = psurf2-&gt;pnext;
                            zinv2 = psurf2-&gt;zinv00 +
                                    psurf2-&gt;zinvstepx * fx +
                                    psurf2-&gt;zinvstepy * fy;
                        } <span class="kw">while</span> (zinv &lt; zinv2);
                        <span class="co">// Insert the surface into the stack</span>
                        psurf-&gt;pnext = psurf2;
                        psurf-&gt;pprev = psurf2-&gt;pprev;
                        psurf2-&gt;pprev-&gt;pnext = psurf;
                        psurf2-&gt;pprev = psurf;
                    }
                }
            } <span class="kw">else</span> {
                <span class="co">// It&#39;s a trailing edge; if this was the top surface,</span>
                <span class="co">// emit the span and remove it.</span>
                <span class="co">// First, make sure the edges didn&#39;t cross</span>
                <span class="kw">if</span> (—psurf-&gt;state == <span class="dv">0</span>) {
                    <span class="kw">if</span> (surfstack.pnext == psurf) {
                        <span class="co">// It&#39;s on top, emit the span</span>
                        x = ((pedge-&gt;x + <span class="bn">0xFFFF</span>) &gt;&gt; <span class="dv">16</span>);
                        pspan-&gt;count = x - psurf-&gt;visxstart;
                        <span class="kw">if</span> (pspan-&gt;count &gt; <span class="dv">0</span>) {
                            pspan-&gt;y = y;
                            pspan-&gt;x = psurf-&gt;visxstart;
                            pspan-&gt;color = psurf-&gt;color;
                            <span class="co">// Make sure we don&#39;t overflow</span>
                            <span class="co">// the span array</span>
                            <span class="kw">if</span> (pspan &lt; &amp;spans[MAX_SPANS])
                                pspan++;
                        }
                        psurf-&gt;pnext-&gt;visxstart = x;
                    }
                    <span class="co">// Remove the surface from the stack</span>
                    psurf-&gt;pnext-&gt;pprev = psurf-&gt;pprev;
                    psurf-&gt;pprev-&gt;pnext = psurf-&gt;pnext;
                }
            }
        }

        <span class="co">// Remove edges that are done</span>
        pedge = removeedges[y];
        <span class="kw">while</span> (pedge) {
            pedge-&gt;pprev-&gt;pnext = pedge-&gt;pnext;
            pedge-&gt;pnext-&gt;pprev = pedge-&gt;pprev;
            pedge = pedge-&gt;pnextremove;
        }

        <span class="co">// Step the remaining edges one scan line, and re-sort</span>
        <span class="kw">for</span> (pedge=edgehead.pnext ; pedge != &amp;edgetail ; ) {
            ptemp = pedge-&gt;pnext;
            <span class="co">// Step the edge</span>
            pedge-&gt;x += pedge-&gt;xstep;
            <span class="co">// Move the edge back to the proper sorted location,</span>
            <span class="co">// if necessary</span>
            <span class="kw">while</span> (pedge-&gt;x &lt; pedge-&gt;pprev-&gt;x) {
                pedge2 = pedge-&gt;pprev;
                pedge2-&gt;pnext = pedge-&gt;pnext;
                pedge-&gt;pnext-&gt;pprev = pedge2;
                pedge2-&gt;pprev-&gt;pnext = pedge;
                pedge-&gt;pprev = pedge2-&gt;pprev;
                pedge-&gt;pnext = pedge2;
                pedge2-&gt;pprev = pedge;
            }
            pedge = ptemp;
        }
    }
    pspan-&gt;x = -<span class="dv">1</span>;  <span class="co">// mark the end of the list</span>
}

<span class="co">// Draw all the spans that were scanned out.</span>
<span class="dt">void</span> DrawSpans (<span class="dt">void</span>)
{
    span_t  *pspan;
    <span class="kw">for</span> (pspan=spans ; pspan-&gt;x != -<span class="dv">1</span> ; pspan++)
        memset (pDIB + (DIBPitch * pspan-&gt;y) + pspan-&gt;x,
                pspan-&gt;color,
                pspan-&gt;count);
}


<span class="co">// Clear the lists of edges to add and remove on each scan line.</span>
<span class="dt">void</span> ClearEdgeLists(<span class="dt">void</span>)
{
    <span class="dt">int</span> i;
    <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;DIBHeight ; i++) {
        newedges[i].pnext = &amp;maxedge;
        removeedges[i] = NULL;
    }
}

<span class="co">// Render the current state of the world to the screen.</span>
<span class="dt">void</span> UpdateWorld()
{
    HPALETTE        holdpal;
    HDC             hdcScreen, hdcDIBSection;
    HBITMAP         holdbitmap;
    polygon2D_t     screenpoly;
    polygon_t       *ppoly, tpoly0, tpoly1, tpoly2;
    convexobject_t  *pobject;
    <span class="dt">int</span>             i, j, k;
    plane_t         plane;
    point_t         tnormal;

    UpdateViewPos();
    SetUpFrustum();
    ClearEdgeLists();
    pavailsurf = surfs;
    pavailedge = edges;

    <span class="co">// Draw all visible faces in all objects</span>
    pobject = objecthead.pnext;
    <span class="kw">while</span> (pobject != &amp;objecthead) {
        ppoly = pobject-&gt;ppoly;
        <span class="kw">for</span> (i=<span class="dv">0</span> ; i&lt;pobject-&gt;numpolys ; i++) {
            <span class="co">// Move the polygon relative to the object center</span>
            tpoly0.numverts = ppoly[i].numverts;
            <span class="kw">for</span> (j=<span class="dv">0</span> ; j&lt;tpoly0.numverts ; j++) {
                <span class="kw">for</span> (k=<span class="dv">0</span> ; k&lt;<span class="dv">3</span> ; k++)
                    tpoly0.verts[j].v[k] = ppoly[i].verts[j].v[k] +
                            pobject-&gt;center.v[k];
            }
            <span class="kw">if</span> (PolyFacesViewer(&amp;tpoly0, &amp;ppoly[i].plane)) {
                <span class="kw">if</span> (ClipToFrustum(&amp;tpoly0, &amp;tpoly1)) {
                    currentcolor = ppoly[i].color;
                    TransformPolygon (&amp;tpoly1, &amp;tpoly2);
                    ProjectPolygon (&amp;tpoly2, &amp;screenpoly);

                    <span class="co">// Move the polygon&#39;s plane into viewspace</span>
                    <span class="co">// First move it into worldspace (object relative)</span>
                    tnormal = ppoly[i].plane.normal;
                    plane.distance = ppoly[i].plane.distance +
                        DotProduct (&amp;pobject-&gt;center, &amp;tnormal);

                    <span class="co">// Now transform it into viewspace</span>
                    <span class="co">// Determine the distance from the viewpont</span>
                    plane.distance -=
                          DotProduct (&amp;currentpos, &amp;tnormal);

                    <span class="co">// Rotate the normal into view orientation</span>
                    plane.normal.v[<span class="dv">0</span>] =
                            DotProduct (&amp;tnormal, &amp;vright);
                    plane.normal.v[<span class="dv">1</span>] =
                            DotProduct (&amp;tnormal, &amp;vup);
                    plane.normal.v[<span class="dv">2</span>] =
                            DotProduct (&amp;tnormal, &amp;vpn);
                    AddPolygonEdges (&amp;plane, &amp;screenpoly);
                }
            }
        }
        pobject = pobject-&gt;pnext;
    }
    ScanEdges ();
    DrawSpans ();

    <span class="co">// We&#39;ve drawn the frame; copy it to the screen</span>
    hdcScreen = GetDC(hwndOutput);
    holdpal = SelectPalette(hdcScreen, hpalDIB, FALSE);
    RealizePalette(hdcScreen);
    hdcDIBSection = CreateCompatibleDC(hdcScreen);
    holdbitmap = SelectObject(hdcDIBSection, hDIBSection);
    BitBlt(hdcScreen, <span class="dv">0</span>, <span class="dv">0</span>, DIBWidth, DIBHeight, hdcDIBSection,
           <span class="dv">0</span>, <span class="dv">0</span>, SRCCOPY);
    SelectPalette(hdcScreen, holdpal, FALSE);
    ReleaseDC(hwndOutput, hdcScreen);
    SelectObject(hdcDIBSection, holdbitmap);
    DeleteDC(hdcDIBSection);
}</code></pre>
<p>By the same token, Listing 67.1 is quite a bit more complicated than the earlier code. The earlier code’s HSR consisted of a z-sort of objects, followed by the drawing of the objects in back-to-front order, one polygon at a time. Apart from the simple object sorter, all that was needed was backface culling and a polygon rasterizer.</p>
<p>Listing 67.1 replaces this simple pipeline with a three-stage HSR process. After backface culling, the edges of each of the polygons in the scene are added to the global edge list, by way of <code>AddPolygonEdges()</code>. After all edges have been added, the edges are turned into spans by <code>ScanEdges()</code>, with each pixel on the screen being covered by one and only one span (that is, there’s no overdraw). Once all the spans have been generated, they’re drawn by <code>DrawSpans()</code>, and rasterization is complete.</p>
<p>There’s nothing tricky about <code>AddPolygonEdges()</code>, and <code>DrawSpans()</code>, as implemented in Listing 67.1, is very straightforward as well. In an implementation that supported texture mapping, however, all the spans wouldn’t be put on one global span list and drawn at once, as is done in Listing 67.1, because that would result in drawing spans from all the surfaces in no particular order. (A surface is a drawing object that’s originally described by a polygon, but in <code>ScanEdges()</code> there is no polygon in the classic sense of a set of vertices bounding an area, but rather just a set of edges and a surface that describes how to draw the spans outlined by those edges.) That would mean constantly skipping from one texture to another, which in turn would hurt processor cache coherency a great deal, and would also incur considerable overhead in setting up gradient and perspective calculations each time a surface was drawn. In Quake, we have a linked list of spans hanging off each surface, and draw all the spans for one surface before moving on to the next surface.</p>
<p>The core of Listing 67.1, and the most complex aspect of 1/z-sorted spans, is <code>ScanEdges()</code>, where the global edge list is converted into a set of spans describing the nearest surface at each pixel. This process is actually pretty simple, though, if you think of it as follows:</p>
<p>For each scan line, there is a set of active edges, which are those edges that intersect the scan line. A good part of <code>ScanEdges()</code> is dedicated to adding any edges that first appear on the current scan line (scan lines are processed from the top scan line on the screen to the bottom), removing edges that reach their bottom on the current scan line, and x-sorting the active edges so that the active edges for the next scan can be processed from left to right. All this is per-scan-line maintenance, and is basically just linked list insertion, deletion, and sorting.</p>
<p>The heart of the action is the loop in <code>ScanEdges()</code> that processes the edges on the current scan line from left to right, generating spans as needed. The best way to think of this loop is as a surface event processor, where each edge is an event with an associated surface. Each leading edge is an event marking the start of its surface on that scan line; if the surface is nearer than the current nearest surface, then a span ends for the nearest surface, and a span starts for the new surface. Each trailing edge is an event marking the end of its surface; if its surface is currently nearest, then a span ends for that surface, and a span starts for the next-nearest surface (the surface with the next-largest 1/z at the coordinate where the edge intersects the scan line). One handy aspect of this event-oriented processing is that leading and trailing edges do not need to be explicitly paired, because they are implicitly paired by pointing to the same surface. This saves the memory and time that would otherwise be needed to track edge pairs.</p>
<p>One more element is required in order for <code>ScanEdges()</code> to work efficiently. Each time a leading or trailing edge occurs, it must be determined whether its surface is nearest (at a larger 1/z value than any currently active surface). In addition, for leading edges, the currently topmost surface must be known, and for trailing edges, it may be necessary to know the currently next-to-topmost surface. The easiest way to accomplish this is with a <em>surface stack</em>; that is, a linked list of all currently active surfaces, starting with the nearest surface and progressing toward the farthest surface, which, as described below, is always the background surface. (The operation of this sort of edge event-based stack was described and illustrated in Chapter 66.) Each leading edge causes its surface to be 1/z-sorted into the surface stack, with a span emitted if necessary. Each trailing edge causes its surface to be removed from the surface stack, again with a span emitted if necessary. As you can see from Listing 67.1, it takes a fair bit of code to implement this, but all that’s really going on is a surface stack driven by edge events.</p>
<section id="implementation-notes" class="level4">
<h4><a href="#implementation-notes">Implementation Notes</a></h4>
<p>Finally, a few notes on Listing 67.1. First, you’ll notice that although we clip all polygons to the view frustum in worldspace, we nonetheless later clamp them to valid screen coordinates before adding them to the edge list. This catches any cases where arithmetic imprecision results in clipped polygon vertices that are a bit outside the frustum. I’ve only found such imprecision to be significant at very small z distances, so clamping would probably be unnecessary if there were a near clip plane, and might not even be needed in Listing 67.1, because of the slight nudge inward that we give the frustum planes, as described in Chapter 65. However, my experience has consistently been that relying on worldspace or viewspace clipping to produce valid screen coordinates 100 percent of the time leads to sporadic and hard-to-debug errors.</p>
<p>There is no separate routine to clear the background in Listing 67.1. Instead, a special background surface at an effectively infinite distance is added, so whenever no polygons are active the background color is drawn. If desired, it’s a simple matter to flag the background surface and draw the background specially. For example, the background could be drawn as a starfield or a cloudy sky.</p>
<p>The edge-processing code in Listing 67.1 is fully capable of handling concave polygons as easily as convex polygons, and can handle an arbitrary number of vertices per polygon, as well. One change is needed for the latter case: Storage for the maximum number of vertices per polygon must be allocated in the polygon structures. In a fully polished implementation, vertices would be linked together or pointed to, and would be dynamically allocated from a vertex pool, so each polygon wouldn’t have to contain enough space for the maximum possible number of vertices.</p>
<p>Each surface has a field named <code>state</code>, which is incremented when a leading edge for that surface is encountered, and decremented when a trailing edge is reached. A surface is activated by a leading edge only if <code>state</code> increments to 1, and is deactivated by a trailing edge only if <code>state</code> decrements to 0. This is another guard against arithmetic problems, in this case quantization during the conversion of vertex coordinates from floating point to fixed point. Due to this conversion, it is possible, although rare, for a polygon that is viewed nearly edge-on to have a trailing edge that occurs slightly <em>before</em> the corresponding leading edge, and the span-generation code will behave badly if it tries to emit a span for a surface that hasn’t yet started. It would help performance if this sort of fix-up could be eliminated by careful arithmetic, but I haven’t yet found a way to do so for 1/z-sorted spans.</p>
<p>Lastly, as discussed in Chapter 66, Listing 67.1 uses the gradients for 1/z with respect to changes in screen x and y to calculate 1/z for active surfaces each time a leading edge needs to be sorted into the surface stack. The natural origin for gradient calculations is the center of the screen, which is (x,y) coordinate (0,0) in viewspace. However, when the gradients are calculated in <code>AddPolygonEdges()</code>, the origin value is calculated at the upper-left corner of the screen. This is done so that screen x and y coordinates can be used directly to calculate 1/z, with no need to adjust the coordinates to be relative to the center of the screen. Also, the screen gradients grow more extreme as a polygon is viewed closer to edge-on. In order to keep the gradient calculations from becoming meaningless or generating errors, a small epsilon is applied to backface culling, so that polygons that are very nearly edge-on are culled. This calculation would be more accurate if it were based directly on the viewing angle, rather than on the dot product of a viewing ray to the polygon with the polygon normal, but that would require a square root, and in my experience the epsilon used in Listing 67.1 works fine.</p>
</section>
</section>
</section>
<section id="chapter-68-quakes-lighting-model" class="level2">
<h2><a href="#chapter-68-quakes-lighting-model">Chapter 68 – Quake’s Lighting Model</a></h2>
<section id="a-radically-different-approach-to-lighting-polygons" class="level3">
<h3><a href="#a-radically-different-approach-to-lighting-polygons">A Radically Different Approach to Lighting Polygons</a></h3>
<p>It was during my senior year in college that I discovered computer games. Not Wizardry, or Choplifter, or Ultima, because none of those existed yet—the game that hooked me was the original Star Trek game, in which you navigated from one 8x8 quadrant to another in search of starbases, occasionally firing phasers or photon torpedoes. This was less exciting than it sounds; after each move, the current quadrant had to be reprinted from scratch, along with the current stats—and the output device was a 10 cps printball console. A typical game took over an hour, during which nothing particularly stimulating ever happened (Klingons appeared periodically, but they politely waited for your next move before attacking, and your photon torpedoes never missed, so the outcome was never in doubt), but none of that mattered; nothing could detract from the sheer thrill of being in a computer-simulated universe.</p>
<p>Then the college got a PDP-11 with four CRT terminals, and suddenly Star Trek could redraw in a second instead of a minute. Better yet, I found the source code for the Star Trek program in the recesses of the new system, the first time I’d ever seen any real-world code other than my own, and excitedly dove into it. One evening, as I was looking through the code, a really cute girl at the next terminal asked me for help getting a program to run. After I had helped her, eager to get to know her better, I said, “Want to see something? This is the actual source for the Star Trek game!” and proceeded to page through the code, describing each subroutine. We got to talking, and eventually I worked up the nerve to ask her out. She said sure, and we ended up having a good time, although things soon fell apart because of her two or three other boyfriends (I never did get an exact count). The interesting thing, though, was her response when I finally got around to asking her out. She said, “It’s about time!” When I asked what she meant, she said, “I’ve been trying to get you to ask me out all evening—but it took you forever! You didn’t actually think I was interested in that Star Trek program, did you?”</p>
<p>Actually, yes, I had thought that, because <em>I</em> was interested in it. One thing I learned from that experience, and have had reinforced countless times since, is that we—you, me, anyone who programs because they love it, who would do it for free if necessary—are a breed apart. We’re different, and luckily so; while everyone else is worrying about downsizing, we’re in one of the hottest industries in the world. And, so far as I can see, the biggest reason we’re in such a good situation isn’t intelligence, or hard work, or education, although those help; it’s that we actually <em>like</em> this stuff.</p>
<p>It’s important to keep it that way. I’ve seen far too many people start to treat programming like a job, forgetting the joy of doing it, and burn out. So keep an eye on how you feel about the programming you’re doing, and if it’s getting stale, it’s time to learn something new; there’s plenty of interesting programming of all sorts to be done. Follow your interests—and don’t forget to have fun!</p>
</section>
<section id="the-lighting-conundrum" class="level3">
<h3><a href="#the-lighting-conundrum">The Lighting Conundrum</a></h3>
<p>I spent about two years working with John Carmack on Quake’s 3-D graphics engine. John faced several fundamental design issues while architecting Quake. I’ve written in earlier chapters about some of those issues, including eliminating non-visible polygons quickly via a precalculated potentially visible set (PVS), and improving performance by inserting potentially visible polygons into a global edge list and scanning out only the nearest polygon at each pixel.</p>
<p>In this chapter, I’m going to talk about another, equally crucial design issue: how we developed our lighting approach for the part of the Quake engine that draws the world itself, the static walls and floors and ceilings. Monsters and players are drawn using completely different rendering code, with speed the overriding factor. A primary goal for the world, on the other hand, was to be as precise as possible, getting everything right so that polygons, textures, and sophisticated lighting would be pegged in place, with no visible shifting or distortion under all viewing conditions, for maximum player immersion—all with good performance, of course. As I’ll discuss, the twin goals of performance and rock-solid, complex lighting proved to be difficult to achieve with traditional lighting approaches; ultimately, a dramatically different approach was required.</p>
</section>
<section id="gouraud-shading" class="level3">
<h3><a href="#gouraud-shading">Gouraud Shading</a></h3>
<p>The traditional way to do realistic lighting in polygon pipelines is Gouraud shading (also known as <em>smooth shading</em>). Gouraud shading involves generating a lighting value at each polygon vertex by applying all relevant world lighting, linearly interpolating between lighting values down the edges of the polygon, and then linearly interpolating between the edges of the polygon across each span. If texture mapping is desired (and all polygons are texture mapped in Quake), then at each pixel in each span, the pixel’s corresponding texture map location (texel) is determined, and the interpolated lighting is applied to the texel to generate a final, lit pixel. Texels are generally taken from a 32x32 or 64x64 texture that’s tiled repeatedly across the polygon, for several reasons: performance (a 64x64 texture sits nicely in the 486 or Pentium cache), database size, and less artwork.</p>
<p>The interpolated lighting can consist of either a color intensity value or three separate red, green, and blue values. RGB lighting produces more sophisticated results, such as colored lights, but is slower and best suited to RGB modes. Games like Quake that are targeted at palettized 256-color modes generally use intensity lighting; each pixel is lit by looking up the pixel color in a table, using the texel color and the lighting intensity as the look-up indices.</p>
<p>Gouraud shading allows for decent lighting effects with a relatively small amount of calculation and a compact data set that’s a simple extension of the basic polygon model. However, there are several important drawbacks to Gouraud shading, as well.</p>
<section id="problems-with-gouraud-shading" class="level4">
<h4><a href="#problems-with-gouraud-shading">Problems with Gouraud Shading</a></h4>
<p>The quality of Gouraud shading depends heavily on the average size of the polygons being drawn. Linear interpolation is used, so highlights can only occur at vertices, and color gradients are monotonic across the face of each polygon. This can make for bland lighting effects if polygons are large, and makes it difficult to do spotlights and other detailed or dramatic lighting effects. After John brought the initial, primitive Quake engine up using Gouraud shading for lighting, the first thing he tried to improve lighting quality was adding a single vertex and creating new polygons wherever a spotlight was directly overhead a polygon, with the new vertex added directly underneath the light, as shown in Figure 68.1. This produced fairly attractive highlights, but simultaneously made evident several problems.</p>
<p>A primary problem with Gouraud shading is that it requires the vertices used for world geometry to serve as lighting sample points as well, even though there isn’t necessarily a close relationship between lighting and geometry. This artificial coupling often forces the subdivision of a single polygon into several polygons purely for lighting reasons, as with the spotlights mentioned above; these extra polygons increase the world database size, and the extra transformations and projections that they induce can harm performance considerably.</p>
<p>Similar problems occur with overlapping lights, and with shadows, where additional polygons are required in order to approximate lighting detail well. In particular, good shadow edges need small polygons, because otherwise the gradient between light and dark gets spread across too wide an area. Worse still, the rate of lighting change across a shadow edge can vary considerably as a function of the geometry the edge crosses; wider polygons stretch and diffuse the transition between light and shadow. A related problem is that lighting discontinuities can be very visible at t-junctions (although ultimately we had to add edges to eliminate t-junctions anyway, because otherwise dropouts can occur along polygon edges). These problems can be eased by adding extra edges, but that increases the rasterization load.</p>
<figure>
<img src="images/68-01.jpg" alt="Figure 68.1  Adding an extra vertex directly beneath a light." /><figcaption><strong>Figure 68.1</strong>  <em>Adding an extra vertex directly beneath a light.</em></figcaption>
</figure>
</section>
<section id="perspective-correctness" class="level4">
<h4><a href="#perspective-correctness">Perspective Correctness</a></h4>
<p>Another problem is that Gouraud shading isn’t perspective-correct. With Gouraud shading, lighting varies linearly across the face of a polygon, in equal increments per pixel—but unless the polygon is parallel to the screen, the same sort of perspective correction is needed to step lighting across the polygon properly as is required for texture mapping. Lack of perspective correction is not as visibly wrong for lighting as it is for texture mapping, because smooth lighting gradients can tolerate considerably more warping than can the detailed bitmapped images used in texture mapping, but it nonetheless shows up in several ways.</p>
<p>First, the extent of the mismatch between Gouraud shading and perspective lighting varies with the angle and orientation of the polygon being lit. As a polygon turns to become more on-edge, for example, the lighting warps more and therefore shifts relative to the perspective-texture mapped texels it’s shading, an effect I’ll call <em>viewing variance</em>. Lighting can similarly shift as a result of clipping, for example if one or more polygon edges are completely clipped; I’ll refer to this as <em>clipping variance</em>.</p>
<p>These are fairly subtle effects; more pronounced is the <em>rotational variance</em> that occurs when Gouraud shading any polygon with more than three vertices. Consistent lighting for a polygon is fully defined by three lighting values; taking four or more vertices and interpolating between them, as Gouraud shading does, is basically a hack, and does not reflect any consistent underlying model. If you view a Gouraud-shaded quad head-on, then rotate it like a pinwheel, the lighting will shift as the quad turns, as shown in Figure 68.2. The extent of the lighting shift can be quite drastic, depending on how different the colors at the vertices are.</p>
<p>It was rotational variance that finally brought the lighting issue to a head for Quake. We’d look at the floors, which were Gouraud-shaded quads; then we’d pivot, and the lighting would shimmy and shift, especially where there were spotlights and shadows. Given the goal of rendering the world as accurately and convincingly as possible, this was unacceptable.</p>
<p>The obvious solution to rotational variance is to use only triangles, but that brings with it a new set of problems. It takes twice as many triangles as quads to describe the same scene, increasing the size of the world database and requiring extra rasterization, at a performance cost. Triangles still don’t provide perspective lighting; their lighting is rotationally invariant, but it’s still wrong—just wrong in a more consistant way. Gouraud-shaded triangles still result in odd lighting patterns, and require lots of triangles to support shadowing and other lighting detail. Finally, triangles don’t solve clipping or viewing variance.</p>
<figure>
<img src="images/68-02.jpg" alt="Figure 68.2  How Gouraud shading varies with polygon screen orientation." /><figcaption><strong>Figure 68.2</strong>  <em>How Gouraud shading varies with polygon screen orientation.</em></figcaption>
</figure>
<p>Yet another problem is that while it may work well to add extra geometry so that spotlights and shadows show up well, that’s feasible only for static lighting. Dynamic lighting—light cast by sources that move—has to work with whatever geometry the world has to offer, because its needs are constantly changing.</p>
<p>These issues led us to conclude that if we were going to use Gouraud shading, we would have to build Quake levels from many small triangles, with sufficiently finely detailed geometry so that complex lighting could be supported and the inaccuracies of Gouraud shading wouldn’t be too noticeable. Unfortunately, that line of thinking brought us back to the problem of a much larger world database and a much heavier rasterization load (all the worse because Gouraud shading requires an additional interpolant, slowing the inner rasterization loop), so that not only would the world still be less than totally solid, because of the limitations of Gouraud shading, but the engine would also be too slow to support the complex worlds we had hoped for in Quake.</p>
</section>
</section>
<section id="the-quest-for-alternative-lighting" class="level3">
<h3><a href="#the-quest-for-alternative-lighting">The Quest for Alternative Lighting</a></h3>
<p>None of which is to say that Gouraud shading isn’t useful in general. Descent uses it to excellent effect, and in fact Quake uses Gouraud shading for moving entities, because these consist of small triangles and are always in motion, which helps hide the relatively small lighting errors. However, Gouraud shading didn’t seem capable of meeting our design goals for rendering quality and speed for drawing the world as a whole, so it was time to look for alternatives.</p>
<p>There are many alternative lighting approaches, most of them higher-quality than Gouraud, starting with Phong shading, in which the surface normal is interpolated across the polygon’s surface, and going all the way up to ray-tracing lighting techniques in which full illumination calculations are performed for all direct and reflected paths from each light source for each pixel. What all these approaches have in common is that they’re slower than Gouraud shading, too slow for our purposes in Quake. For weeks, we kicked around and rejected various possibilities and continued working with Gouraud shading for lack of a better alternative—until the day John came into work and said, “You know, I have an idea….”</p>
<section id="decoupling-lighting-from-rasterization" class="level4">
<h4><a href="#decoupling-lighting-from-rasterization">Decoupling Lighting from Rasterization</a></h4>
<p>John’s idea came to him while was looking at a wall that had been carved into several pieces because of a spotlight, with an ugly lighting glitch due to a t-junction. He thought to himself that if only there were some way to treat it as one surface, it would look better and draw faster—and then he realized that there was a way to do that.</p>
<p>The insight was to split lighting and rasterization into two separate steps. In a normal Gouraud-based rasterizer, there’s first an off-line preprocessing step when the world database is built, during which polygons are added to support additional lighting detail as needed, and lighting values are calculated at the vertices of all polygons. At runtime, the lighting values are modified if dynamic lighting is required, and then the polygons are drawn with Gouraud shading.</p>
<p>Quake’s approach, which I’ll call surface-based lighting, preprocesses differently, and adds an extra rendering step. During off-line preprocessing, a grid, called a light map, is calculated for each polygon in the world, with a lighting value every 16 texels horizontally and vertically. This lighting is done by casting light from all the nearby lights in the world to each of the grid points on the polygon, and summing the results for each grid point. The Quake preprocessor filters the values, so shadow edges don’t have a stair-step appearance (a technique suggested by Billy Zelsnack); additional preprocessing could be done, for example Phong shading to make surfaces appear smoothly curved. Then, at runtime, the polygon’s texture is tiled into a buffer, with each texel lit according to the weighted average intensities of the four nearest light map points, as shown in Figure 68.3. If dynamic lighting is needed, the light map is modified accordingly before the buffer, which I’ll call a surface, is built. Then the polygon is drawn with perspective texture mapping, with the surface serving as the input texture, and with no lighting performed during the texture mapping.</p>
<p>So what does surface-based lighting buy us? First and foremost, it provides consistent, perspective-correct lighting, eliminating all rotational, viewing, and clipping variance, because lighting is done in surface space rather than in screen space. By lighting in surface space, we bind the lighting to the texels in an invariant way, and then the lighting gets a free ride through the perspective texture mapper and ends up perfectly matched to the texels. Surface-based lighting also supports good, although not perfect, detail for overlapping lights and shadows. The 16-texel grid has a resolution of two feet in the Quake frame of reference, and this relatively fine resolution, together with the filtering performed when the light map is built, is sufficient to support complex shadows with smoothly fading edges. Additionally, surface-based lighting eliminates lighting glitches at t-junctions, because lighting is unrelated to vertices. In short, surface-based lighting meets all of Quake’s visual quality goals, which leaves only one question: How does it perform?</p>
</section>
<section id="size-and-speed" class="level4">
<h4><a href="#size-and-speed">Size and Speed</a></h4>
<p>As it turns out, the raw speed of surface-based lighting is pretty good. Although an extra step is required to build the surface, moving lighting and tiling into a separate loop from texture mapping allows each of the two loops to be optimized very effectively, with almost all variables kept in registers. The surface-building inner loop is particularly efficient, because it consists of nothing more than interpolating intensity, combining it with a texel and using the result to look up a lit texel color, and storing the results with a dword write every four texels. In assembly language, we got this code down to 2.25 cycles per lit texel in Quake. Similarly, the texture-mapping inner loop, which overlaps an FDIV for floating-point perspective correction with integer pixel drawing in 16-pixel bursts, has been squeezed down to 7.5 cycles per pixel on a Pentium, so the combined inner loop times for building and drawing a surface is roughly in the neighborhood of 10 cycles per pixel. It’s certainly possible to write a Gouraud-shaded perspective-correct texture mapper that’s somewhat faster than 10 cycles, but 10 cycles/pixel is fast enough to do 40 frames/second at 640x400 on a Pentium/100, so the cycle counts of surface-based lighting are acceptable. It’s worth noting that it’s possible to write a one-pass texture mapper that does approximately perspective-correct lighting. However, I have yet to hear of or devise such an inner loop that isn’t complicated and full of special cases, which makes it hard to optimize; worse, this approach doesn’t work well with the procedural and post-processing techniques I’ll discuss shortly.</p>
<figure>
<img src="images/68-03.jpg" alt="Figure 68.3  Tiling the texture and lighting the texels from the light map." /><figcaption><strong>Figure 68.3</strong>  <em>Tiling the texture and lighting the texels from the light map.</em></figcaption>
</figure>
<p>Moreover, surface-based lighting tends to spend more of its time in inner loops, because polygons can have any number of sides and don’t need to be split into multiple smaller polygons for lighting purposes; this reduces the amount of transformation and projection that are required, and makes polygon spans longer. So the performance of surface-based lighting stacks up very well indeed—except for caching.</p>
<p>I mentioned earlier that a 64x64 texture tile fits nicely in the processor cache. A typical surface doesn’t. Every texel in every surface is unique, so even at 320x200 resolution, something on the rough order of 64,000 texels must be read in order to draw a single scene. (The number actually varies quite a bit, as discussed below, but 64,000 is in the ballpark.) This means that on a Pentium, we’re guaranteed to miss the cache once every 32 texels, and the number can be considerably worse than that if the texture access patterns are such that we don’t use every texel in a given cache line before that data gets thrown out of the cache. Then, too, when a surface is built, the surface buffer won’t be in the cache, so the writes will be uncached writes that have to go to main memory, then get read back from main memory at texture mapping time, potentially slowing things further still. All this together makes the combination of surface building and unlit texture mapping a potential performance problem, but that never posed a problem during the development of Quake, thanks to surface caching.</p>
</section>
</section>
<section id="surface-caching" class="level3">
<h3><a href="#surface-caching">Surface Caching</a></h3>
<p>When he thought of surface-based lighting, John immediately realized that surface building would be relatively expensive. (In fact, he assumed it would be considerably more expensive than it actually turned out to be with full assembly-language optimization.) Consequently, his design included the concept of caching surfaces, so that if the same surface were visible in the next frame, it could be reused without having to be rebuilt.</p>
<p>With surface rebuilding needed only rarely, thanks to surface caching, Quake’s rasterization speed is generally the speed of the unlit, perspective-correct texture-mapping inner loop, which suffers from more cache misses than Gouraud-shaded, tiled texture mapping, but doesn’t have the overhead of Gouraud shading, and allows the use of larger polygons. In the worst case, where everything in a frame is a new surface, the speed of the surface-caching approach is somewhat slower than Gouraud shading, but generally surface caching provides equal or better performance, so once surface caching was implemented in Quake, performance was no longer a problem—but size became a concern.</p>
<p>The amount of memory required for surface caching looked forbidding at first. Surfaces are large relative to texture tiles, because every texel of every surface is unique. Also, a surface can contain many texels relative to the number of pixels actually drawn on the screen, because due to perspective foreshortening, distant polygons have only a few pixels relative to the surface size in texels. Surfaces associated with partly hidden polygons must be fully built, even though only part of the polygon is visible, and if polygons are drawn back to front with overdraw, some polygons won’t even be visible, but will still require surface building and caching. What all this meant was that the surface cache initially looked to be very large, on the order of several megabytes, even at 320x200—too much for a game intended to run on an 8 MB machine.</p>
<section id="mipmapping-to-the-rescue" class="level4">
<h4><a href="#mipmapping-to-the-rescue">Mipmapping To The Rescue</a></h4>
<p>Two factors combined to solve this problem. First, polygons are drawn through an edge list with no overdraw, as I discussed a few chapters back, so no surface is ever built unless at least part of it is visible. Second, surfaces are built at four mipmap levels, depending on distance, with each mipmap level having one-quarter as many texels as the preceding level, as shown in Figure 68.4.</p>
<p>For those whose heads haven’t been basted in 3-D technology for the past several years, <em>mipmapping</em> is 3-D graphics jargon for a process that normalizes the number of texels in a surface to be approximately equal to the number of pixels, reducing calculation time for distant surfaces containing only a few pixels. The mipmap level for a given surface is selected to result in a texel:pixel ratio approximately between 1:1 and 1:2, so texels map roughly to pixels, and more distant surfaces are correspondingly smaller. As a result, the number of surface texels required to draw a scene at 320x200 is on the rough order of 64,000; the number is actually somewhat higher, because of portions of surfaces that are obscured and viewspace-tilted polygons, which have high texel-to-pixel ratios along one axis, but not a whole lot higher. Thanks to mipmapping and the edge list, 600K has proven to be plenty for the surface cache at 320x200, even in the most complex scenes, and at 640x480, a little more than 1 MB suffices.</p>
<figure>
<img src="images/68-04.jpg" alt="Figure 68.4  How mipmapping reduces surface caching requirements." /><figcaption><strong>Figure 68.4</strong>  <em>How mipmapping reduces surface caching requirements.</em></figcaption>
</figure>
<p>All mipmapped texture tiles are generated as a preprocessing step, and loaded from disk at runtime. One interesting point is that a key to making mipmapping look good turned out to be box-filtering down from one level to the next by averaging four adjacent pixels, then using error diffusion dithering to generate the mipmapped texels.</p>
<p>Also, mipmapping is done on a per-surface basis; the mipmap level for a whole surface is selected based on the distance from the viewer of the nearest vertex. This led us to limit surface size to a maximum of 256x256. Otherwise, surfaces such as floors would extend for thousands of texels, all at the mipmap level of the nearest vertex, and would require huge amounts of surface cache space while displaying a great deal of aliasing in distant regions due to a high texel:pixel ratio.</p>
</section>
<section id="two-final-notes-on-surface-caching" class="level4">
<h4><a href="#two-final-notes-on-surface-caching">Two Final Notes on Surface Caching</a></h4>
<p>Dynamic lighting has a significant impact on the performance of surface caching, because whenever the lighting on a surface changes, the surface has to be rebuilt. In the worst case, where the lighting changes on every visible surface, the surface cache provides no benefit, and rendering runs at the combined speed of surface building and texture mapping. This worst-case slowdown is tolerable but certainly noticeable, so it’s best to design games that use surface caching so only some of the surfaces change lighting at any one time. If necessary, you could alternate surface relighting so that half of the surfaces change on even frames, and half on odd frames, but large-scale, constant relighting is not surface caching’s strongest suit.</p>
<p>Finally, Quake barely begins to tap surface caching’s potential. All sorts of procedural texturing and post-processing effects are possible. If a wall is shot, a sprite of pockmarks could be attached to the wall’s data structure, and the sprite could be drawn into the surface each time the surface is rebuilt. The same could be done for splatters, or graffiti, with translucency easily supported. These effects would then be cached and drawn as part of the surface, so the performance cost would be much less than effects done by on-screen overdraw every frame. Basically, the surface is a handy repository for all sorts of effects, because multiple techniques can be composited, because it caches the results for reuse without rebuilding, and because the texels constructed in a surface are automatically drawn in perspective.</p>
</section>
</section>
</section>
<section id="chapter-69-surface-caching-and-quakes-triangle-models" class="level2">
<h2><a href="#chapter-69-surface-caching-and-quakes-triangle-models">Chapter 69 – Surface Caching and Quake’s Triangle Models</a></h2>
<section id="probing-hardware-assisted-surfaces-and-fast-model-animation-without-sprites" class="level3">
<h3><a href="#probing-hardware-assisted-surfaces-and-fast-model-animation-without-sprites">Probing Hardware-Assisted Surfaces and Fast Model Animation Without Sprites</a></h3>
<p>In the late ’70s, I spent a summer doing contract programming at a government-funded installation called the Northeast Solar Energy Center (NESEC). Those were heady times for solar energy, what with the oil shortages, and there was lots of money being thrown at places like NESEC, which was growing fast.</p>
<p>NESEC was across the street from MIT, which made for good access to resources. Unfortunately, it also meant that NESEC was in a severely parking-impaired part of the world, what with the student population and Boston’s chronic parking shortage. The NESEC building did have its own parking lot, but it wasn’t nearly big enough, because students parked in it at every opportunity. The lot was posted, and cars periodically got towed, but King Canute stood a better chance against the tide than NESEC did against the student hordes, and late arrivals to work often had to park blocks away and hike to work, to their considerable displeasure.</p>
<p>Back then, I drove an aging Volvo sedan that was sorely in need of a ring job. It ran fine but burned a quart of oil every 250 miles, so I carried a case of oil in the trunk, and checked the level frequently. One day, walking to the computer center a couple of blocks away, I cut through the parking lot and checked the oil in my car. It was low, so I topped it off, left the empty oil can next to the car so I would see it and remember to pick it up to throw out on my way back, and headed toward the computer center.</p>
<p>I’d gone only a few hundred feet when I heard footsteps and shouting behind me, and a wild-eyed man in a business suit came running up to me, screaming. “It’s bad enough you park in our lot, but now you’re leaving your garbage lying around!” he yelled. “Don’t you people have any sense of decency?” I told him I worked at NESEC and was going to pick up the can on my way back, and he shouted, “Don’t give me that!” I repeated my statements, calmly, and told him who I worked for and where my office was, and he said, “Don’t give me that” again, but with a little less certainty. I kept adding detail until it was obvious that I was telling the truth, and he suddenly said, “Oh, my God,” turned red, and started to apologize profusely. A few days later, we passed in the hallway, and he didn’t look me in the eye.</p>
<p>The interesting point is that there was really no useful outcome that could have resulted from his outburst. Suppose I had been a student—what would he have accomplished by yelling at me? He let his emotions overrule his common sense, and as a result, did something he later wished he hadn’t. I’ve seen many programmers do the same thing, especially when they’re working long hours and not feeling adequately appreciated. For example, some time back I got mail from a programmer who complained bitterly that although he was critical to his company’s success, management didn’t appreciate his hard work and talent, and asked if I could help him find a better job. I suggested several ways that he might look for another job, but also asked if he had tried working his problems out with his employers; if he really was that valuable, what did he have to lose? He admitted he hadn’t, and recently he wrote back and said that he had talked to his boss, and now he was getting paid a lot more money, was getting credit for his work, and was just flat-out happy.</p>
<p>We programmers think of ourselves as rational creatures, but most of us get angry at times, and when we do, like everyone else, we tend to be driven by our emotions instead of our minds. It’s my experience that thinking rationally under those circumstances can be difficult, but produces better long-term results every time—so if you find yourself in that situation, stay cool and think your way through it, and odds are you’ll be happier down the road.</p>
<p>Of course, most of the time programmers really <em>are</em> rational creatures, and the more information we have, the better. In that spirit, let’s look at more of the stuff that makes Quake tick, starting with what I’ve recently learned about surface caching.</p>
</section>
<section id="surface-caching-with-hardware-assistance" class="level3">
<h3><a href="#surface-caching-with-hardware-assistance">Surface Caching with Hardware Assistance</a></h3>
<p>In Chapter 68, I discussed in detail the surface caching technique that Quake uses to do detailed, high-quality lighting without lots of polygons. Since writing that chapter, I’ve gone further, and spent a considerable amount of time working on the port of Quake to Rendition’s Verite 3-D accelerator chip. So let me start off this chapter by discussing what I’ve learned about using surface caching in conjunction with hardware.</p>
<p>As you’ll recall, the key to surface caching is that lighting information and polygon detail are stored separately, with lighting not tied to polygon vertices, then combined on demand into what I call <em>surfaces</em>: lit, textured rectangles that are used as the input to the texture mapper. Building surfaces takes time, so performance is enhanced by caching the surfaces from one frame to the next. As I pointed out in Chapter 68, 3-D hardware accelerators are designed to optimize Gouraud shading, but surface caching can also work on hardware accelerators, with some significant quality advantages.</p>
<p>The surface-caching architecture of the Verite version of Quake (which we call VQuake) is essentially the same as in the software-only version of Quake: The CPU builds surfaces on demand, which are then downloaded to the accelerator’s memory and cached there. There are a couple of key differences, however: the need to download surfaces, and the requirement that the surfaces be in 16-bit-per-pixel (bpp) format.</p>
<p>Downloading surfaces to the accelerator is a performance hit that doesn’t exist in the software-only version. Although Verite uses DMA to download surfaces, DMA does in fact steal performance from the CPU. This cost is increased by the requirement for 16-bpp surfaces, because twice as much data must be downloaded. Worse still, it takes about twice as long to build 16-bpp surfaces as 8-bpp surfaces, so the cost of missing the surface cache is well over twice as expensive in VQuake as in Quake. Fortunately, there’s 4 MB of memory on Verite-based adapters, so the surface cache doesn’t miss very often and VQuake runs fine (and looks very good, thanks to bilinear texture filtering, which by itself is pretty much worth the cost of 3-D hardware), but it’s nonetheless true that a completely straightforward port of the surface-caching model is not as appealing for hardware as for software. This is especially true at high resolutions, where the needs of the surface cache increase due to more detailed surfaces but available memory decreases due to frame buffer size.</p>
<p>Does my recent experience indicate that as the PC market moves to hardware, there’s no choice but to move to Gouraud shading, despite the quality issues? Not at all. First of all, surface caching does still work well, just not as relatively well compared to Gouraud shading as is the case in software. Second, there are at least two alternatives that preserve the advantages of surface caching without many of the disadvantages noted above.</p>
<section id="letting-the-graphics-card-build-the-textures" class="level4">
<h4><a href="#letting-the-graphics-card-build-the-textures">Letting the Graphics Card Build the Textures</a></h4>
<p>One obvious solution is to have the accelerator card build the textures, rather than having the CPU build and then download them. This eliminates downloading completely, and lets the accelerator, which should be faster at such things, do the texel manipulation. Whether this is actually faster depends on whether the CPU or the accelerator is doing more of the work overall, but it eliminates download time, which is a big help. This approach retains the ability to composite other effects, such as splatters and dents, onto surfaces, but by the same token retains the high memory requirements and dynamic lighting performance impact of the surface cache. It also requires that the 3-D API and accelerator being used allow drawing into a texture, which is not universally true. Neither do all APIs or accelerators allow applications enough control over the texture heap so that an efficient surface cache can be implemented, a point that favors non-caching approaches. (A similar option that wasn’t open to us due to time limitations is downloading 8-bpp surfaces and having the accelerator expand them to 16-bpp surfaces as it stores them in texture memory. Better yet, some accelerators support 8-bpp palettized hardware textures that are expanded to 16-bpp on the fly during texturing.)</p>
</section>
<section id="the-light-map-as-alpha-texture" class="level4">
<h4><a href="#the-light-map-as-alpha-texture">The Light Map as Alpha Texture</a></h4>
<p>Another appealing non-caching approach is doing unlit texture-mapping in one pass, then lighting from the light map as a second pass, using the light map as an alpha texture. In other words, the textured polygon is drawn first, with no lighting, then the light map is textured on top of the polygon, with the light map intensity used as an alpha value to determine how brightly to light each texel. The hardware’s texture-mapping circuitry is used for both passes, so the lighting comes out perspective-correct and consistent under all viewing conditions, just as with the surface cache. The lighting polygons don’t even have to match the texture polygons, so they can represent dynamically changing lighting.</p>
<p>Two-pass lighting not only looks good, but has no memory footprint other than texture and light map storage, and provides level performance, because it’s not dependent on surface cache hit rate. The primary downside to two-pass lighting is that it requires at least twice as much performance from the accelerator as single-pass drawing. The current crop of 3-D accelerators is not particularly fast, and few of them are up to the task of doing two passes at high resolution, although that will change soon. Another potential problem is that some accelerators don’t implement true alpha blending. Nonetheless, as accelerators get better, I expect two-pass drawing (or three-or-more-pass, for adding splatters and the like by overlaying sprite polygons) to be widely used. I also expect Gouraud shading to be widely used; it’s easy to use and fast. Also, speedier CPUs and accelerators will enable much more detailed geometry to be used, and the smaller that polygons become, the better Gouraud shading looks compared to surface caching and two-pass lighting.</p>
<p>The next graphics engine you’ll see from id Software will be oriented heavily toward hardware accelerators, and at this point it’s a tossup whether the engine will use surface caching, Gouraud shading, or two-pass lighting.</p>
</section>
</section>
<section id="drawing-triangle-models" class="level3">
<h3><a href="#drawing-triangle-models">Drawing Triangle Models</a></h3>
<p>Most of the last group of chapters in this book discuss how Quake works. If you look closely, though, you’ll see that almost all of the information is about drawing the world—the static walls, floors, ceilings, and such. There are several reasons for this, in particular that it’s hard to get a world renderer working well, and that the world is the base on which everything else is drawn. However, moving entities, such as monsters, are essential to a useful game engine. Traditionally, these have been done with sprites, but when we set out to build Quake, we knew that it was time to move on to polygon-based models. (In the case of Quake, the models are composed of triangles.) We didn’t know exactly how we were going to make the drawing of these models fast enough, though, and went through quite a bit of experimentation and learning in the process of doing so. For the rest of this chapter I’ll discuss some interesting aspects of our triangle-model architecture, and present code for one useful approach for the rapid drawing of triangle models.</p>
<section id="drawing-triangle-models-fast" class="level4">
<h4><a href="#drawing-triangle-models-fast">Drawing Triangle Models Fast</a></h4>
<p>We would have liked one rendering model, and hence one graphics pipeline, for all drawing in Quake; this would have simplified the code and tools, and would have made it much easier to focus our optimization efforts. However, when we tried adding polygon models to Quake’s global edge table, edge processing slowed down unacceptably. This isn’t that surprising, because the edge table was designed to handle 200 to 300 large polygons, not the 2,000 to 3,000 tiny triangles that a dozen triangle models in a scene can add. Restructuring the edge list to use trees rather than linked lists would have helped with the larger data sets, but the basic problem is that the edge table requires a considerable amount of overhead per edge per scan line, and triangle models have too few pixels per edge to justify that overhead. Also, the much larger edge table generated by adding triangle models doesn’t fit well in the CPU cache.</p>
<p>Consequently, we implemented a separate drawing pipeline for triangle models, as shown in Figure 69.1. Unlike the world pipeline, the triangle-model pipeline is in most respects a traditional one, with a few exceptions, noted below. The entire world is drawn first, and then the triangle models are drawn, using z-buffering for proper visibility. For each triangle model, all vertices are transformed and projected first, and then each triangle is drawn separately.</p>
<p>Triangle models are stored quite differently from the world itself. Each model consists of front and back skins stretched around a triangle mesh, and contains a full set of vertex coordinates for each animation frame, so animation is performed by simply using the correct set of coordinates for the desired frame. No interpolation, morphing, or other runtime vertex calculations are performed.</p>
<p>Early on, we decided to allow lower drawing quality for triangle models than for the world, in the interests of speed. For example, the triangles in the models are small, and usually distant—and generally part of a quickly moving monster that’s trying its best to do you in—so the quality benefits of perspective texture mapping would add little value. Consequently, we chose to draw the triangles with affine texture mapping, avoiding the work required for perspective. Mind you, the models are perspective-correct at the vertices; it’s just the pixels between the vertices that suffer slight warping.</p>
<figure>
<img src="images/69-01.jpg" alt="Figure 69.1  Quake’s triangle-model drawing pipeline." /><figcaption><strong>Figure 69.1</strong>  <em>Quake’s triangle-model drawing pipeline.</em></figcaption>
</figure>
</section>
<section id="trading-subpixel-precision-for-speed" class="level4">
<h4><a href="#trading-subpixel-precision-for-speed">Trading Subpixel Precision for Speed</a></h4>
<p>Another sacrifice at the altar of performance was subpixel precision. Before each triangle is drawn, we snap its vertices to the nearest integer screen coordinates, rather than doing the extra calculations to handle fractional vertex coordinates. This causes some jumping of triangle edges, but again, is not a problem in normal gameplay, especially for the animation of figures in continuous motion.</p>
<p>One interesting benefit of integer coordinates is that they let us do backface culling and rejection of degenerate triangles in one operation, because the cross-product z component used for backface culling returns zero for degenerate triangles. Conveniently, that cross-product component is also the denominator for the lighting and texture gradient calculations used in drawing each triangle, so as soon as we check the cross-product z value and determine that the triangle is drawable, we immediately start the FDIV to calculate the reciprocal. By the time we get around to calculating the gradients, the FDIV has completed execution, effectively taking only the one cycle required to issue it, because the integer execution pipes can process independently while FDIV executes.</p>
<p>Finally, we decided to Gouraud-shade the triangle models, because this makes them look considerably more 3-D. However, we can’t afford to calculate where all the relevant light sources for each model are in each frame, or even which is the primary light source. Instead, we select each model’s lighting level based on how brightly the floor point it was standing on is lit, and use that lighting level for both ambient lighting (so all parts of the model have some illumination) and Gouraud shading—but the lighting vector for Gouraud shading is a fixed vector, so the model is always lit from the same direction. Somewhat surprisingly, in practice this looks considerably better than pure ambient lighting.</p>
</section>
<section id="an-idea-that-didnt-work" class="level4">
<h4><a href="#an-idea-that-didnt-work">An Idea that Didn’t Work</a></h4>
<p>As we implemented triangle models, we tried several ideas that didn’t work out. One that’s notable because it seems so appealing is caching a model’s image from one frame and reusing it in the next frame as a sprite. Our thinking was that clipping, transforming, projecting, and drawing a several-hundred-triangle model was going to be a lot more expensive than drawing a sprite, too expensive to allow very many models to be visible at once. We wanted to be able to display at least a dozen simultaneous models, so the idea was that for all but the closest models, we’d draw into a sprite, then reuse that sprite at the model’s new locations for the next two or three frames, amortizing the 3-D drawing cost over several frames and boosting overall model-drawing performance. The rendering wouldn’t be exactly right when the sprite was reused, because the view of the model would change from frame to frame as the viewer and model moved, but it didn’t seem likely that that slight inaccuracy would be noticeable for any but the nearest and largest models.</p>
<p>As it turns out, though, we were wrong: The repeated frames were sometimes painfully visible, looking like jerky cardboard cutouts. In fact they looked a lot like the sprites used in DOOM—precisely the effect we were trying to avoid. This was especially true if we reused them more than once—and if we reused them only once, then we had to do one full 3-D rendering plus two sprite renderings every two frames, which wasn’t much faster than simply doing two 3-D renderings.</p>
<p>The sprite architecture also introduced considerable code complexity, increased memory footprint because of the need to cache the sprites, and made it difficult to get hidden surfaces exactly right because sprites are unavoidably 2-D. The performance of drawing the sprites dropped sharply as models got closer, and that’s also where the sprites looked worse when they were reused, limiting sprites to use at a considerable distance. All these problems could have been worked out reasonably well if necessary, but the sprite architecture just had the feeling of being fundamentally not the right approach, so we tried thinking along different lines.</p>
</section>
<section id="an-idea-that-did-work" class="level4">
<h4><a href="#an-idea-that-did-work">An Idea that Did Work</a></h4>
<p>John Carmack had the notion that it was just way too much effort per pixel to do all the work of scanning out the tiny triangles in distant models. After all, distant models are just indistinct blobs of pixels, suffering heavily from effects such as texture aliasing and pixel quantization, he reasoned, so it should work just as well if we could come up with another way of drawing blobs of approximately equal quality. The trick was to come up with such an alternative approach. We tossed around half-formed ideas like flood-filling the model’s image within its silhouette, or encoding the model as a set of deltas, picking a visible seed point, and working around the visible side of the model according to the deltas. The first approach that seemed practical enough to try was drawing the pixel at each vertex replicated to form a 2x2 box, with all the vertices together forming the approximate shape of the model. Sometimes this worked quite well, but there were gaps where the triangles were large, and the quality was very erratic. However, it did point the way to something that in the end did the trick.</p>
<p>One morning I came in to the office to find that overnight (and well into the morning), John had designed and implemented a technique I’ll call <em>subdivision rasterization</em>. This technique scans out approximately the right pixels for each triangle, with almost no overhead, as follows. First, all vertices in the model are drawn. Ideally, only the vertices on the visible side of the model would be drawn, but determining which vertices those are would take time, and the occasional error from a visible back vertex is lost in the noise.</p>
<p>Once the vertices are drawn, the triangles are processed one at a time. Each triangle that makes it through backface culling is then drawn with recursive subdivision. If any of the triangle’s sides is more than one pixel long in either x or y—that is, if the triangle contains any pixels that aren’t at vertices—then that side is split in half as nearly as possible at given integer coordinates, and a new vertex is created at the split, with texture and screen coordinates that are halfway between those of the vertices at the endpoints. (The same splitting could be done for lighting, but we found that for small triangles—the sort that subdivision works well on—it was adequate to flat-shade each triangle at the light level of the first vertex, so we didn’t bother with Gouraud shading.) The halfway values can be calculated very quickly with shifts. This vertex is drawn, and then each of the two resulting triangles is then processed recursively in the same way, as shown in Figure 69.2. There are some additional details, such as the fill rule that ensures that each pixel is drawn only once (except for backside vertices, as noted above), but basically subdivision rasterization boils down to taking a triangle, splitting a side that has at least one undrawn pixel and drawing the vertex at the split, and repeating the process for each of the two new triangles. The code to do this, shown in Listing 69.1, is very simple and easily optimized, especially by comparison with a generalized triangle rasterizer.</p>
<p>Subdivision rasterization introduces considerably more error than affine texture mapping, and doesn’t draw exactly the right triangle shape, but the difference is very hard to detect for triangles that contain only a few pixels. We found that the point at which the difference between the two rasterizers becomes noticeable was surprisingly close: 30 or 40 feet for the Ogres, and about 12 feet for the Zombies. This means that most of the triangle models that are visible in a typical Quake scene are drawn with subdivision rasterization, not affine texture mapping.</p>
<p>How much does subdivision rasterization help performance? When John originally implemented it, it more than doubled triangle-model drawing speed, because the affine texture mapper was not yet optimized. However, I took it upon myself to see how fast I could make the mapper, so now affine texture mapping is only about 20 percent slower than subdivision rasterization. While 20 percent may not sound impressive, it includes clipping, transform, projection, and backface-culling time, so the rasterization difference alone is more than 50 percent. Besides, 20 percent overall means that we can have 12 monsters now where we could only have had 10 before, so we count subdivision rasterization as a clear success.</p>
<p><strong>LISTING 69.1 L69-1.C</strong></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Quake&#39;s recursive subdivision triangle rasterizer; draws all</span>
<span class="co">// pixels in a triangle other than the vertices by splitting an</span>
<span class="co">// edge to form a new vertex, drawing the vertex, and recursively</span>
<span class="co">// processing each of the two new triangles formed by using the</span>
<span class="co">// new vertex. Results are less accurate than from a precise</span>
<span class="co">// affine or perspective texture mapper, and drawing boundaries</span>
<span class="co">// are not identical to those of a precise polygon drawer, although</span>
<span class="co">// they are consistent between adjacent polygons drawn with this</span>
<span class="co">// technique.</span>
<span class="co">//</span>
<span class="co">// Invented and implemented by John Carmack of id Software.</span>

<span class="dt">void</span> D_PolysetRecursiveTriangle (<span class="dt">int</span> *lp1, <span class="dt">int</span> *lp2, <span class="dt">int</span> *lp3)
{
<span class="dt">int</span>    *temp;
<span class="dt">int</span>    d;

<span class="dt">int</span>    new[<span class="dv">6</span>];
<span class="dt">int</span>    z;
<span class="dt">short</span>  *zbuf;

<span class="co">// try to find an edge that&#39;s more than one pixel long in x or y</span>
d = lp2[<span class="dv">0</span>] - lp1[<span class="dv">0</span>];
<span class="kw">if</span> (d &lt; -<span class="dv">1</span> || d &gt; <span class="dv">1</span>)
<span class="kw">goto</span> split;
d = lp2[<span class="dv">1</span>] - lp1[<span class="dv">1</span>];
<span class="kw">if</span> (d &lt; -<span class="dv">1</span> || d &gt; <span class="dv">1</span>)
<span class="kw">goto</span> split;
d = lp3[<span class="dv">0</span>] - lp2[<span class="dv">0</span>];
<span class="kw">if</span> (d &lt; -<span class="dv">1</span> || d &gt; <span class="dv">1</span>)
<span class="kw">goto</span> split2;
d = lp3[<span class="dv">1</span>] - lp2[<span class="dv">1</span>];
<span class="kw">if</span> (d &lt; -<span class="dv">1</span> || d &gt; <span class="dv">1</span>)
<span class="kw">goto</span> split2;
d = lp1[<span class="dv">0</span>] - lp3[<span class="dv">0</span>];
<span class="kw">if</span> (d &lt; -<span class="dv">1</span> || d &gt; <span class="dv">1</span>)
<span class="kw">goto</span> split3;
d = lp1[<span class="dv">1</span>] - lp3[<span class="dv">1</span>];
<span class="kw">if</span> (d &lt; -<span class="dv">1</span> || d &gt; <span class="dv">1</span>)
{
split3:
<span class="co">// shuffle points so first edge is edge to split</span>
temp = lp1;
lp1 = lp3;
lp3 = lp2;
lp2 = temp;
<span class="kw">goto</span> split;
}

<span class="kw">return</span>;         <span class="co">// no pixels left to fill in triangle</span>

split2:
<span class="co">// shuffle points so first edge is edge to split</span>
temp = lp1;
lp1 = lp2;
lp2 = lp3;
lp3 = temp;

split:
<span class="co">// split first edge screen x, screen y, texture s, texture t, and z</span>
<span class="co">// to form a new vertex.  Lighting (index 4) is ignored; the</span>
<span class="co">// difference between interpolating lighting and using the same</span>
<span class="co">// shading for the entire triangle is unnoticeable for small</span>
<span class="co">// triangles, so we just use the lighting for the first vertex of</span>
<span class="co">// the original triangle (which was used during set-up to set</span>
<span class="co">// d_colormap, used below to look up lit texels)</span>
new[<span class="dv">0</span>] = (lp1[<span class="dv">0</span>] + lp2[<span class="dv">0</span>]) &gt;&gt; <span class="dv">1</span>;        <span class="co">// split screen x</span>
new[<span class="dv">1</span>] = (lp1[<span class="dv">1</span>] + lp2[<span class="dv">1</span>]) &gt;&gt; <span class="dv">1</span>;        <span class="co">// split screen y</span>
new[<span class="dv">2</span>] = (lp1[<span class="dv">2</span>] + lp2[<span class="dv">2</span>]) &gt;&gt; <span class="dv">1</span>;        <span class="co">// split texture s</span>
new[<span class="dv">3</span>] = (lp1[<span class="dv">3</span>] + lp2[<span class="dv">3</span>]) &gt;&gt; <span class="dv">1</span>;        <span class="co">// split texture t</span>
new[<span class="dv">5</span>] = (lp1[<span class="dv">5</span>] + lp2[<span class="dv">5</span>]) &gt;&gt; <span class="dv">1</span>;        <span class="co">// split z</span>

<span class="co">// draw the point if splitting a leading edge</span>
<span class="kw">if</span> (lp2[<span class="dv">1</span>] &gt; lp1[<span class="dv">1</span>])
<span class="kw">goto</span> nodraw;
<span class="kw">if</span> ((lp2[<span class="dv">1</span>] == lp1[<span class="dv">1</span>]) &amp;&amp; (lp2[<span class="dv">0</span>] &lt; lp1[<span class="dv">0</span>]))
<span class="kw">goto</span> nodraw;


z = new[<span class="dv">5</span>]&gt;&gt;<span class="dv">16</span>;

<span class="co">// point to the pixel&#39;s z-buffer entry, looking up the scanline start</span>
<span class="co">// address based on screen y and adding in the screen x coordinate</span>
zbuf = zspantable[new[<span class="dv">1</span>]] + new[<span class="dv">0</span>];

<span class="co">// draw the split vertex if it&#39;s not obscured by something nearer, as</span>
<span class="co">// indicated by the z-buffer</span>
<span class="kw">if</span> (z &gt;= *zbuf)
{
<span class="dt">int</span>     pix;

<span class="co">// set the z-buffer to the new pixel&#39;s distance</span>
*zbuf = z;

<span class="co">// get the texel from the model&#39;s skin bitmap, according to</span>
<span class="co">// the s and t texture coordinates, and translate it through</span>
<span class="co">// the lighting look-up table set according to the first</span>
<span class="co">// vertex for the original (top-level) triangle.  Both s and</span>
<span class="co">// t are in 16.16 format</span>
pix = d_pcolormap[skintable[new[<span class="dv">3</span>]&gt;&gt;<span class="dv">16</span>][new[<span class="dv">2</span>]&gt;&gt;<span class="dv">16</span>]];

<span class="co">// draw the pixel, looking up the scanline start address</span>
<span class="co">// based on screen y and adding in the screen x coordinate</span>
d_viewbuffer[d_scantable[new[<span class="dv">1</span>]] + new[<span class="dv">0</span>]] = pix;
}

nodraw:
<span class="co">// recursively draw the two new triangles we created by adding the</span>
<span class="co">// split vertex</span>
D_PolysetRecursiveTriangle (lp3, lp1, new);
D_PolysetRecursiveTriangle (lp3, new, lp2);
}</code></pre>
<figure>
<img src="images/69-02.jpg" alt="Figure 69.2  One recursive subdivision triangle-drawing step." /><figcaption><strong>Figure 69.2</strong>  <em>One recursive subdivision triangle-drawing step.</em></figcaption>
</figure>
</section>
<section id="more-ideas-that-might-work" class="level4">
<h4><a href="#more-ideas-that-might-work">More Ideas that Might Work</a></h4>
<p>Useful as subdivision rasterization proved to be, we by no means think that we’ve maxed out triangle-model drawing, if only because we spent far less design and development time on subdivision than on the affine rasterizer, so it’s likely that there’s quite a bit more performance to be found for drawing small triangles. For example, it could be faster to precalculate drawing masks or even precompile drawing code for all possible small triangles (say, up to 4x4 or 5x5), and the memory footprint looks reasonable. (It’s worth noting that both precalculated drawing and subdivision rasterization are only possible because we snap to integer coordinates; none of this stuff works with fixed-point vertices.)</p>
<p>More interesting still is the stack-based rendering described in the article “Time/Space Tradeoffs for Polygon Mesh Rendering,” by Bar-Yehuda and Gotsman, in the April, 1996 <em>ACM Transactions on Graphics</em>. Unfortunately, the article is highly abstract and slow going, but the bottom line is that it’s possible to represent a triangle mesh as a stream of commands that place vertices in a stack, remove them from the stack, and draw triangles using the vertices in the stack. This results in excellent CPU cache coherency, because rather than indirecting all over a vertex pool to retrieve vertex data, all vertices reside in a tiny stack that’s guaranteed to be in the cache. Local variables used while drawing can be stored in a small block next to the stack, and the stream of commands representing the model is accessed sequentially from start to finish, so cache utilization should be very high. As processors speed up at a much faster rate than main memory access, cache optimizations of this sort will become steadily more important in improving drawing performance.</p>
<p>As with so many aspects of 3-D, there is no one best approach to drawing triangle models, and no such thing as the fastest code. In a way, that’s frustrating, but the truth is, it’s these nearly infinite possibilities that make 3-D so interesting; not only is it an endless, varied challenge, but there’s almost always a better solution waiting to be found.</p>
</section>
</section>
</section>
<section id="chapter-70-quake-a-post-mortem-and-a-glimpse-into-the-future" class="level2">
<h2><a href="#chapter-70-quake-a-post-mortem-and-a-glimpse-into-the-future">Chapter 70 – Quake: A Post-Mortem and a Glimpse into the Future</a></h2>
<p><em>Why did not any of the children in the first group think of this faster method of going across the room? It is simple. They looked at what they were given to use for materials and, they are like all of us, they wanted to use everything. But they did not need everything. They could do better with less, in a different way.</em></p>
<p>—<em>Frederik Pohl</em>, The Gold at the Starbow’s End</p>
<p>Eleven years ago, I started the first serious graphics article I ever wrote with the above quote. The point I was making at the time was that programming assumptions based on high-level languages or other processors had to be discarded in the quest for maximum x86 performance. While that’s certainly still true, time and the microcomputer world have moved on, and today there’s a more important lesson 3-D game programmers can draw from Frederik Pohl’s words. Nowadays, CPUs, 3-D hardware, 3-D algorithms, and 3-D data structures are evolving so rapidly that the enemy is now often the assumptions and techniques from the last product—and sometimes the assumptions and techniques in the <em>current</em> product. We all feel most comfortable with techniques we’ve already mastered, but leading-edge 3-D game technology is such a delicate balancing act between performance, features (particularly with game designers always wanting to add more), and workflow (as we’ll see, preprocessing that improves performance often hurts designer productivity) that it’s never safe to stop looking for a better approach until the game has actually shipped. Change is the rule, and we must always be looking to “do better with less, in a different way.”</p>
<p>I’ve talked about Quake’s technology elsewhere in this book, However, those chapters focused on specific areas, not overall structure. Moreover, Quake changed in significant ways between the writing of those chapters and the final shipping. Then, after shipping, Quake was ported to 3-D hardware. And the post-Quake engine, code-named Trinity, is already in development at this writing (Spring 1997), with some promising results. So in wrapping up this book, I’ll recap Quake’s overall structure relatively quickly, then bring you up to date on the latest developments. And in the spirit of Frederik Pohl’s quote, I’ll point out that we implemented and discarded at least half a dozen 3-D engines in the course of developing Quake (and all of Quake’s code was written from scratch, rather than using Doom code), and almost switched to another one in the final month, as I’ll describe later. And even at this early stage, Trinity uses almost no Quake technology.</p>
<p>In fact, I’ll take this opportunity to coin Carmack’s Law, as follows: <em>Fight code entropy</em>. If you have a new fundamental assumption, throw away your old code and rewrite it from scratch. Incremental patching and modifying seems easier at first, and is the normal course of things in software development, but ends up being much harder and producing bulkier, markedly inferior code in the long run, as we’ll see when we discuss the net code for QuakeWorld. It may seem safer to modify working code, but the nastiest bugs arise from unexpected side effects and incorrect assumptions, which almost always arise in patched-over code, not in code designed from the ground up. Do the hard work up front to make your code simple, elegant, great—and just plain <em>right</em>—and it’ll pay off many times over in the long run.</p>
<p>Before I begin, I’d like to remind you that all of the Doom and Quake material I’m presenting in this book is presented in the spirit of sharing information to make our corner of the world a better place for everyone. I’d like to thank John Carmack, Quake’s architect and lead programmer, and id Software for allowing me to share this technology with you, and I encourage you to share your own insights by posting on the Internet and writing books and articles whenever you have the opportunity and the right to do so. (Of course, check with your employer first!) We’ve all benefited greatly from the shared wisdom of people like Knuth, Foley and van Dam, Jim Blinn, Jim Kajiya, and hundreds of others—are you ready to take a shot at making your own contribution to the future?</p>
<section id="preprocessing-the-world" class="level3">
<h3><a href="#preprocessing-the-world">Preprocessing the World</a></h3>
<p>For the most part, I’ll discuss Quake’s 3-D engine in this chapter, although I’ll touch on other areas of interest. For 3-D rendering purposes, Quake consists of two basic sorts of objects: the world, which is stored as a single BSP model and never changes shape or position; and potentially moving objects, called <em>entities</em>, which are drawn in several different ways. I’ll discuss each separately.</p>
<p>The world is constructed from a set of brushes, which are n-sided convex polyhedra placed in a level by a designer using a map editor, with a selectable texture on each face. When a level is completed, a preprocessing program combines all brushes to form a skin around the solid areas of the world, so there is no interpenetration of polygons, just a continuous mesh delineating solid and empty areas. Once this is done, the next step is generating a BSP tree for the level.</p>
<p>The BSP consists of splitting planes aligned with polygons, called nodes, and of leaves, which are the convex subspaces into which all the nodes carve space. The top node carves the world into two subspaces, and divides the remaining polygons into two sets, splitting any polygon that spans the node into two pieces. Each subspace is then similarly split by one node each, and so on until all polygons have been used to create nodes. A node’s subspace is the total space occupied by all its children: the subspace that the node splits into two parts, and that its children continue to subdivide. When the only polygon in a node’s subspace is the polygon that splits the subspace—the polygon whose plane defines the node—then the two child subspaces are called leaves, and are not divided any further.</p>
<p>The BSP tree is built using the polygon that splits the fewest of the polygons in the current node’s subspace as the heuristic for choosing splitters, which is not an optimal solution—but an optimal solution is NP-complete, and our heuristic adds only 10% to 15% more polygons to the level as a result of BSP splits. Polygons are not split all the way into leaves; rather, they are placed on the nodes with which they are coplanar (one set on the front and one on the back, which has the advantage of letting us reuse the BSP-walking dot product for backface culling as well), thereby reducing splitting considerably, because polygons are split only by parent nodes, not by child nodes (as would be necessary if polygons were split into leaves). Eliminating polygon splits, thus reducing the total number of polygons per level, not only shrinks Quake’s memory footprint, but also reduces the number of polygons that need to be processed by the 3-D pipeline, producing a speedup of about 10% in Quake’s overall performance.</p>
<p>Getting proper front-to-back drawing order is a little more complicated with polygons on nodes. As we walk the BSP tree front-to-back, in each leaf we mark the polygons that are at least partially in that leaf, and then after we’ve recursed and processed everything in front of a node, we then process all the marked polygons on that node, after which we recurse to process the polygons behind the node. So putting the polygons on the nodes saves memory and improves performance significantly, but loses the simple approach of simply recursing the tree and processing the polygons in each leaf as we come to it, in favor of recursing and marking in front of a node, processing marked polygons on the node, then recursing behind the node.</p>
<p>After the BSP is built, the outer surfaces of the level, which no one can ever see (because levels are sealed spaces), are removed, so the interior of the level, containing all the empty space through which a player can move, is completely surrounded by a solid region. This eliminates a great many irrelevant polygons, and reduces the complexity of the next step, calculating the potentially visible set.</p>
</section>
<section id="the-potentially-visible-set-pvs" class="level3">
<h3><a href="#the-potentially-visible-set-pvs">The Potentially Visible Set (PVS)</a></h3>
<p>After the BSP tree is built, the potentially visible set (PVS) for each leaf is calculated. The PVS for a leaf consists of all the leaves that can be seen from anywhere in that leaf, and is used to reduce to a near-minimum the polygons that have to be considered for drawing from a given viewpoint, as well as the entities that have to be updated over the network (for multiplayer games) and drawn. Calculating the PVS is expensive; Quake levels take 10 to 30 minutes to process on a four-processor Alpha, and even with speedup tweaks to the BSPer (the most effective of which was replacing many calls to <code>malloc()</code> with stack-based structures—beware of <code>malloc()</code> in performance-sensitive code), Quake 2 levels are taking up to an hour to process. (Note, however, that that includes BSPing, PVS calculations, and radiosity lighting, which I’ll discuss later.)</p>
<p>Some good news, though, is that in the nearly two years since we got the Alpha, Pentium Pros have become as fast as that generation of Alphas, so it is now possible to calculate the PVS on an affordable machine. On the other hand, even 10 minutes of BSPing does hurt designer productivity. John has always been a big advocate of moving code out of the runtime program into utilities, and of preprocessing for performance and runtime simplicity, but even he thinks that in Quake, we may have pushed that to the point where it interfered too much with workflow. The real problem, of course, is that even a huge amount of money can’t buy orders of magnitude more performance than commodity computers; we are getting an eight-R10000 SGI compute server, but that’s only about twice as fast as an off-the-shelf four-processor Pentium Pro.</p>
<p>The size of the PVS for each leaf is manageable because it is stored as a bit vector, with a 1-bit for the position in the overall leaf array of each leaf that’s visible from the current leaf. Most leaves are invisible from any one leaf, so the PVS for each leaf consists mostly of zeros, and compacts nicely with run-length encoding.</p>
<p>There are two further interesting points about the PVS. First, the Quake PVS does not exclude quite as many leaves from potential visibility as it could, because the surfaces that precisely describe leaf-to-leaf visibility are quadratic surfaces; in the interests of speed and simplicity, planar surfaces with some slope are used instead. Second, the PVS describes visibility from anywhere in a leaf, rather than from a specific viewpoint; this can cause two or three times as many polygons as are actually visible to be considered. John has been researching the possibility of an EVS—an <em>exactly visible set</em>—and has concluded that a 6-D BSP with hyperbolic separating planes could do the job; the problem now is that he doesn’t know how to get the math to work, at least at any reasonable speed.</p>
<p>An interesting extension of the PVS is what John calls the <em>potentially hearable set</em> (PHS)—all the leaves visible from a given leaf, plus all the leaves visible from <em>those</em> leaves—in other words, both the directly visible leaves and the one-bounce visible leaves. Of course, this is not exactly the hearable space, because sounds could echo or carry further than that, but it does serve quite nicely as a potentially <em>relevant</em> space—the set of leaves that have any interest to the player. In Quake, all sounds that happen anywhere in the world are sent to the client, and are heard, even through walls, if they’re close enough; an explosion around the corner could be well within hearing and very important to hear, so the PVS can’t be used to reject that sound, but unfortunately an explosion on the other side of a solid wall will sound exactly the same. Not only is it confusing hearing sounds through walls, but in a modem game, the bandwidth required to send all the sounds in a level can slow things down considerably. In a recent version of QuakeWorld, a specifically multiplayer variant of Quake I’ll discuss later, John uses the PHS to determine which sounds to bother sending, and the resulting bandwidth improvement has made it possible to bump the maximum number of players from 16 to 32. Better yet, a sound on the other side of a solid wall won’t be heard unless there’s an opening that permits the sound to come through. (In the future, John will use the PVS to determine fully audible sounds, and the PHS to determine muted sounds.) Also, the PHS can be used for events like explosions that might not have their center in the PVS, but have portions that reach into the PVS. In general, the PHS is useful as an approximation of the space in which the client might need to be notified of events.</p>
<p>The final preprocessing step is light map generation. Each light is traced out into the world to see what polygons it strikes, and the cumulative effect of all lights on each surface is stored as a light map, a sampling of light values on a 16-texel grid. In Quake 2, radiosity lighting—a considerably more expensive process, but one that produces highly realistic lighting—is performed, but I’ll save that for later.</p>
</section>
<section id="passages-the-last-minute-change-that-didnt-happen" class="level3">
<h3><a href="#passages-the-last-minute-change-that-didnt-happen">Passages: The Last-Minute Change that Didn’t Happen</a></h3>
<p>Earlier, I mentioned that we almost changed 3-D engines again in the last month of Quake’s development. Here’s what happened: One of the alternatives to the PVS is the use of <em>portals</em>, where the focus is on the places where polygons don’t exist along leaf faces, rather than the more usual focus on the polygons themselves. These “empty” places are themselves polygons, called portals, that describe all the places that visibility can pass from one leaf to another. Portals are used by the PVS generator to determine visibility, and are used in other 3-D engines as the primary mechanism for determining leaf or sector visibility. For example, portals can be projected to screenspace, then used as a 2-D clipping region to restrict drawing of more distant polygons to only those that are visible through the portal. Or, as in Quake’s preprocessor, visibility boundary planes can be constructed from one portal to the next, and 3-D clipping to those planes can be used to determine visible polygons or leaves. Used either way, portals can support more changeable worlds than the PVS, because, unlike the PVS, the portals themselves can easily be changed on the fly.</p>
<p>The problem with portal-based visibility is that it tends to perform at its worst in complex scenes, which can have many, many portals. Since those are the most expensive scenes to draw, as well, portals tend to worsen the worst case. However, late in Quake’s development, John realized that the approach of storing portals themselves in the world database could readily be improved upon. (To be clear, Quake wasn’t using portals at that point, and didn’t end up using them.) Since the aforementioned sets of 3-D visibility clipping planes <em>between</em> portals—which he named <em>passages</em>—were what actually got used for visibility, if he stored those, instead of generating them dynamically from the portals, he would be able to do visibility much faster than with standard portals. This would give a significantly tighter polygon set than the PVS, because it would be based on visibility through the passages from the viewpoint, rather than the PVS’s approach of visibility from anywhere in the leaf, and that would be a considerable help, because the level designers were running right up against performance limits, partly because of the PVS’s relatively loose polygon set. John immediately decided that passages-based visibility was a sufficiently superior approach that if it worked out, he would switch Quake to it, even at that late stage, and within a weekend, he had implemented it and had it working—only to find that, like portals, it improved best cases but worsened worst cases, and overall wasn’t a win for Quake. In truth, given how close we were to shipping, John was as much thankful as disappointed that passages didn’t work out, but the possibilities were too great for us not to have taken a shot at it.</p>
<p>So why even bother mentioning this? Partly to show that not every interesting idea pans out; I tend to discuss those that <em>did</em> pan out, and it’s instructive to point out that many ideas don’t. That doesn’t mean you shouldn’t try promising ideas, though. First, some do pan out, and you’ll never know which unless you try. Second, an idea that doesn’t work out in one case can still be filed away for another case. It’s quite likely that passages will be useful in a different context in a future engine.</p>
<p>The more approaches you try, the larger your toolkit and the broader your understanding will be when you tackle your next project.</p>
</section>
<section id="drawing-the-world" class="level3">
<h3><a href="#drawing-the-world">Drawing the World</a></h3>
<p>Everything described so far is a preprocessing step. When Quake is actually running, the world is drawn as follows: First, the PVS for the view leaf is decompressed, and each leaf flagged as visible is marked as being in the current frame’s PVS. (The marking is done by storing the current frame’s number in the leaf; this avoids having to clear the PVS marking each frame.) All the parent nodes of each leaf in the PVS are also marked; this information could have been stored as additional PVS flags, but to save space is bubbled up the BSP from each visible leaf.</p>
<p>After the PVS is marked, the BSP is walked front-to-back. At each node, the bounding box of the node’s subspace is clipped against the view frustum; if the bounding box is fully clipped, then that node and all its children are ignored. Likewise, if the node is not in the PVS for the current viewpoint leaf, the node and all its children are ignored. If the bounding box is partially clipped or not clipped at all, that information is passed to the children so that any unnecessary clip tests can be avoided. The children in front of the node are then processed recursively. When a leaf is reached, polygons that touch that leaf are marked as potentially drawable. When recursion in front of a node is finished, all polygons on the front side of the node that are marked as potentially drawable are added to the edge list, and then the children on the back side of that node are similarly processed recursively.</p>
<p>The edge list is a special, intermediate step between polygons and drawing. Each polygon is clipped, transformed, and projected, and its non-horizontal edges are added to a global list of potentially drawable edges. After all the potentially drawable edges in the world have been added, the global edge list is scanned out all at once, and all the visible spans (the nearest spans, as determined by sorting on BSP-walk order) in the world are emitted into span lists linked off the respective surface descriptors (for now, you can think of a surface as being the same as a polygon). Taken together, these spans cover every pixel on the screen once and only once, resulting in zero overdraw; surfaces that are completely hidden by nearer surfaces generate no spans at all. The spans are then drawn; all the spans for one surface are drawn, and then all the spans for the next, so that there’s texture coherency between spans, which is very helpful for processor cache coherency, and also to reduce setup overhead.</p>
<p>The primary purpose of the edge list is to make Quake’s performance as level—that is, as consistent—as possible. Compared to simply drawing all potentially drawable polygons front-to-back, the edge list certainly slows down the best case, that is, when there’s no overdraw. However, by eliminating overdraw, the worst case is helped considerably; in Quake, there’s a ratio of perhaps 4:1 between worst and best case drawing time, versus the 10:1 or more that can happen with straight polygon drawing. Leveling is very important, because cases where a game slows down to the point of being unplayable dictate game and level design, and the fewer constraints placed on design, the better.</p>
<blockquote>
<p><img src="images/i.jpg" /> A corollary is that best case performance can be seductively misleading; it’s a great feeling to see a scene running at 30 or even 60 frames per second, but if the bulk of the game runs at 15 fps, those best cases are just going to make the rest of the game look worse.</p>
</blockquote>
<p>The edge list is an atypical technology for John; it’s an extra stage in the engine, it’s complex, and it doesn’t scale well. A Quake level might have a maximum of 500 potentially drawable polygons that get placed into the edge list, and that runs fine, but if you were to try to put 5,000 polygons into the edge list, it would quickly bog down due to edge sorting, link following, and dataset size. Different data structures (like using a tree to store the edges rather than a linear linked list) would help to some degree, but basically the edge list has a relatively small window of applicability; it was appropriate technology for the degree of complexity possible in a Pentium-based game (and even then, only with the reduction in polygons made possible by the PVS), but will probably be poorly suited to more complex scenes. It served well in the Quake engine, but remains an inelegant solution, and, in the end, it feels like there’s something better we didn’t hit on. However, as John says, “I’m pragmatic above all else”—and the edge list did the job.</p>
</section>
<section id="rasterization" class="level3">
<h3><a href="#rasterization">Rasterization</a></h3>
<p>Once the visible spans are scanned out of the edge list, they must still be drawn, with perspective-correct texture mapping and lighting. This involves hundreds of lines of heavily optimized assembly language, but is fundamentally pretty simple. In order to draw the spans for a given surface, the screenspace equations for 1/z, s/z, and t/z (where s and t are the texture coordinates and z is distance) are calculated for the surface. Then for each span, these values are calculated for the points at each end of the span, the reciprocal of 1/z is calculated with a divide, and s and t are then calculated as (s/z)*z and (t/z)*z. If the span is longer than 16 pixels, s and t are likewise calculated every 16 pixels along the span. Then each stretch of up to 16 pixels is drawn by linearly interpolating between these correctly calculated points. This introduces some slight error, but this is almost never visible, and even then is only a small ripple, well worth the performance improvement gained by doing the perspective-correct math only once every 16 pixels. To speed things up a little more, the FDIV to calculate the reciprocal of 1/z is overlapped with drawing 16 pixels, taking advantage of the Pentium’s ability to perform floating-point in parallel with integer instructions, so the FDIV effectively takes only one cycle.</p>
<section id="lighting" class="level4">
<h4><a href="#lighting">Lighting</a></h4>
<p>Lighting is less simple to explain. The traditional way of doing polygon lighting is to calculate the correct light at the vertices and linearly interpolate between those points (Gouraud shading), but this has several disadvantages; in particular, it makes it hard to get detailed lighting without creating a lot of extra polygons, the lighting isn’t perspective correct, and the lighting varies with viewing angle for polygons other than triangles. To address these problems, Quake uses surface-based lighting instead. In this approach, when it’s time to draw a surface (a world polygon), that polygon’s texture is tiled into a memory buffer. At the same time, the texture is lit according to the surface’s light map, as calculated during preprocessing. Lighting values are linearly interpolated between the light map’s 16-texel grid points, so the lighting effects are smooth, but slightly blurry. Then, the polygon is drawn to the screen using the perspective-correct texture mapping described above, with the prelit surface buffer being the source texture, rather than the original texture tile. No additional lighting is performed during texture mapping; all lighting is done when the surface buffer is created.</p>
<p>Certainly it takes longer to build a surface buffer and then texture map from it than it does to do lighting and texture mapping in a single pass. However, surface buffers are cached for reuse, so only the texture mapping stage is usually needed. Quake surfaces tend to be big, so texture mapping is slowed by cache misses; however, the Quake approach doesn’t need to interpolate lighting on a pixel-by-pixel basis, which helps speed things up, and it doesn’t require additional polygons to provide sophisticated lighting. On balance, the performance of surface-based drawing is roughly comparable to tiled, Gouraud-shaded texture mapping—and it looks much better, being perspective correct, rotationally invariant, and highly detailed. Surface-based drawing also has the potential to support some interesting effects, because anything that can be drawn into the surface buffer can be cached as well, and is automatically drawn in correct perspective. For instance, paint splattered on a wall could be handled by drawing the splatter image as a sprite into the appropriate surface buffer, so that drawing the surface would draw the splatter as well.</p>
</section>
<section id="dynamic-lighting" class="level4">
<h4><a href="#dynamic-lighting">Dynamic Lighting</a></h4>
<p>Here we come to a feature added to Quake after last year’s Computer Game Developer’s Conference (CGDC). At that time, Quake did not support dynamic lighting; that is, explosions and such didn’t produce temporary lighting effects. We hadn’t thought dynamic lighting would add enough to the game to be worth the trouble; however, at CGDC Billy Zelsnack showed us a demo of his latest 3-D engine, which was far from finished at the time, but did have impressive dynamic lighting effects. This caused us to move dynamic lighting up the priority list, and when I got back to id, I spent several days making the surface-building code as fast as possible (winding up at 2.25 cycles per texel in the inner loop) in anticipation of adding dynamic lighting, which would of course cause dynamically lit surfaces to constantly be rebuilt as the lighting changed. (A significant drawback of dynamic lighting is that it makes surface caching worthless for dynamically lit surfaces, but if most of the surfaces in a scene are not dynamically lit at any one time, it works out fine.) There things stayed for several weeks, while more critical work was done, and it was uncertain whether dynamic lighting would, in fact, make it into Quake.</p>
<p>Then, one Saturday, John suggested that I take a shot at adding the high-level dynamic lighting code, the code that would take the dynamic light sources and project their sphere of illumination into the world, and which would then add the dynamic contributions into the appropriate light maps and rebuild the affected surfaces. I said I would as soon as I finished up the stuff I was working on, but it might be a day or two. A little while later, he said, “I bet I can get dynamic lighting working in less than an hour,” and dove into the code. One hour and nine minutes later, we had dynamic lighting, and it’s now hard to imagine Quake without it. (It sure is easier to imagine the impact of features and implement them once you’ve seen them done by someone else!)</p>
<p>One interesting point about Quake’s dynamic lighting is how inaccurate it is. It is basically a linear projection, accounting properly for neither surface angle nor lighting falloff with distance—and yet that’s almost impossible to notice unless you specifically look for it, and has no negative impact on gameplay whatsoever. Motion and fast action can surely cover for a multitude of graphics sins.</p>
<p>It’s well worth pointing out that because Quake’s lighting is perspective correct and independent of vertices, and because the rasterizer is both subpixel and subtexel correct, Quake worlds are visually very solid and stable. This was an important design goal from the start, both as a point of technical pride and because it greatly improves the player’s sense of immersion.</p>
</section>
</section>
<section id="entities" class="level3">
<h3><a href="#entities">Entities</a></h3>
<p>So far, all we’ve drawn is the static, unchanging (apart from dynamic lighting) world. That’s an important foundation, but it’s certainly not a game; now we need to add moving objects. These objects fall into four very different categories: BSP models, polygon models, sprites, and particles.</p>
<section id="bsp-models" class="level4">
<h4><a href="#bsp-models">BSP Models</a></h4>
<p>BSP models are just like the world, except that they can move. Examples include doors, moving bridges, and health and ammo boxes. The way these are rendered is by clipping their polygons into the world BSP tree, so each polygon fragment is in only one leaf. Then these fragments are added to the edge list, just like world polygons, and scanned out, along with the rest of the world, when the edge list is processed. The only trick here is front-to-back ordering. Each BSP model polygon fragment is given the BSP sorting order of the leaf in which it resides, allowing it to sort properly versus the world polygons. If two or more polygons from different BSP models are in the same leaf, however, BSP ordering is no longer useful, so we then sort those polygons by 1/z, calculated from the polygons’ plane equations.</p>
<p>Interesting note: We originally tried to sort all world polygons on 1/z as well, the reason being that we could then avoid splitting polygons except when they actually intersected, rather than having to split them along the lines of parent nodes. This would result in fewer edges, and faster edge list processing and rasterization. Unfortunately, we found that precision errors and special cases such as seamlessly abutting objects made it difficult to get global 1/z sorting to work completely reliably, and the code that we had to add to work around these problems slowed things up to the point where we were getting no extra performance for all the extra code complexity. This is not to say that 1/z sorting can’t work (especially in something like a flight sim, where objects never abut), but BSP sorting order can be a wonderful thing, partly because it always works perfectly, and partly because it’s simpler and faster to sort on integer node and leaf orders than on floating-point 1/z values.</p>
<p>BSP models take some extra time because of the cost of clipping them into the world BSP tree, but render just as fast as the rest of the world, again with no overdraw, so closed doors, for example, block drawing of whatever’s on the other side (although it’s still necessary to transform, project, and add to the edge list the polygons the door occludes, because they’re still in the PVS—they’re potentially visible if the door opens). This makes BSP models most suitable for fairly simple structures, such as boxes, which have relatively few polygons to clip, and cause relatively few edges to be added to the edge list.</p>
</section>
<section id="polygon-models-and-z-buffering" class="level4">
<h4><a href="#polygon-models-and-z-buffering">Polygon Models and Z-Buffering</a></h4>
<p>Polygon models, such as monsters, weapons, and projectiles, consist of a triangle mesh with front and back skins stretched over the model. For speed, the triangles are drawn with affine texture mapping; the triangles are small enough, and the models are generally distant enough, that affine distortion isn’t visible. (However, it is visible on the player’s weapon; this caused a lot of extra work for the artists, and we will probably implement a perspective-correct polygon-model rasterizer in Quake 2 for this specific purpose.) The triangles are also Gouraud shaded; interestingly, the light vector used to shade the models is always from the same direction, and has no relation to any actual lights in the world (although it does vary in intensity, along with the model’s ambient lighting, to match the brightness of the spot the player is standing above in the world). Even this highly inaccurate lighting works well, though; the Gouraud shading makes models look much more three-dimensional, and varying the lighting in even so crude a way allows hiding in shadows and illumination by explosions and muzzle flashes.</p>
<p>One issue with polygon models was how to handle occlusion issues; that is, what parts of models were visible, and what surfaces they were in front of. We couldn’t add models to the edge list, because the hundreds of polygons per model would overwhelm the edge list. Our initial occlusion solution was to sort polygon-model polygons into the world BSP, drawing the portions in each leaf at the right points as we drew the world in BSP order. That worked reasonably well with respect to the world (not perfectly, though, because it would have been too expensive to clip all the polygon-model polygons into the world, so there was some occlusion error), but didn’t handle the case of sorting polygon models in the same leaf against each other, and also didn’t help the polygons in a given polygon model sort properly against each other.</p>
<p>The solution to this turned out to be z-buffering. After all the spans in the world are drawn, the z-buffer is filled in for those spans. This is a write-only operation, and involves no comparisons or overdraw (remember, the spans cover every pixel on the screen exactly once), so it’s not that expensive—the performance cost is about 10%. Then polygon models are drawn with z-buffering; this involves a z-compare at each polygon-model pixel, but no complicated clipping or sorting—and occlusion is exactly right in all respects. Polygon models tend to occupy a small portion of the screen, so the cost of z-buffering is not that high, anyway.</p>
<p>Opinions vary as to the desirability of z-buffers; some people who favor more analytical approaches to hidden surface removal claim that John has been seduced by the z-buffer. Maybe so, but there’s a lot there to be seduced by, and that will be all the more true as hardware rendering becomes the norm. The addition of particles—thousands of tiny colored rectangles—to Quake illustrated just how seductive the z-buffer can be; it would have been very difficult to get all those rectangles to draw properly using any other occlusion technique. Certainly z-buffering by itself can’t perform well enough to serve for all hidden surface removal; that’s why we have the PVS and the edge list (although for hardware rendering the PVS would suffice), but z-buffering pretty much means that if you can figure out how to draw an effect, you can readily insert it into the world with proper occlusion, and that’s a powerful capability indeed.</p>
<p>Supporting scenes with a dozen or more models of 300 to 500 polygons each was a major performance challenge in Quake, and the polygon-model drawing code was being optimized right up until the last week before it shipped. One help in allowing more models per scene was the PVS; we only drew those models that were in the PVS, meaning that levels could have a hundred or more models without requiring a lot of work to eliminate most of those that were occluded. (Note that this is not unique to the PVS; whatever high-level culling scheme we had ended up using for world polygons would have provided the same benefit for polygon models.) Also, model bounding boxes were used to trivially clip those that weren’t in the view pyramid, and to identify those that were unclipped, so they could be sent through a special fast path. The biggest breakthrough, though, was a very different sort of rasterizer that John came up with for relatively distant models.</p>
</section>
<section id="the-subdivision-rasterizer" class="level4">
<h4><a href="#the-subdivision-rasterizer">The Subdivision Rasterizer</a></h4>
<p>This rasterizer, which we call the <em>subdivision rasterizer</em>, first draws all the vertices in the model. Then it takes each front-facing triangle, and determines if it has a side that’s at least two pixels long. If it does, we split that side into two pieces at the pixel nearest to the middle (using adds and shifts to average the endpoints of that side), draw the vertex at the split point, and process each of the two split triangles recursively, until we get down to triangles that have only one-pixel sides and hence have nothing left to draw. This approach is hideously slow and quite ugly (due to inaccuracies from integer quantization) for 100-pixel triangles—but it’s very fast for, say, five-pixel triangles, and is indistinguishable from more accurate rasterization when a model is 25 or 50 feet away. Better yet, the subdivider is ridiculously simple—a few dozen lines of code, far simpler than the affine rasterizer—and was implemented in an evening, immediately making the drawing of distant models about three times as fast, a very good return for a bit of conceptual work. The affine rasterizer got fairly close to the same performance with further optimization—in the range of 10% to 50% slower—but that took weeks of difficult programming.</p>
<p>We switch between the two rasterizers based on the model’s distance and average triangle size, and in almost any scene, most models are far enough away so subdivision rasterization is used. There are undoubtedly faster ways yet to rasterize distant models adequately well, but the subdivider was clearly a win, and is a good example of how thinking in a radically different direction can pay off handsomely.</p>
</section>
<section id="sprites" class="level4">
<h4><a href="#sprites">Sprites</a></h4>
<p>We had hoped to be able to eliminate sprites completely, making Quake 100% 3-D, but sprites—although sometimes very visibly 2-D—were used for a few purposes, most noticeably the cores of explosions. As of CGDC last year, explosions consisted of an exploding spray of particles (discussed below), but there just wasn’t enough visual punch with that representation; adding a series of sprites animating an explosion did the trick. (In hindsight, we probably should have made the explosions polygon models rather than sprites; it would have looked about as good, and the few sprites we used didn’t justify the considerable amount of code and programming time required to support them.) Drawing a sprite is similar to drawing a normal polygon, complete with perspective correction, although of course the inner loop must detect and skip over transparent pixels, and must also perform z-buffering.</p>
</section>
<section id="particles" class="level4">
<h4><a href="#particles">Particles</a></h4>
<p>The last drawing entity type is particles. Each particle is a solid-colored rectangle, scaled by distance from the viewer and drawn with z-buffering. There can be up to 2,000 particles in a scene, and they are used for rocket trails, explosions, and the like. In one sense, particles are very primitive technology, but they allow effects that would be extremely difficult to do well with the other types of entities, and they work well in tandem with other entities, as, for example, providing a trail of fire behind a polygon-model lava ball that flies into the air, or generating an expanding cloud around a sprite explosion core.</p>
</section>
</section>
<section id="how-we-spent-our-summer-vacation-after-shipping-quake" class="level3">
<h3><a href="#how-we-spent-our-summer-vacation-after-shipping-quake">How We Spent Our Summer Vacation: After Shipping Quake</a></h3>
<p>Since shipping Quake in the summer of 1996, we’ve extended it in several ways: We’ve worked with Rendition to port it to the Verite accelerator chip, we’ve ported it to OpenGL, we’ve ported it to Win32, we’ve done QuakeWorld, and we’ve added features for Quake 2. I’ll discuss each of these briefly.</p>
<section id="verite-quake" class="level4">
<h4><a href="#verite-quake">Verite Quake</a></h4>
<p>Verite Quake (VQuake) was the first hardware-accelerated version of Quake. It looks extremely good, due to bilinear texture filtering, which eliminates most pixel aliasing, and because it provides good performance at higher resolutions such as 512x384 and 640x480. Implementing VQuake proved to be an interesting task, for two reasons: The Verite chip’s fill rate was marginal for Quake’s needs, and Verite contains a programmable RISC chip, enabling more sophisticated processing than most 3-D accelerators. The need to squeeze as much performance as possible out of Verite ruled out the use of a standard API such as Direct 3D or OpenGL; instead, VQuake uses Rendition’s proprietary API, Speedy3D, with the addition of some special calls and custom Verite code.</p>
<p>Interestingly, VQuake is very similar to software Quake; in order to allow Verite to handle the high pixel processing loads of high-res, VQuake uses an edge list and builds span lists on the CPU, just as in software Quake, then Verite DMAs the span descriptors to onboard memory and draws them. (This was only possible because Verite is fully programmable; most accelerators wouldn’t be able to support this architecture.) Similarly, the CPU builds lit, tiled surfaces in system RAM, then Verite DMAs them to an onboard surface cache, from which they are texture-mapped. In short, VQuake is very much like normal Quake, except that the drawing of the spans is done by a specialized processor.</p>
<p>This approach works well, but some of the drawbacks of a surface cache become more noticeable when hardware is involved. First, the DMAing is an extra step that’s not necessary in software, slowing things down. Second, onboard memory is a relatively limited resource (4 MB total), and textures must be 16-bpp (because hardware can only do filtering in RGB modes), thus eating up twice as much memory as the software version’s 8-bpp textures—and memory becomes progressively scarcer at higher resolutions, especially given the need for a z-buffer and two 16-bpp pages. (Note that using the edge list helps here, because it filters out spans from polygons that are in the PVS but fully occluded, reducing the number of surfaces that have to be downloaded.) Surface caching in VQuake usually works just fine, but response when coming around corners into complex scenes or when spinning can be more sluggish than in software Quake.</p>
<p>An alternative to surface caching would have been to do two passes across each span, one tiling the texture, and the other doing an alpha blend using the light map as a texture, to light the texture (two-pass alpha lighting). This approach produces exactly the same results as the surface cache, without requiring downloading and caching of large surfaces, and has the advantage of very level performance. However, this approach requires at least twice the fill rate of the surface cache approach, and Verite didn’t have enough fill rate for that at higher resolutions. It’s also worth noting that two-pass alpha lighting doesn’t have the same potential for procedural texturing that surface caching does. In fact, given MMX and ever-faster CPUs, and the ability of the CPU and the accelerator to process in parallel, it will become increasingly tempting to use the CPU to build surfaces with procedural texturing such as bump mapping, shimmers, and warps; this sort of procedural texturing has the potential to give accelerated games highly distinctive visuals. So the choice between surface caching and two-pass alpha lighting for hardware accelerators depends on a game’s needs, and it seems most likely that the two approaches will be mixed together, with surface caching used for special surfaces, and two-pass alpha lighting used for most drawing.</p>
</section>
<section id="glquake" class="level4">
<h4><a href="#glquake">GLQuake</a></h4>
<p>The second (and, according to current plans, last) port of Quake to a hardware accelerator was an OpenGL version, GLQuake, a native Win32 application. I have no intention of getting into the 3-D API wars currently raging; the observation I want to make here is that GLQuake uses two-pass alpha lighting, and runs very well on fast chips such as the 3Dfx, but rather slowly on most of the current group of accelerators. The accelerators coming out this year should all run GLQuake fine, however. It’s also worth noting that we’ll be using two-pass alpha lighting in the N64 port of Quake; in fact, it looks like the N64’s hardware is capable of performing both texture-tiling and alpha-lighting in a single pass, which is pretty much an ideal hardware-acceleration architecture: It’s as good looking and generally faster than surface caching, without the need to build, download, and cache surfaces, and much better looking and about as fast as Gouraud shading. We hope to see similar capabilities implemented in PC accelerators and exposed by 3-D APIs in the near future.</p>
<p>Dynamic lighting is done differently in GLQuake than in software Quake. It could have been implemented by changing the light maps, as usual, but current OpenGL drivers are not very fast at downloading textures (when the light maps are used as in GLQuake); also, it takes time to identify and change the affected light maps. Instead, GLQuake simply alpha-blends an approximate sphere around the light source. This requires very little calculation and no texture downloading, and as a bonus allows dynamic lights to be colored, so a rocket, for example, can cast a yellowish light.</p>
<p>Unlike Quake or VQuake, GLQuake does not use the edge list and draws all polygons in the potentially visible set. Because OpenGL drivers are not currently very fast at selecting new textures, GLQuake sorts polygons by texture, so that all polygons that use a given texture are drawn together. Once texture selection is faster, it might be worthwhile to draw back-to-front with z-fill, because some hardware can do z-fill faster than z-compare, or to draw front-to-back, so that z-buffering can reject as many pixels as possible, saving display-memory writes. GLQuake also avoids having to do z-buffer clearing by splitting the z range into two parts, and alternating between the two parts from frame to frame; at the same time, the z-compare polarity is switched (from greater-than-or-equal to less-than-or-equal), so that the previous frame’s z values are always considered more distant than the current frame’s.</p>
<p>GLQuake was very easy to develop, taking only a weekend to get up and running, and that leads to another important point: OpenGL is also an excellent API on which to build tools. QuakeEd, the tool we use to build levels, is written for OpenGL running on Win32, and when John needed a 3-D texture editing tool for modifying model skins, he was able to write it in one night by building it on OpenGL. After we finished Quake, we realized that about half our code and half our time was spent on tools, rather than on the game engine itself, and the artists’ and level designers’ productivity is heavily dependent on the tools they have to use; considering all that, we’d be foolish not to use OpenGL, which is very well suited to such tasks.</p>
<p>One good illustration of how much easier a good 3-D API can make development is how quickly John was able to add two eye-candy features to GLQuake: dynamic shadows and reflections. Dynamic shadows were implemented by projecting a model’s silhouette onto the ground plane, then alpha-blending that silhouette into the world. This doesn’t always work properly—for example, if the player is standing at the edge of a cliff, the shadow sticks out in the air—but it was added in a few hours, and most of the time looks terrific. Implementing it properly will take only a day or two more and should run adequately fast; it’s a simple matter of projecting the silhouette into the world, and onto the surfaces it encounters.</p>
<p>Reflections are a bit more complex, but again were implemented in a day. A special texture is designated as a mirror surface; when this is encountered while drawing, a hole is left. Then the z-range is changed so that everything drawn next is considered more distant than the scene just drawn, and a second scene is drawn, this time from the reflected viewpoint behind the mirror; this causes the mirror to be behind any nearer objects in the true scene. The only drawback to this approach (apart from the extra processing time to draw two scenes) is that because of the z-range change, the mirror must be against a sealed wall, with nothing in the PVS behind it, to ensure that a hole is left into which the reflection can be drawn. (Note that an OpenGL stencil buffer would be ideal here, but while OpenGL accelerators can be relied upon to support z-buffering and alpha-blending in hardware, the same is not yet true of stencil buffers.) As a final step, a marbled texture is blended into the mirror surface, to make the surface itself less than perfectly reflective and visible enough to seem real.</p>
<p>Both alpha-blending and z-buffering are relatively new to PC games, but are standard equipment on accelerators, and it’s a lot of fun seeing what sorts of previously very difficult effects can now be up and working in a matter of hours.</p>
</section>
<section id="winquake" class="level4">
<h4><a href="#winquake">WinQuake</a></h4>
<p>I’m not going to spend much time on the Win32 port of Quake; most of what I learned doing this consists of tedious details that are doubtless well covered elsewhere, and frankly it wasn’t a particularly interesting task and was harder than I expected, and I’m pretty much tired of the whole thing. However, I will say that Win32 is clearly the future, especially now that NT is coming on strong, and like it or not, you had best learn to write games for Win32. Also, Internet gaming is becoming ever more important, and Win32’s built-in TCP/IP support is a big advantage over DOS; that alone was enough to convince us we had to port Quake. As a last comment, I’d say that it is nice to have Windows take care of device configuration and interfacing—now if only we could get manufacturers to write drivers for those devices that actually worked reliably! This will come as no surprise to veteran Windows programmers, who have suffered through years of buggy 2-D Windows drivers, but if you’re new to Windows programming, be prepared to run into and learn to work around—or at least document in your readme files—driver bugs on a regular basis.</p>
<p>Still, when you get down to it, the future of gaming is a networked Win32 world, and that’s that, so if you haven’t already moved to Win32, I’d say it’s time.</p>
</section>
<section id="quakeworld" class="level4">
<h4><a href="#quakeworld">QuakeWorld</a></h4>
<p>QuakeWorld is a native Win32 multiplayer-only version of Quake, and was done as a learning experience; it is not a commercial product, but is freely distributed on the Internet. The idea behind it was to try to improve the multiplayer experience, especially for people linked by modem, by reducing actual and perceived latency. Before I discuss QuakeWorld, however, I should discuss the evolution of Quake’s multiplayer code.</p>
<p>From the beginning, Quake was conceived as a client-server app, specifically so that it would be possible to have persistent servers always running on the Internet, independent of whether anyone was playing on them at any particular time, as a step toward the long-term goal of persistent worlds. Also, client-server architectures tend to be more flexible and robust than peer-to-peer, and it is much easier to have players come and go at will with client-server. Quake is client-server from the ground up, and even in single-player mode, messages are passed through buffers between the client code and the server code; it’s quite likely that the client and server would have been two processes, in fact, were it not for the need to support DOS. Client-server turned out to be the right decision, because Quake’s ability to support persistent, come-and-go-as-you-please Internet servers with up to 16 people has been instrumental in the game’s high visibility in the press, and its lasting popularity.</p>
<p>However, client-server is not without a cost, because, in its pure form, latency for clients consists of the round trip from the client to the server and back. (In Quake, orientation changes instantly on the client, short-circuiting the trip to the server, but all other events, such as motion and firing, must make the round trip before they happen on the client.) In peer-to-peer games, maximum latency can be just the cost of the one-way trip, because each client is running a simulation of the game, and each peer sees its own actions instantly. What all this means is that latency is the downside of client-server, but in many other respects client-server is very attractive. So the big task with client-server is to reduce latency.</p>
<p>As of the release of QTest1, the first and last prerelease of Quake, John had smoothed net play considerably by actually keeping the client’s virtual time a bit earlier than the time of the last server packet, and interpolating events between the last two packets to the client’s virtual time. This meant that events didn’t snap to whatever packet had arrived last, and got rid of considerable jerking and stuttering. Unfortunately, it actually increased latency, because of the retarding of time needed to make the interpolation possible. This illustrates a common tradeoff, which is that reduced latency often makes for rougher play.</p>
<blockquote>
<p><img src="images/i.jpg" /> Reduced latency also often makes for more frustrating play. It’s actually not hard to reduce the latency perceived by the player, but many of the approaches that reduce latency introduce the potential for paradoxes that can be quite distracting and annoying. For example, a player may see a rocket go by, and think they’ve dodged it, only to find themselves exploding a second later as the difference of opinion between his simulation and the other simulation is resolved to his detriment.</p>
</blockquote>
<p>Worse, QTest1 was prone to frequent hitching over all but the best connections, because it was built around reliable packet delivery (TCP) provided by the operating system. Whenever a packet didn’t arrive, there was a long pause waiting for the retransmission. After QTest1, John realized that this was a fundamentally wrong assumption, and changed the code to use unreliable packet delivery (UDP), sending the relevant portion of the full state every time (possible only because the PVS can be used to cull most events in a level), and letting the game logic itself deal with packets that didn’t arrive. A reliable sideband was used as well, but only for events like scores, not for gameplay state. However, this was a good example of Carmack’s Law: John did not rewrite the net code to reflect this new fundamental assumption, and wound up with 8,000 lines of messy code that took right up until Quake shipped to debug. For QuakeWorld, John did rewrite the net code from scratch around the assumption of unreliable packet delivery, and it wound up as just 1,500 lines of clean, bug-free code.</p>
<p>In the long run, it’s cheaper to rewrite than to patch and modify!</p>
<p>So as of shipping Quake, multiplayer performance was quite smooth, but latency was still a major issue, often in the 250 to 400 ms range for modem players. QuakeWorld attacked this in two ways. First, it reduced latency by around 50 to 100 ms with a server change. The Quake server runs 10 or 20 times a second, batching up inputs in between ticks, and sending out results after the tick. By contrast, QuakeWorld servers run immediately whenever a client sends input, knocking up to 50 or 100 ms off response time, although at the cost of a greater server processing load. (A similar anti-latency idea that wasn’t implemented in QuakeWorld is having a separate thread that can send input off to the server as soon as it happens, instead of incurring up to a frame of latency.)</p>
<p>The second way in which QuakeWorld attacks latency is by not interpolating. The player is actually predicted well ahead of the latest server packet (after all, the client has all the information needed to move the player, unless an outside force intervenes), giving very responsive control. The rest of the world is drawn as of the latest server packet; this is jerkier than Quake, again showing that smoothness is often a tradeoff for latency. The player’s prediction may, of course, result in a minor paradox; for example, if an explosion turns out to have knocked the player sideways, the player’s location may suddenly jump without warning as the server packet arrives with the correct location. In the latest version of QuakeWorld, the other players are predicted as well, with consequently more frequent paradoxes, but smoother, more convincing motion. Platforms and doors are still not predicted, and consequently are still pretty jerky. It is, of course, possible to predict more and more objects into the future; it’s a tradeoff of smoothness and perceived low latency for the frustration of paradoxes—and that’s the way it’s going to stay until most people are connected to the Internet by something better than modems.</p>
</section>
<section id="quake-2" class="level4">
<h4><a href="#quake-2">Quake 2</a></h4>
<p>I can’t talk in detail about Quake 2 as a game, but I can describe some interesting technology features. The Quake 2 rendering engine isn’t going to change that much from Quake; the improvements are largely in areas such as physics, gameplay, artwork, and overall design. The most interesting graphics change is in the preprocessing, where John has added support for radiosity lighting; that is, the ability to put a light source into the world and have the light bounced around the world realistically. This is sometimes terrific—it makes for great glowing light around lava and hanging light panels—but in other cases it’s less spectacular than the effects that designers can get by placing lots of direct-illumination light sources in a room, so the two methods can be used as needed. Also, radiosity is <em>very</em> computationally expensive, approximately as expensive as BSPing. Most of the radiosity demos I’ve seen have been in one or two rooms, and the order of the problem goes up tremendously on whole Quake levels. Here’s another case where the PVS is essential; without it, radiosity processing time would be O(polygons<sup>2</sup>), but with the PVS it’s O(polygons*average_potentially_visible_polygons), which is over an order of magnitude less (and increases approximately linearly, rather than as a squared function, with greater-level complexity).</p>
<p>Also, the moving sky texture will probably be gone or will change. One likely replacement is an enclosing texture-mapped box around the world, at a virtually infinite distance; this will allow open vistas, much like Doom, a welcome change from the claustrophobic feel of Quake.</p>
<p>Another likely change in Quake 2 is a shift from interpreted Quake-C code for game logic to compiled DLLs. Part of the incentive here is performance—interpretation isn’t cheap—and part is debugging, because the standard debugger can be used with DLLs. The drawback, of course, is portability; Quake-C program files are completely portable to any platform Quake runs on, with no modification or recompilation, but DLLs compiled for Win32 require a real porting effort to run anywhere else. Our thinking here is that there are almost no non-console platforms other than the PC that matter that much anymore, and for those few that do (notably the Mac and Linux), the DLLs can be ported along with the core engine code. It just doesn’t make sense for easy portability to tiny markets to impose a significant development and performance cost on the one huge market. Consoles will always require serious porting effort anyway, so going to Win32-specific DLLs for the PC version won’t make much difference in the ease of doing console ports.</p>
<p>Finally, Internet support will improve in Quake 2. Some of the QuakeWorld latency improvements will doubtless be added, but more important, there will be a new interface, especially for monitoring and joining net games, in the form of an HTML page. John has always been interested in moving as much code as possible out of the game core, and letting the browser take care of most of the UI makes it possible to eliminate menuing and such from the Quake 2 engine. Think of being able to browse hundreds of Quake servers from a single Web page (much as you can today with QSpy, but with the advantage of a standard, familiar interface and easy extensibility), and I think you’ll see why John considers this the game interface of the future.</p>
<p>By the way, Quake 2 is currently being developed as a native Win32 app only; no DOS version is planned.</p>
</section>
</section>
<section id="looking-forward" class="level3">
<h3><a href="#looking-forward">Looking Forward</a></h3>
<p>In my address to the Computer Game Developer’s Conference in 1996, I said that it wasn’t a bad time to start up a game company aimed at hardware-only rasterization, and trying to make a game that leapfrogged the competition. It looks like I was probably a year early, because hardware took longer to ship than I expected, although there was a good living to be made writing games that hardware vendors could bundle with their boards. Now, though, it clearly is time. By Christmas 1997, there will be several million fast accelerators out there, and by Christmas 1998, there will be tens of millions. At the same time, vastly more people are getting access to the Internet, and it’s from the convergence of these two trends that I think the technology for the next generation of breakthrough real-time games will emerge.</p>
<p>John is already working on id’s next graphics engine, code-named Trinity and targeted around Christmas of 1998. Trinity is not only a hardware-only engine, its baseline system is a Pentium Pro 200-plus with MMX, 32 MB, and an accelerator capable of at least 50 megapixels and 300 K triangles per second with alpha blending and z-buffering. The goals of Trinity are quite different from those of Quake. Quake’s primary technical goals were to do high-quality, well-lit, complex indoor scenes with 6 degrees of freedom, and to support client-server Internet play. That was a good start, but only that. Trinity’s goals are to have much less-constrained, better-connected worlds than Quake. Imagine seeing through open landscape from one server to the next, and seeing the action on adjacent servers in detail, in real time, and you’ll have an idea of where things are heading in the near future.</p>
<p>A huge graphics challenge for the next generation of games is level of detail (LOD) management. If we’re to have larger, more open worlds, there will inevitably be more geometry visible at one time. At the same time, the push for greater detail that’s been in progress for the past four years or so will continue; people will start expecting to see real cracks and bumps when they get close to a wall, not just a picture of cracks and bumps painted on a flat wall. Without LOD, these two trends are in direct opposition; there’s no way you can make the world larger and make all its surfaces more detailed at the same time, without bringing the renderer to its knees.</p>
<p>The solution is to draw nearer surfaces with more detail than farther surfaces. In itself, that’s not so hard, but doing it without popping and snapping being visible as you move about is quite a challenge. John has implemented fractal landscapes with constantly adjustable level of detail, and has made it so new vertices appear as needed and gradually morph to their final positions, so there is no popping. Trinity is already capable of displaying oval pillars that have four sides when viewed from a distance, and add vertices and polygons smoothly as you get closer, such that the change is never visible, and the pillars look oval at all times.</p>
<p>Similarly, polygon models, which maxed out at about 5,000 polygon-model polygons total—for all models—per scene in Quake, will probably reach 6,000 or 7,000 per scene in Quake 2 in the absence of LOD. Trinity will surely have many more moving objects, and those objects will look far more detailed when viewed up close, so LOD for moving polygon models will definitely be needed.</p>
<p>One interesting side effect of morphing vertices as part of LOD is that Gouraud shading doesn’t work very well with this approach. The problem is that adding a new vertex causes a major shift in Gouraud shading, which is, after all, based on lighting at vertices. Consequently, two-pass alpha lighting and surface caching seem to be much better matches for smoothly changing LOD.</p>
<p>Some people worry that the widespread use of hardware acceleration will mean that 3-D programs will all look the same, and that there will no longer be much challenge in 3-D programming. I hope that this brief discussion of the tightly interconnected, highly detailed worlds toward which we’re rapidly heading will help you realize that both the challenge and the potential of 3-D programming are in fact greater than they’ve ever been. The trick is that rather than getting stuck in the rut of established techniques, you must constantly strive to “do better with less, in a different way”; keep learning and changing and trying new approaches—and working your rear end off—and odds are you’ll be part of the wave of the future.</p>
</section>
</section>
</section>
<section id="afterword" class="level1">
<h1><a href="#afterword">Afterword</a></h1>
<p>If you’ve followed me this far, you might agree that we’ve come through some rough country. Still, I’m of the opinion that hard-won knowledge is the best knowledge, not only because it sticks to you better, but also because winning a hard race makes it easier to win the next one.</p>
<p>This is an unusual book in that sense: In addition to being a compilation of much of what I know about fast computer graphics, it is a journal recording some of the process by which I discovered and refined that knowledge. I didn’t just sit down one day to write this book—I wrote it over a period of years and published its component parts in many places. It is a journal of my successes and frustrations, with side glances of my life as it happened along the way.</p>
<p>And there is yet another remarkable thing about this book: You, the reader, helped me write it. Perhaps not you personally, but many people who have read my articles and columns over the years sent me notes asking me questions, suggesting improvements (occasionally by daring me to beat them at the code performance game!) or sometimes just dumping remarkable code into my lap. Where it seemed appropriate, I dropped in the code and sometimes even the words of my correspondents, and the book is much the richer for it.</p>
<p>Here and there, I learned things that had nothing at all to do with fast graphics.</p>
<p>For example: I’m not a doomsayer who thinks American education lags hopelessly behind the rest of the Western world, but now and then something happens that makes me wonder. Some time back, I received a letter from one Melvyn J. Lafitte requesting that I spend some time in my columns describing fast 3-D animation techniques. Melvyn hoped that I would be so kind as to discuss, among other things, hidden surface removal and perspective projection, performed in real time, of course, and preferably in Mode X. Sound familiar?</p>
<p>Melvyn shared with me a hidden surface approach that he had developed. His technique involved defining polygon vertices in clockwise order, as viewed from the visible side. Then, he explained, one can use the cross-product equations found in any math book to determine which way the perpendicular to the polygon is pointing. Better yet, he pointed out, it’s necessary to calculate only the Z component of the perpendicular, and only the sign of the Z component need actually be tested.</p>
<p>What Melvyn described is, of course, backface removal, a key hidden-surface technique that I used heavily in X-Sharp. In general, other hidden surface techniques must be used in conjunction with backface removal, but backface removal is nonetheless important and highly efficient. Simply put, Melvyn had devised for himself one of the fundamental techniques of 3-D drawing.</p>
<p>Melvyn lives in Moens, France. At the time he wrote me, Melvyn was 17 years old. Try to imagine any American 17-year-old of your acquaintance inventing backface removal. Try to imagine any teenager you know even using the phrase “the cross-product equations found in any math book.” Not to mention that Melvyn was able to write a highly technical letter in English; and if Melvyn’s English was something less than flawless, it was perfectly understandable, and, in my experience, vastly better than an average, or even well-educated, American’s French. Please understand, I believe we Americans excel in a wide variety of ways, but I worry that when it comes to math and foreign languages, we are becoming a nation of <em>têtes de pomme de terre</em>.</p>
<p>Maybe I worry too much. If the glass is half empty, well, it’s also half full. Plainly, something I wrote inspired Melvyn to do something that is wonderful, whether he realizes it or not. And it has been tremendously gratifying to sense in the letters I have received the same feeling of remarkably smart people going out there and doing amazing things just for the sheer unadulterated fun of it.</p>
<p>I don’t think I’m exaggerating too much (well, maybe a little) when I say that this sort of fun is what I live for. I’m glad to see that so many of you share that same passion.</p>
<p>Good luck. Thank you for your input, your code, and all your kind words. Don’t be afraid to attempt the impossible. Simply knowing what is impossible is useful knowledge—and you may well find, in the wake of some unexpected success, that not half of the things we call impossible have any right at all to wear the label.</p>
<p>—Michael Abrash</p>
</section>
<section id="about-this-version" class="level1">
<h1><a href="#about-this-version">About this version</a></h1>
<p>All rights belong to Michael Abrash. Reproduced with permission.</p>
<p>This version was extracted from the PDFs which were <a href="http://www.drdobbs.com/parallel/graphics-programming-black-book/184404919">released by Michael Abrash and Dr. Dobbs in 2001</a>. The intention is to maintain a canonical electronic version of the book, and make it easier to read in other formats and on other devices than were available when the book was released online.</p>
<p>For comments, suggestions, and improvements contact James Gregory at <script type="text/javascript">
<!--
h='&#106;&#x61;&#x67;&#114;&#x65;&#x67;&#x6f;&#114;&#x79;&#46;&#x63;&#x6f;&#x6d;';a='&#64;';n='&#106;&#x61;&#x6d;&#x65;&#x73;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#106;&#x61;&#x6d;&#x65;&#x73;&#32;&#x61;&#116;&#32;&#106;&#x61;&#x67;&#114;&#x65;&#x67;&#x6f;&#114;&#x79;&#32;&#100;&#x6f;&#116;&#32;&#x63;&#x6f;&#x6d;</noscript>.</p>
<p>The source and issues list can be found on github: <a href="https://github.com/jagregory/abrash-black-book">github.com/jagregory/abrash-black-book</a>.</p>
</section>
</body>
</html>
