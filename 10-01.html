<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: Patient Coding, Faster Code</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=10//-->
<!--PAGES=190-193//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><body>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="09-07.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="10-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H2><A NAME="Heading1"></A>Chapter 10<BR>Patient Coding, Faster Code</H2>
<H3><A NAME="Heading2"></A>How Working Quickly Can Bring Execution to a Crawl</H3>
<P>My grandfather does <I>The New York Times</I> crossword puzzle every Sunday. In ink. With nary a blemish.</P>
<P>The relevance of which will become apparent in a trice.</P>
<P>What my grandfather is, is a pattern matcher <I>par excellence</I>. You&rsquo;re a pattern matcher, too. So am I. We can&rsquo;t help it; it comes with the territory. Try focusing on text and not reading it. Can&rsquo;t do it. Can you hear the voice of someone you know and not recognize it? I can&rsquo;t. And how in the Nine Billion Names of God is it that we&rsquo;re capable of instantly recognizing one face out of the thousands we&rsquo;ve seen in our lifetimes&mdash;even years later, from a different angle and in different light? Although we take them for granted, our pattern-matching capabilities are surely a miracle on the order of loaves and fishes.</P>
<P>By &ldquo;pattern matching,&rdquo; I mean more than just recognition, though. I mean that we are generally able to take complex and often seemingly woefully inadequate data, instantaneously match it in an incredibly flexible way to our past experience, extrapolate, and reach amazing conclusions, something that computers can scarcely do at all. Crossword puzzles are an excellent example; given a couple of letters and a cryptic clue, we&rsquo;re somehow able to come up with one out of several hundred thousand words that we know. Try writing a program to do that! What&rsquo;s more, we don&rsquo;t process data in the serial brute-force way that computers do. Solutions tend to be virtually instantaneous or not at all; none of those &ldquo;N log N&rdquo; or &ldquo;N<SUP>2&rdquo;</SUP> execution times for us.</P>
<P>It goes without saying that pattern matching is good; more than that, it&rsquo;s a large part of what we are, and, generally, the faster we are at it, the better. Not always, though. Sometimes insufficient information really is insufficient, and, in our haste to get the heady rush of coming up with a solution, incorrect or less-than-optimal conclusions are reached, as anyone who has ever done the <I>Times</I> Sunday crossword will attest. Still, my grandfather does that puzzle every Sunday <I>in ink</I>. What&rsquo;s his secret? Patience and discipline. He never fills a word in until he&rsquo;s confirmed it in his head via intersecting words, no matter how strong the urge may be to put something down where he can see it and feel like he&rsquo;s getting somewhere.</P>
<P>There&rsquo;s a surprisingly close parallel to programming here. Programming is certainly a sort of pattern matching in the sense I&rsquo;ve described above, and, as with crossword puzzles, following your programming instincts too quickly can be a liability. For many programmers, myself included, there&rsquo;s a strong urge to find a workable approach to a particular problem and start coding it <I>right now</I>, what some people call &ldquo;hacking&rdquo; a program. Going with the first thing your programming pattern matcher comes up with can be a lot of fun; there&rsquo;s instant gratification and a feeling of unbounded creativity. Personally, I&rsquo;ve always hungered to get results from my work as soon as possible; I gravitated toward graphics for its instant and very visible gratification. Over time, however, I&rsquo;ve learned patience.</P>
<TABLE WIDTH="100%"><TR>
<TD WIDTH="5%" VALIGN="TOP"><IMG SRC="images/i.jpg"><TD WIDTH="95%"><SMALL><I>I&rsquo;ve come to spend an increasingly large portion of my time choosing algorithms, designing, and simply giving my mind quiet time in which to work on problems and come up with non-obvious approaches before coding; and I&rsquo;ve found that the extra time up front more than pays for itself in both decreased coding time and superior programs.</I></SMALL>
</TABLE>
<P>In this chapter, I&rsquo;m going to walk you through a simple but illustrative case history that nicely points up the wisdom of delaying gratification when faced with programming problems, so that your mind has time to chew on the problems from other angles. The alternative solutions you find by doing this may seem obvious, once you&rsquo;ve come up with them. They may not even differ greatly from your initial solutions. Often, however, they will be much better&mdash;and you&rsquo;ll never even have the chance to decide whether they&rsquo;re better or not if you take the first thing that comes into your head and run with it.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading3"></A>The Case for Delayed Gratification</H4>
<P>Once upon a time, I set out to read <I>Algorithms</I>, by Robert Sedgewick (Addison-Wesley), which turned out to be a wonderful, stimulating, and most useful book, one that I recommend highly. My story, however, involves only what happened in the first 12 pages, for it was in those pages that Sedgewick discussed Euclid&rsquo;s algorithm.</P>
<P>Euclid&rsquo;s algorithm (discovered by Euclid, of Euclidean geometry fame, a very long time ago, way back when computers still used core memory) is a straightforward algorithm that solves one of the simplest problems imaginable: finding the greatest common integer divisor (GCD) of two positive integers. Sedgewick points out that this is useful for reducing a fraction to its lowest terms. I&rsquo;m sure it&rsquo;s useful for other things, as well, although none spring to mind. (A long time ago, I wrote an article about optimizing a bit of code that wasn&rsquo;t even vaguely time-critical, and got swamped with letters telling me so. I knew it wasn&rsquo;t time-critical; it was just a good example. So for now, close your eyes and <I>imagine</I> that finding the GCD is not only necessary but must also be done as quickly as possible, because it&rsquo;s perfect for the point I want to make here and now. Okay?)</P>
<P>The problem at hand, then, is simply this: Find the largest integer value that evenly divides two arbitrary positive integers. That&rsquo;s all there is to it. So warm up your pattern matchers...and go!</P>
<H3><A NAME="Heading4"></A>The Brute-Force Syndrome</H3>
<P>I have a funny feeling that you&rsquo;d already figured out how to find the GCD before I even said &ldquo;go.&rdquo; That&rsquo;s what I did when reading <I>Algorithms;</I> before I read another word, I had to figure it out for myself. Programmers are like that; give them a problem and their eyes immediately glaze over as they try to solve it before you&rsquo;ve even shut your mouth. That sort of instant response can certainly be impressive, but it can backfire, too, as it did in my case.</P>
<P>You see, I fell victim to a common programming pitfall, the &ldquo;brute-force&rdquo; syndrome. The basis of this syndrome is that there are many problems that have obvious, brute-force solutions&mdash;with one small drawback. The drawback is that if you were to try to apply a brute-force solution by hand&mdash;that is, work a single problem out with pencil and paper or a calculator&mdash;it would generally require that you have the patience and discipline to work on the problem for approximately seven hundred years, not counting eating and sleeping, in order to get an answer. Finding all the prime numbers less than 1,000,000 is a good example; just divide each number up to 1,000,000 by every lesser number, and see what&rsquo;s left standing. For most of the history of humankind, people were forced to think of cleverer solutions, such as the Sieve of Eratosthenes (we&rsquo;d have been in big trouble if the ancient Greeks had had computers), mainly because after about five minutes of brute force-type work, people&rsquo;s attention gets diverted to other important matters, such as how far a paper airplane will fly from a second-story window.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="09-07.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="10-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
Graphics Programming Black Book &copy; 2001 Michael Abrash
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


