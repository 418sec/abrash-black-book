<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Hints My Readers Gave Me</title>
  <meta name="chapter" content="09" />
  <meta name="pages" content="167-172" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="08-05.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="09-02.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <h2 id="Heading1">Chapter 9<br />
  Hints My Readers Gave Me</h2>

  <h3 id="Heading2">Optimization Odds and Ends from the Field</h3>

  <p>Back in high school, I took a pre-calculus class from Mr. Bourgeis, whose most notable characteristics were incessant pacing and truly enormous feet. My friend Barry, who sat in the back row, right behind me, claimed that it was because of his large feet that Mr. Bourgeis was so restless. Those feet were <i>so</i> heavy, Barry hypothesized, that if Mr. Bourgeis remained in any one place for too long, the floor would give way under the strain, plunging the unfortunate teacher deep into the mantle of the Earth and possibly all the way through to China. Many amusing cartoons were drawn to this effect.</p>

  <p>Unfortunately, Barry was too busy drawing cartoons, or, alternatively, sleeping, to actually learn any math. In the long run, that didn&rsquo;t turn out to be a handicap for Barry, who went on to become vice-president of sales for a ham-packing company, where presumably he was rarely called upon to derive the quadratic equation. Barry&rsquo;s lack of scholarship caused some problems back then, though. On one memorable occasion, Barry was half-asleep, with his eyes open but unfocused and his chin balanced on his hand in the classic &ldquo;if I fall asleep my head will fall off my hand and I&rsquo;ll wake up&rdquo; posture, when Mr. Bourgeis popped a killer problem:</p>

  <p>&ldquo;Barry, solve this for X, please.&rdquo; On the blackboard lay the equation:</p>
  <pre>
X - 1 = 0
</pre>

  <p>&ldquo;Minus 1,&rdquo; Barry said promptly.</p>

  <p>Mr. Bourgeis shook his head mournfully. &ldquo;Try again.&rdquo; Barry thought hard. He knew the fundamental rule that the answer to most mathematical questions is either 0, 1, infinity, -1, or minus infinity (do not apply this rule to balancing your checkbook, however); unfortunately, that gave him only a 25 percent chance of guessing right.</p>

  <p>&ldquo;One,&rdquo; I whispered surreptitiously.</p>

  <p>&ldquo;Zero,&rdquo; Barry announced. Mr. Bourgeis shook his head even more sadly.</p>

  <p>&ldquo;One,&rdquo; I whispered louder. Barry looked still more thoughtful&mdash;a bad sign&mdash;so I whispered &ldquo;one&rdquo; again, even louder. Barry looked so thoughtful that his eyes nearly rolled up into his head, and I realized that he was just doing his best to convince Mr. Bourgeis that Barry had solved this one by himself.</p>

  <p>As Barry neared the climax of his stirring performance and opened his mouth to speak, Mr. Bourgeis looked at him with great concern. &ldquo;Barry, can you hear me all right?&rdquo;</p>

  <p>&ldquo;Yes, sir,&rdquo; Barry replied. &ldquo;Why?&rdquo;</p>

  <p>&ldquo;Well, I could hear the answer all the way up here. Surely you could hear it just one row away?&rdquo;</p>

  <p>The class went wild. They might as well have sent us home early for all we accomplished the rest of the day.</p>

  <p>I like to think I know more about performance programming than Barry knew about math. Nonetheless, I always welcome good ideas and comments, and many readers have sent me a slew of those over the years. So in this chapter, I think I&rsquo;ll return the favor by devoting a chapter to reader feedback.</p>

  <h4 align="left" id="Heading3">Another Look at LEA</h4>

  <p>Several people have pointed out that while <b>LEA</b> is great for performing certain additions (see Chapter 6), it isn&rsquo;t a perfect replacement for <b>ADD</b>. What&rsquo;s the difference? <b>LEA</b>, an addressing instruction by trade, doesn&rsquo;t affect the flags, while the arithmetic <b>ADD</b> instruction most certainly does. This is no problem when performing additions that involve only quantities that fit in one machine word (32 bits in 386 protected mode, 16 bits otherwise), but it renders <b>LEA</b> useless for multiword operations, which use the Carry flag to tie together partial results. For example, these instructions</p>
  <pre>
ADD  EAX,EBX
ADC  EDX,ECX
</pre>

  <p>could <i>not</i> be replaced</p>
  <pre>
LEA  EAX,[EAX+EBX]
ADC  EDX,ECX
</pre>

  <p>because <b>LEA</b> doesn&rsquo;t affect the Carry flag.</p>

  <p>The no-carry characteristic of <b>LEA</b> becomes a distinct advantage when performing pointer arithmetic, however. For instance, the following code uses <b>LEA</b> to advance the pointers while adding one 128-bit memory variable to another such variable:</p>
  <pre>
   MOV   ECX,4   ;# of 32-bit words to add
   CLC
;no carry into the initial ADC
ADDLOOP:

   MOV   EAX,[ESI]    ;get the next element of one array
   ADC   [EDI],EAX    ;add it to the other array, with carry
   LEA   ESI,[ESI+4]  ;advance one array&rsquo;s pointer
   LEA   EDI,[EDI+4]  ;advance the other array&rsquo;s pointer
         LOOP ADDLOOP
</pre>

  <p>(Yes, I could use <b>LODSD</b> instead of <b>MOV/LEA</b>; I&rsquo;m just illustrating a point here. Besides, <b>LODS</b> is only 1 cycle faster than <b>MOV/LEA</b> on the 386, and is actually more than twice as slow on the 486.) If we used <b>ADD</b> rather than <b>LEA</b> to advance the pointers, the carry from one <b>ADC</b> to the next would have to be preserved with either <b>PUSHF/POPF</b> or <b>LAHF/SAHF</b>. (Alternatively, we could use multiple <b>INC</b>s, since <b>INC</b> doesn&rsquo;t affect the Carry flag.)</p>

  <p>In short, <b>LEA</b> is indeed different from <b>ADD</b>. Sometimes it&rsquo;s better. Sometimes not; that&rsquo;s the nature of the various instruction substitutions and optimizations that will occur to you over time. There&rsquo;s no such thing as &ldquo;best&rdquo; instructions on the x86; it all depends on what you&rsquo;re trying to do.</p>

  <p>But there sure are a lot of interesting options, aren&rsquo;t there?</p>

  <h4 align="left" id="Heading4">The Kennedy Portfolio</h4>

  <p>Reader John Kennedy regularly passes along intriguing assembly programming tricks, many of which I&rsquo;ve never seen mentioned anywhere else. John likes to optimize for size, whereas I lean more toward speed, but many of his optimizations are good for both purposes. Here are a few of my favorites:</p>

  <p>John&rsquo;s code for setting AX to its absolute value is:</p>
  <pre>
CWD
XOR   AX,DX
SUB   AX,DX
</pre>

  <p>This does nothing when bit 15 of AX is 0 (that is, if AX is positive). When AX is negative, the code &ldquo;nots&rdquo; it and adds 1, which is exactly how you perform a two&rsquo;s complement negate. For the case where AX is not negative, this trick usually beats the stuffing out of the standard absolute value code:</p>
  <pre>
   AND   AX,AX        ;negative?
   JNS   IsPositive   ;no
   NEG   AX           ;yes,negate it
IsPositive:
</pre>

  <p>However, John&rsquo;s code is slower on a 486; as you&rsquo;re no doubt coming to realize (and as I&rsquo;ll explain in Chapters 12 and 13), the 486 is an optimization world unto itself.</p>

  <p>Here&rsquo;s how John copies a block of bytes from DS:SI to ES:DI, moving as much data as possible a word at a time:</p>
  <pre>
SHR   CX,1      ;word count
REP   MOVSW     ;copy as many words as possible
ADC   CX,CX     ;CX=1 if copy length was odd,
                ;0 else
REP   MOVSB     ;copy any odd byte
</pre>

  <p>(<b>ADC CX,CX</b> can be replaced with <b>RCL CX,1</b>; which is faster depends on the processor type.) It might be hard to believe that the above is faster than this:</p>
  <pre>
   SHR   CX,1      ;word count
   REP   MOVSW     ;copy as many words as
                   ;possible
   JNC   CopyDone  ;done if even copy length
   MOVSB           ;copy the odd byte
CopyDone:
</pre>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="08-05.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="09-02.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
