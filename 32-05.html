<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: Be It Resolved: 360x480</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=32//-->
<!--PAGES=620-622//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><BODY LINK=#0000FF ALINK=#000099 VLINK=#0000FF BGCOLOR=#FFFFFF>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="32-04.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="33-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>The key to solving this problem lies in recalling that the VGA is designed to drive a monitor that sweeps the electron beam across the screen at exactly the same speed, no matter what mode the VGA is in. If the monitor always sweeps at the same speed, how does the VGA manage to display both 640 pixels across the screen (in high-resolution graphics modes) and 720 pixels across the screen (in 80-column text modes)? Good question indeed&#151;and the answer is that the VGA has not one but <I>two</I> clocks on board, and one of those clocks is just sufficiently faster than the other clock so that an extra 80 (or 40) pixels can be displayed on each scan line.</P>
<P>In other words, there&#146;s a slow clock (about 25 MHz) that&#146;s usually used in graphics modes to get 640 (or 320) pixels on the screen during each scan line, and a second, fast clock (about 28 MHz) that&#146;s usually used in text modes to crank out 720 (or 360) pixels per scan line. In particular, 320&#215;400 256-color mode uses the 25 MHz clock.</P>
<P>I&#146;ll bet that you can see where I&#146;m headed: We can switch from the 25 MHz clock to the 28 MHz clock in 320&#215;480 256mode in order to get more pixels. It takes two clocks to produce one 256-color pixel, so we&#146;ll get 40 rather than 80 extra pixels by doing this, bringing our horizontal resolution to the desired 360 pixels.</P>
<P>Switching horizontal resolutions sounds easy, doesn&#146;t it? Alas, it&#146;s not. There&#146;s no standard VGA mode that uses the 28 MHz clock to draw 8 rather than 9 dots per character, so the timing parameters have to be calculated from scratch. John Bridges has already done that for us, but I want you to appreciate that producing this mode took some work. The registers controlling the total number of characters per scan line, the number of characters displayed, the horizontal sync pulse, horizontal blanking, the offset from the start of one line to the start of the next, and the clock speed all have to be altered in order to set up 360&#215;480 256-color mode. The function <B>Set360&#215;480Mode</B> in Listing 32.1 does all that, and sets up the registers that control vertical resolution, as well.</P>
<P>Once all that&#146;s done, the VGA is in 360&#215;480 mode, awaiting our every high-resolution 256-color graphics whim.</P>
<H4 ALIGN="LEFT"><A NAME="Heading8"></A><FONT COLOR="#000077">Accessing Display Memory in 360&#215;480 256-Color Mode</FONT></H4>
<P>Setting up for 360&#215;480 256-color mode proved to be quite a task. Is drawing in this mode going to be as difficult?
</P>
<P>No. In fact, if you know how to draw in 320&#215;400 256-color mode, you already know how to draw in 360&#215;480 256-color mode; the conversion between the two is a simple matter of changing the working screen width from 320 pixels to 360 pixels. In fact, if you were to take the 320&#215;400 256-color pixel reading and pixel writing code from Chapter 31 and change the <B>SCREEN_WIDTH</B> equate from 320 to 360, those routines would work perfectly in 360&#215;480 256-color mode.</P>
<P>The organization of display memory in 360&#215;480 256-color mode is almost exactly the same as in 320&#215;400 256-color mode, which we covered in detail in the last chapter. However, as a quick refresher, each byte of display memory controls one 256-color pixel, just as in mode 13H. The VGA is reprogrammed by the mode set so that adjacent pixels lie in adjacent planes of display memory. Look back to Figure 31.1 in the last chapter to see the organization of the first few pixels on the screen; the bytes controlling those pixels run cross-plane, advancing to the next address only every fourth pixel. The address of the pixel at screen coordinate (<I>x,y</I>) is</P>
<P><I>address</I> = ((<I>y</I>*360)&#43;<I>x</I>)/4</P>
<P>and the plane of a given pixel is:</P>
<P><I>plane</I> = <I>x</I> modulo 4</P>
<P>A new scan line starts every 360 pixels, or 90 bytes, as shown in Figure 32.1. This is the major programming difference between the 360&#215;480 and 320&#215;400 256-color modes; in the 320&#215;400 mode, a new scan line starts every 80 bytes.</P>
<P>The other programming difference between the two modes is that the area of display memory mapped to the screen is longer in 360&#215;480 256-color mode, which is only common sense given that there are more pixels in that mode. The exact amount of memory required in 360&#215;480 256-color mode is 360 times 480 = 172,800 bytes. That&#146;s more than half of the VGA&#146;s 256 Kb memory complement, so page-flipping is out; however, there&#146;s no reason you couldn&#146;t use that extra memory to create a virtual screen larger than 360&#215;480, around which you could then scroll, if you wish.</P>
<P>That&#146;s really all there is to drawing in 360&#215;480 256-color mode. From a programming perspective, this mode is no more complicated than 320&#215;400 256-color mode once the mode set is completed, and should be capable of good performance given some clever coding. It&#146;s not particular straightforward to implement bitblt, block move, or fast line-drawing code for any of the extended 256-color modes, but it can be done&#151;and it&#146;s worth the trouble. Even the small taste we&#146;ve gotten of the capabilities of these modes shows that they put the traditional CGA, EGA, and generally even VGA modes to shame.</P>
<P><A NAME="Fig1"><!-- </A><A HREF="javascript:displayWindow('images/32-01.jpg',406,181 )"> --><IMG SRC="images/32-01.jpg"><BR><!-- </A>
<BR><A HREF="javascript:displayWindow('images/32-01.jpg',406,181)"> --><FONT COLOR="#000077"><B>Figure 32.1</B></FONT></A>&nbsp;&nbsp;<I>Pixel organization in 360&#215;480 256-color mode.</I>
</P>
<P>There&#146;s more and better to come, though; in later chapters, we&#146;ll return to high-resolution 256-color programming in a big way, by exploring the tremendous potential of these modes for real time 2-D and 3-D animation.
</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="32-04.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="33-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Graphics Programming Black Book &copy; 2001 Michael Abrash</font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


