<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Quake's Lighting Model</title><!-- HEADER -->
  <!-- Empty Reference Subhead -->
  <!--ISBN=1576101746//-->
  <!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
  <!--AUTHOR=Michael Abrash//-->
  <!--PUBLISHER=The Coriolis Group, Inc.//-->
  <!--CHAPTER=68//-->
  <!--PAGES=1247-1251//-->
  <!--UNASSIGNED1//-->
  <!--UNASSIGNED2//-->
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="68-01.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="68-03.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p>A primary problem with Gouraud shading is that it requires the vertices used for world geometry to serve as lighting sample points as well, even though there isn&rsquo;t necessarily a close relationship between lighting and geometry. This artificial coupling often forces the subdivision of a single polygon into several polygons purely for lighting reasons, as with the spotlights mentioned above; these extra polygons increase the world database size, and the extra transformations and projections that they induce can harm performance considerably.</p>

  <p>Similar problems occur with overlapping lights, and with shadows, where additional polygons are required in order to approximate lighting detail well. In particular, good shadow edges need small polygons, because otherwise the gradient between light and dark gets spread across too wide an area. Worse still, the rate of lighting change across a shadow edge can vary considerably as a function of the geometry the edge crosses; wider polygons stretch and diffuse the transition between light and shadow. A related problem is that lighting discontinuities can be very visible at t-junctions (although ultimately we had to add edges to eliminate t-junctions anyway, because otherwise dropouts can occur along polygon edges). These problems can be eased by adding extra edges, but that increases the rasterization load.</p>

  <p><a id="Fig1"><!-- </A><A HREF="javascript:displayWindow('images/68-01.jpg',409,281 )"> --><img src="images/68-01.jpg" /><br />
  <!-- </A>
<BR><A HREF="javascript:displayWindow('images/68-01.jpg',409,281)"> --><b>Figure 68.1</b></a>&nbsp;&nbsp;<i>Adding an extra vertex directly beneath a light.</i></p>

  <h4 align="left"><a id="Heading6"></a>Perspective Correctness</h4>

  <p>Another problem is that Gouraud shading isn&rsquo;t perspective-correct. With Gouraud shading, lighting varies linearly across the face of a polygon, in equal increments per pixel&mdash;but unless the polygon is parallel to the screen, the same sort of perspective correction is needed to step lighting across the polygon properly as is required for texture mapping. Lack of perspective correction is not as visibly wrong for lighting as it is for texture mapping, because smooth lighting gradients can tolerate considerably more warping than can the detailed bitmapped images used in texture mapping, but it nonetheless shows up in several ways.</p>

  <p>First, the extent of the mismatch between Gouraud shading and perspective lighting varies with the angle and orientation of the polygon being lit. As a polygon turns to become more on-edge, for example, the lighting warps more and therefore shifts relative to the perspective-texture mapped texels it&rsquo;s shading, an effect I&rsquo;ll call <i>viewing variance</i>. Lighting can similarly shift as a result of clipping, for example if one or more polygon edges are completely clipped; I&rsquo;ll refer to this as <i>clipping variance</i>.</p>

  <p>These are fairly subtle effects; more pronounced is the <i>rotational variance</i> that occurs when Gouraud shading any polygon with more than three vertices. Consistent lighting for a polygon is fully defined by three lighting values; taking four or more vertices and interpolating between them, as Gouraud shading does, is basically a hack, and does not reflect any consistent underlying model. If you view a Gouraud-shaded quad head-on, then rotate it like a pinwheel, the lighting will shift as the quad turns, as shown in Figure 68.2. The extent of the lighting shift can be quite drastic, depending on how different the colors at the vertices are.</p>

  <p>It was rotational variance that finally brought the lighting issue to a head for Quake. We&rsquo;d look at the floors, which were Gouraud-shaded quads; then we&rsquo;d pivot, and the lighting would shimmy and shift, especially where there were spotlights and shadows. Given the goal of rendering the world as accurately and convincingly as possible, this was unacceptable.</p>

  <p>The obvious solution to rotational variance is to use only triangles, but that brings with it a new set of problems. It takes twice as many triangles as quads to describe the same scene, increasing the size of the world database and requiring extra rasterization, at a performance cost. Triangles still don&rsquo;t provide perspective lighting; their lighting is rotationally invariant, but it&rsquo;s still wrong&mdash;just wrong in a more consistant way. Gouraud-shaded triangles still result in odd lighting patterns, and require lots of triangles to support shadowing and other lighting detail. Finally, triangles don&rsquo;t solve clipping or viewing variance.</p>

  <p><a id="Fig2"><!-- </A><A HREF="javascript:displayWindow('images/68-02.jpg',409,219 )"> --><img src="images/68-02.jpg" /><br />
  <!-- </A>
<BR><A HREF="javascript:displayWindow('images/68-02.jpg',409,219)"> --><b>Figure 68.2</b></a>&nbsp;&nbsp;<i>How Gouraud shading varies with polygon screen orientation.</i></p>

  <p>Yet another problem is that while it may work well to add extra geometry so that spotlights and shadows show up well, that&rsquo;s feasible only for static lighting. Dynamic lighting&mdash;light cast by sources that move&mdash;has to work with whatever geometry the world has to offer, because its needs are constantly changing.</p>

  <p>These issues led us to conclude that if we were going to use Gouraud shading, we would have to build Quake levels from many small triangles, with sufficiently finely detailed geometry so that complex lighting could be supported and the inaccuracies of Gouraud shading wouldn&rsquo;t be too noticeable. Unfortunately, that line of thinking brought us back to the problem of a much larger world database and a much heavier rasterization load (all the worse because Gouraud shading requires an additional interpolant, slowing the inner rasterization loop), so that not only would the world still be less than totally solid, because of the limitations of Gouraud shading, but the engine would also be too slow to support the complex worlds we had hoped for in Quake.</p>

  <h3><a id="Heading7"></a>The Quest for Alternative Lighting</h3>

  <p>None of which is to say that Gouraud shading isn&rsquo;t useful in general. Descent uses it to excellent effect, and in fact Quake uses Gouraud shading for moving entities, because these consist of small triangles and are always in motion, which helps hide the relatively small lighting errors. However, Gouraud shading didn&rsquo;t seem capable of meeting our design goals for rendering quality and speed for drawing the world as a whole, so it was time to look for alternatives.</p>

  <p>There are many alternative lighting approaches, most of them higher-quality than Gouraud, starting with Phong shading, in which the surface normal is interpolated across the polygon&rsquo;s surface, and going all the way up to ray-tracing lighting techniques in which full illumination calculations are performed for all direct and reflected paths from each light source for each pixel. What all these approaches have in common is that they&rsquo;re slower than Gouraud shading, too slow for our purposes in Quake. For weeks, we kicked around and rejected various possibilities and continued working with Gouraud shading for lack of a better alternative&mdash;until the day John came into work and said, &ldquo;You know, I have an idea....&rdquo;</p>

  <h4 align="left"><a id="Heading8"></a>Decoupling Lighting from Rasterization</h4>

  <p>John&rsquo;s idea came to him while was looking at a wall that had been carved into several pieces because of a spotlight, with an ugly lighting glitch due to a t-junction. He thought to himself that if only there were some way to treat it as one surface, it would look better and draw faster&mdash;and then he realized that there was a way to do that.</p>

  <p>The insight was to split lighting and rasterization into two separate steps. In a normal Gouraud-based rasterizer, there&rsquo;s first an off-line preprocessing step when the world database is built, during which polygons are added to support additional lighting detail as needed, and lighting values are calculated at the vertices of all polygons. At runtime, the lighting values are modified if dynamic lighting is required, and then the polygons are drawn with Gouraud shading.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="68-01.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="68-03.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div><!-- all of the reference materials (books) have the footer and subfoot reveresed -->
  <!-- reference_subfoot = footer -->
  <!-- reference_footer = subfoot -->
  <!-- BEGIN SUB FOOTER -->
  <!-- END FOOTER -->
</body>
</html>
