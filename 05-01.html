<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Crossing the Border</title><!-- HEADER -->
  <!-- Empty Reference Subhead -->
  <!--ISBN=1576101746//-->
  <!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
  <!--AUTHOR=Michael Abrash//-->
  <!--PUBLISHER=The Coriolis Group, Inc.//-->
  <!--CHAPTER=05//-->
  <!--PAGES=111-115//-->
  <!--UNASSIGNED1//-->
  <!--UNASSIGNED2//-->
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="04-10.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="05-02.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <h2><a id="Heading1"></a>Chapter 5<br />
  Crossing the Border</h2>

  <h3><a id="Heading2"></a>Searching Files with Restartable Blocks</h3>

  <p><i>We just moved.</i> Those three little words should strike terror into the heart of anyone who owns more than a sleeping bag and a toothbrush. Our last move was the usual zoo&mdash;and then some. Because the distance from the old house to the new was only five miles, we used cars to move everything smaller than a washing machine. We have a sizable household&mdash;cats, dogs, kids, com, you name it&mdash;so the moving process took a number of car trips. A <i>large</i> number&mdash;33, to be exact. I personally spent about 15 hours just driving back and forth between the two houses. The move took days to complete.</p>

  <p><i>Never again</i>.</p>

  <p>You&rsquo;re probably wondering two things: What does this have to do with high-performance programming, and why on earth didn&rsquo;t I rent a truck and get the move over in one or two trips, saving hours of driving? As it happens, the second question answers the first. I didn&rsquo;t rent a truck because it <i>seemed</i> easier and cheaper to use cars&mdash;no big truck to drive, no rentals, spread the work out more manageably, and so on.</p>

  <p>It wasn&rsquo;t easier, and wasn&rsquo;t even much cheaper. (It costs quite a bit to drive a car 330 miles, to say nothing of the value of 15 hours of my time.) But, at the time, it seemed as though my approach would be easier and cheaper. In fact, I didn&rsquo;t realize just how much time I had wasted driving back and forth until I sat down to write this chapter.</p>

  <p>In Chapter 1, I briefly discussed using <i>restartable blocks</i>. This, you might remember, is the process of handling in chunks data sets too large to fit in memory so that they can be processed just about as fast as if they did fit in memory. The restartable block approach is very fast but is relatively difficult to program.</p>

  <p>At the opposite end of the spectrum lies byte-by-byte processing, whereby DOS (or, in less extreme cases, a group of library functions) is allowed to do all the hard work, so that you only have to deal with one byte at a time. Byte-by-byte processing is easy to program but can be extremely slow, due to the vast overhead that results from invoking DOS each time a byte must be processed.</p>

  <p>Sound familiar? It should. I moved via the byte-by-byte approach, and the overhead of driving back and forth made for miserable performance. Renting a truck (the restartable block approach) would have required more effort and forethought, but would have paid off handsomely.</p>

  <table width="100%">
    <tr>
      <td align="left" valign="top" width="5%"><img src="images/i.jpg" /></td>

      <td align="left" valign="top" width="95%"><small><i>The easy, familiar approach often has nothing in its favor except that it requires less thinking; not a great virtue when writing high-performance code&mdash;or when moving.</i></small></td>
    </tr>
  </table>

  <p>And with that, let&rsquo;s look at a fairly complex application of restartable blocks.</p>

  <h4 align="left"><a id="Heading3"></a>Searching for Text</h4>

  <p>The application we&rsquo;re going to examine searches a file for a specified string. We&rsquo;ll develop a program that will search the file specified on the command line for a string (also specified on the comline), then report whether the string was found or not. (Because the searched-for string is obtained via <b>argv</b>, it can&rsquo;t contain any whitespace characters.)</p>

  <p>This is a <i>very</i> limited subset of what search utilities such as grep can do, and isn&rsquo;t really intended to be a generally useful application; the purpose is to provide insight into restartable blocks in particular and optimization in general in the course of developing a search engine. That search engine will, however, be easy to plug into any program, and there&rsquo;s nothing preventing you from using it in a more fruitful context, like searching through a user-selectable file set.</p>

  <p>The first point to address in designing our program involves the appropriate text-search approach to use. Literally dozens of workable ways exist to search a file. We can immediately discard all approaches that involve reading any byte of the file more than once, because disk access time is orders of magnitude slower than any data handling performed by our own code. Based on our experience in Chapter 1, we can also discard all approaches that get bytes either one at a time or in small sets from DOS. We want to read big &ldquo;buffers-full&rdquo; of bytes at a pop from the searched file, and the bigger the buffer the better&mdash;in order to minimize DOS&rsquo;s overhead. A good rough cut is a buffer that will be between 16K and 64K, depending on the exact search approach, 64K being the maximum size because near pointers make for superior performance.</p>

  <p>So we know we want to work with a large buffer, filling it as infrequently as possible. Now we have to figure out how to search through a file by loading it into that large buffer in chunks. To accomplish this, we have to know how we want to do our searching, and that&rsquo;s not immediately obvious. Where do we begin?</p>

  <p>Well, it might be instructive to consider how we would search if our search involved only one buffer, already resident in memory. In other words, suppose we don&rsquo;t have to bother with file handling at all, and further suppose that we don&rsquo;t have to deal with searching through multiple blocks. After all, that&rsquo;s a good description of the all-important inner loop of our searching program, where the program will spend virtually all of its time (aside from the unavoidable disk access overhead).</p>

  <h3><a id="Heading4"></a>Avoiding the String Trap</h3>

  <p>The easiest approach would be to use a C/C<small>++</small> library function. The closest match to what we need is <b>strstr()</b>, which searches one string for the first occurrence of a second string. However, while <b>strstr()</b> would work, it isn&rsquo;t ideal for our purposes. The problem is this: Where we want to search a fixed-length buffer for the first occurrence of a string, <b>strstr()</b> searches a <i>string</i> for the first occurrence of another string.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="04-10.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="05-02.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div><!-- all of the reference materials (books) have the footer and subfoot reveresed -->
  <!-- reference_subfoot = footer -->
  <!-- reference_footer = subfoot -->
  <!-- BEGIN SUB FOOTER -->
  <!-- END FOOTER -->
</body>
</html>
