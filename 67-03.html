<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: Sorted Spans in Action</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=67//-->
<!--PAGES=1230-1238//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><BODY LINK=#0000FF ALINK=#000099 VLINK=#0000FF BGCOLOR=#FFFFFF>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="67-02.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="67-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H4 ALIGN="LEFT"><A NAME="Heading7"></A><FONT COLOR="#000077">Independent Span Sorting</FONT></H4>
<P>Finally, we come to independent span sorting, the simplest and fastest of the three, and the type the sample code in Listing 67.1 uses. Here, polygons never intersect or touch any other polygons except adjacent polygons with which they form a continuous mesh. This means that when a polygon starts on a scan line, a single 1/z comparison between that polygon and the polygons it overlaps on the screen is guaranteed to produce correct sorting, with no extra calculations or tricky cases to worry about.
</P>
<P>Independent span sorting is ideal for scenes with lots of moving objects that never actually touch each other, such as a space battle. Next, we&rsquo;ll look at an implementation of independent 1/z span sorting.</P>
<H3><A NAME="Heading8"></A><FONT COLOR="#000077">1/z Span Sorting in Action</FONT></H3>
<P>Listing 67.1 is a portion of a program that demonstrates independent 1/z span sorting. This program is based on the sample 3-D clipping program from Chapter 65; however, the earlier program did hidden surface removal (HSR) by simply z-sorting whole objects and drawing them back-to-front, while Listing 67.1 draws all polygons by way of a 1/z-sorted edge list. Consequently, where the earlier program worked only so long as object centers correctly described sorting order, Listing 67.1 works properly for all combinations of non-intersecting and non-abutting polygons. In particular, Listing 67.1 correctly handles concave polyhedra; a new L-shaped object (the data for which is not included in Listing 67.1) has been added to the sample program to illustrate this capability. The ability to handle complex shapes makes Listing 67.1 vastly more useful for real-world applications than the 3-D clipping demo from Chapter 65.
</P>
<P><B>Listing 67.1  L67_1.C</B></P>
<!-- CODE //-->
<PRE>
// Part of Win32 program to demonstrate z-sorted spans. Whitespace
// removed for space reasons. Full source code, with whitespace,
// available from ftp.idsoftware.com/mikeab/ddjzsort.zip.

#define MAX_SPANS           10000
#define MAX_SURFS           1000
#define MAX_EDGES           5000

typedef struct surf_s {
    struct surf_s   *pnext, *pprev;
    int             color, visxstart, state;
    double          zinv00, zinvstepx, zinvstepy;
} surf_t;

typedef struct edge_s {
    int             x, xstep, leading;
    surf_t          *psurf;
    struct edge_s   *pnext, *pprev, *pnextremove;
} edge_t;

// Span, edge, and surface lists
span_t  spans[MAX_SPANS];
edge_t  edges[MAX_EDGES];
surf_t  surfs[MAX_SURFS];

// Bucket list of new edges to add on each scan line
edge_t  newedges[MAX_SCREEN_HEIGHT];

// Bucket list of edges to remove on each scan line
edge_t  *removeedges[MAX_SCREEN_HEIGHT];

// Head and tail for the active edge list
edge_t  edgehead, edgetail;

// Edge used as sentinel of new edge lists
edge_t  maxedge = {0x7FFFFFFF};

// Head/tail/sentinel/background surface of active surface stack
surf_t  surfstack;

// pointers to next available surface and edge
surf_t  *pavailsurf;
edge_t  *pavailedge;


// Returns true if polygon faces the viewpoint, assuming a clockwise
// winding of vertices as seen from the front.
int PolyFacesViewer(polygon_t *ppoly, plane_t *pplane)
{
    int     i;
    point_t viewvec;

    for (i=0 ; i&lt;3 ; i++)
        viewvec.v[i] = ppoly-&gt;verts[0].v[i] - currentpos.v[i];
    // Use an epsilon here so we don&rsquo;t get polygons tilted so
    // sharply that the gradients are unusable or invalid
    if (DotProduct (&ampviewvec, &amppplane-&gt;normal) &lt; -0.01)
        return 1;
    return 0;
}


// Add the polygon&rsquo;s edges to the global edge table.
void AddPolygonEdges (plane_t *plane, polygon2D_t *screenpoly)
{
    double  distinv, deltax, deltay, slope;
    int     i, nextvert, numverts, temp, topy, bottomy, height;
    edge_t  *pedge;

    numverts = screenpoly-&gt;numverts;

    // Clamp the polygon&rsquo;s vertices just in case some very near
    // points have wandered out of range due to floating-point
    // imprecision
    for (i=0 ; i&lt;numverts ; i++) {
        if (screenpoly-&gt;verts[i].x &lt; -0.5)
            screenpoly-&gt;verts[i].x = -0.5;
        if (screenpoly-&gt;verts[i].x &gt; ((double)DIBWidth - 0.5))
            screenpoly-&gt;verts[i].x = (double)DIBWidth - 0.5;
        if (screenpoly-&gt;verts[i].y &lt; -0.5)
            screenpoly-&gt;verts[i].y = -0.5;
        if (screenpoly-&gt;verts[i].y &gt; ((double)DIBHeight - 0.5))
            screenpoly-&gt;verts[i].y = (double)DIBHeight - 0.5;
    }

    // Add each edge in turn
    for (i=0 ; i&lt;numverts ; i++) {
        nextvert = i + 1;
        if (nextvert &gt;= numverts)
            nextvert = 0;
        topy = (int)ceil(screenpoly-&gt;verts[i].y);
        bottomy = (int)ceil(screenpoly-&gt;verts[nextvert].y);
        height = bottomy - topy;
        if (height == 0)
            continue;       // doesn&rsquo;t cross any scan lines
        if (height &lt; 0) {
            // Leading edge
            temp = topy;
            topy = bottomy;
            bottomy = temp;
            pavailedge-&gt;leading = 1;
            deltax = screenpoly-&gt;verts[i].x -
                     screenpoly-&gt;verts[nextvert].x;
            deltay = screenpoly-&gt;verts[i].y -
                     screenpoly-&gt;verts[nextvert].y;
            slope = deltax / deltay;
            // Edge coordinates are in 16.16 fixed point
            pavailedge-&gt;xstep = (int)(slope * (float)0x10000);
            pavailedge-&gt;x = (int)((screenpoly-&gt;verts[nextvert].x +
                ((float)topy - screenpoly-&gt;verts[nextvert].y) *
                slope) * (float)0x10000);
        } else {
            // Trailing edge
            pavailedge-&gt;leading = 0;
            deltax = screenpoly-&gt;verts[nextvert].x -
                     screenpoly-&gt;verts[i].x;
            deltay = screenpoly-&gt;verts[nextvert].y -
                     screenpoly-&gt;verts[i].y;
            slope = deltax / deltay;
            // Edge coordinates are in 16.16 fixed point
            pavailedge-&gt;xstep = (int)(slope * (float)0x10000);
            pavailedge-&gt;x = (int)((screenpoly-&gt;verts[i].x +
                ((float)topy - screenpoly-&gt;verts[i].y) * slope) *
                (float)0x10000);
        }

        // Put the edge on the list to be added on top scan
        pedge = &ampnewedges[topy];
        while (pedge-&gt;pnext-&gt;x &lt; pavailedge-&gt;x)
            pedge = pedge-&gt;pnext;
        pavailedge-&gt;pnext = pedge-&gt;pnext;
        pedge-&gt;pnext = pavailedge;

        // Put the edge on the list to be removed after final scan
        pavailedge-&gt;pnextremove = removeedges[bottomy - 1];
        removeedges[bottomy - 1] = pavailedge;

        // Associate the edge with the surface we&rsquo;ll create for
        // this polygon
        pavailedge-&gt;psurf = pavailsurf;

        // Make sure we don&rsquo;t overflow the edge array
        if (pavailedge &lt; &ampedges[MAX_EDGES])
            pavailedge++;
    }

    // Create the surface, so we&rsquo;ll know how to sort and draw from
    // the edges
    pavailsurf-&gt;state = 0;
    pavailsurf-&gt;color = currentcolor;

    // Set up the 1/z gradients from the polygon, calculating the
    // base value at screen coordinate 0,0 so we can use screen
    // coordinates directly when calculating 1/z from the gradients
    distinv = 1.0 / plane-&gt;distance;
    pavailsurf-&gt;zinvstepx = plane-&gt;normal.v[0] * distinv *
            maxscreenscaleinv * (fieldofview / 2.0);
    pavailsurf-&gt;zinvstepy = -plane-&gt;normal.v[1] * distinv *
            maxscreenscaleinv * (fieldofview / 2.0);
    pavailsurf-&gt;zinv00 = plane-&gt;normal.v[2] * distinv -
            xcenter * pavailsurf-&gt;zinvstepx -
            ycenter * pavailsurf-&gt;zinvstepy;

    // Make sure we don&rsquo;t overflow the surface array
    if (pavailsurf &lt; &ampsurfs[MAX_SURFS])
        pavailsurf++;
}


// Scan all the edges in the global edge table into spans.
void ScanEdges (void)
{
    int     x, y;
    double  fx, fy, zinv, zinv2;
    edge_t  *pedge, *pedge2, *ptemp;
    span_t  *pspan;
    surf_t  *psurf, *psurf2;

    pspan = spans;

    // Set up the active edge list as initially empty, containing
    // only the sentinels (which are also the background fill). Most
    // of these fields could be set up just once at start-up
    edgehead.pnext = &ampedgetail;
    edgehead.pprev = NULL;
    edgehead.x = -0xFFFF;           // left edge of screen
    edgehead.leading = 1;
    edgehead.psurf = &ampsurfstack;
    edgetail.pnext = NULL;          // mark edge of list
    edgetail.pprev = &ampedgehead;
    edgetail.x = DIBWidth &lt;&lt; 16;    // right edge of screen
    edgetail.leading = 0;
    edgetail.psurf = &ampsurfstack;

    // The background surface is the entire stack initially, and
    // is infinitely far away, so everything sorts in front of it.
    // This could be set just once at start-up
    surfstack.pnext = surfstack.pprev = &ampsurfstack;
    surfstack.color = 0;
    surfstack.zinv00 = -999999.0;
    surfstack.zinvstepx = surfstack.zinvstepy = 0.0;
    for (y=0 ; y&lt;DIBHeight ; y++) {
        fy = (double)y;
        // Sort in any edges that start on this scan
        pedge = newedges[y].pnext;
        pedge2 = &ampedgehead;
        while (pedge != &ampmaxedge) {
            while (pedge-&gt;x &gt; pedge2-&gt;pnext-&gt;x)
                pedge2 = pedge2-&gt;pnext;
            ptemp = pedge-&gt;pnext;
            pedge-&gt;pnext = pedge2-&gt;pnext;
            pedge-&gt;pprev = pedge2;
            pedge2-&gt;pnext-&gt;pprev = pedge;
            pedge2-&gt;pnext = pedge;
            pedge2 = pedge;
            pedge = ptemp;
        }

        // Scan out the active edges into spans
        // Start out with the left background edge already inserted,
        // and the surface stack containing only the background
        surfstack.state = 1;
        surfstack.visxstart = 0;
        for (pedge=edgehead.pnext ; pedge ; pedge=pedge-&gt;pnext) {
            psurf = pedge-&gt;psurf;
            if (pedge-&gt;leading) {
                // It&rsquo;s a leading edge. Figure out where it is
                // relative to the current surfaces and insert in
                // the surface stack; if it&rsquo;s on top, emit the span
                // for the current top.
                // First, make sure the edges don&rsquo;t cross
                if (++psurf-&gt;state == 1) {
                    fx = (double)pedge-&gt;x * (1.0 / (double)0x10000);
                    // Calculate the surface&rsquo;s 1/z value at this pixel
                    zinv = psurf-&gt;zinv00 + psurf-&gt;zinvstepx * fx +
                            psurf-&gt;zinvstepy * fy;
                    // See if that makes it a new top surface
                    psurf2 = surfstack.pnext;
                    zinv2 = psurf2-&gt;zinv00 + psurf2-&gt;zinvstepx * fx +
                            psurf2-&gt;zinvstepy * fy;
                    if (zinv &gt;= zinv2) {
                        // It&rsquo;s a new top surface
                        // emit the span for the current top
                        x = (pedge-&gt;x + 0xFFFF) &gt;&gt; 16;
                        pspan-&gt;count = x - psurf2-&gt;visxstart;
                        if (pspan-&gt;count &gt; 0) {
                            pspan-&gt;y = y;
                            pspan-&gt;x = psurf2-&gt;visxstart;
                            pspan-&gt;color = psurf2-&gt;color;
                            // Make sure we don&rsquo;t overflow
                            // the span array
                            if (pspan &lt; &ampspans[MAX_SPANS])
                                pspan++;
                        }
                        psurf-&gt;visxstart = x;
                        // Add the edge to the stack
                        psurf-&gt;pnext = psurf2;
                        psurf2-&gt;pprev = psurf;
                        surfstack.pnext = psurf;
                        psurf-&gt;pprev = &ampsurfstack;
                    } else {
                        // Not a new top; sort into the surface stack.
                        // Guaranteed to terminate due to sentinel
                        // background surface
                        do {
                            psurf2 = psurf2-&gt;pnext;
                            zinv2 = psurf2-&gt;zinv00 +
                                    psurf2-&gt;zinvstepx * fx +
                                    psurf2-&gt;zinvstepy * fy;
                        } while (zinv &lt; zinv2);
                        // Insert the surface into the stack
                        psurf-&gt;pnext = psurf2;
                        psurf-&gt;pprev = psurf2-&gt;pprev;
                        psurf2-&gt;pprev-&gt;pnext = psurf;
                        psurf2-&gt;pprev = psurf;
                    }
                }
            } else {
                // It&rsquo;s a trailing edge; if this was the top surface,
                // emit the span and remove it.
                // First, make sure the edges didn&rsquo;t cross
                if (&mdash;psurf-&gt;state == 0) {
                    if (surfstack.pnext == psurf) {
                        // It&rsquo;s on top, emit the span
                        x = ((pedge-&gt;x + 0xFFFF) &gt;&gt; 16);
                        pspan-&gt;count = x - psurf-&gt;visxstart;
                        if (pspan-&gt;count &gt; 0) {
                            pspan-&gt;y = y;
                            pspan-&gt;x = psurf-&gt;visxstart;
                            pspan-&gt;color = psurf-&gt;color;
                            // Make sure we don&rsquo;t overflow
                            // the span array
                            if (pspan &lt; &ampspans[MAX_SPANS])
                                pspan++;
                        }
                        psurf-&gt;pnext-&gt;visxstart = x;
                    }
                    // Remove the surface from the stack
                    psurf-&gt;pnext-&gt;pprev = psurf-&gt;pprev;
                    psurf-&gt;pprev-&gt;pnext = psurf-&gt;pnext;
                }
            }
        }

        // Remove edges that are done
        pedge = removeedges[y];
        while (pedge) {
            pedge-&gt;pprev-&gt;pnext = pedge-&gt;pnext;
            pedge-&gt;pnext-&gt;pprev = pedge-&gt;pprev;
            pedge = pedge-&gt;pnextremove;
        }

        // Step the remaining edges one scan line, and re-sort
        for (pedge=edgehead.pnext ; pedge != &ampedgetail ; ) {
            ptemp = pedge-&gt;pnext;
            // Step the edge
            pedge-&gt;x += pedge-&gt;xstep;
            // Move the edge back to the proper sorted location,
            // if necessary
            while (pedge-&gt;x &lt; pedge-&gt;pprev-&gt;x) {
                pedge2 = pedge-&gt;pprev;
                pedge2-&gt;pnext = pedge-&gt;pnext;
                pedge-&gt;pnext-&gt;pprev = pedge2;
                pedge2-&gt;pprev-&gt;pnext = pedge;
                pedge-&gt;pprev = pedge2-&gt;pprev;
                pedge-&gt;pnext = pedge2;
                pedge2-&gt;pprev = pedge;
            }
            pedge = ptemp;
        }
    }
    pspan-&gt;x = -1;  // mark the end of the list
}

// Draw all the spans that were scanned out.
void DrawSpans (void)
{
    span_t  *pspan;
    for (pspan=spans ; pspan-&gt;x != -1 ; pspan++)
        memset (pDIB + (DIBPitch * pspan-&gt;y) + pspan-&gt;x,
                pspan-&gt;color,
                pspan-&gt;count);
}


// Clear the lists of edges to add and remove on each scan line.
void ClearEdgeLists(void)
{
    int i;
    for (i=0 ; i&lt;DIBHeight ; i++) {
        newedges[i].pnext = &ampmaxedge;
        removeedges[i] = NULL;
    }
}

// Render the current state of the world to the screen.
void UpdateWorld()
{
    HPALETTE        holdpal;
    HDC             hdcScreen, hdcDIBSection;
    HBITMAP         holdbitmap;
    polygon2D_t     screenpoly;
    polygon_t       *ppoly, tpoly0, tpoly1, tpoly2;
    convexobject_t  *pobject;
    int             i, j, k;
    plane_t         plane;
    point_t         tnormal;

    UpdateViewPos();
    SetUpFrustum();
    ClearEdgeLists();
    pavailsurf = surfs;
    pavailedge = edges;

    // Draw all visible faces in all objects
    pobject = objecthead.pnext;
    while (pobject != &ampobjecthead) {
        ppoly = pobject-&gt;ppoly;
        for (i=0 ; i&lt;pobject-&gt;numpolys ; i++) {
            // Move the polygon relative to the object center
            tpoly0.numverts = ppoly[i].numverts;
            for (j=0 ; j&lt;tpoly0.numverts ; j++) {
                for (k=0 ; k&lt;3 ; k++)
                    tpoly0.verts[j].v[k] = ppoly[i].verts[j].v[k] +
                            pobject-&gt;center.v[k];
            }
            if (PolyFacesViewer(&amptpoly0, &ampppoly[i].plane)) {
                if (ClipToFrustum(&amptpoly0, &amptpoly1)) {
                    currentcolor = ppoly[i].color;
                    TransformPolygon (&amptpoly1, &amptpoly2);
                    ProjectPolygon (&amptpoly2, &ampscreenpoly);

                    // Move the polygon&rsquo;s plane into viewspace
                    // First move it into worldspace (object relative)
                    tnormal = ppoly[i].plane.normal;
                    plane.distance = ppoly[i].plane.distance +
                        DotProduct (&amppobject-&gt;center, &amptnormal);

                    // Now transform it into viewspace
                    // Determine the distance from the viewpont
                    plane.distance -=
                          DotProduct (&ampcurrentpos, &amptnormal);

                    // Rotate the normal into view orientation
                    plane.normal.v[0] =
                            DotProduct (&amptnormal, &ampvright);
                    plane.normal.v[1] =
                            DotProduct (&amptnormal, &ampvup);
                    plane.normal.v[2] =
                            DotProduct (&amptnormal, &ampvpn);
                    AddPolygonEdges (&ampplane, &ampscreenpoly);
                }
            }
        }
        pobject = pobject-&gt;pnext;
    }
    ScanEdges ();
    DrawSpans ();

    // We&rsquo;ve drawn the frame; copy it to the screen
    hdcScreen = GetDC(hwndOutput);
    holdpal = SelectPalette(hdcScreen, hpalDIB, FALSE);
    RealizePalette(hdcScreen);
    hdcDIBSection = CreateCompatibleDC(hdcScreen);
    holdbitmap = SelectObject(hdcDIBSection, hDIBSection);
    BitBlt(hdcScreen, 0, 0, DIBWidth, DIBHeight, hdcDIBSection,
           0, 0, SRCCOPY);
    SelectPalette(hdcScreen, holdpal, FALSE);
    ReleaseDC(hwndOutput, hdcScreen);
    SelectObject(hdcDIBSection, holdbitmap);
    DeleteDC(hdcDIBSection);
}
</PRE>
<!-- END CODE //-->
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="67-02.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="67-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Graphics Programming Black Book &copy; 2001 Michael Abrash</font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


