The key to understanding Listing 26.1 is understanding the effect of
ANDing the rotated CPU data with the contents of the Bit Mask register.
The CPU data is the pattern for the character to be drawn, with bits
equal to 1 indicating where character pixels are to appear. The Data
Rotate register is set to rotate the CPU data to pixel-align it, since
without rotation characters could only be drawn on byte boundaries.

  ------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ![](images/i.jpg)   *As I pointed out in Chapter 25, the CPU is perfectly capable of rotating the data itself, and it's often the case that that's more efficient. The problem with using the Data Rotate register is that the **OUT** that sets that register is time-consuming, especially for proportional text, which requires a different rotation for each character. Also, if the code performs full-byte accesses to display memory—that is, if it combines pieces of two adjacent characters into one byte—whenever possible for efficiency, the CPU generally has to do extra work to prepare the data so the VGA's rotator can handle it.*
  ------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

At the same time that the Data Rotate register is set, the Bit Mask
register is set to allow the CPU to modify only that portion of the
display memory byte accessed that the pixel-aligned character falls in,
so that other characters and/or graphics data won't be wiped out. The
result of ANDing the rotated CPU data byte with the contents of the Bit
Mask register is a bit mask that allows only the bits equal to 1 in the
original character pattern (rotated and masked to provide pixel
alignment) to be modified by the CPU; all other bits come straight from
the latches. The latches should have previously been loaded from the
target address, so the effect of the ultimate synthesized bit mask value
is to allow the CPU to modify only those pixels in display memory that
correspond to the 1 bits in that part of the pixel-aligned character
that falls in the currently addressed byte. The color of the pixels set
by the CPU is determined by the contents of the Set/Reset register.

Whew. It sounds complex, but given an understanding of what the data
rotator, set/reset, and the bit mask do, it's not that bad. One good way
to make sense of it is to refer to the original text-drawing program in
Listing 25.1 back in Chapter 25, and then see how Listing 26.1 differs
from that program.

It's worth noting that the results generated by Listing 26.1 could have
been accomplished without write mode 3. Write mode 0 could have been
used instead, but at a significant performance cost. Instead of letting
write mode 3 rotate the CPU data and AND it with the contents of the Bit
Mask register, the CPU could simply have rotated the CPU data directly
and ANDed it with the value destined for the Bit Mask register and then
set the Bit Mask register to the resulting value. Additionally, enable
set/reset could have been forced on for all planes, emulating what write
mode 3 does to provide pixel colors.

The write mode 3 approach used in Listing 26.1 can be efficiently
extended to drawing large blocks of text. For example, suppose that we
were to draw a line of 8-pixel-wide bit-mapped text 40 characters long.
We could then set up the bit mask and data rotation as appropriate for
the left portion of each bit-aligned character (the portion of each
character to the left of the byte boundary) and then draw the left
portions only of all 40 characters in write mode 3. Then the bit mask
could be set up for the right portion of each character, and the right
portions of all 40 characters could be drawn. The VGA's fast rotator
would be used to do all rotation, and the only **OUT**s required would
be those required to set the bit mask and data rotation. This technique
could well outperform single-character bit-mapped text drivers such as
the one in Listing 26.1 by a significant margin. Listing 26.2
illustrates one implementation of such an approach. Incidentally, note
the use of the 8x14 ROM font in Listing 26.2, rather than the 8x8 ROM
font used in Listing 26.1. There is also an 8x16 font stored in ROM,
along with the tables used to alter the 8x14 and 8x16 ROM fonts into
9x14 and 9x16 fonts.

**LISTING 26.2 L26-2.ASM**

    ; Program to illustrate high-speed text-drawing operation of
    ;  write mode 3 of the VGA.
    ;  Draws a string of 8x14 characters at arbitrary locations
    ;  without disturbing the background, using VGA's 8x14 ROM font.
    ;  Designed for use with modes 0Dh, 0Eh, 0Fh, 10h, and 12h.
    ; Runs only on VGAs (in Models 50 & up and IBM Display Adapter
    ;  and 100% compatibles).
    ; Assembled with MASM
    ; By Michael Abrash
    ;
    stack   segment para stack ‘STACK'
            db      512 dup(?)
    stack   ends
    ;
    VGA_VIDEO_SEGMENT       equ     0a000h      ;VGA display memory segment
    SCREEN_WIDTH_IN_BYTES   equ     044ah       ;offset of BIOS variable
    FONT_CHARACTER_SIZE     equ     14          ;# bytes in each font char
    ;
    ; VGA register equates.
    ;
    SC_INDEX                equ     3c4h        ;SC index register
    SC_MAP_MASK             equ     2           ;SC map mask register index
    GC_INDEX                equ     3ceh        ;GC index register
    GC_SET_RESET            equ     0           ;GC set/reset register index
    GC_ENABLE_SET_RESET     equ     1           ;GC enable set/reset register index
    GC_ROTATE               equ     3           ;GC data rotate/logical function
                                                ; register index
    GC_MODE                 equ     5           ;GC Mode register
    GC_BIT_MASK             equ     8           ;GC bit mask register index
    ;
    dseg    segment para common ‘DATA'
    TEST_TEXT_ROW           equ     69          ;row to display test text at
    TEST_TEXT_COL           equ     17          ;column to display test text at
    TEST_TEXT_COLOR         equ     0fh         ;high intensity white
    TestString      label   byte
            db      ‘Hello, world!',0           ;test string to print.
    FontPointer     dd      ?                   ;font offset
    dseg    ends
    ;
    cseg    segment para public ‘CODE'
            assume  cs:cseg, ds:dseg
    start   proc    near
            mov     ax,dseg
            mov     ds,ax
    ;
    ; Select 640x480 graphics mode.
    ;
            mov     ax,012h
            int     10h
    ;
    ; Set the screen to all blue, using the readability of VGA registers
    ; to preserve reserved bits.
    ;
            mov     dx,GC_INDEX
            mov     al,GC_SET_RESET
            out     dx,al
            inc     dx
            in      al,dx
            and     al,0f0h
            or      al,1                ;blue plane only set, others reset
            out     dx,al
            dec     dx
            mov     al,GC_ENABLE_SET_RESET
            out     dx,al
            inc     dx
            in      al,dx
            and     al,0f0h
            or      al,0fh              ;enable set/reset for all planes
            out     dx,al
            mov     dx,VGA_VIDEO_SEGMENT
            mov     es,dx               ;point to display memory
            mov     di,0
            mov     cx,8000h            ;fill all 32k words
            mov     ax,0ffffh           ;because of set/reset, the value
                                        ; written actually doesn't matter
            rep stosw                   ;fill with blue
    ;
    ; Set driver to use the 8x14 font.
    ;
            mov     ah,11h          ;VGA BIOS character generator function,
            mov     al,30h          ; return info subfunction
            mov     bh,2            ;get 8x14 font pointer
            int     10h
            call    SelectFont
    ;
    ; Print the test string.
    ;
            mov     si,offset TestString
            mov     bx,TEST_TEXT_ROW
            mov     cx,TEST_TEXT_COL
            mov     ah,TEST_TEXT_COLOR
            call    DrawString
    ;
    ; Wait for a key, then set to text mode & end.
    ;
            mov     ah,1
            int     21h             ;wait for a key
            mov     ax,3
            int     10h             ;restore text mode
    ;
    ; Exit to DOS.
    ;
            mov     ah,4ch
            int     21h
    Start   endp
    ;
    ; Subroutine to draw a text string left-to-right in a linear
    ;  graphics mode (0Dh, 0Eh, 0Fh, 010h, 012h) with 8-dot-wide
    ;  characters. Background around the pixels that make up the
    ;  characters is preserved.
    ; Font used should be pointed to by FontPointer.
    ;
    ; Input:
    ;  AH = color to draw string in
    ;  BX = row to draw string on
    ;  CX = column to start string at
    ;  DS:SI = string to draw
    ;
    ;  Forces ALU function to "move".
    ;  Forces write mode 3.
    ;
    DrawString      proc    near
            push    ax
            push    bx
            push    cx
            push    dx
            push    si
            push    di
            push    bp
            push    ds
    ;
    ; Set up set/reset to produce character color, using the readability
    ; of VGA register to preserve the setting of reserved bits 7-4.
    ;
            mov     dx,GC_INDEX
            mov     al,GC_SET_RESET
            out     dx,al
            inc     dx
            in      al,dx
            and     al,0f0h
            and     ah,0fh
            or      al,ah
            out     dx,al
    ;
    ; Select write mode 3, using the readability of VGA registers
    ; to leave bits other than the write mode bits unchanged.
    ;
            mov     dx,GC_INDEX
            mov     al,GC_MODE
            out     dx,al
            inc     dx
            in      al,dx
            or      al,3
            out     dx,al
            mov     dx,VGA_VIDEO_SEGMENT
            mov     es,dx                   ;point to display memory
    ;
    ; Calculate screen address of byte character starts in.
    ;
            push    ds              ;point to BIOS data segment
            sub     dx,dx
            mov     ds,dx
            mov     di,ds:[SCREEN_WIDTH_IN_BYTES]   ;retrieve BIOS
                                                    ; screen width
            pop     ds
            mov     ax,bx           ;row
            mul     di              ;calculate offset of start of row
            push    di              ;set aside screen width
            mov     di,cx           ;set aside the column
            and     cl,0111b        ;keep only the column in-byte address
            shr     di,1
            shr     di,1
            shr     di,1            ;divide column by 8 to make a byte address
            add     di,ax           ;and point to byte
    ;
    ; Set up the GC rotation. In write mode 3, this is the rotation
    ; of CPU data before it is ANDed with the Bit Mask register to
    ; form the bit mask. Force the ALU function to "move". Uses the
    ; readability of VGA registers to leave reserved bits unchanged.
    ;
            mov     dx,GC_INDEX
            mov     al,GC_ROTATE
            out     dx,al
            inc     dx
            in      al,dx
            and     al,0e0h
            or      al,cl
            out     dx,al
    ;
    ; Set up BH as bit mask for left half, BL as rotation for right half.
    ;
            mov     bx,0ffffh
            shr     bh,cl
            neg     cl
            add     cl,8
            shl     bl,cl
    ;
    ; Draw all characters, left portion first, then right portion in the
    ; succeeding byte, using the data rotation to position the character
    ; across the byte boundary and then using write mode 3 to combine the
    ; character data with the bit mask to allow the set/reset value (the
    ; character color) through only for the proper portion (where the
    ; font bits for the character are 1) of the character for each byte.
    ; Wherever the font bits for the character are 0, the background
    ; color is preserved.
    ; Does not check for case where character is byte-aligned and
    ; no rotation and only one write is required.
    ;
    ; Draw the left portion of each character in the string.
    ;
            pop     cx              ;get back screen width
            push    si
            push    di
            push    bx
    ;
    ; Set the bit mask for the left half of the character.
    ;
            mov     dx,GC_INDEX
            mov     al,GC_BIT_MASK
            mov     ah,bh
            out     dx,ax
    LeftHalfLoop:
            lodsb
            and     al,al
            jz      LeftHalfLoopDone
            call    CharacterUp
            inc     di              ;point to next character location
            jmp     LeftHalfLoop
    LeftHalfLoopDone:
            pop     bx
            pop     di
            pop     si
    ;
    ; Draw the right portion of each character in the string.
    ;
            inc     di              ;right portion of each character is across
                                    ; byte boundary
    ;
    ; Set the bit mask for the right half of the character.
    ;
            mov     dx,GC_INDEX
            mov     al,GC_BIT_MASK
            mov     ah,bl
            out     dx,ax
    RightHalfLoop:
            lodsb
            and     al,al
            jz      RightHalfLoopDone
            call    CharacterUp
            inc     di              ;point to next character location
            jmp     RightHalfLoop
    RightHalfLoopDone:
    ;
            pop     ds
            pop     bp
            pop     di
            pop     si
            pop     dx
            pop     cx
            pop     bx
            pop     ax
            ret
    DrawString      endp
    ;
    ; Draw a character.
    ;
    ; Input:
    ;  AL = character
    ;  CX = screen width
    ;  ES:DI = address to draw character at
    ;
    CharacterUp     proc    near
            push    cx
            push    si
            push    di
            push    ds
    ;
    ; Set DS:SI to point to font and ES to point to display memory.
    ;
            lds     si,[FontPointer]        ;point to font
    ;
    ; Calculate font address of character.
    ;
            mov     bl,14           ;14 bytes per character
            mul     bl
            add     si,ax           ;offset in font segment of character

            mov     bp,FONT_CHARACTER_SIZE
            dec     cx              ; -1 because one byte per char
    CharacterLoop:
            lodsb                   ;get character byte
            mov     ah,es:[di]      ;load latches
            stosb                   ;write character byte
    ;
    ; Point to next line of character in display memory.
    ;
            add     di,cx
    ;
            dec     bp
            jnz     CharacterLoop
    ;
            pop     ds
            pop     di
            pop     si
            pop     cx
            ret
    CharacterUp     endp
    ;
    ; Set the pointer to the font to draw from to ES:BP.
    ;
    SelectFont      proc    near
            mov     word ptr [FontPointer],bp       ;save pointer
            mov     word ptr [FontPointer+2],es
            ret
    SelectFont      endp
    ;
    cseg    ends
            end     start

In this chapter, I've tried to give you a feel for how write mode 3
works and what it might be used for, rather than providing polished,
optimized, plug-it-in-and-go code. Like the rest of the VGA's write
path, write mode 3 is a resource that can be used in a remarkable
variety of ways, and I don't want to lock you into thinking of it as
useful in just one context. Instead, you should take the time to
thoroughly understand what write mode 3 does, and then, when you do VGA
programming, think about how write mode 3 can best be applied to the
task at hand. Because I focused on illustrating the operation of write
mode 3, neither listing in this chapter is the fastest way to accomplish
the desired result. For example, Listing 26.2 could be made nearly twice
as fast by simply having the CPU rotate, mask, and join the bytes from
adjacent characters, then draw the combined bytes to display memory in a
single operation.

Similarly, Listing 26.1 is designed to illustrate write mode 3 and its
interaction with the rest of the VGA as a contrast to Listing 25.1 in
Chapter 25, rather than for maximum speed, and it could be made
considerably more efficient. If we were going for performance, we'd have
the CPU not only rotate the bytes into position, but also do the masking
by ANDing in software. Even more significantly, we would have the CPU
combine adjacent characters into complete, rotated bytes whenever
possible, so that only one drawing operation would be required per byte
of display memory modified. By doing this, we would eliminate all
per-character **OUT**s, and would minimize display memory accesses,
approximately doubling text-drawing speed.

As a final note, consider that non-transparent text could also be
accelerated with write mode 3. The latches could be filled with the
background (text box) color, set/reset could be set to the foreground
(text) color, and write mode 3 could then be used to turn monochrome
text bytes written by the CPU into characters on the screen with just
one write per byte. There are complications, such as drawing partial
bytes, and rotating the bytes to align the characters, which we'll
revisit later on in Chapter 55, while we're working through the details
of the X-Sharp library. Nonetheless, the performance benefit of this
approach can be a speedup of as much as four times—all thanks to the
decidedly quirky but surprisingly powerful and flexible write mode 3.

### A Note on Preserving Register Bits {#Heading4}

If you take a quick look, you'll see that the code in Listing 26.1 uses
the readable register feature of the VGA to preserve reserved bits and
bits other than those being modified. Older adapters such as the CGA and
EGA had few readable registers, so it was necessary to set all bits in a
register whenever that register was modified. Happily, all VGA registers
are readable, which makes it possible to change only those bits of
immediate interest, and, in general, I highly recommend doing exactly
that, since IBM (or clone manufacturers) may well someday use some of
those reserved bits or change the meanings of some of the bits that are
currently in use.
