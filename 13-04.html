<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Aiming the 486</title>
  <meta name="chapter" content="13" />
  <meta name="pages" content="256-258" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td>
          <a href="13-03.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="14-01.html">Next</a>
        </td>
      </tr>
    </table>
  </center>

  <h3 id="Heading7">32-Bit Addressing Modes</h3>

  <p>The 386 and 486 both support 32-bit addressing modes, in which any register may serve as the base memory addressing register, and almost any register may serve as the potentially scaled index register. For example,</p>
  <pre>
mov al,BaseTable[ecx+edx*4]
</pre>

  <p>uses a perfectly valid 32-bit address, with the byte accessed being the one at the offset in DS pointed to by the sum of EDX times 4 plus the offset of <b>BaseTable</b> plus ECX. This is a very powerful memory addressing scheme, far superior to 8088-style 16-bit addressing, but it&rsquo;s not without its quirks and costs, so let&rsquo;s take a quick look at 32-bit addressing. (By the way, 32-bit addressing is not limited to protected mode; 32-bit instructions may be used in real mode, although each instruction that uses 32-bit addressing must have an address-size prefix byte, and the presence of a prefix byte costs a cycle on a 486.)</p>

  <p>Any register may serve as the base register component of an address. Any register except ESP may also serve as the index register, which can be scaled by 1, 2, 4, or 8. (Scaling is very handy for performing lookups in arrays and tables.) The same register may serve as both base and index register, except for ESP, which can only be the base. Incidentally, it makes sense that ESP can&rsquo;t be scaled; ESP presumably always points to a valid stack, and I can&rsquo;t think of any reason you&rsquo;d want to use the stack pointer times 2, 4, or 8 in an address. ESP is, by its nature, a base rather than index pointer.</p>

  <p>That&rsquo;s all there is to the functionality of 32-bit addressing; it&rsquo;s very simple, much simpler than 16-bit addressing, with its sharply limited memory addressing register combinations. The costs of 32-bit addressing are a bit more subtle. The only performance cost (apart from the aforementioned 1-cycle penalty for using 32-bit addressing in real mode) is a 1-cycle penalty imposed for using an index register. In this context, you use an index register when you use a register that&rsquo;s scaled, or when you use the sum of two registers to point to memory. <b>MOV BL,[EBX*2]</b> uses an index register and takes an extra cycle, as does <b>MOV CL,[EAX+EDX]; MOV CL,[EAX+100H]</b> is not indexed, however.</p>

  <p>The other cost of 32-bit addressing is in instruction size. Old-style 16-bit addressing usually (except in a few special cases) uses one extra byte, which Intel calls the Mod-R/M byte, which is placed immediately after each instruction&rsquo;s opcode to describe the memory addressing mode, plus 1 or 2 optional bytes of addressing displacement&mdash;that is, a constant value to add into the address. In many cases, 32-bit addressing continues to use the Mod-R/M byte, albeit with a different interpretation; in these cases, 32-bit addressing is no larger than 16-bit addressing, except when a 32-bit displacement is involved. For example, <b>MOV AL, [EBX]</b> is a 2-byte instruction; <b>MOV AL, [EBX+10H]</b> is a 3-byte instruction; and <b>MOV AL, [EBX+10000H]</b> is a 6-byte instruction.</p>

  <table width="100%">
    <tr>
      <td align="left" valign="top" width="5%"><img src="images/i.jpg" /></td>

      <td align="left" valign="top" width="95%"><small><i>Note that 1 and 4-byte displacements, but not 2-byte displacements, are supported for 32-bit addressing. Code size can be greatly improved by keeping stack frame variables within 128 bytes of EBP, and variables in pointed-to structures within 127 bytes of the start of the structure, so that displacements can be 1 rather than 4 bytes.</i></small></td>
    </tr>
  </table>

  <p>However, because 32-bit addressing supports many more addressing combinations than 16-bit addressing, the Mod-R/M byte can&rsquo;t describe all the combinations. Therefore, whenever an index register (as described above) is involved, a second byte, the SIB byte, follows the Mod-R/M byte to provide additional address information. Consequently, whenever you use a scaled memory addressing register or use the sum of two registers to point to memory, you automatically add 1 cycle and 1 byte to that instruction. This is not to say that you shouldn&rsquo;t use index registers when they&rsquo;re needed, but if you find yourself using them inside key loops, you should see if it&rsquo;s possible to move the index calculation outside the loop as, for example, in a loop like this:</p>
  <pre>
LoopTop:
      add   ax,DataTable[ebx*2]
      inc   ebx
      dec   cx
      jnz   LoopTop
</pre>

  <p>You could change this to the following for greater performance:</p>
  <pre>
      add   ebx,ebx      ;ebx*2
LoopTop:
      add   ax,DataTable[ebx]
      add   ebxX,2
      dec   cx
      jnz   LoopTop
      shr   ebx,1 ;ebx*2/2
</pre>

  <p>I&rsquo;ll end this chapter with two more quirks of 32-bit addressing. First, as with 16-bit addressing, addressing that uses EBP as a base register both accesses the SS segment by default and always has a displacement of at least 1 byte. This reflects the common use of EBP to address a stack frame, but is worth keeping in mind if you should happen to use EBP to address non-stack memory.</p>

  <p>Lastly, as I mentioned, ESP cannot be scaled. In fact, ESP cannot be an index register; it must be a base register. Ironically, however, ESP is the one register that cannot be used to address memory without the presence of an SIB byte, even if it&rsquo;s used without an index register. This is an outcome of the way in which the SIB byte extends the capabilities of the Mod-R/M byte, and there&rsquo;s nothing to be done about it, but it&rsquo;s at least worth noting that ESP-based, non-indexed addressing makes for instructions that are a byte larger than other non-indexed addressing (but not any slower; there&rsquo;s no 1-cycle penalty for using ESP as a base register) on the 486.</p>

  <center>
    <table border="1">
      <tr>
        <td>
          <a href="13-03.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="14-01.html">Next</a>
        </td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
