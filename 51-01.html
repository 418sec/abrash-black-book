<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Sneakers in Space</title>
  <meta name="chapter" content="51" />
  <meta name="pages" content="951-955" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td>
          <a href="50-07.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="51-02.html">Next</a>
        </td>
      </tr>
    </table>
  </center>

  <h2 id="Heading1">Chapter 51<br />
  Sneakers in Space</h2>

  <h3 id="Heading2">Using Backface Removal to Eliminate Hidden Surfaces</h3>

  <p>As I&rsquo;m fond of pointing out, computer animation isn&rsquo;t a matter of mathematically exact modeling or raw technical prowess, but rather of fooling the eye and the mind. That&rsquo;s especially true for 3-D animation, where we&rsquo;re not only trying to convince viewers that they&rsquo;re seeing objects on a screen&mdash;when in truth that screen contains no objects at all, only gaggles of pixels&mdash;but we&rsquo;re also trying to create the illusion that the objects exist in three-space, possessing four dimensions (counting movement over time as a fourth dimension) of their own. To make this magic happen, we must provide cues for the eye not only to pick out boundaries, but also to detect depth, orientation, and motion. This involves perspective, shading, proper handling of hidden surfaces, and rapid and smooth screen updates; the whole deal is considerably more difficult to pull off on a PC than 2-D animation.</p>

  <table width="100%">
    <tr>
      <td width="5%" valign="top"><img src="images/i.jpg" /></td>

      <td width="95%" valign="top"><small><i>In some senses, however, 3-D animation is easier than 2-D. Because there&rsquo;s more going on in 3-D animation, the eye and brain tend to make more assumptions, and so are more apt to see what they expect to see, rather than what&rsquo;s actually there.</i></small></td>
    </tr>
  </table>

  <p>If you&rsquo;re piloting a (virtual) ship through a field of thousands of asteroids at high speed, you&rsquo;re unlikely to notice if the more distant asteroids occasionally seem to go right through each other, or if the topographic detail on the asteroids&rsquo; surfaces sometimes shifts about a bit. You&rsquo;ll be busy viewing the asteroids in their primary role, as objects to be navigated around, and the mere presence of topographic detail will suffice; without being aware of it, you&rsquo;ll fill in the blanks. Your mind will see the topography peripherally, recognize it for what it is supposed to be, and, unless the landscape does something really obtrusive such as vanishing altogether or suddenly shooting a spike miles into space, you will see what you expect to see: a bunch of nicely detailed asteroids tumbling around you.</p>

  <p>To what extent can you rely on the eye and mind to make up for imperfections in the 3-D animation process? In some areas, hardly at all; for example, jaggies crawling along edges stick out like red flags, and likewise for flicker. In other areas, though, the human perceptual system is more forgiving than you&rsquo;d think. Consider this: At the end of <i>Return of the Jedi</i>, in the battle to end all battles around the Death Star, there is a sequence of about five seconds in which several spaceships are visible in the background. One of those spaceships (and it&rsquo;s not very far in the background, either) looks a bit unusual. What it looks like is a sneaker. In fact, it <i>is</i> a sneaker&mdash;but unless you know to look for it, you&rsquo;ll never notice it, because your mind is busy making simplifying assumptions about the complex scene it&rsquo;s seeing&mdash;and one of those assumptions is that medium-sized objects floating in space are spaceships, unless proven otherwise. (Thanks to Chris Hecker for pointing this out. I&rsquo;d never have noticed the sneaker, myself, without being tipped off&mdash;which is, of course, the whole point.)</p>

  <p>If it&rsquo;s good enough for George Lucas, it&rsquo;s good enough for us. And with that, let&rsquo;s resume our quest for realtime 3-D animation on the PC.</p>

  <h3 id="Heading3">One-sided Polygons: Backface Removal</h3>

  <p>In the previous chapter, we implemented the basic polygon drawing pipeline, transforming a polygon all the way from its basic definition in object space, through the shared 3-D world space, and into the 3-D space as seen from the viewpoint, called <i>view space</i>. From view space, we performed a perspective projection to convert the polygon into screen space, then mapped the transformed and projected vertices to the nearest screen coordinates and filled the polygon. Armed with code that implemented this pipeline, we were able to watch as a polygon rotated about its Y axis, and were able to move the polygon around in space freely.</p>

  <p>One of the drawbacks of the previous chapter&rsquo;s approach was that the polygon had two visible sides. Why is that a drawback? It isn&rsquo;t, necessarily, but in our case we want to use polygons to build solid objects with continuous surfaces, and in that context, only one side of a polygon is visible; the other side always faces the inside of the object, and can never be seen. It would save time and simplify the process of hidden surface removal if we could quickly and easily determine whether the inside or outside face of each polygon was facing us, so that we could draw each polygon only if it were visible (that is, had the outside face pointing toward the viewer). On average, half the polygons in an object could be instantly rejected by a test of this sort. Such testing of polygon visibility goes by a number of names in the literature, including backplane culling, backface removal, and assorted variations thereon; I&rsquo;ll refer to it as <i>backface removal</i>.</p>

  <center>
    <table border="1">
      <tr>
        <td>
          <a href="50-07.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="51-02.html">Next</a>
        </td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
