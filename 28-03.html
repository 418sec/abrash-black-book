<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Reading VGA Memory</title><!-- HEADER -->
  <!-- Empty Reference Subhead -->
  <!--ISBN=1576101746//-->
  <!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
  <!--AUTHOR=Michael Abrash//-->
  <!--PUBLISHER=The Coriolis Group, Inc.//-->
  <!--CHAPTER=28//-->
  <!--PAGES=530-531//-->
  <!--UNASSIGNED1//-->
  <!--UNASSIGNED2//-->
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="28-02.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="28-04.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p>By the way, the code in Listing 28.1 is intended only to illustrate read mode 0, and is, in general, a poor way to perform animation, since it&rsquo;s slow and tends to flicker. Later in this book, we&rsquo;ll take a look at some far better VGA animation techniques.</p>

  <p>As you&rsquo;d expect, neither the read mode nor the setting of the Read Map register affects CPU <i>writes</i> to VGA memory in any way.</p>

  <table width="100%">
    <tr>
      <td width="5%" valign="top"><img src="images/i.jpg" /></td>

      <td width="95%"><small><i>An important point regarding reading VGA memory involves the VGA&rsquo;s latches. (Remember that each of the four latches stores a byte for one plane; on CPU writes, the latches can provide some or all of the data written to display memory, allowing fast copying and efficient pixel masking.) Whenever the CPU reads a given address in VGA memory, each of the four latches is loaded with the contents of the byte at that address in its respective plane. Even though the CPU only receives data from one plane in read mode 0, all four planes are always read, and the values read are stored in the latches. This is true in read mode 1 as well. In short, whenever the CPU reads VGA memory in any read mode, all four planes are read and all four latches are always loaded.</i></small></td>
    </tr>
  </table>

  <h3><a id="Heading4"></a>Read Mode 1</h3>

  <p>Read mode 0 is the workhorse read mode, but it&rsquo;s got an annoying limitation: Whenever you want to determine the color of a given pixel in read mode 0, you have to perform four VGA memory reads, one for each plane, and then interpret the four bytes you&rsquo;ve read as eight 16-color pixels. That&rsquo;s a lot of programming. The code is also likely to run slowly, all the more so because a standard IBM VGA takes an average of 1.1 microseconds to complete each memory read, and read mode 0 requires four reads in order to read the four planes, not to mention the even greater amount of time taken by the <b>OUT</b>s required to switch between the planes. (1.1 microseconds may not sound like much, but on a 66-MHz 486, it&rsquo;s 73 clock cycles! Local-bus VGAs can be a good deal faster, but a read from the fastest local-bus adapter I&rsquo;ve yet seen would still cost in the neighborhood of 10 486/66 cycles.)</p>

  <p>Read mode 1, also known as <i>color compare mode</i>, provides special hardware assistance for determining whether a pixel is a given color. With a single read mode 1 read, you can determine whether each of up to eight pixels is a specific color, and you can even specify any or all planes as &ldquo;don&rsquo;t care&rdquo; planes in the pixel color comparison.</p>

  <p>Read mode 1 is selected by setting bit 3 of the Graphics Mode register (Graphics Controller register 5) to 1. In its simplest form, read mode 1 compares the cross-plane value of each of the eight pixels at a given address to the color value in bits 3-0 of the Color Compare register (Graphics Controller register 2), and returns a 1 to the CPU in the bit position of each pixel that matches the color in the Color Compare register and a 0 for each pixel that does not match.</p>

  <p>That&rsquo;s certainly interesting, but what&rsquo;s read mode 1 good for? One obvious application is in implementing flood-fill algorithms, since read mode 1 makes it easy to tell when a given byte contains a pixel of a boundary color. Another application is in detecting on-screen object collisions, as illustrated by the code in Listing 28.2.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="28-02.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="28-04.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div><!-- all of the reference materials (books) have the footer and subfoot reveresed -->
  <!-- reference_subfoot = footer -->
  <!-- reference_footer = subfoot -->
  <!-- BEGIN SUB FOOTER -->
  <!-- END FOOTER -->
</body>
</html>
