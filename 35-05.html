<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Bresenham Is Fast, and Fast Is Good</title>
  <meta name="chapter" content="35" />
  <meta name="pages" content="667-670" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="35-04.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="35-06.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p>There is one line-drawing function for octants 0 and 3, <b>Octant0</b>, and one line-drawing function for octants 1 and 2, <b>Octant1</b>. A single function with <b>if</b> statements could certainly be used to handle all four octants, but at a significant performance cost. There is, on the other hand, very little performance cost to grouping octants 0 and 3 together and octants 1 and 2 together, since the two octants in each pair differ only in the direction of change of the X coordinate.</p>

  <p><b>EVGALine</b> determines which line-drawing function to call and with what value for the direction of change of the X coordinate based on two criteria: whether <b>DeltaX</b> is negative or not, and whether the absolute value of <b>DeltaX</b> (|<b>DeltaX</b>|) is less than <b>DeltaY</b> or not, as shown in Figure 35.5. Recall that the value of <b>DeltaY</b>, and hence the direction of change of the Y coordinate, is guaranteed to be non-negative as a result of the earlier elimination of four of the line orientations.</p>

  <p>After calling the appropriate function to draw the line (more on those functions shortly), <b>EVGALine</b> restores the state of the Enable Set/Reset register to its default of zero. In this state, the Set/Reset register has no effect, so it is not necessary to restore the state of the Set/Reset register as well. <b>EVGALine</b> also restores the state of the Bit Mask register (which, as we will see, is modified by <b>EVGADot</b>, the pixel-drawing routine actually used to draw each pixel of the lines produced by <b>EVGALine</b>) to its default of 0FFH. While it would be more modular to have <b>EVGADot</b> restore the state of the Bit Mask register after drawing each pixel, it would also be considerably slower to do so. The same could be said of having <b>EVGADot</b> set the Enable Set/Reset and Set/Reset registers for each pixel: While modularity would improve, speed would suffer markedly.</p>

  <p><a id="Fig5"><img src="images/35-05.jpg" /><br />
  <b>Figure 35.5</b></a>&nbsp;&nbsp;<i>EVGALine&rsquo;s decision logic.</i></p>

  <h4 align="left" id="Heading8">Drawing Each Line</h4>

  <p>The <b>Octant0</b> and <b>Octant1</b> functions draw lines for which |<b>DeltaX</b>| is greater than <b>DeltaY</b> and lines for which |<b>DeltaX</b>| is less than or equal to <b>DeltaY</b>, respectively. The parameters to <b>Octant0</b> and <b>Octant1</b> are the starting point of the line, the length of the line in each dimension, and <b>XDirection</b>, the amount by which the X coordinate should be changed when it moves. <b>XDirection</b> must be either 1 (to draw toward the right edge of the screen) or -1 (to draw toward the left edge of the screen). No value is required for the amount by which the Y coordinate should be changed; since <b>DeltaY</b> is guaranteed to be positive, the Y coordinate always changes by 1 pixel.</p>

  <p><b>Octant0</b> draws lines for which |<b>DeltaX</b>| is greater than <b>DeltaY</b>. For such lines, the X coordinate of each pixel drawn differs from the previous pixel by either 1 or -1, depending on the value of <b>XDirection</b>. (This makes it possible for <b>Octant0</b> to draw lines in both octant 0 and octant 3.) Whenever <b>ErrorTerm</b> becomes non-negative, indicating that the next Y coordinate is a better approximation of the line being drawn, the Y coordinate is increased by 1.</p>

  <p><b>Octant1</b> draws lines for which |<b>DeltaX</b>| is less than or equal to DeltaY. For these lines, the Y coordinate of each pixel drawn is 1 greater than the Y coordinate of the previous pixel. Whenever <b>ErrorTerm</b> becomes non-negative, indicating that the next X coordinate is a better approximation of the line being drawn, the X coordinate is advanced by either 1 or -1, depending on the value of <b>XDirection</b>. (This makes it possible for <b>Octant1</b> to draw lines in both octant 1 and octant 2.)</p>

  <h4 align="left" id="Heading9">Drawing Each Pixel</h4>

  <p>At the core of <b>Octant0</b> and <b>Octant1</b> is a pixel-drawing function, <b>EVGADot</b>. <b>EVGADot</b> draws a pixel at the specified coordinates in whatever color the hardware of the VGA happens to be set up for. As described earlier, since the entire line drawn by <b>EVGALine</b> is of the same color, line-drawing performance is improved by setting the VGA&rsquo;s hardware up once in <b>EVGALine</b> before the line is drawn, and then drawing all the pixels in the line in the same color via <b>EVGADot</b>.</p>

  <p><b>EVGADot</b> makes certain assumptions about the screen. First, it assumes that the address of the byte controlling the pixels at the start of a given row on the screen is 80 bytes after the start of the row immediately above it. In other words, this implementation of <b>EVGADot</b> only works for screens configured to be 80 bytes wide. Since this is the standard configuration of all of the modes <b>EVGALine</b> is designed to work in, the assumption of 80 bytes per row should be no problem. If it is a problem, however, <b>EVGADot</b> could easily be modified to retrieve the BIOS integer variable at address 0040:004A, which contains the number of bytes per row for the current video mode.</p>

  <p>Second, <b>EVGADot</b> assumes that screen memory is organized as a linear bitmap starting at address A000:0000, with the pixel at the upper left of the screen controlled by bit 7 of the byte at offset 0, the next pixel to the right controlled by bit 6, the ninth pixel controlled by bit 7 of the byte at offset 1, and so on. Further, it assumes that the graphics adapter&rsquo;s hardware is configured such that setting the Bit Mask register to allow modification of only the bit controlling the pixel of interest and then ORing a value of 0FEH with display memory will draw that pixel correctly without affecting any other dots. (Note that 0FEH is used rather than 0FFH or 0 because some optimizing compilers turn ORs with the latter values into simpler operations or optimize them away entirely. As explained later, however, it&rsquo;s not the value that&rsquo;s ORed that matters, given the way we&rsquo;ve set up the VGA&rsquo;s hardware; it&rsquo;s the act of ORing itself, and the value 0FEH forces the compiler to perform the OR operation.) Again, this is the normal way in which modes 0EH, 0FH, 10H, and 12H operate. As described earlier, <b>EVGADot</b> also assumes that the VGA is set up so that each pixel drawn in the above-mentioned manner will be drawn in the correct color.</p>

  <p>Given those assumptions, <b>EVGADot</b> becomes a surprisingly simple function. First, <b>EVGADot</b> builds a far pointer that points to the byte of display memory controlling the pixel to be drawn. Second, a mask is generated consisting of zeros for all bits except the bit controlling the pixel to be drawn. Third, the Bit Mask register is set to that mask, so that when display memory is read and then written, all bits except the one that controls the pixel to be drawn will be left unmodified.</p>

  <p>Finally, 0FEH is ORed with the display memory byte controlling the pixel to be drawn. ORing with 0FEH first reads display memory, thereby loading the VGA&rsquo;s internal latches with the contents of the display memory byte controlling the pixel to be drawn, and then writes to display memory with the value 0FEH. Because of the unusual way in which the VGA&rsquo;s data paths work and the way in which <b>EVGALine</b> sets up the VGA&rsquo;s Enable Set/Reset and Set/Reset registers, the value that is written by the <b>OR</b> instruction is ignored. Instead, the value that actually gets placed in display memory is the color that was passed to <b>EVGALine</b> and placed in the Set/Reset register. The Bit Mask register, which was set up in step three above, allows only the single bit controlling the pixel to be drawn to be set to this color value. For more on the various machineries the VGA brings to bear on graphics data, look back to Chapter 25.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="35-04.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="35-06.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
