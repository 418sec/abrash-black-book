<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Higher 256-Color Resolution on the VGA</title>
  <meta name="chapter" content="31" />
  <meta name="pages" content="591-593" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td>
          <a href="31-01.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="31-03.html">Next</a>
        </td>
      </tr>
    </table>
  </center>

  <p>That&rsquo;s a shame, because mode 13H has the simplest bitmap organization of any mode&mdash;one long, linear bitmap, with each byte controlling one pixel. We can&rsquo;t have that organization, though, so we&rsquo;ll have to find an acceptable substitute if we want to use a higher 256-color resolution.</p>

  <p>We&rsquo;re talking about the VGA, so of course there are actually <i>several</i> bitmap organizations that let us use higher 256-color resolutions than mode 13H. The one I like best is shown in Figure 31.1. Each byte controls one 256-color pixel. Pixel 0 is at address 0 in plane 0, pixel 1 is at address 0 in plane 1, pixel 2 is at address 0 in plane 2, pixel 3 is at address 0 in plane 3, pixel 4 is at address 1 in plane 0, and so on.</p>

  <p>Let&rsquo;s look at this another way. Ideally, we&rsquo;d like one long bitmap, with each pixel at the address that&rsquo;s just after the address of the pixel to the left. Well, that&rsquo;s true in this case too, <i>if</i> you consider the number of the plane that the pixel is in to be part of the pixel&rsquo;s address. View the pixel numbers on the screen as increasing from left to right and from the end of one scan line to the start of the next. Then the pixel number, n, of the pixel at display memory address <i>address</i> in plane <i>plane</i> is:</p>

  <p><a id="Fig1"><img src="images/31-01.jpg" /><br />
  <b>Figure 31.1</b></a>&nbsp;&nbsp;<i>Bitmap organization in 320x400 256-color mode in 320x400 256-color mode.</i></p>

  <p><i>n</i> = (<i>address</i> * 4) + <i>plane</i></p>

  <p>To turn that around, the display memory address of pixel number n is given by</p>

  <p>address = <i>n</i> / 4</p>

  <p>and the plane of pixel <i>n</i> is given by:</p>

  <p>plane = <i>n</i> modulo 4</p>

  <p>Basically, the full address of the pixel, its pixel number, is broken into two components: the display memory address and the plane.</p>

  <p>By the way, because 320x400 mode has a significantly different memory organization from mode 13H, the BIOS text routines won&rsquo;t work in 320x400 mode. If you want to draw text in 320x400 mode, you&rsquo;ll have to look up a font in the BIOS ROM and draw the text yourself. Likewise, the BIOS read pixel and write pixel routines won&rsquo;t work in 320x400 mode, but that&rsquo;s no problem because I&rsquo;ll provide equivalent routines in the next section.</p>

  <p>Our next task is to convert standard mode 13H into 320x400 mode. That&rsquo;s accomplished by undoing some of the mode bits that are set up especially for mode 13H, so that from a programming perspective the VGA reverts to a straightforward planar model of memory. That means taking the VGA out of chain 4 mode and doubleword mode, turning off the double display of each scan line, making sure chain mode, odd/even mode, and word mode are turned off, and selecting byte mode for video data display. All that&rsquo;s done in the <b>Set320x400Mode</b> subroutine in Listing 31.1, which we&rsquo;ll discuss next.</p>

  <h4 id="Heading6">Reading and Writing Pixels</h4>

  <p>The basic graphics functions in any mode are functions to read and write single pixels. Any more complex function can be built on these primitives, although that&rsquo;s rarely the speediest solution. What&rsquo;s more, once you understand the operation of the read and write pixel functions, you&rsquo;ve got all the knowledge you need to create functions that perform more complex graphics functions. Consequently, we&rsquo;ll start our exploration of 320x400 mode with pixel-at-a-time line drawing.</p>

  <p>Listing 31.1 draws 8 multicolored octagons in turn, drawing a new one on top of the old one each time a key is pressed. The main-loop code of Listing 31.1 should be easily understood; a series of diagonal, horizontal, and vertical lines are drawn one pixel at a time based on a list of line descriptors, with the draw colors incremented for each successive time through the line list.</p>

  <center>
    <table border="1">
      <tr>
        <td>
          <a href="31-01.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="31-03.html">Next</a>
        </td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
