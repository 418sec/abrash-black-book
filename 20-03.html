<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Pentium Rules</title>
  <meta name="chapter" content="20" />
  <meta name="pages" content="390-393" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="20-02.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="20-04.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <h3 id="Heading5">Lockstep Execution</h3>

  <p>You may wonder why anyone would bother breaking <b>ADD [MemVar],EAX</b> into three instructions, given that this instruction can go through either pipe with equal ease. The answer is that while the memory-accessing instructions other than <b>MOV, PUSH</b>, and <b>POP</b> listed in Table 20.1 (that is, <b>INC/DEC [<i>mem</i>], ADD/SUB/XOR/AND/OR/CMP/ADC/SBB <i>reg</i>,[<i>mem</i>]</b>, and <b>ADD/SUB/XOR/AND/OR/CMP/ADC/SBB [<i>mem</i>],<i>reg/immed</i></b>) can be paired, they do not provide the 100 percent overlap that we seek. If you look at Tables 20.1 and 20.2, you will see that instructions taking from 1 to 3 cycles can pair. However, any pair of instructions goes through the two pipes in lockstep. This means, for example, that if <b>ADD [EBX],EDX</b> is going through the U-pipe, and <b>INC EAX</b> is going through the V-pipe, the V-pipe will be idle for 2 of the 3 cycles that the U-pipe takes to execute its instruction, as shown in Figure 20.4. Out of the theoretical 6 cycles of work that can be done during this time, we actually get only 4 cycles of work, or 67 percent utilization. Even though these instructions pair, then, this sequence fails to make maximum use of the Pentium&rsquo;s horsepower.</p>

  <p>The key here is that when two instructions pair, both execution units are tied up until both instructions have finished (which means at least for the amount of time required for the longer of the two to execute, plus possibly some extra cycles for pairable instructions that can&rsquo;t fully overlap, as described below). The logical conclusion would seem to be that we should strive to pair instructions of the same lengths, but that is often not correct.</p>

  <table width="100%">
    <tr>
      <td valign="top" align="left" width="5%"><img src="images/i.jpg" /></td>

      <td valign="top" align="left" width="95%"><small><i>The actual rule is that we should strive to pair one-cycle instructions (or, at most, two-cycle instructions, but not three-cycle instructions), which in turn leads to the corollary that we should, in general, use mostly one-cycle instructions when optimizing.</i></small></td>
    </tr>
  </table>

  <p><a id="Fig4"><img src="images/20-04.jpg" /><br />
  <b>Figure 20.4</b></a>&nbsp;&nbsp;<i>Lockstep execution and idle time in the V-pipe.</i></p>

  <p>Here&rsquo;s why. The Pentium is fully capable of handling instructions that use memory operands in either pipe, or, if necessary, in both pipes at once. Each pipe has its own write FIFO, which buffers the last few writes and takes care of writing the data out while the Pentium continues processing. The Pentium also has a write-back internal data cache, so data that is frequently changed doesn&rsquo;t have to be written to external memory (which is much slower than the cache) very often. This combination means that unless you write large blocks of data at a high speed, the Pentium should be able to keep up with both pipes&rsquo; memory writes without stalling execution.</p>

  <p>The Pentium is also designed to satisfy both pipes&rsquo; needs for reading memory operands with little waiting. The data cache is constructed so that both pipes can read from the cache <i>on the same cycle</i>. This feat is accomplished by organizing the data cache as eight-banked memory, as shown in Figure 20.5, with each 32-byte cache line consisting of 8 dwords, 1 in each bank. The banks are independent of one another, so as long as the desired data is in the cache and the U- and V-pipes don&rsquo;t try to read from the same bank on the same cycle, both pipes can read memory operands on the same cycle. (If there is a cache bank collision, the V-pipe instruction stalls for one cycle.)</p>

  <p>Normally, you won&rsquo;t pay close attention to which of the eight dword banks your paired memory accesses fall in&mdash;that&rsquo;s just too much work&mdash;but you might want to watch out for simultaneously read addresses that have the same values for address</p>

  <p><a id="Fig5"><img src="images/20-05.jpg" /><br />
  <b>Figure 20.5</b></a>&nbsp;&nbsp;<i>The Pentium&rsquo;s eight bank data cache.</i></p>

  <p>bits 2, 3, and 4 (fall in the same bank) in tight loops, and you should also avoid sequences like</p>
  <pre>
mov  bl,[esi]
mov  bh,[esi+1]
</pre>

  <p>because both operands will generally be in the same bank. An alternative is to place another instruction between the two instructions that access the same bank, as in this sequence:</p>
  <pre>
mov  bl,[esi]
mov  edi,edx
mov  bh,[esi+1]
</pre>

  <p>By the way, the reason a code sequence that takes two instructions to load a single word is attractive in a 32-bit segment is because it takes only one cycle when the two instructions can be paired with other instructions; by contrast, the obvious way of loading BX</p>
  <pre>
mov bx,[esi]
</pre>

  <p>takes 1.5 to two cycles because the size prefix can&rsquo;t pair, as described below. This is yet another example of how different Pentium optimization can be from everything we&rsquo;ve learned about its predecessors.</p>

  <p>The problem with pairing non-single-cycle instructions arises when a pipe executes an instruction other than <b>MOV</b> that has an explicit memory operand. (I&rsquo;ll call these <i>complex memory instructions</i>. They&rsquo;re the only pairable instructions, other than branches, that take more than one cycle.) We&rsquo;ve already seen that, because instructions go through the pipes in lockstep, if one pipe executes a complex memory instruction such as <b>ADD EAX,[EBX]</b> while the other pipe executes a single-cycle instruction, the pipe with the faster instruction will sit idle for part of the time, wasting cycles. You might think that if both pipes execute complex instructions of the same length, then neither would lie idle, but that turns out to not always be the case. Two two-cycle instructions (instructions with register destination operands) can indeed pair and execute in two cycles, so it&rsquo;s okay to pair two instructions such as these:</p>
  <pre>
add esi,[SourceSkip]        ;U-pipe cycles 1 and 2
add edi,[DestinationSkip]   ;V-pipe cycles 1 and 2
</pre>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="20-02.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="20-04.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
