<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Hints My Readers Gave Me</title><!-- HEADER -->
  <!-- Empty Reference Subhead -->
  <!--ISBN=1576101746//-->
  <!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
  <!--AUTHOR=Michael Abrash//-->
  <!--PUBLISHER=The Coriolis Group, Inc.//-->
  <!--CHAPTER=09//-->
  <!--PAGES=175-178//-->
  <!--UNASSIGNED1//-->
  <!--UNASSIGNED2//-->
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="09-02.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="09-04.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p>Listing 9.1 implements the scan-on-first-character approach. Listing 9.2 scans for whatever character the caller specifies. Listing 9.3 is a test program used to compare the two approaches. How much difference does Rob&rsquo;s revelation make? Plenty. Even when the entire C function call to <b>FindString</b> is timed&mdash;<b>strlen</b> calls, parameter pushing, calling, setup, and all&mdash;the version of <b>FindString</b> in Listing 9.2, which is directed by Listing 9.3 to scan for the infrequently-occurring &ldquo;Q,&rdquo; is about 40 percent faster on a 20 MHz cached 386 for the test search of Listing 9.3 than is the version of <b>FindString</b> in Listing 9.1, which always scans for the first character, in this case &ldquo;E.&rdquo; However, when only the search loops (the code that actually does the searching) in the two versions of <b>FindString</b> are compared, Listing 9.2 is more than <i>twice</i> as fast as Listing 9.1&mdash;a remarkable improvement over code that already uses <b>REPNZ SCASB</b> and <b>REPZ CMPS</b>.</p>

  <p>What I like so much about Rob&rsquo;s approach is that it demonstrates that optimization involves much more than instruction selection and cycle counting. Listings 9.1 and 9.2 use pretty much the same instructions, and even use the same approach of scanning with <b>REPNZ SCASB</b> and using <b>REPZ CMPS</b> to check scanning matches.</p>

  <table width="100%">
    <tr>
      <td width="5%" valign="top" align="left"><img src="images/i.jpg" /></td>

      <td width="95%" valign="top" align="left"><small><i>The difference between Listings 9.1 and 9.2 (which gives you more than a doubling of performance) is due entirely to understanding the nature of the data being handled, and biasing the code to reflect that knowledge.</i></small></td>
    </tr>
  </table>

  <p><a id="Fig2"><!-- </A><A HREF="javascript:displayWindow('images/09-02.jpg',409,306 )"> --><img src="images/09-02.jpg" /><br />
  <!-- </A>
<BR><A HREF="javascript:displayWindow('images/09-02.jpg',409,306)"> --><b>Figure 9.2</b></a>&nbsp;&nbsp;<i>Faster searching method for locating a text string.</i></p>

  <p><b>LISTING 9.1 L9-1.ASM</b></p><!-- CODE //-->
  <pre>
; Searches a text buffer for a text string. Uses REPNZ SCASB to sca"n
; the buffer for locations that match the first character of the
; searched-for string, then uses REPZ CMPS to check fully only those
; locations that REPNZ SCASB has identified as potential matches.
;
; Adapted from Zen of Assembly Language, by Michael Abrash
;
; C small model-callable as:
;    unsigned char * FindString(unsigned char * Buffer,
;     unsigned int BufferLength, unsigned char * SearchString,
;     unsigned int SearchStringLength);
;
; Returns a pointer to the first match for SearchString in Buffer,or
; a NULL pointer if no match is found. Buffer should not start at
; offset 0 in the data segment to avoid confusing a match at 0 with
; no match found.
Parmsstruc
                        dw    2 dup(?) ;pushed BP/return address
Buffer                  dw      ?      ;pointer to buffer to search
BufferLength            dw      ?      ;length of buffer to search
SearchString            dw      ?      ;pointer to string for which to search
SearchStringLength      dw      ?      ;length of string for which to search
Parmsends
      .model      small
      .code
      public _FindString
_FindStringprocnear
      push     bp      ;preserve caller&rsquo;s stack frame
      mov      bp,sp   ;point to our stack frame
      push     si      ;preserve caller&rsquo;s register variables
      push     di
      cld              ;make string instructions increment pointers
      mov      si,[bp+SearchString]       ;pointer to string to search for
      mov      bx,[bp+SearchStringLength] ;length of string
      and bx,bx
      jz       FindStringNotFound         ;no match if string is 0 length
      movd      x,[bp+BufferLength]       ;length of buffer
      sub      dx,bx                      ;difference between buffer and string lengths
      jc      FindStringNotFound          ;no match if search string is
                                          ; longer than buffer
      inc      dx      ;difference between buffer and search string
                       ; lengths, plus 1 (# of possible string start
                       ; locations to check in the buffer)
      mov      di,ds
      mov      es,di
      mov      di,[bp+Buffer]       ;point ES:DI to buffer to search thru
      lodsb                         ;put the first byte of the search string in AL
      mov      bp,si                ;set aside pointer to the second search byte
      dec      bx                   ;don&rsquo;t need to compare the first byte of the
                                    ; string with CMPS; we&rsquo;ll do it with SCAS
FindStringLoop:
      mov    cx,dx ;put remaining buffer search length in CX
      repnz  scasb ;scan for the first byte of the string
      jnz    FindStringNotFound ;not found, so there&rsquo;s no match
                                ;found, so we have a potential match-check the
                                ; rest of this candidate location
      push   di                 ;remember the address of the next byte to scan
      mov    dx,cx              ;set aside the remaining length to search in
                                ; the buffer
      mov    si,bp              ;point to the rest of the search string
      mov    cx,bx              ;string length (minus first byte)
      shr    cx,1               ;convert to word for faster search
      jnc    FindStringWord     ;do word search if no odd byte
      cmpsb                     ;compare the odd byte
      jnz    FindStringNoMatch  ;odd byte doesn&rsquo;t match, so we
                                ; haven&rsquo;t found the search string here
FindStringWord:
      jcxz   FindStringFound    ;test whether we&rsquo;ve already checked
                                ; the whole string; if so, this is a match
                                ; bytes long; if so, we&rsquo;ve found a match
      repz   cmpsw              ;check the rest of the string a word at a time
      jz     FindStringFound    ;it&rsquo;s a match
FindStringNoMatch:
      pop    di                 ;get back pointer to the next byte to scan
      and    dx,dx              ;is there anything left to check?
      jnz    FindStringLoop     ;yes-check next byte
FindStringNotFound:
      sub    ax,ax              ;return a NULL pointer indicating that the
      jmp    FindStringDone     ; string was not found
FindStringFound:
      pop    ax                 ;point to the buffer location at which the
      dec    ax                 ; string was found (earlier we pushed the
                                ; address of the byte after the start of the
                                ; potential match)
FindStringDone:
      pop    di                 ;restore caller&rsquo;s register variables
      pop    si
      pop    bp                 ;restore caller&rsquo;s stack frame
ret
_FindStringendp
      end
</pre><!-- END CODE //-->

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="09-02.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="09-04.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div><!-- all of the reference materials (books) have the footer and subfoot reveresed -->
  <!-- reference_subfoot = footer -->
  <!-- reference_footer = subfoot -->
  <!-- BEGIN SUB FOOTER -->
  <!-- END FOOTER -->
</body>
</html>
