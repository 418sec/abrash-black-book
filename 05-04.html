<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Crossing the Border</title>
  <meta name="chapter" content="05" />
  <meta name="pages" content="121-122" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="05-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="05-05.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <h3 id="Heading8">Interpreting Where the Cycles Go</h3>

  <p>To boost the overall performance of Listing 5.1, I would normally convert <b>SearchForString()</b> to assembly language at this point. However, I&rsquo;m not going to do that, and the reason is as important a lesson as any discussion of optimized assembly code is likely to be. Take a moment to examine some interesting performance aspects of the C implementation, and all should become much clearer.</p>

  <p>As you&rsquo;ll recall from Chapter 1, one of the important rules for optimization involves knowing when optimization is worth bothering with at all. Another rule involves understanding where most of a program&rsquo;s execution time is going. That&rsquo;s more true for Listing 5.1 than you might think.</p>

  <p>When Listing 5.1 is run on a 1 MB assembly source file, it takes about three seconds to find the string &ldquo;xxxend&rdquo; (which is at the end of the file) on a 20 MHz 386 machine, with the entire file in a disk cache. If <b>BLOCK_SIZE</b> is trimmed from 16K to 4K, <i>execution time does not increase perceptibly!</i> At 2K, the program slows slightly; it&rsquo;s not until the block size shrinks to 64 bytes that execution time becomes approximately double that of the 16K buffer.</p>

  <p>So the first thing we&rsquo;ve discovered is that, while bigger blocks do make for the best performance, the increment in performance may not be very large, and might not justify the extra memory required for those larger blocks. Our next discovery is that, even though we read the file in large chunks, most of the execution time of Listing 5.1 is nonetheless spent in executing the <b>read()</b> function.</p>

  <p>When I replaced the <b>read()</b> function call in Listing 5.1 with code that simply fools the program into thinking that a 1 MB file is being read, the program ran almost instantaneously&mdash;in less than 1/2 second, even when the searched-for string wasn&rsquo;t anywhere to be found. By contrast, Listing 5.1 requires three seconds to run even when searching for a single character that isn&rsquo;t found anywhere in the file, the case in which a single call to <b>memchr()</b> (and thus a single <b>REPNZ SCASB</b>) can eliminate an entire block at a time.</p>

  <p>All in all, the time required for DOS disk access calls is taking up at least 80 percent of execution time, and search time is less than 20 percent of overall execution time. In fact, search time is probably a good deal less than 20 percent of the total, given that the overhead of loading the program, running through the C startup code, opening the file, executing <b>printf()</b>, and exiting the program and returning to the DOS shell are also included in my timings. Given which, it should be apparent why converting to assembly language isn&rsquo;t worth the trouble&mdash;the best we could do by speeding up the search is a 10 percent or so improvement, and that would require more than doubling the performance of code that already uses repeated string instructions to do most of the work.</p>

  <p>Not likely.</p>

  <h4 align="left" id="Heading9">Knowing When Assembly Is Pointless</h4>

  <p>So that&rsquo;s why we&rsquo;re not going to go to assembly language in this example&mdash;which is not to say it would never be worth converting the search engine in Listing 5.1 to assembly.</p>

  <p>If, for example, your application will typically search buffers in which the first character of the search string occurs frequently as might be the case when searching a text buffer for a string starting with the space character an assembly implementation might be several times faster. Why? Because assembly code can switch from <b>REPNZ SCASB</b> to match the first character to <b>REPZ CMPS</b> to check the remaining characters in just a few instructions.</p>

  <p>In contrast, Listing 5.1 must return from <b>memchr()</b>, set up parameters, and call <b>memcmp()</b> in order to do the same thing. Likewise, assembly can switch back to <b>REPNZ SCASB</b> after a non-match much more quickly than Listing 5.1. The switching overhead is high; when searching a file completely filled with the character z for the string &ldquo;zy,&rdquo; Listing 5.1 takes almost 1/2 minute, or nearly an order of magnitude longer than when searching a file filled with normal text.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="05-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="05-05.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
