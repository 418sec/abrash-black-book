<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: The Best Optimizer Is between Your Ears</title>
  <meta name="chapter" content="01" />
  <meta name="pages" content="007-009" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="01-01.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="01-03.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <h3 id="Heading5">Rules for Building High-Performance Code</h3>

  <p>We&rsquo;ve got the following rules for creating high-performance software:</p>

  <ul>
    <li>Know where you&rsquo;re going (understand the objective of the software).</li>

    <li>Make a big map (have an overall program design firmly in mind, so the various parts of the program and the data structures work well together).</li>

    <li>Make lots of little maps (design an algorithm for each separate part of the overall design).</li>

    <li>Know the territory (understand exactly how the computer carries out each task).</li>

    <li>Know when it matters (identify the portions of your programs where performance matters, and don&rsquo;t waste your time optimizing the rest).</li>

    <li>Always consider the alternatives (don&rsquo;t get stuck on a single approach; odds are there&rsquo;s a better way, if you&rsquo;re clever and inventive enough).</li>

    <li>Know how to turn on the juice (optimize the code as best you know how when it <i>does</i> matter).</li>
  </ul>

  <p>Making rules is easy; the hard part is figuring out how to apply them in the real world. For my money, examining some actual working code is always a good way to get a handle on programming concepts, so let&rsquo;s look at some of the performance rules in action.</p>

  <h4 align="left" id="Heading6">Know Where You&rsquo;re Going</h4>

  <p>If we&rsquo;re going to create high-performance code, first we have to know what that code is going to do. As an example, let&rsquo;s write a program that generates a 16-bit checksum of the bytes in a file. In other words, the program will add each byte in a specified file in turn into a 16-bit value. This checksum value might be used to make sure that a file hasn&rsquo;t been corrupted, as might occur during transmission over a modem or if a Trojan horse virus rears its ugly head. We&rsquo;re not going to do anything with the checksum value other than print it out, however; right now we&rsquo;re only interested in generating that checksum value as rapidly as possible.</p>

  <h4 align="left" id="Heading7">Make a Big Map</h4>

  <p>How are we going to generate a checksum value for a specified file? The logical approach is to get the file name, open the file, read the bytes out of the file, add them together, and print the result. Most of those actions are straightforward; the only tricky part lies in reading the bytes and adding them together.</p>

  <h4 align="left" id="Heading8">Make Lots of Little Maps</h4>

  <p>Actually, we&rsquo;re only going to make one little map, because we only have one program section that requires much thought&mdash;the section that reads the bytes and adds them up. What&rsquo;s the best way to do this?</p>

  <p>It would be convenient to load the entire file into memory and then sum the bytes in one loop. Unfortunately, there&rsquo;s no guarantee that any particular file will fit in the available memory; in fact, it&rsquo;s a sure thing that many files <i>won&rsquo;t</i> fit into memory, so that approach is out.</p>

  <p>Well, if the whole file won&rsquo;t fit into memory, one byte surely will. If we read the file one byte at a time, adding each byte to the checksum value before reading the next byte, we&rsquo;ll minimize memory requirements and be able to handle any size file at all.</p>

  <p>Sounds good, eh? Listing 1.1 shows an implementation of this approach. Listing 1.1 uses C&rsquo;s <b>read()</b> function to read a single byte, adds the byte into the checksum value, and loops back to handle the next byte until the end of the file is reached. The code is compact, easy to write, and functions perfectly&mdash;with one slight hitch:</p>

  <p>It&rsquo;s <i>slow</i>.</p>

  <p><b>LISTING 1.1 L1-1.C</b></p>
  <pre>
/*
* Program to calculate the 16-bit checksum of all bytes in the
* specified file. Obtains the bytes one at a time via read(),
* letting DOS perform all data buffering.
*/
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;

main(int argc, char *argv[]) {
     int Handle;
     unsigned char Byte;
     unsigned int Checksum;
     int ReadLength;

     if ( argc != 2 ) {
          printf(&ldquo;usage: checksum filename\n&rdquo;);
          exit(1);
     }
     if ( (Handle = open(argv[1], O_RDONLY | O_BINARY)) == -1 ) {
          printf(&ldquo;Can&rsquo;t open file: %s\n&rdquo;, argv[1]);
          exit(1);
     }

     /* Initialize the checksum accumulator */
     Checksum = 0;

     /* Add each byte in turn into the checksum accumulator */
     while ( (ReadLength = read(Handle, &amp;Byte, sizeof(Byte))) &gt; 0 ) {
          Checksum += (unsigned int) Byte;
     }
     if ( ReadLength == -1 ) {
          printf(&ldquo;Error reading file %s\n&rdquo;, argv[1]);
          exit(1);
     }


     /* Report the result */
     printf(&ldquo;The checksum is: %u\n&rdquo;, Checksum);
     exit(0);
}
</pre>

  <p>Table 1.1 shows the time taken for Listing 1.1 to generate a checksum of the WordPerfect version 4.2 thesaurus file, TH.WP (362,293 bytes in size), on a 10 MHz AT machine of no special parentage. Execution times are given for Listing 1.1 compiled with Borland and Microsoft compilers, with optimization both on and off; all four times are pretty much the same, however, and all are much too slow to be acceptable. Listing 1.1 requires over two and one-half minutes to checksum <i>one</i> file!</p>

  <table width="100%">
    <tr>
      <td width="5%" valign="top"><img src="images/i.jpg" /></td>

      <td width="95%"><small><i>Listings 1.2 and 1.3 form the C/assembly equivalent to Listing 1.1, and Listings 1.6 and 1.7 form the C/assembly equivalent to Listing 1.5.</i></small></td>
    </tr>
  </table>

  <p>These results make it clear that it&rsquo;s folly to rely on your compiler&rsquo;s optimization to make your programs fast. Listing 1.1 is simply poorly designed, and no amount of compiler optimization will compensate for that failing. To drive home the point, conListings 1.2 and 1.3, which together are equivalent to Listing 1.1 except that the entire checksum loop is written in tight assembly code. The assembly language implementation is indeed faster than any of the C versions, as shown in Table 1.1, but it&rsquo;s less than 10 percent faster, and it&rsquo;s still unacceptably slow.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="01-01.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="01-03.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
