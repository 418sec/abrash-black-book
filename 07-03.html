<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Local Optimization</title>
  <meta name="chapter" content="07" />
  <meta name="pages" content="141-143" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="07-02.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="07-04.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p><b>LISTING 7.1 L7-1.ASM</b></p>
  <pre>
; Program to illustrate searching through a buffer of a specified
; length until either a specified byte or a zero byte is
; encountered.
; A standard loop terminated with LOOP is used.

        .model      small
        .stack      100h
        .data
; Sample string to search through.
SampleString        labelbyte
        db   &lsquo;This is a sample string of a long enough length &rsquo;
        db   &lsquo;so that raw searching speed can outweigh any &rsquo;
        db   &lsquo;extra set-up time that may be required.&rsquo;,0
SAMPLE_STRING_LENGTH  equ  $-SampleString

; User prompt.
Prompt     db      &lsquo;Enter character to search for:$&rsquo;

; Result status messages.
ByteFoundMsg         db    0dh,0ah
                     db    &lsquo;Specified byte found.&rsquo;,0dh,0ah,&lsquo;$&rsquo;
ZeroByteFoundMsg db  0dh, 0ah
                     db    &lsquo;Zero byte encountered.&rsquo;,0dh,0ah,&lsquo;$&rsquo;
NoByteFoundMsg       db    0dh,0ah
                     db    &lsquo;Buffer exhausted with no match.&rsquo;, 0dh, 0ah, &lsquo;$&rsquo;

    .code
Startprocnear
    mov  ax,@data    ;point to standard data segment
    mov  ds,ax
    mov  dx,offset Prompt
    mov  ah,9               ;DOS print string function
    int  21h                ;prompt the user
    mov  ah,1               ;DOS get key function
    int  21h                ;get the key to search for
    mov  ah,al              ;put character to search for in AH
    mov  cx,SAMPLE_STRING_LENGTH        ;# of bytes to search
    mov  si,offset SampleString         ;point to buffer to search
    call SearchMaxLength                ;search the buffer
    mov  dx,offset ByteFoundMsg         ;assume we found the byte
    jc   PrintStatus                    ;we did find the byte
                                        ;we didn&rsquo;t find the byte, figure out
                                        ;whether we found a zero byte or
                                        ;ran out of buffer
    mov dx,offset NoByteFoundMsg
                                        ;assume we didn&rsquo;t find a zero byte
    jcxz PrintStatus                    ;we didn&rsquo;t find a zero byte
    mov  dx,offset ZeroByteFoundMsg     ;we found a zero byte
PrintStatus:
    mov  ah,9             ;DOS print string function
    int  21h              ;report status
    mov  ah,4ch           ;return to DOS
    int  21h
Startendp

; Function to search a buffer of a specified length until either a
; specified byte or a zero byte is encountered.
; Input:
;    AH = character to search for
;    CX = maximum length to be searched (must be &gt; 0)
;    DS:SI = pointer to buffer to be searched
; Output:
;    CX = 0 if and only if we ran out of bytes without finding
;         either the desired byte or a zero byte
;    DS:SI = pointer to searched-for byte if found, otherwise byte
;         after zero byte if found, otherwise byte after last
;         byte checked if neither searched-for byte nor zero
;         byte is found
;    Carry Flag = set if searched-for byte found, reset otherwise

SearchMaxLengthprocnear
      cld
SearchMaxLengthLoop:
      lodsb                        ;get the next byte
      cmp   al,ah                  ;is this the byte we want?
      jz    ByteFound              ;yes, we&rsquo;re done with success
      and   al,al                  ;is this the terminating 0 byte?
      jz    ByteNotFound           ;yes, we&rsquo;re done with failure
      loop  SearchMaxLengthLoop    ;it&rsquo;s neither, so check the next
                                   ;byte, if any
ByteNotFound:
      clc                          ;return &ldquo;not found&rdquo; status
      ret
ByteFound:
      dec   si                     ;point back to the location at which
                                   ;we found the searched-for byte
      stc                          ;return &ldquo;found&rdquo; status
      ret
SearchMaxLengthendp
      end   Start
</pre>

  <h3 id="Heading7">Unrolling Loops</h3>

  <p>Listing 7.2 takes a different tack, unrolling the loop so that four bytes are checked for each <b>LOOP</b> performed. The same instructions are used inside the loop in each listing, but Listing 7.2 is arranged so that three-quarters of the <b>LOOP</b>s are eliminated. Listings 7.1 and 7.2 perform exactly the same task, and they use the same instructions in the loop&mdash;the searching algorithm hasn&rsquo;t changed in any way&mdash;but we have sequenced the instructions differently in Listing 7.2, and that makes all the difference.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="07-02.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="07-04.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
