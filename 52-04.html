<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Fast 3-D Animation: Meet X-Sharp</title><!-- HEADER -->
  <!-- Empty Reference Subhead -->
  <!--ISBN=1576101746//-->
  <!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
  <!--AUTHOR=Michael Abrash//-->
  <!--PUBLISHER=The Coriolis Group, Inc.//-->
  <!--CHAPTER=52//-->
  <!--PAGES=977-979//-->
  <!--UNASSIGNED1//-->
  <!--UNASSIGNED2//-->
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="52-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="52-05.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p><b>LISTING 52.6 L52-6.C</b></p><!-- CODE //-->
  <pre>
/* Rotates and moves a polygon-based object around the three axes.
   Movement is implemented only along the Z axis currently. */

#include &ldquo;polygon.h&rdquo;

void RotateAndMovePObject(PObject * ObjectToMove)
{
   if (--ObjectToMove-&gt;RDelayCount == 0) {   /* rotate */
      ObjectToMove-&gt;RDelayCount = ObjectToMove-&gt;RDelayCountBase;
      if (ObjectToMove-&gt;Rotate.RotateX != 0.0)
         AppendRotationX(ObjectToMove-&gt;XformToWorld,
               ObjectToMove-&gt;Rotate.RotateX);
      if (ObjectToMove-&gt;Rotate.RotateY != 0.0)
         AppendRotationY(ObjectToMove-&gt;XformToWorld,
               ObjectToMove-&gt;Rotate.RotateY);
      if (ObjectToMove-&gt;Rotate.RotateZ != 0.0)
         AppendRotationZ(ObjectToMove-&gt;XformToWorld,
               ObjectToMove-&gt;Rotate.RotateZ);
      ObjectToMove-&gt;RecalcXform = 1;
   }
   /* Move in Z, checking for bouncing and stopping */
   if (--ObjectToMove-&gt;MDelayCount == 0) {
      ObjectToMove-&gt;MDelayCount = ObjectToMove-&gt;MDelayCountBase;
      ObjectToMove-&gt;XformToWorld[2][3] += ObjectToMove-&gt;Move.MoveZ;
      if (ObjectToMove-&gt;XformToWorld[2][3]&gt;ObjectToMove-&gt;Move.MaxZ)
         ObjectToMove-&gt;Move.MoveZ = 0; /* stop if close enough */
      ObjectToMove-&gt;RecalcXform = 1;
   }
}
</pre><!-- END CODE //-->

  <p><b>LISTING 52.7 L52-7.C</b></p><!-- CODE //-->
  <pre>
/* Draws all visible faces in specified polygon-based object. Object must have
   previously been transformed and projected, so that ScreenVertexList array is
   filled in. */

#include &ldquo;polygon.h&rdquo;

void DrawPObject(PObject * ObjectToXform)
{
   int i, j, NumFaces = ObjectToXform-&gt;NumFaces, NumVertices;
   int * VertNumsPtr;
   Face * FacePtr = ObjectToXform-&gt;FaceList;
   Point * ScreenPoints = ObjectToXform-&gt;ScreenVertexList;
   long v1, v2, w1, w2;
   Point Vertices[MAX_POLY_LENGTH];
   PointListHeader Polygon;

   /* Draw each visible face (polygon) of the object in turn */
   for (i=0; i&lt;NumFaces; i++, FacePtr++) {
      NumVertices = FacePtr-&gt;NumVerts;
      /* Copy over the face's vertices from the vertex list */
      for (j=0, VertNumsPtr=FacePtr-&gt;VertNums; j&lt;NumVertices; j++)
         Vertices[j] = ScreenPoints[*VertNumsPtr++];
      /* Draw only if outside face showing (if the normal to the
         polygon points toward viewer; that is, has a positive Z component) */
      v1 = Vertices[1].X - Vertices[0].X;
      w1 = Vertices[NumVertices-1].X - Vertices[0].X;
      v2 = Vertices[1].Y - Vertices[0].Y;
      w2 = Vertices[NumVertices-1].Y - Vertices[0].Y;
      if ((v1*w2 - v2*w1) &gt; 0) {
         /* It is facing the screen, so draw */
         /* Appropriately adjust the extent of the rectangle used to
            erase this object later */
         for (j=0; j&lt;NumVertices; j++) {
            if (Vertices[j].X &gt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Right)
               if (Vertices[j].X &lt; SCREEN_WIDTH)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Right =
                        Vertices[j].X;
               else ObjectToXform-&gt;EraseRect[NonDisplayedPage].Right =
                     SCREEN_WIDTH;
            if (Vertices[j].Y &gt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Bottom)
               if (Vertices[j].Y &lt; SCREEN_HEIGHT)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Bottom =
                        Vertices[j].Y;
               else ObjectToXform-&gt;EraseRect[NonDisplayedPage].Bottom=
                     SCREEN_HEIGHT;
            if (Vertices[j].X &lt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Left)
               if (Vertices[j].X &gt; 0)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Left =
                        Vertices[j].X;
               else ObjectToXform-&gt;EraseRect[NonDisplayedPage].Left=0;
            if (Vertices[j].Y &lt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Top)
               if (Vertices[j].Y &gt; 0)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Top =
                        Vertices[j].Y;
               else ObjectToXform-&gt;EraseRect[NonDisplayedPage].Top=0;
         }
         /* Draw the polygon */
         DRAW_POLYGON(Vertices, NumVertices, FacePtr-&gt;Color, 0, 0);
      }
   }
}
</pre><!-- END CODE //-->

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="52-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="52-05.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div><!-- all of the reference materials (books) have the footer and subfoot reveresed -->
  <!-- reference_subfoot = footer -->
  <!-- reference_footer = subfoot -->
  <!-- BEGIN SUB FOOTER -->
  <!-- END FOOTER -->
</body>
</html>
