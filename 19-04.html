<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Pentium: Not the Same Old Song</title><!-- HEADER -->
  <!-- Empty Reference Subhead -->
  <!--ISBN=1576101746//-->
  <!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
  <!--AUTHOR=Michael Abrash//-->
  <!--PUBLISHER=The Coriolis Group, Inc.//-->
  <meta name="chapter" content="19" />
  <meta name="pages" content="377-379" />
  <!--UNASSIGNED1//-->
  <!--UNASSIGNED2//-->
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="19-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="20-01.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <h3><a id="Heading8"></a>Branch Prediction</h3>

  <p>One brand-spanking-new feature of the Pentium is <i>branch prediction</i>, whereby the Pentium tries to guess, based on past history, which way (or, for conditional jumps, whether or not), your code will jump at each branch, and prefetches along the likelier path. If the guess is correct, the branch or fall-through takes only 1 cycle&mdash;2 cycles less than a branch and the same as a fall-through on the 486; if the guess is wrong, the branch or fall-through takes 4 or 5 cycles (if it executes in the U- or V-pipe, respectively)&mdash;1 or 2 cycles more than a branch and 3 or 4 cycles more than a fall-through on the 486.</p>

  <table width="100%">
    <tr>
      <td valign="top" align="left" width="5%"><img src="images/i.jpg" /></td>

      <td valign="top" align="left" width="95%"><small><i>Branch prediction is unprecedented in the x86, and fundamentally alters the nature of pedal-to-the-metal optimization, for the simple reason that it renders unrolled loops largely obsolete. Rare indeed is the loop that can&rsquo;t afford to spare even 1 or 0 (yes, zero!) cycles per iteration for loop counting, and that&rsquo;s how low the cost can go for maintaining a loop on the Pentium.</i></small></td>
    </tr>
  </table>

  <p>Also, unrolled loops are bigger than normal loops, so there are extra (and expensive) cache misses the first time through the loop if the entire loop isn&rsquo;t already in the cache; then, too, an unrolled loop will shoulder other code out of the internal and external caches. If in a critical loop you absolutely need the time taken by the loop control instructions, or if you need an extra register that can be freed by unrolling a loop, then by all means unroll the loop. Don&rsquo;t expect the sort of speed-up you get from this on the 486 or especially the 386, though, and watch out for the cache effects.</p>

  <p>You may well wonder exactly <i>when</i> the Pentium correctly predicts branching. Alas, this is one area that Intel has declined to document, beyond saying that you should endeavor to fall through branches when you have a choice. That&rsquo;s good advice on every other x86 processor, anyway, so it&rsquo;s well worth following. Also, it&rsquo;s a pretty safe bet that in a tight loop, the Pentium will start guessing the right branch direction at the bottom of the loop pretty quickly, so you can treat loop branches as one-cycle instructions.</p>

  <p>It&rsquo;s an equally safe bet that it&rsquo;s a bad move to have in a loop a conditional branch that goes both ways on a random basis; it&rsquo;s hard to see how the Pentium could consistently predict such branches correctly, and mispredicted branches are more expensive than they might appear to be. Not only does a mispredicted branch take 4 or 5 cycles, but the Pentium can potentially execute as many as 8 or 10 instructions in that time&mdash;3 times as many as the 486 can execute during its branch time&mdash;so correct branch prediction (or eliminating branch instructions, if possible) is very important in inner loops. Note that on the 486 you can count on a branch to take 1 cycle when it falls through, but on the Pentium you can&rsquo;t be sure whether it will take 1 or either 4 or 5 cycles on any given iteration.</p>

  <table width="100%">
    <tr>
      <td valign="top" align="left" width="5%"><img src="images/i.jpg" /></td>

      <td valign="top" align="left" width="95%"><small><i>As things currently stand, branch prediction is an annoyance for assembly language optimization because it&rsquo;s impossible to be certain exactly how code will perform until you measure it, and even then it&rsquo;s difficult to be sure exactly where the cycles went. All I can say is try to fall through branches if possible, and try to be consistent in your branching if not.</i></small></td>
    </tr>
  </table>

  <h3><a id="Heading9"></a>Miscellaneous Pentium Topics</h3>

  <p>The Pentium has all the instructions of the 486, plus a few new ones. One much-needed instruction that has finally made it into the instruction set is <b>CPUID</b>, which allows your code to determine what processor it&rsquo;s running on. <b>CPUID</b> is 15 years late, but at least it&rsquo;s finally here. Another new instruction is <b>CMPXCHG8B</b>, which does a compare and conditional exchange on a qword. <b>CMPXCHG8B</b> doesn&rsquo;t seem to me to be a particularly useful instruction, but I&rsquo;m sure Intel wouldn&rsquo;t have added it without a reason; if you know of a use for it, please pass it along to me.</p>

  <h4 align="left"><a id="Heading10"></a>486 versus Pentium Optimization</h4>

  <p>Many Pentium optimizations help, or at least don&rsquo;t hurt, on the 486. Many, but not all&mdash;and many <i>do</i> hurt on the 386. As I discuss various Pentium optimizations, I will attempt to note the effects on the 486 as well, but doing this in complete detail would double the sizes of these discussions and make them hard to follow. In general, I&rsquo;d recommend reserving Pentium optimization for your most critical code, and even there, it&rsquo;s a good idea to have at least two code paths, one for the 386 and one for the 486/Pentium. It&rsquo;s also a good idea to time your code on a 486 before and after Pentium-optimizing it, to make sure you haven&rsquo;t hurt performance on what will be, after all, by far the most important processor over the next couple of years.</p>

  <p>With that in mind, is optimizing for the Pentium even worthwhile today? That depends on your application and its market&mdash;but if you want absolutely the best possible performance for your DOS and Windows apps on the fastest hardware, Pentium optimization can make your code <i>scream</i>.</p>

  <h4 align="left"><a id="Heading11"></a>Going Superscalar</h4>

  <p>In the next chapter, we&rsquo;ll look into the single biggest element of Pentium performance, cranking up the Pentium&rsquo;s second execution pipe. This is the area in which compiler technology is most touted for the Pentium, the two thoughts apparently being that (1) most existing code is in C, so recompiling to use the second pipe better is an automatic win, and (2) it&rsquo;s so complicated to optimize Pentium code that only a compiler can do it well. The first point is a reasonable one, but it does suffer from one flaw for large programs, in that Pentium-optimized code is larger than 486- or 386-optimized code, for reasons that will become apparent in the next chapter. Larger code means more cache misses and more page faults; and while most of the code in any program is not critical to performance, compilers optimize code indiscriminately.</p>

  <p>The result is that Pentium compiler optimization not only expands code, but can be less beneficial than expected or even slower in some cases. What makes more sense is enabling Pentium optimization <i>only</i> for key code. Better yet, you could hand-tune the most important code&mdash;and yes, you can absolutely do a better job with a small, critical loop than any PC compiler I&rsquo;ve ever seen, or expect to see. Sure, you keep hearing how great each new compiler generation is, and compilers certainly have improved; but they play by the same rules we do, and we&rsquo;re more flexible and know more about what we&rsquo;re doing&mdash;and now we have the wonderfully complex and powerful Pentium upon which to loose our carbon-based optimizers.</p>

  <p>A compiler that generates better code than a good assembly programmer? That&rsquo;ll be the day.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="19-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="20-01.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div><!-- all of the reference materials (books) have the footer and subfoot reveresed -->
  <!-- reference_subfoot = footer -->
  <!-- reference_footer = subfoot -->
  <!-- BEGIN SUB FOOTER -->
  <!-- END FOOTER -->
</body>
</html>
