<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: Fast 3-D Animation: Meet X-Sharp</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=52//-->
<!--PAGES=977-979//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><BODY LINK=#0000FF ALINK=#000099 VLINK=#0000FF BGCOLOR=#FFFFFF>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="52-03.html">Previous</A></TD>
<TD><A HREF="../index.html">Table of Contents</A></TD>
<TD><A HREF="52-05.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P><B>LISTING 52.6 L52-6.C</B></P>
<!-- CODE //-->
<PRE>
/* Rotates and moves a polygon-based object around the three axes.
   Movement is implemented only along the Z axis currently. */

#include &#147;polygon.h&#148;

void RotateAndMovePObject(PObject * ObjectToMove)
{
   if (--ObjectToMove-&gtRDelayCount == 0) {   /* rotate */
      ObjectToMove-&gtRDelayCount = ObjectToMove-&gtRDelayCountBase;
      if (ObjectToMove-&gtRotate.RotateX != 0.0)
         AppendRotationX(ObjectToMove-&gtXformToWorld,
               ObjectToMove-&gtRotate.RotateX);
      if (ObjectToMove-&gtRotate.RotateY != 0.0)
         AppendRotationY(ObjectToMove-&gtXformToWorld,
               ObjectToMove-&gtRotate.RotateY);
      if (ObjectToMove-&gtRotate.RotateZ != 0.0)
         AppendRotationZ(ObjectToMove-&gtXformToWorld,
               ObjectToMove-&gtRotate.RotateZ);
      ObjectToMove-&gtRecalcXform = 1;
   }
   /* Move in Z, checking for bouncing and stopping */
   if (--ObjectToMove-&gtMDelayCount == 0) {
      ObjectToMove-&gtMDelayCount = ObjectToMove-&gtMDelayCountBase;
      ObjectToMove-&gtXformToWorld[2][3] += ObjectToMove-&gtMove.MoveZ;
      if (ObjectToMove-&gtXformToWorld[2][3]&gtObjectToMove-&gtMove.MaxZ)
         ObjectToMove-&gtMove.MoveZ = 0; /* stop if close enough */
      ObjectToMove-&gtRecalcXform = 1;
   }
}
</PRE>
<!-- END CODE //-->
<P><B>LISTING 52.7 L52-7.C</B></P>
<!-- CODE //-->
<PRE>
/* Draws all visible faces in specified polygon-based object. Object must have
   previously been transformed and projected, so that ScreenVertexList array is
   filled in. */

#include &#147;polygon.h&#148;

void DrawPObject(PObject * ObjectToXform)
{
   int i, j, NumFaces = ObjectToXform-&gtNumFaces, NumVertices;
   int * VertNumsPtr;
   Face * FacePtr = ObjectToXform-&gtFaceList;
   Point * ScreenPoints = ObjectToXform-&gtScreenVertexList;
   long v1, v2, w1, w2;
   Point Vertices[MAX_POLY_LENGTH];
   PointListHeader Polygon;

   /* Draw each visible face (polygon) of the object in turn */
   for (i=0; i&ltNumFaces; i++, FacePtr++) {
      NumVertices = FacePtr-&gtNumVerts;
      /* Copy over the face's vertices from the vertex list */
      for (j=0, VertNumsPtr=FacePtr-&gtVertNums; j&ltNumVertices; j++)
         Vertices[j] = ScreenPoints[*VertNumsPtr++];
      /* Draw only if outside face showing (if the normal to the
         polygon points toward viewer; that is, has a positive Z component) */
      v1 = Vertices[1].X - Vertices[0].X;
      w1 = Vertices[NumVertices-1].X - Vertices[0].X;
      v2 = Vertices[1].Y - Vertices[0].Y;
      w2 = Vertices[NumVertices-1].Y - Vertices[0].Y;
      if ((v1*w2 - v2*w1) &gt 0) {
         /* It is facing the screen, so draw */
         /* Appropriately adjust the extent of the rectangle used to
            erase this object later */
         for (j=0; j&ltNumVertices; j++) {
            if (Vertices[j].X &gt
                  ObjectToXform-&gtEraseRect[NonDisplayedPage].Right)
               if (Vertices[j].X &lt SCREEN_WIDTH)
                  ObjectToXform-&gtEraseRect[NonDisplayedPage].Right =
                        Vertices[j].X;
               else ObjectToXform-&gtEraseRect[NonDisplayedPage].Right =
                     SCREEN_WIDTH;
            if (Vertices[j].Y &gt
                  ObjectToXform-&gtEraseRect[NonDisplayedPage].Bottom)
               if (Vertices[j].Y &lt SCREEN_HEIGHT)
                  ObjectToXform-&gtEraseRect[NonDisplayedPage].Bottom =
                        Vertices[j].Y;
               else ObjectToXform-&gtEraseRect[NonDisplayedPage].Bottom=
                     SCREEN_HEIGHT;
            if (Vertices[j].X &lt
                  ObjectToXform-&gtEraseRect[NonDisplayedPage].Left)
               if (Vertices[j].X &gt 0)
                  ObjectToXform-&gtEraseRect[NonDisplayedPage].Left =
                        Vertices[j].X;
               else ObjectToXform-&gtEraseRect[NonDisplayedPage].Left=0;
            if (Vertices[j].Y &lt
                  ObjectToXform-&gtEraseRect[NonDisplayedPage].Top)
               if (Vertices[j].Y &gt 0)
                  ObjectToXform-&gtEraseRect[NonDisplayedPage].Top =
                        Vertices[j].Y;
               else ObjectToXform-&gtEraseRect[NonDisplayedPage].Top=0;
         }
         /* Draw the polygon */
         DRAW_POLYGON(Vertices, NumVertices, FacePtr-&gtColor, 0, 0);
      }
   }
}
</PRE>
<!-- END CODE //-->
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="52-03.html">Previous</A></TD>
<TD><A HREF="../index.html">Table of Contents</A></TD>
<TD><A HREF="52-05.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Graphics Programming Black Book &copy; 2001 Michael Abrash</font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


