<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Compiling BSP Trees</title>
  <meta name="chapter" content="60" />
  <meta name="pages" content="1123-1127" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="60-02.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="60-04.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p><b>Listing 60.1 L60_1.CPP</b></p>
  <pre>
#define MAX_NUM_LINESEGS 1000
#define MAX_INT          0x7FFFFFFF
#define MATCH_TOLERANCE  0.00001
// A vertex
typedef struct _VERTEX
{
   double x;
   double y;
} VERTEX;
// A potentially split piece of a line segment, as processed from the
// base line in the original list
typedef struct _LINESEG
{
   _LINESEG *pnextlineseg;
    int startvertex;
    int endvertex;
    double walltop;
    double wallbottom;
    double tstart;
    double tend;
    int color;
    _LINESEG *pfronttree;
    _LINESEG *pbacktree;
} LINESEG, *PLINESEG;
static VERTEX *pvertexlist;
static int NumCompiledLinesegs = 0;
static LINESEG *pCompiledLinesegs;
// Builds a BSP tree from the specified line list. List must contain
// at least one entry. If pCurrentTree is NULL, then this is the root
// node, otherwise pCurrentTree is the tree that&rsquo;s been build so far.
// Returns NULL for errors.
LINESEG * SelectBSPTree(LINESEG * plineseghead,
    LINESEG * pCurrentTree, LINESEG ** pParentsChildPointer)
{
    LINESEG *pminsplit;
    int minsplits;
    int tempsplitcount;
    LINESEG *prootline;
    LINESEG *pcurrentline;
    double nx, ny, numer, denom, t;
    // Pick a line as the root, and remove it from the list of lines
    // to be categorized. The line we&rsquo;ll select is the one of those in
    // the list that splits the fewest of the other lines in the list
    minsplits = MAX_INT;
    prootline = plineseghead;
    while (prootline != NULL) {
        pcurrentline = plineseghead;
        tempsplitcount = 0;
        while (pcurrentline != NULL) {
            // See how many other lines the current line splits
            nx = pvertexlist[prootline-&gt;startvertex].y -
                    pvertexlist[prootline-&gt;endvertex].y;
            ny = -(pvertexlist[prootline-&gt;startvertex].x -
                    pvertexlist[prootline-&gt;endvertex].x);
            // Calculate the dot products we&rsquo;ll need for line
            // intersection and spatial relationship
            numer = (nx * (pvertexlist[pcurrentline-&gt;startvertex].x -
                    pvertexlist[prootline-&gt;startvertex].x)) +
                    (ny * (pvertexlist[pcurrentline-&gt;startvertex].y -
                    pvertexlist[prootline-&gt;startvertex].y));
            denom = ((-nx) * (pvertexlist[pcurrentline-&gt;endvertex].x -
                    pvertexlist[pcurrentline-&gt;startvertex].x)) +
                    ((-ny) * (pvertexlist[pcurrentline-&gt;endvertex].y -
                    pvertexlist[pcurrentline-&gt;startvertex].y));
            // Figure out if the infinite lines of the current line
            // and the root intersect; if so, figure out if the
            // current line segment is actually split, split if so,
            // and add front/back polygons as appropriate
            if (denom == 0.0) {
                // No intersection, because lines are parallel; no
                // split, so nothing to do
            } else {
                // Infinite lines intersect; figure out whether the
                // actual line segment intersects the infinite line
                // of the root, and split if so
                t =  numer / denom;
                if ((t &gt; pcurrentline-&gt;tstart) &amp;&amp;
                        (t &lt; pcurrentline-&gt;tend)) {
                    // The root splits the current line
                    tempsplitcount++;
                } else {
                    // Intersection outside segment limits, so no
                    // split, nothing to do
                }
            }
            pcurrentline = pcurrentline-&gt;pnextlineseg;
        }
        if (tempsplitcount &lt; minsplits) {
            pminsplit = prootline;
            minsplits = tempsplitcount;
        }
        prootline = prootline-&gt;pnextlineseg;
    }
    // For now, make this a leaf node so we can traverse the tree
    // as it is at this point. BuildBSPTree() will add children as
    // appropriate
    pminsplit-&gt;pfronttree = NULL;
    pminsplit-&gt;pbacktree = NULL;
    // Point the parent&rsquo;s child pointer to this node, so we can
    // track the currently-build tree
    *pParentsChildPointer = pminsplit;
    return BuildBSPTree(plineseghead, pminsplit, pCurrentTree);
}
// Builds a BSP tree given the specified root, by creating front and
// back lists from the remaining lines, and calling itself recursively
LINESEG * BuildBSPTree(LINESEG * plineseghead, LINESEG * prootline,
    LINESEG * pCurrentTree)
{
    LINESEG *pfrontlines;
    LINESEG *pbacklines;
    LINESEG *pcurrentline;
    LINESEG *pnextlineseg;
    LINESEG *psplitline;
    double nx, ny, numer, denom, t;
    int Done;
    // Categorize all non-root lines as either in front of the root&rsquo;s
    // infinite line, behind the root&rsquo;s infinite line, or split by the
    // root&rsquo;s infinite line, in which case we split it into two lines
    pfrontlines = NULL;
    pbacklines = NULL;
    pcurrentline = plineseghead;
    while (pcurrentline != NULL)
    {
      // Skip the root line when encountered
      if (pcurrentline == prootline) {
        pcurrentline = pcurrentline-&gt;pnextlineseg;
      } else  {
        nx = pvertexlist[prootline-&gt;startvertex].y -
                pvertexlist[prootline-&gt;endvertex].y;
        ny = -(pvertexlist[prootline-&gt;startvertex].x -
                pvertexlist[prootline-&gt;endvertex].x);
        // Calculate the dot products we&rsquo;ll need for line intersection
        // and spatial relationship
        numer = (nx * (pvertexlist[pcurrentline-&gt;startvertex].x -
                 pvertexlist[prootline-&gt;startvertex].x)) +
                (ny * (pvertexlist[pcurrentline-&gt;startvertex].y -
                 pvertexlist[prootline-&gt;startvertex].y));
        denom = ((-nx) * (pvertexlist[pcurrentline-&gt;endvertex].x -
                 pvertexlist[pcurrentline-&gt;startvertex].x)) +
                (-(ny) * (pvertexlist[pcurrentline-&gt;endvertex].y -
                 pvertexlist[pcurrentline-&gt;startvertex].y));
        // Figure out if the infinite lines of the current line and
        // the root intersect; if so, figure out if the current line
        // segment is actually split, split if so, and add front/back
        // polygons as appropriate
        if (denom == 0.0) {
            // No intersection, because lines are parallel; just add
            // to appropriate list
            pnextlineseg = pcurrentline-&gt;pnextlineseg;
            if (numer &lt; 0.0) {
                // Current line is in front of root line; link into
                // front list
                pcurrentline-&gt;pnextlineseg = pfrontlines;
                pfrontlines = pcurrentline;
            } else {
                // Current line behind root line; link into back list
                pcurrentline-&gt;pnextlineseg = pbacklines;
                pbacklines = pcurrentline;
            }
            pcurrentline = pnextlineseg;
        } else {
            // Infinite lines intersect; figure out whether the actual
            // line segment intersects the infinite line of the root,
            // and split if so
            t =  numer / denom;
            if ((t &gt; pcurrentline-&gt;tstart) &amp;&amp;
                    (t &lt; pcurrentline-&gt;tend)) {
                // The line segment must be split; add one split
                // segment to each list
                if (NumCompiledLinesegs &gt; (MAX_NUM_LINESEGS - 1)) {
                    DisplayMessageBox(&ldquo;Out of space for line segs;&rdquo;
                                 &ldquo;increase MAX_NUM_LINESEGS&rdquo;);
                    return NULL;
                }
                // Make a new line entry for the split part of line
                psplitline = &amp;pCompiledLinesegs[NumCompiledLinesegs];
                NumCompiledLinesegs++;
                *psplitline = *pcurrentline;
                psplitline-&gt;tstart = t;
                pcurrentline-&gt;tend = t;

                pnextlineseg = pcurrentline-&gt;pnextlineseg;
                if (numer &lt; 0.0) {
                    // Presplit part is in front of root line; link
                    // into front list and put postsplit part in back
                    // list
                    pcurrentline-&gt;pnextlineseg = pfrontlines;
                    pfrontlines = pcurrentline;
                    psplitline-&gt;pnextlineseg = pbacklines;
                    pbacklines = psplitline;
                } else {
                    // Presplit part is in back of root line; link
                    // into back list and put postsplit part in front
                    // list
                    psplitline-&gt;pnextlineseg = pfrontlines;
                    pfrontlines = psplitline;
                    pcurrentline-&gt;pnextlineseg = pbacklines;
                    pbacklines = pcurrentline;
                }
                pcurrentline = pnextlineseg;
            } else {
                // Intersection outside segment limits, so no need to
                // split; just add to proper list
                pnextlineseg = pcurrentline-&gt;pnextlineseg;
                Done = 0;
                while (!Done) {
                    if (numer &lt; -MATCH_TOLERANCE) {
                        // Current line is in front of root line;
                        // link into front list
                        pcurrentline-&gt;pnextlineseg = pfrontlines;
                        pfrontlines = pcurrentline;
                        Done = 1;
                    } else if (numer &gt; MATCH_TOLERANCE) {
                        // Current line is behind root line; link
                        // into back list
                        pcurrentline-&gt;pnextlineseg = pbacklines;
                        pbacklines = pcurrentline;
                        Done = 1;
                    } else {
                        // The point on the current line we picked to
                        // do front/back evaluation happens to be
                        // collinear with the root, so use the other
                        // end of the current line and try again
                        numer =
                            (nx *
                             (pvertexlist[pcurrentline-&gt;endvertex].x -
                              pvertexlist[prootline-&gt;startvertex].x))+
                            (ny *
                             (pvertexlist[pcurrentline-&gt;endvertex].y -
                              pvertexlist[prootline-&gt;startvertex].y));
                    }
                }
                pcurrentline = pnextlineseg;
            }
        }
      }
    }
    // Make a node out of the root line, with the front and back trees
    // attached
    if (pfrontlines == NULL) {
        prootline-&gt;pfronttree = NULL;
    } else {
        if (!SelectBSPTree(pfrontlines, pCurrentTree,
                          &amp;prootline-&gt;pfronttree)) {
            return NULL;
        }
    }
    if (pbacklines == NULL) {
        prootline-&gt;pbacktree = NULL;
    } else {
        if (!SelectBSPTree(pbacklines, pCurrentTree,
                          &amp;prootline-&gt;pbacktree)) {
            return NULL;
        }
    }
    return(prootline);
}
</pre>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="60-02.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="60-04.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
