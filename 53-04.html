<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Raw Speed and More</title>
  <meta name="chapter" content="53" />
  <meta name="pages" content="1001-1003" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="53-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="54-01.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p><b>LISTING 53.2 OLIST.C</b></p>
  <pre>
/* Object list-related functions. */
#include &lt;stdio.h&gt;
#include &ldquo;polygon.h&rdquo;

/* Set up the empty object list, with sentinels at both ends to
  terminate searches */
void InitializeObjectList()
{
   ObjectListStart.NextObject = &amp;ObjectListEnd;
   ObjectListStart.PreviousObject = NULL;
   ObjectListStart.CenterInView.Z = INT-TO-FIXED(-32768);
   ObjectListEnd.NextObject = NULL;
   ObjectListEnd.PreviousObject = &amp;ObjectListStart;
   ObjectListEnd.CenterInView.Z = 0x7FFFFFFFL;
   NumObjects = 0;
}

/* Adds an object to the object list, sorted by center Z coord. */
void AddObject(Object *ObjectPtr)
{
   Object *ObjectListPtr = ObjectListStart.NextObject;

   /* Find the insertion point. Guaranteed to terminate because of
      the end sentinel */
   while (ObjectPtr-&gt;CenterInView.Z &gt; ObjectListPtr-&gt;CenterInView.Z) {
      ObjectListPtr = ObjectListPtr-&gt;NextObject;
   }

   /* Link in the new object */
   ObjectListPtr-&gt;PreviousObject-&gt;NextObject = ObjectPtr;
   ObjectPtr-&gt;NextObject = ObjectListPtr;
   ObjectPtr-&gt;PreviousObject = ObjectListPtr-&gt;PreviousObject;
   ObjectListPtr-&gt;PreviousObject = ObjectPtr;
   NumObjects++;
}

/* Resorts the objects in order of ascending center Z coordinate in view space,
   by moving each object in turn to the correct position in the object list. */
void SortObjects()
{
   int i;
   Object *ObjectPtr, *ObjectCmpPtr, *NextObjectPtr;

   /* Start checking with the second object */
   ObjectCmpPtr = ObjectListStart.NextObject;
   ObjectPtr = ObjectCmpPtr-&gt;NextObject;
   for (i=1; i&lt;NumObjects; i++) {
      /* See if we need to move backward through the list */
      if (ObjectPtr-&gt;CenterInView.Z &lt; ObjectCmpPtr-&gt;CenterInView.Z) {
         /* Remember where to resume sorting with the next object */
         NextObjectPtr = ObjectPtr-&gt;NextObject;
         /* Yes, move backward until we find the proper insertion
            point. Termination guaranteed because of start sentinel */
         do {
            ObjectCmpPtr = ObjectCmpPtr-&gt;PreviousObject;
         } while (ObjectPtr-&gt;CenterInView.Z &lt;
               ObjectCmpPtr-&gt;CenterInView.Z);

         /* Now move the object to its new location */
         /* Unlink the object at the old location */
         ObjectPtr-&gt;PreviousObject-&gt;NextObject =
               ObjectPtr-&gt;NextObject;
         ObjectPtr-&gt;NextObject-&gt;PreviousObject =
               ObjectPtr-&gt;PreviousObject;

         /* Link in the object at the new location */
         ObjectCmpPtr-&gt;NextObject-&gt;PreviousObject = ObjectPtr;
         ObjectPtr-&gt;PreviousObject = ObjectCmpPtr;
         ObjectPtr-&gt;NextObject = ObjectCmpPtr-&gt;NextObject;
         ObjectCmpPtr-&gt;NextObject = ObjectPtr;

         /* Advance to the next object to sort */
         ObjectCmpPtr = NextObjectPtr-&gt;PreviousObject;
         ObjectPtr = NextObjectPtr;
      } else {
         /* Advance to the next object to sort */
         ObjectCmpPtr = ObjectPtr;
         ObjectPtr = ObjectPtr-&gt;NextObject;
      }
   }
}
</pre>

  <h4 align="left" id="Heading6">Rounding</h4>

  <p>FIXED.ASM contains the equate <b>ROUNDING-ON</b>. When this equate is 1, the results of multiplications and divisions are rounded to the nearest fixed-point values; when it&rsquo;s 0, the results are truncated. The difference between the results produced by the two approaches is, at most, 2<sup><small>-16</small></sup>; you wouldn&rsquo;t think that would make much difference, now, would you? But it does. When the animation is run with rounding disabled, the cubes start to distort visibly after a few minutes, and after a few minutes more they look like they&rsquo;ve been run over. In contrast, I&rsquo;ve never seen any significant distortion with rounding on, even after a half-hour or so. I think the difference with rounding is not that it&rsquo;s so much more accurate, but rather that the errors are evenly distributed; with truncation, the errors are biased, and biased errors become very visible when they&rsquo;re applied to right-angle objects. Even with rounding, though, the errors will eventually creep in, and reorthogonalization will become necessary at some point.</p>

  <p>The performance cost of rounding is small, and the benefits are highly visible. Still, truncation errors become significant only when they accumulate over time, as, for example, when rotation matrices are repeatedly concatenated over the course of many transformations. Some time could be saved by rounding only in such cases. For example, division is performed only in the course of projection, and the results do not accumulate over time, so it would be reasonable to disable rounding for division.</p>

  <h4 align="left" id="Heading7">Having a Ball</h4>

  <p>So far in our exploration of 3-D animation, we&rsquo;ve had nothing to look at but triangles and cubes. It&rsquo;s time for something a little more visually appealing, so the demonstration program now features a 72-sided ball. What&rsquo;s particularly interesting about this ball is that it&rsquo;s created by the GENBALL.C program in the BALL subdirectory of X-Sharp, and both the size of the ball and the number of bands of faces are programmable. GENBALL.C spits out to a file all the arrays of vertices and faces needed to create the ball, ready for inclusion in INITBALL.C. True, if you change the number of bands, you must change the Colors array in INITBALL.C to match, but that&rsquo;s a tiny detail; by and large, the process of generating a ball-shaped object is now automated. In fact, we&rsquo;re not limited to ball-shaped objects; substitute a different vertex and face generation program for GENBALL.C, and you can make whatever convex polyhedron you want; again, all you have to do is change the <b>Colors</b> array correspondingly. You can easily create multiple versions of the base object, too; INITCUBE.C is an example of this, creating 11 different cubes.</p>

  <p>What we have here is the first glimmer of an object-editing system. GENBALL.C is the prototype for object definition, and INITBALL.C is the prototype for general-purpose object instantiation. Certainly, it would be nice to someday have an interactive 3-D object editing tool and resource management setup. We have our hands full with the drawing end of things at the moment, though, and for now it&rsquo;s enough to be able to create objects in a semiautomated way.</p>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="53-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="54-01.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
