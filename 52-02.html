<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Fast 3-D Animation: Meet X-Sharp</title><!-- HEADER -->
  <!-- Empty Reference Subhead -->
  <!--ISBN=1576101746//-->
  <!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
  <!--AUTHOR=Michael Abrash//-->
  <!--PUBLISHER=The Coriolis Group, Inc.//-->
  <!--CHAPTER=52//-->
  <!--PAGES=973-974//-->
  <!--UNASSIGNED1//-->
  <!--UNASSIGNED2//-->
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="52-01.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="52-03.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p><b>LISTING 52.1 L52-1.C</b></p><!-- CODE //-->
  <pre>
/* 3-D animation program to rotate 12 cubes. Uses fixed point. All C code
   tested with Borland C++ in C compilation mode and the small model. */

#include &lt;conio.h&gt;
#include &lt;dos.h&gt;
#include &ldquo;polygon.h&rdquo;

/* base offset of page to which to draw */
unsigned int CurrentPageBase = 0;
/* clip rectangle; clips to the screen */
int ClipMinX = 0, ClipMinY = 0;
int ClipMaxX = SCREEN_WIDTH, ClipMaxY = SCREEN_HEIGHT;
static unsigned int PageStartOffsets[2] =
   {PAGE0_START_OFFSET,PAGE1_START_OFFSET};
int DisplayedPage, NonDisplayedPage;
int RecalcAllXforms = 1, NumObjects = 0;
Xform WorldViewXform;   /* initialized from floats */
/* pointers to objects */
Object *ObjectList[MAX_OBJECTS];

void main() {
   int Done = 0, i;
   Object *ObjectPtr;
   union REGS regset;

   InitializeFixedPoint(); /* set up fixed-point data */
   InitializeCubes();      /* set up cubes and add them to object list; other
                              objects would be initialized now, if there were any */
   Set320x240Mode();       /* set the screen to mode X */
   ShowPage(PageStartOffsets[DisplayedPage = 0]);
   /* Keep transforming the cube, drawing it to the undisplayed page,
      and flipping the page to show it */
   do {
      /* For each object, regenerate viewing info, if necessary */
      for (i=0; i&lt;NumObjects; i++) {
         if ((ObjectPtr = ObjectList[i])-&gt;RecalcXform ||
               RecalcAllXforms) {
            ObjectPtr-&gt;RecalcFunc(ObjectPtr);
            ObjectPtr-&gt;RecalcXform = 0;
         }
      }
      RecalcAllXforms = 0;
      CurrentPageBase =    /* select other page for drawing to */
            PageStartOffsets[NonDisplayedPage = DisplayedPage ^ 1];
      /* For each object, clear the portion of the non-displayed page
         that was drawn to last time, then reset the erase extent */
      for (i=0; i&lt;NumObjects; i++) {
         ObjectPtr = ObjectList[i];
         FillRectangleX(ObjectPtr-&gt;EraseRect[NonDisplayedPage].Left,
            ObjectPtr-&gt;EraseRect[NonDisplayedPage].Top,
            ObjectPtr-&gt;EraseRect[NonDisplayedPage].Right,
            ObjectPtr-&gt;EraseRect[NonDisplayedPage].Bottom,
            CurrentPageBase, 0);
         ObjectPtr-&gt;EraseRect[NonDisplayedPage].Left =
              ObjectPtr-&gt;EraseRect[NonDisplayedPage].Top = 0x7FFF;
         ObjectPtr-&gt;EraseRect[NonDisplayedPage].Right =
               ObjectPtr-&gt;EraseRect[NonDisplayedPage].Bottom = 0;
      }
      /* Draw all objects */
      for (i=0; i&lt;NumObjects; i++)
         ObjectList[i]-&gt;DrawFunc(ObjectList[i]);
      /* Flip to display the page into which we just drew */
      ShowPage(PageStartOffsets[DisplayedPage = NonDisplayedPage]);
      /* Move and reorient each object */
      for (i=0; i&lt;NumObjects; i++)
         ObjectList[i]-&gt;MoveFunc(ObjectList[i]);
      if (kbhit())
         if (getch() == 0x1B) Done = 1;   /* Esc to exit */
   } while (!Done);
   /* Return to text mode and exit */
   regset.x.ax = 0x0003;   /* AL = 3 selects 80x25 text mode */
   int86(0x10, &amp;regset, &amp;regset);
   exit(1);
}
</pre><!-- END CODE //-->

  <p><b>LISTING 52.2 L52-2.C</b></p><!-- CODE //-->
  <pre>
/* Transforms all vertices in the specified polygon-based object into view
   space, then perspective projects them to screen space and maps them to screen
   coordinates, storing results in the object. Recalculates object-&gt;view
   transformation because only if transform changes would we bother
   to retransform the vertices. */

#include &lt;math.h&gt;
#include &ldquo;polygon.h&rdquo;

void XformAndProjectPObject(PObject * ObjectToXform)
{
   int i, NumPoints = ObjectToXform-&gt;NumVerts;
   Point3 * Points = ObjectToXform-&gt;VertexList;
   Point3 * XformedPoints = ObjectToXform-&gt;XformedVertexList;
   Point3 * ProjectedPoints = ObjectToXform-&gt;ProjectedVertexList;
   Point * ScreenPoints = ObjectToXform-&gt;ScreenVertexList;

   /* Recalculate the object-&gt;view transform */
   ConcatXforms(WorldViewXform, ObjectToXform-&gt;XformToWorld,
                ObjectToXform-&gt;XformToView);
   /* Apply that new transformation and project the points */
   for (i=0; i&lt;NumPoints; i++, Points++, XformedPoints++,
         ProjectedPoints++, ScreenPoints++) {
      /* Transform to view space */
      XformVec(ObjectToXform-&gt;XformToView, (Fixedpoint *) Points,
            (Fixedpoint *) XformedPoints);
      /* Perspective-project to screen space */
      ProjectedPoints-&gt;X =
            FixedMul(FixedDiv(XformedPoints-&gt;X, XformedPoints-&gt;Z),
            DOUBLE_TO_FIXED(PROJECTION_RATIO * (SCREEN_WIDTH/2)));
      ProjectedPoints-&gt;Y =
            FixedMul(FixedDiv(XformedPoints-&gt;Y, XformedPoints-&gt;Z),
            DOUBLE_TO_FIXED(PROJECTION_RATIO * (SCREEN_WIDTH/2)));
      ProjectedPoints-&gt;Z = XformedPoints-&gt;Z;
      /* Convert to screen coordinates. The Y coord is negated to flip from
         increasing Y being up to increasing Y being down, as expected by polygon
         filler. Add in half the screen width and height to center on screen. */
      ScreenPoints-&gt;X = ((int) ((ProjectedPoints-&gt;X +
            DOUBLE_TO_FIXED(0.5)) &gt;&gt; 16)) + SCREEN_WIDTH/2;
      ScreenPoints-&gt;Y = (-((int) ((ProjectedPoints-&gt;Y +
            DOUBLE_TO_FIXED(0.5)) &gt;&gt; 16))) + SCREEN_HEIGHT/2;
   }
}
</pre><!-- END CODE //-->

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="52-01.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="52-03.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div><!-- all of the reference materials (books) have the footer and subfoot reveresed -->
  <!-- reference_subfoot = footer -->
  <!-- reference_footer = subfoot -->
  <!-- BEGIN SUB FOOTER -->
  <!-- END FOOTER -->
</body>
</html>
