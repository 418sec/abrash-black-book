<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: The Polygon Primeval</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=38//-->
<!--PAGES=717-720//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><BODY LINK=#0000FF ALINK=#000099 VLINK=#0000FF BGCOLOR=#FFFFFF>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="38-02.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="38-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P><B>LISTING 38.3  L38-3.C</B></P>
<!-- CODE //-->
<PRE>
 /* Sample program to exercise the polygon-filling routines. This code
    and all polygon-filling code has been tested with Borland and
    Microsoft compilers. */

 #include &lt;conio.h&gt;
 #include &lt;dos.h&gt;
 #include &#147;polygon.h&#148;

 /* Draws the polygon described by the point list PointList in color
    Color with all vertices offset by (X,Y) */
 #define DRAW_POLYGON(PointList,Color,X,Y)                   \
    Polygon.Length = sizeof(PointList)/sizeof(struct Point); \
    Polygon.PointPtr = PointList;                            \
    FillConvexPolygon(&ampPolygon, Color, X, Y);
   
 void main(void);
 extern int FillConvexPolygon(struct PointListHeader *, int, int, int);

 void main() {
    int i, j;
    struct PointListHeader Polygon;
    static struct Point ScreenRectangle[] =
          {{0,0},{320,0},{320,200},{0,200}};
    static struct Point ConvexShape[] =
          {{0,0},{121,0},{320,0},{200,51},{301,51},{250,51},{319,143},
          {320,200},{22,200},{0,200},{50,180},{20,160},{50,140},
          {20,120},{50,100},{20,80},{50,60},{20,40},{50,20}};
    static struct Point Hexagon[] =
          {{90,-50},{0,-90},{-90,-50},{-90,50},{0,90},{90,50}};
    static struct Point Triangle1[] = {{30,0},{15,20},{0,0}};
    static struct Point Triangle2[] = {{30,20},{15,0},{0,20}};
    static struct Point Triangle3[] = {{0,20},{20,10},{0,0}};
    static struct Point Triangle4[] = {{20,20},{20,0},{0,10}};
    union REGS regset;

    /* Set the display to VGA mode 13h, 320&#215;200 256-color mode */
    regset.x.ax = 0&#215;0013;   /* AH = 0 selects mode set function,
                               AL = 0&#215;13 selects mode 0&#215;13
                               when set as parameters for INT 0&#215;10 */
    int86(0&#215;10, &ampregset, &ampregset);

    /* Clear the screen to cyan */
    DRAW_POLYGON(ScreenRectangle, 3, 0, 0);

    /* Draw an irregular shape that meets our definition of convex but
       is not convex by any normal description */
    DRAW_POLYGON(ConvexShape, 6, 0, 0);
    getch();    /* wait for a keypress */

    /* Draw adjacent triangles across the top half of the screen */
    for (j=0; j&lt;=80; j&#43;=20) {
       for (i=0; i&lt;290; i &#43;= 30) {
          DRAW_POLYGON(Triangle1, 2, i, j);
          DRAW_POLYGON(Triangle2, 4, i&#43;15, j);
       }
    }

    /* Draw adjacent triangles across the bottom half of the screen */
    for (j=100; j&lt;=170; j&#43;=20) {
       /* Do a row of pointing-right triangles */
       for (i=0; i&lt;290; i &#43;= 20) {
          DRAW_POLYGON(Triangle3, 40, i, j);
       }
       /* Do a row of pointing-left triangles halfway between one row
          of pointing-right triangles and the next, to fit between */
       for (i=0; i&lt;290; i &#43;= 20) {
          DRAW_POLYGON(Triangle4, 1, i, j&#43;10);
       }
    }
    getch();    /* wait for a keypress */

    /* Finally, draw a series of concentric hexagons of approximately
       the same proportions in the center of the screen */
    for (i=0; i&lt;16; i&#43;&#43;) {
       DRAW_POLYGON(Hexagon, i, 160, 100);
       for (j=0; j&lt;sizeof(Hexagon)/sizeof(struct Point); j&#43;&#43;) {
          /* Advance each vertex toward the center */
          if (Hexagon[j].X != 0) {
             Hexagon[j].X -= Hexagon[j].X &gt;= 0 ? 3 : -3;
             Hexagon[j].Y -= Hexagon[j].Y &gt;= 0 ? 2 : -2;
          } else {
             Hexagon[j].Y -= Hexagon[j].Y &gt;= 0 ? 3 : -3;
          }
       }
    }
    getch();    /* wait for a keypress */

    /* Return to text mode and exit */
    regset.x.ax = 0&#215;0003;   /* AL = 3 selects 80&#215;25 text mode */
    int86(0&#215;10, &ampregset, &ampregset);
 }
</PRE>
<!-- END CODE //-->
<P><B>LISTING 38.4  POLYGON.H</B></P>
<!-- CODE //-->
<PRE>
 /* POLYGON.H: Header file for polygon-filling code */

 /* Describes a single point (used for a single vertex) */
 struct Point {
    int X;   /* X coordinate */
    int Y;   /* Y coordinate */
 };

 /* Describes a series of points (used to store a list of vertices that
    describe a polygon; each vertex is assumed to connect to the two
    adjacent vertices, and the last vertex is assumed to connect to the
    first) */
 struct PointListHeader {
    int Length;                /* # of points */
    struct Point * PointPtr;   /* pointer to list of points */
 };

 /* Describes the beginning and ending X coordinates of a single
    horizontal line */
 struct HLine {
    int XStart; /* X coordinate of leftmost pixel in line */
    int XEnd;   /* X coordinate of rightmost pixel in line */
 };

 /* Describes a Length-long series of horizontal lines, all assumed to
    be on contiguous scan lines starting at YStart and proceeding
    downward (used to describe a scan-converted polygon to the
    low-level hardware-dependent drawing code) */
 struct HLineList {
    int Length;                /* # of horizontal lines */
    int YStart;                /* Y coordinate of topmost line */
    struct HLine * HLinePtr;   /* pointer to list of horz lines */
 };

</PRE>
<!-- END CODE //-->
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="38-02.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="38-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Graphics Programming Black Book &copy; 2001 Michael Abrash</font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


