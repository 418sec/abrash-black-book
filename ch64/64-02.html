<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: Quake's Visible-Surface Determination</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=64//-->
<!--PAGES=1181-1185//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><BODY LINK=#0000FF ALINK=#000099 VLINK=#0000FF BGCOLOR=#FFFFFF>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="64-01.html">Previous</A></TD>
<TD><A HREF="../index.html">Table of Contents</A></TD>
<TD><A HREF="64-03.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H3><A NAME="Heading4"></A><FONT COLOR="#000077">The Structure of Quake Levels</FONT></H3>
<P>Before diving into VSD, let me note that each Quake level is stored as a single huge 3-D BSP tree. This BSP tree, like any BSP, subdivides space, in this case along the planes of the polygons. However, unlike the BSP tree I presented in Chapter 62, Quake&#146;s BSP tree does not store polygons in the tree nodes, as part of the splitting planes, but rather in the empty (non-solid) leaves, as shown in overhead view in Figure 64.1.
</P>
<P>Correct drawing order can be obtained by drawing the leaves in front-to-back or back-to-front BSP order, again as discussed in Chapter 62. Also, because BSP leaves are always convex and the polygons are on the boundaries of the BSP leaves, facing inward, the polygons in a given leaf can never obscure one another and can be drawn in any order. (This is a general property of convex polyhedra.)</P>
<H3><A NAME="Heading5"></A><FONT COLOR="#000077">Culling and Visible Surface Determination</FONT></H3>
<P>The process of VSD would ideally work as follows: First, you would cull all polygons that are completely outside the view frustum (view pyramid), and would clip away the irrelevant portions of any polygons that are partially outside. Then, you would draw only those pixels of each polygon that are actually visible from the current viewpoint, as shown in overhead view in Figure 64.2, wasting no time overdrawing pixels multiple times; note how little of the polygon sets in Figure 64.2 actually need to be drawn. Finally, in a perfect world, the tests to figure out what parts of which polygons are visible would be free, and the processing time would be the same for all possible viewpoints, giving the game a smooth visual flow.
</P>
<P><A NAME="Fig1"><!-- </A><A HREF="javascript:displayWindow('images/64-01.jpg',406,226 )"> --><IMG SRC="images/64-01.jpg"><BR><!-- </A>
<BR><A HREF="javascript:displayWindow('images/64-01.jpg',406,226)"> --><FONT COLOR="#000077"><B>Figure 64.1</B></FONT></A>&nbsp;&nbsp;<I>Quake&#146;s polygons are stored as empty leaves.</I>
</P>
<P><A NAME="Fig2"><!-- </A><A HREF="javascript:displayWindow('images/64-02.jpg',405,243 )"> --><IMG SRC="images/64-02.jpg"><BR><!-- </A>
<BR><A HREF="javascript:displayWindow('images/64-02.jpg',405,243)"> --><FONT COLOR="#000077"><B>Figure 64.2</B></FONT></A>&nbsp;&nbsp;<I>Pixels visible from the current viewpoint.</I>
</P>
<P>As it happens, it is easy to determine which polygons are outside the frustum or partially clipped, and it&#146;s quite possible to figure out precisely which pixels need to be drawn. Alas, the world is far from perfect, and those tests are far from free, so the real trick is how to accelerate or skip various tests and still produce the desired result.
</P>
<P>As I discussed at length in Chapter 62, given a BSP, it&#146;s easy and inexpensive to walk the world in front-to-back or back-to-front order. The simplest VSD solution, which I in fact demonstrated earlier, is to simply walk the tree back-to-front, clip each polygon to the frustum, and draw it if it&#146;s facing forward and not entirely clipped (the painter&#146;s algorithm). Is that an adequate solution?</P>
<P>For relatively simple worlds, it is perfectly acceptable. It doesn&#146;t scale very well, though. One problem is that as you add more polygons in the world, more transformations and tests have to be performed to cull polygons that aren&#146;t visible; at some point, that will bog considerably performance down.</P>
<H4 ALIGN="LEFT"><A NAME="Heading6"></A><FONT COLOR="#000077">Nodes Inside and Outside the View Frustum</FONT></H4>
<P>Happily, there&#146;s a good workaround for this particular problem. As discussed earlier, each leaf of a BSP tree represents a convex subspace, with the nodes that bound the leaf delimiting the space. Perhaps less obvious is that each node in a BSP tree also describes a subspace&#151;the subspace composed of all the node&#146;s children, as shown in Figure 64.3. Another way of thinking of this is that each node splits the subspace into two pieces created by the nodes above it in the tree, and the node&#146;s children then further carve that subspace into all the leaves that descend from the node.
</P>
<P><A NAME="Fig3"><!-- </A><A HREF="javascript:displayWindow('images/64-03.jpg',410,214 )"> --><IMG SRC="images/64-03.jpg"><BR><!-- </A>
<BR><A HREF="javascript:displayWindow('images/64-03.jpg',410,214)"> --><FONT COLOR="#000077"><B>Figure 64.3</B></FONT></A>&nbsp;&nbsp;<I>The substance described by node E.</I>
</P>
<P>Since a node&#146;s subspace is bounded and convex, it is possible to test whether it is entirely outside the frustum. If it is, <I>all</I> of the node&#146;s children are certain to be fully clipped and can be rejected without any additional processing. Since most of the world is typically outside the frustum, many of the polygons in the world can be culled almost for free, in huge, node-subspace chunks. It&#146;s relatively expensive to perform a perfect test for subspace clipping, so instead bounding spheres or boxes are often maintained for each node, specifically for culling tests.</P>
<P>So culling to the frustum isn&#146;t a problem, and the BSP can be used to draw back-to- front. What, then, <I>is</I> the problem?</P>
<H3><A NAME="Heading7"></A><FONT COLOR="#000077">Overdraw</FONT></H3>
<P>The problem John Carmack, the driving technical force behind DOOM and Quake, faced when he designed Quake was that in a complex world, many scenes have an awful lot of polygons in the frustum. Most of those polygons are partially or entirely obscured by other polygons, but the painter&#146;s algorithm described earlier requires that every pixel of every polygon in the frustum be drawn, often only to be overdrawn. In a 10,000-polygon Quake level, it would be easy to get a worst-case overdraw level of 10 times or more; that is, in some frames each pixel could be drawn 10 times or more, on average. No rasterizer is fast enough to compensate for an order of such magnitude and more work than is actually necessary to show a scene; worse still, the painter&#146;s algorithm will cause a vast difference between best-case and worst-case performance, so the frame rate can vary wildly as the viewer moves around.
</P>
<P>So the problem John faced was how to keep overdraw down to a manageable level, preferably drawing each pixel exactly once, but certainly no more than two or three times in the worst case. As with frustum culling, it would be ideal if he could eliminate all invisible polygons in the frustum with virtually no work. It would also be a plus if he could manage to draw only the visible parts of partially-visible polygons, but that was a balancing act in that it had to be a lower-cost operation than the overdraw that would otherwise result.</P>
<P>When I arrived at id at the beginning of March 1995, John already had an engine prototyped and a plan in mind, and I assumed that our work was a simple matter of finishing and optimizing that engine. If I had been aware of id&#146;s history, however, I would have known better. John had done not only DOOM, but also the engines for Wolfenstein 3-D and several earlier games, and had actually done several different versions of each engine in the course of development (once doing four engines in four weeks), for a total of perhaps 20 distinct engines over a four-year period. John&#146;s tireless pursuit of new and better designs for Quake&#146;s engine, from every angle he could think of, would end only when we shipped the product.</P>
<P>By three months after I arrived, only one element of the original VSD design was anywhere in sight, and John had taken the dictum of &#147;try new things&#148; farther than I&#146;d ever seen it taken.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="64-01.html">Previous</A></TD>
<TD><A HREF="../index.html">Table of Contents</A></TD>
<TD><A HREF="64-03.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Graphics Programming Black Book &copy; 2001 Michael Abrash</font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


