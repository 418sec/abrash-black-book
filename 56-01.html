<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: Pooh and the Space Station</title>
  <meta name="chapter" content="56" />
  <meta name="pages" content="1046-1050" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td>
          <a href="55-04.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="56-02.html">Next</a>
        </td>
      </tr>
    </table>
  </center>

  <h2 id="Heading1">Chapter 56<br />
  Pooh and the Space Station</h2>

  <h3 id="Heading2">Using Fast Texture Mapping to Place Pooh on a Polygon</h3>

  <p>So, here&rsquo;s where Winnie the Pooh lives: in a space station orbiting Saturn. No, really; I have it straight from my daughter, and an eight-year-old wouldn&rsquo;t make up something that important, would she? One day she wondered aloud, &ldquo;Where is the Hundred Acre Wood, exactly?&rdquo; and before I could give one of those boring parental responses about how it was imaginary&mdash;but A.A. Milne probably imagined it to be somewhere near London&mdash;my daughter announced that the Hundred Acre Wood was in a space station orbiting Saturn, and there you have it.</p>

  <p>As it turns out, that&rsquo;s a very good location for the Hundred Acre Wood, leading to many exciting adventures for Pooh and Piglet. Consider the time they went down to the Jupiter gravity level (we&rsquo;re talking centrifugal force here; the station is spinning, of course) and nearly turned into pancakes of the Pooh and Piglet varieties, respectively. Or the time they drifted out into the free-fall area at the core and had to be rescued by humans with wings strapped on (a tip of the hat to Robert Heinlein here). Or the time they were caught up by the current in the river through the Wood and drifted for weeks around the circumference of the station, meeting many cultures and finding many adventures along the way. (Yes, Farmer&rsquo;s Riverworld; no one said the stories you tell your children need to be purely original, just interesting.)</p>

  <p>(If you think Pooh and Piglet in a space station is a tad peculiar, then I won&rsquo;t even mention Karla, the woman who invented agriculture, medicine, sanitation, reading and writing, peace, and just about everything else while travelling the length of the Americas with her mountain lion during the last Ice Age; or the Mars Cats and their trip in suspended animation to the Lesser Magellenic Cloud and beyond; or most assuredly Little Whale, the baby Universe Whale that is naughty enough to eat inhabited universes. But I digress.)</p>

  <p>Anyway, I bring up Pooh and the space station because the time has come to discuss fast texture mapping. <i>Texture mapping</i> is the process of mapping an image (in our case, a bitmap) onto the surface of a polygon that&rsquo;s been transformed in the process of 3-D drawing. Up to this point, each polygon we&rsquo;ve drawn in X-Sharp has been a single, solid color. Over the last couple of chapters we added the ability to shade polygons according to lighting, but each polygon was still a single color. Thus, in order to produce any sort of intricate design, a great many tiny polygons would have to be drawn. That would be very slow, so we need another approach. One such approach is texture mapping; that is, mapping the bitmap containing the desired image onto the pixels contained within the transformed polygon. Done properly, this should make it possible to change X-Sharp&rsquo;s output from a bland collection of monocolor facets to a lively, detailed, and much more realistic scene.</p>

  <p>&ldquo;What sort of scene?&rdquo; you may well ask. This is where Pooh and the space station came in. When I sat down to think of a sample texture-mapping application, it occurred to me that the shaded ball demo we added to X-Sharp recently looked at least a bit like a spinning, spherical space station, and that the single unshaded, yellow polygon looked somewhat like a window in the space station, and it might be a nice example if someone were standing in the window....</p>

  <p>The rest is history.</p>

  <h3 id="Heading3">Principles of Quick-and-Dirty Texture Mapping</h3>

  <p>The key to our texture-mapping approach will be to quickly determine what pixel value to draw for each pixel in the transformed destination polygon. These polygon pixel values will be determined by mapping each destination pixel in the transformed polygon back to the image bitmap, via a reverse transformation, and seeing what color resides at the corresponding location in the image bitmap, as shown in Figure 56.1. It might seem more intuitive to map pixels the other way, from the image bitmap to the transformed polygon, but in fact it&rsquo;s crucial that the mapping proceed backward from the destination to avoid gaps in the final image. With the approach of finding the right value for each destination pixel in turn, via a backward mapping, there&rsquo;s no way we can miss any destination pixels. On the other hand, with the forward-mapping method, some destination pixels may be skipped or double-drawn, because this is not necessarily a one-to-one or one-to-many mapping. Although we&rsquo;re not going to take advantage of it now, mapping back to the source makes it possible to average several neighboring image pixels together to calculate the value for each destination pixel; that is, to antialias the image. This can greatly improve texture quality, although it is slower.</p>

  <p><a id="Fig1"><img src="images/56-01.jpg" /><br />
  <b>Figure 56.1</b></a>&nbsp;&nbsp;<i>Using reverse transformation to find the source pixel color.</i></p>

  <h4 id="Heading4">Mapping Textures Made Easy</h4>

  <p>To understand how we&rsquo;re going to map textures, consider Figure 56.2, which maps a bitmapped image directly onto an untransformed polygon. Here, we simply map the origin of the polygon&rsquo;s untransformed coordinate system somewhere within the image, then map the vertices to the corresponding image pixels. (For simplicity, I&rsquo;ll assume in this discussion that the polygon&rsquo;s coordinate system is in units of pixels, but scaling images to polygons is eminently doable. This will become clearer when we look at mapping images onto transformed polygons, next.) Mapping the image to the polygon is then a simple matter of stepping one scan line at a time in both the image and the polygon, each time advancing the X coordinates of the edges according to the slopes of the lines, just as is normally done when filling a polygon. Since the polygon is untransformed, the stepping is identical in both the image and the polygon, and the pixel mapping is one-to-one, so the appropriate part of each scan line of the image can simply be block copied to the destination.</p>

  <p><a id="Fig2"><img src="images/56-02.jpg" /><br />
  <b>Figure 56.2</b></a>&nbsp;&nbsp;<i>Mapping a texture onto an untransformed polygon.</i></p>

  <p>Now, matters get more complicated. What if the destination polygon is rotated in two dimensions? We no longer have a neat direct mapping from image scan lines to destination polygon scan lines. We still want to draw across each destination scan line, but the proper source pixels for each destination scan line may now track across the source bitmap at an angle, as shown in Figure 56.3. What can we do?</p>

  <p>The solution is remarkably simple. We&rsquo;ll just map each transformed vertex to the corresponding vertex in the bitmap; this is easy, because the vertices are at the same indices in the original and transformed vertex lists. Each time we select a new edge to scan for the destination polygon, we&rsquo;ll select the corresponding edge in the source bitmap, as well. Then&mdash;and this is crucial&mdash;each time we step a destination edge one scan line, we&rsquo;ll step the corresponding source image edge an equivalent amount.</p>

  <center>
    <table border="1">
      <tr>
        <td>
          <a href="55-04.html">Previous</a>
        </td>

        <td>
          <a href="index.html">Table of Contents</a>
        </td>

        <td>
          <a href="56-02.html">Next</a>
        </td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
