<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: Hints My Readers Gave Me</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=09//-->
<!--PAGES=172-175//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><BODY LINK=#0000FF ALINK=#000099 VLINK=#0000FF BGCOLOR=#FFFFFF>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="09-01.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="09-03.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>However, it generally is. Sure, if the length is odd, John&#146;s approach incurs a penalty approximately equal to the <B>REP</B> startup time for <B>MOVSB</B>. However, if the length is even, John&#146;s approach doesn&#146;t branch, saving cycles and not emptying the prefetch queue. If copy lengths are evenly distributed between even and odd, John&#146;s approach is faster in most x86 systems. (Not on the 486, though.)</P>
<P>John also points out that on the 386, multiple <B>LEA</B>s can be combined to perform multiplications that can&#146;t be handled by a single <B>LEA</B>, much as multiple shifts and adds can be used for multiplication, only faster. <B>LEA</B> can be used to multiply in a single instruction on the 386, but only by the values 2, 3, 4, 5, 8, and 9; several <B>LEA</B>s strung together can handle a much wider range of values. For example, video programmers are undoubtedly familiar with the following code to multiply AX times 80 (the width in bytes of the bitmap in most PC display modes):</P>
<!-- CODE SNIP //-->
<PRE>
SHL   AX,1        ;*2
SH   LAX,1        ;*4
SH   LAX,1        ;*8
SH   LAX,1        ;*16
MO   VBX,AX
SH   LAX,1        ;*32
SH   LAX,1        ;*64
ADD  AX,BX        ;*80
</PRE>
<!-- END CODE SNIP //-->
<P>Using <B>LEA</B> on the 386, the above could be reduced to</P>
<!-- CODE SNIP //-->
<PRE>
LEA   EAX,[EAX*2]     ;*2
LEA   EAX,[EAX*8]     ;*16
LEA   EAX,[EAX&#43;EAX*4] ;*80
</PRE>
<!-- END CODE SNIP //-->
<P>which still isn&#146;t as fast as using a lookup table like
</P>
<!-- CODE SNIP //-->
<PRE>
MOV   EAX,MultiplesOf80Table[EAX*4]
</PRE>
<!-- END CODE SNIP //-->
<P>but is close and takes a great deal less space.
</P>
<P>Of course, on the 386, the shift and add version could also be reduced to this considerably more efficient code:</P>
<!-- CODE SNIP //-->
<PRE>
SH    LAX,4      ;*16
MOV   BX,AX
SHL   AX,2       ;*64
ADD   AX,BX      ;*80
</PRE>
<!-- END CODE SNIP //-->
<H4 ALIGN="LEFT"><A NAME="Heading5"></A><FONT COLOR="#000077">Speeding Up Multiplication</FONT></H4>
<P>That brings us to multiplication, one of the slowest of x86 operations and one that allows for considerable optimization. One way to speed up multiplication is to use shift and add, <B>LEA</B>, or a lookup table to hard-code a multiplication operation for a fixed multiplier, as shown above. Another is to take advantage of the early-out feature of the 386 (and the 486, but in the interests of brevity I&#146;ll just say &#147;386&#148; from now on) by arranging your operands so that the multiplier (always the rightmost operand following <B>MUL</B> or <B>IMUL</B>) is no larger than the other operand.</P>
<TABLE WIDTH="100%"><TD WIDTH="5%" VALIGN="TOP" ALIGN="LEFT"><IMG SRC="images/09-01i.jpg"><TD WIDTH="95%" VALIGN="TOP" ALIGN="LEFT"><SMALL><I>Why? Because the 386 processes one multiplier bit per cycle and immediately ends a multiplication when all significant bits of the multiplier have been processed, so fewer cycles are required to multiply a large multiplicand times a small multiplier than a small multiplicand times a large multiplier, by a factor of about 1 cycle for each significant multiplier bit eliminated.</I></SMALL>
</TABLE>
<P>(There&#146;s a minimum execution time on this trick; below 3 significant multiplier bits, no additional cycles are saved.) For example, multiplication of 32,767 times 1 is 12 cycles faster than multiplication of 1 times 32,727.
</P>
<P>Choosing the right operand as the multiplier can work wonders. According to published specs, the 386 takes 38 cycles to multiply by a multiplier with 32 significant bits but only 9 cycles to multiply by a multiplier of 2, a performance improvement of more than four times! (My tests regularly indicate that multiplication takes 3 to 4 cycles longer than the specs indicate, but the cycle-per-bit advantage of smaller multipliers holds true nonetheless.)</P>
<P>This highlights another interesting point: <B>MUL</B> and <B>IMUL</B> on the 386 are so fast that alternative multiplication approaches, while generally still faster, are worthwhile only in truly time-critical code.</P>
<TABLE WIDTH="100%"><TD WIDTH="5%" VALIGN="TOP" ALIGN="LEFT"><IMG SRC="images/09-02i.jpg"><TD WIDTH="95%" VALIGN="TOP" ALIGN="LEFT"><SMALL><I>On 386SXs and uncached 386s, where code size can significantly affect performance due to instruction prefetching, the compact <B>MUL</B> and <B>IMUL</B> instructions can approach and in some cases even outperform the &#147;optimized&#148; alternatives.</I></SMALL>
</TABLE>
<P>All in all, <B>MUL</B> and <B>IMUL</B> are reasonable performers on the 386, no longer to be avoided in most cases&#151;and you can help that along by arranging your code to make the smaller operand the multiplier whenever you know which operand is smaller.</P>
<P>That doesn&#146;t mean that your code should test and swap operands to make sure the smaller one is the multiplier; that rarely pays off. I&#146;m speaking more of the case where you&#146;re scaling an array up by a value that&#146;s always in the range of, say, 2 to 10; because the scale value will always be small and the array elements may have any value, the scale value is the logical choice for the multiplier.</P>
<H4 ALIGN="LEFT"><A NAME="Heading6"></A><FONT COLOR="#000077">Optimizing Optimized Searching</FONT></H4>
<P>Rob Williams writes with a wonderful optimization to the <B>REPNZ SCASB-</B>based optimized searching routine I discussed in Chapter 5. As a quick refresher, I described searching a buffer for a text string as follows: Scan for the first byte of the text string with <B>REPNZ SCASB</B>, then use <B>REPZ CMPS</B> to check for a full match whenever <B>REPNZ SCASB</B> finds a match for the first character, as shown in Figure 9.1. The principle is that most buffer characters won&#146;t match the first character of any given string, so <B>REPNZ SCASB</B>, by far the fastest way to search on the PC, can be used to eliminate most potential matches; each remaining potential match can then be checked in its entirety with <B>REPZ CMPS</B>.</P>
<P><A NAME="Fig1"><!-- </A><A HREF="javascript:displayWindow('images/09-01.jpg',406,306 )"> --><IMG SRC="images/09-01.jpg"><BR><!-- </A>
<BR><A HREF="javascript:displayWindow('images/09-01.jpg',406,306)"> --><FONT COLOR="#000077"><B>Figure 9.1</B></FONT></A>&nbsp;&nbsp;<I>Simple searching method for locating a text string.</I>
</P>
<P>Rob&#146;s revelation, which he credits without explanation to Edgar Allen Poe (search nevermore?), was that by far the slowest part of the whole deal is handling <B>REPNZ SCASB</B> matches, which require checking the remainder of the string with <B>REPZ CMPS</B> and restarting <B>REPNZ SCASB</B> if no match is found.</P>
<TABLE WIDTH="100%"><TD WIDTH="5%" VALIGN="TOP" ALIGN="LEFT"><IMG SRC="images/09-03i.jpg"><TD WIDTH="95%" VALIGN="TOP" ALIGN="LEFT"><SMALL><I>Rob points out that the number of <B>REPNZ SCASB</B> matches can easily be reduced simply by scanning for the character in the searched-for string that appears least often in the buffer being searched.</I></SMALL>
</TABLE>
<P>Imagine, if you will, that you&#146;re searching for the string &#147;EQUAL.&#148; By my approach, you&#146;d use <B>REPNZ SCASB</B> to scan for each occurrence of &#147;E,&#148; which crops up quite often in normal text. Rob points out that it would make more sense to scan for &#147;Q,&#148; then back up one character and check the whole string when a &#147;Q&#148; is found, as shown in Figure 9.2. &#147;Q&#148; is likely to occur much less often, resulting in many fewer whole-string checks and much faster processing.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="09-01.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="09-03.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Graphics Programming Black Book &copy; 2001 Michael Abrash</font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


