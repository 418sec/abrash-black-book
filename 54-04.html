<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="vsisbn" content="1576101746" />
  <meta name="vstitle" content="Michael Abrash's Graphics Programming Black Book, Special Edition" />
  <meta name="vsauthor" content="Michael Abrash" />
  <meta name="vspublisher" content="The Coriolis Group" />
  <meta name="vspubdate" content="07/01/97" />
  <meta name="vscategory" content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development" />

  <title>Michael Abrash's Graphics Programming Black Book Special Edition: 3-D Shading</title>
  <meta name="chapter" content="54" />
  <meta name="pages" content="1025-1027" />
</head>

<body>
  <center>
    <table border="1">
      <tr>
        <td><a href="54-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="54-05.html">Next</a></td>
      </tr>
    </table>
  </center>

  <p><br /></p>

  <p><b>LISTING 54.2 DRAWPOBJ.C</b></p>
  <pre>
/* Draws all visible faces in the specified polygon-based object. The object
   must have previously been transformed and projected, so that all vertex
   arrays are filled in. Ambient and diffuse shading are supported. */
#include "polygon.h"

void DrawPObject(PObject * ObjectToXform)
{
   int i, j, NumFaces = ObjectToXform-&gt;NumFaces, NumVertices;
   int * VertNumsPtr, Spot;
   Face * FacePtr = ObjectToXform-&gt;FaceList;
   Point * ScreenPoints = ObjectToXform-&gt;ScreenVertexList;
   PointListHeader Polygon;
   Fixedpoint Diffusion;
   ModelColor ColorTemp;
   ModelIntensity IntensityTemp;
   Point3 UnitNormal, *NormalStartpoint, *NormalEndpoint;
   long v1, v2, w1, w2;
   Point Vertices[MAX-POLY-LENGTH];

   /* Draw each visible face (polygon) of the object in turn */
   for (i=0; i&lt;NumFaces; i++, FacePtr++) {
      /* Remember where we can find the start and end of the polygon's
         unit normal in view space, and skip over the unit normal endpoint
         entry. The end and start points of the unit normal to the polygon
         must be the first and second entries in the polgyon's vertex list.
         Note that the second point is also an active polygon vertex */
      VertNumsPtr = FacePtr-&gt;VertNums;
      NormalEndpoint = &amp;ObjectToXform-&gt;XformedVertexList[*VertNumsPtr++];
      NormalStartpoint = &amp;ObjectToXform-&gt;XformedVertexList[*VertNumsPtr];
      /* Copy over the face's vertices from the vertex list */
      NumVertices = FacePtr-&gt;NumVerts;
      for (j=0; j&lt;NumVertices; j++)
         Vertices[j] = ScreenPoints[*VertNumsPtr++];
      /* Draw only if outside face showing (if the normal to the polygon
         in screen coordinates points toward the viewer; that is, has a
         positive Z component) */
      v1 = Vertices[1].X - Vertices[0].X;
      w1 = Vertices[NumVertices-1].X - Vertices[0].X;
      v2 = Vertices[1].Y - Vertices[0].Y;
      w2 = Vertices[NumVertices-1].Y - Vertices[0].Y;
      if ((v1*w2 - v2*w1) &gt; 0) {
         /* It is facing the screen, so draw */
         /* Appropriately adjust the extent of the rectangle used to
            erase this object later */
         for (j=0; j&lt;NumVertices; j++) {
            if (Vertices[j].X &gt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Right)
               if (Vertices[j].X &lt; SCREEN-WIDTH)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Right =
                        Vertices[j].X;
               else ObjectToXform-&gt;EraseRect[NonDisplayedPage].Right =
                     SCREEN-WIDTH;
            if (Vertices[j].Y &gt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Bottom)
               if (Vertices[j].Y &lt; SCREEN-HEIGHT)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Bottom =
                        Vertices[j].Y;
               else ObjectToXform-&gt;EraseRect[NonDisplayedPage].Bottom=
                     SCREEN-HEIGHT;
            if (Vertices[j].X &lt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Left)
               if (Vertices[j].X &gt; 0)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Left =
                        Vertices[j].X;
               else ObjectToXform-&gt;EraseRect[NonDisplayedPage].Left=0;
            if (Vertices[j].Y &lt;
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Top)
               if (Vertices[j].Y &gt; 0)
                  ObjectToXform-&gt;EraseRect[NonDisplayedPage].Top =
                        Vertices[j].Y;
               else ObjectToXform-&gt;EraseRect[NonDisplayedPage].Top=0;
         }
         /* See if there's any shading */
            if (FacePtr-&gt;ShadingType == 0) {
            /* No shading in effect, so just draw */
            DRAW-POLYGON(Vertices, NumVertices, FacePtr-&gt;ColorIndex, 0, 0);
         } else {
            /* Handle shading */
            /* Do ambient shading, if enabled */
            if (AmbientOn &amp;&amp; (FacePtr-&gt;ShadingType &amp; AMBIENT-SHADING)) {
               /* Use the ambient shading component */
               IntensityTemp = AmbientIntensity;
            } else {
               SET-INTENSITY(IntensityTemp, 0, 0, 0);
            }
            /* Do diffuse shading, if enabled */
            if (FacePtr-&gt;ShadingType &amp; DIFFUSE-SHADING) {
               /* Calculate the unit normal for this polygon, for use in dot
                  products */
               UnitNormal.X = NormalEndpoint-&gt;X - NormalStartpoint-&gt;X;
               UnitNormal.Y = NormalEndpoint-&gt;Y - NormalStartpoint-&gt;Y;
               UnitNormal.Z = NormalEndpoint-&gt;Z - NormalStartpoint-&gt;Z;
               /* Calculate the diffuse shading component for each active
                  spotlight */
               for (Spot=0; Spot&lt;MAX-SPOTS; Spot++) {
                  if (SpotOn[Spot] != 0) {
                     /* Spot is on, so sum, for each color component, the
                        intensity, accounting for the angle of the light rays
                        relative to the orientation of the polygon */
                     /* Calculate cosine of angle between the light and the
                        polygon normal; skip if spot is shining from behind
                        the polygon */
                     if ((Diffusion = DOT-PRODUCT(SpotDirectionView[Spot],
                           UnitNormal)) &gt; 0) {
                        IntensityTemp.Red +=
                              FixedMul(SpotIntensity[Spot].Red, Diffusion);
                        IntensityTemp.Green +=
                              FixedMul(SpotIntensity[Spot].Green, Diffusion);
                        IntensityTemp.Blue +=
                              FixedMul(SpotIntensity[Spot].Blue, Diffusion);
                     }
                  }
               }
            }
            /* Convert the drawing color to the desired fraction of the
               brightest possible color */
            IntensityAdjustColor(&amp;ColorTemp, &amp;FacePtr-&gt;FullColor,
                  &amp;IntensityTemp);
            /* Draw with the cumulative shading, converting from the general
               color representation to the best-match color index */
            DRAW-POLYGON(Vertices, NumVertices,
                  ModelColorToColorIndex(&amp;ColorTemp), 0, 0);
         }
      }
   }
}
</pre>

  <p><br /></p>

  <center>
    <table border="1">
      <tr>
        <td><a href="54-03.html">Previous</a></td>

        <td><a href="index.html">Table of Contents</a></td>

        <td><a href="54-05.html">Next</a></td>
      </tr>
    </table>
  </center>
  <hr width="90%" size="1" noshade="noshade" />

  <div align="center">
    Graphics Programming Black Book &copy; 2001 Michael Abrash
  </div>
</body>
</html>
