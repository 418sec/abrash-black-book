<HTML>
<HEAD>
<META name=vsisbn content="1576101746">
<META name=vstitle content="Michael Abrash's Graphics Programming Black Book, Special Edition">
<META name=vsauthor content="Michael Abrash">
<META name=vspublisher content="The Coriolis Group">
<META name=vspubdate content="07/01/97">
<META name=vscategory content="Web and Software Development: Game Development,Web and Software Development: Graphics and Multimedia Development">






<TITLE>Michael Abrash's Graphics Programming Black Book Special Edition: Pooh and the Space Station</TITLE>

<!-- HEADER -->
<!-- Empty Reference Subhead -->

<!--ISBN=1576101746//-->
<!--TITLE=Michael Abrash's Graphics Programming Black Book Special Edition//-->
<!--AUTHOR=Michael Abrash//-->
<!--PUBLISHER=The Coriolis Group, Inc.//-->
<!--CHAPTER=56//-->
<!--PAGES=1053-1059//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//--></HEAD><body>

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="56-02.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="57-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H3><A NAME="Heading6"></A>Fast Texture Mapping: An Implementation</H3>
<P>As you might expect, I&rsquo;ve implemented DDA texture mapping in X-Sharp, and the changes are reflected in the X-Sharp archive in this chapter&rsquo;s subdirectory on the listings disk. Listing 56.1 shows the new header file entries, and Listing 56.2 shows the actual texture-mapped polygon drawer. The set-pixel routine that Listing 56.2 calls is a slight modification of the Mode X set-pixel routine from Chapter 47. In addition, INITBALL.C has been modified to create three texture-mapped polygons and define the texture bitmaps, and modifications have been made to allow the user to flip the axis of rotation. You will of course need the complete X-Sharp library to see texture mapping in action, but Listings 56.1 and 56.2 are the actual texture mapping code in its entirety.
</P>
<TABLE WIDTH="100%"><TD WIDTH="5%" VALIGN="TOP" ALIGN="LEFT"><IMG SRC="images/i.jpg"><TD WIDTH="95%" VALIGN="TOP" ALIGN="LEFT"><SMALL><I>Here&rsquo;s a major tip: DDA texture mapping looks best on fast-moving surfaces, where the eye doesn&rsquo;t have time to pick nits with the shearing and aliasing that&rsquo;s an inevi table by-product of such a crude approach. Compile DEMO1 from the X-Sharp archive in this chapter&rsquo;s subdirectory of the listings disk, and run it. The initial display looks okay, but certainly not great, because the rotational speed is so slow. Now press the S key a few times to speed up the rotation and flip between different rotation axes. I think you&rsquo;ll be amazed at how much better DDA texture mapping looks at high speed. This technique would be great for mapping textures onto hurtling asteroids or jets, but would come up short for slow, finely detailed movements.</I></SMALL>
</TABLE>
<P><B>LISTING 56.1  L56-1.C</B></P>
<!-- CODE //-->
<PRE>
/* New header file entries related to texture-mapped polygons */

/* Draws the polygon described by the point list PointList with a bitmap
   texture mapped onto it */
#define DRAW_TEXTURED_POLYGON(PointList,NumPoints,TexVerts,TexMap) \
   Polygon.Length = NumPoints; Polygon.PointPtr = PointList;       \
   DrawTexturedPolygon(&amp;Polygon, TexVerts, TexMap);
#define FIXED_TO_INT(FixedVal) ((int) (FixedVal &gt;&gt; 16))
#define ROUND_FIXED_TO_INT(FixedVal) \
   ((int) ((FixedVal + DOUBLE_TO_FIXED(0.5)) &gt;&gt; 16))
/* Retrieves specified pixel from specified image bitmap of specified width. */
#define GET_IMAGE_PIXEL(TexMapBits, TexMapWidth, X, Y) \
   TexMapBits[(Y * TexMapWidth) + X]
/* Masks to mark shading types in Face structure */
#define NO_SHADING      0x0000
#define AMBIENT_SHADING 0x0001
#define DIFFUSE_SHADING 0x0002
#define TEXTURE_MAPPED_SHADING 0x0004
/* Describes a texture map */
typedef struct {
   int TexMapWidth;  /* texture map width in bytes */
   char *TexMapBits; /* pointer to texture bitmap */
} TextureMap;

/* Structure describing one face of an object (one polygon) */
typedef struct {
   int * VertNums;   /* pointer to list of indexes of this polygon&rsquo;s vertices
                        in the object&rsquo;s vertex list. The first two indexes
                        must select end and start points, respectively, of this
                        polygon&rsquo;s unit normal vector. Second point should also
                        be an active polygon vertex */
   int NumVerts;     /* # of verts in face, not including the initial
                        vertex, which must be the end of a unit normal vector
                        that starts at the second index in VertNums */
   int ColorIndex;   /* direct palette index; used only for non-shaded faces */
   ModelColor FullColor; /* polygon&rsquo;s color */
   int ShadingType;  /* none, ambient, diffuse, texture mapped, etc. */
   TextureMap * TexMap; /* pointer to bitmap for texture mapping, if any */
   Point * TexVerts; /* pointer to list of this polygon&rsquo;s vertices, in
                        TextureMap coordinates. Index n must map to index
                        n + 1 in VertNums, (the + 1 is to skip over the unit
                        normal endpoint in VertNums) */
} Face;
extern void DrawTexturedPolygon(PointListHeader *, Point *, TextureMap *);
</PRE>
<!-- END CODE //-->
<P><B>LISTING 56.2  L56-2.C</B></P>
<!-- CODE //-->
<PRE>
/* Draws a bitmap, mapped to a convex polygon (draws a texture-mapped polygon).
   &ldquo;Convex&rdquo; means that every horizontal line drawn through the polygon at any
   point would cross exactly two active edges (neither horizontal lines nor 
   zero-length edges count as active edges; both are acceptable anywhere in 
   the polygon), and that the right &amp; left edges never cross. Nonconvex 
   polygons won&rsquo;t be drawn properly. Can&rsquo;t fail. */
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &ldquo;polygon.h&rdquo;
/* Describes the current location and stepping, in both the source and
   the destination, of an edge */
typedef struct {
   int Direction;         /* through edge list; 1 for a right edge (forward
                             through vertex list), -1 for a left edge (backward
                             through vertex list) */
   int RemainingScans;    /* height left to scan out in dest */
   int CurrentEnd;        /* vertex # of end of current edge */
   Fixedpoint SourceX;    /* current X location in source for this edge */
   Fixedpoint SourceY;    /* current Y location in source for this edge */
   Fixedpoint SourceStepX;/* X step in source for Y step in dest of 1 */
   Fixedpoint SourceStepY;/* Y step in source for Y step in dest of 1 */
                          /* variables used for all-integer Bresenham&rsquo;s-type
                             X stepping through the dest, needed for precise
                             pixel placement to avoid gaps */
   int DestX;             /* current X location in dest for this edge */
   int DestXIntStep;      /* whole part of dest X step per scan-line Y step */
   int DestXDirection;    /* -1 or 1 to indicate way X steps (left/right) */
   int DestXErrTerm;      /* current error term for dest X stepping */
   int DestXAdjUp;        /* amount to add to error term per scan line move */
   int DestXAdjDown;      /* amount to subtract from error term when the
                             error term turns over */
} EdgeScan;
int StepEdge(EdgeScan *);
int SetUpEdge(EdgeScan *, int);
void ScanOutLine(EdgeScan *, EdgeScan *);
int GetImagePixel(char *, int, int, int);
/* Statics to save time that would otherwise pass them to subroutines. */
static int MaxVert, NumVerts, DestY;
static Point * VertexPtr;
static Point * TexVertsPtr;
static char * TexMapBits;
static int TexMapWidth;
/* Draws a texture-mapped polygon, given a list of destination polygon
   vertices, a list of corresponding source texture polygon vertices, and a
   pointer to the source texture&rsquo;s descriptor. */
void DrawTexturedPolygon(PointListHeader * Polygon, Point * TexVerts,
   TextureMap * TexMap)
{
   int MinY, MaxY, MinVert, i;
   EdgeScan LeftEdge, RightEdge;
   NumVerts = Polygon-&gt;Length;
   VertexPtr = Polygon-&gt;PointPtr;
   TexVertsPtr = TexVerts;
   TexMapBits = TexMap-&gt;TexMapBits;
   TexMapWidth = TexMap-&gt;TexMapWidth;
   /* Nothing to draw if less than 3 vertices */
   if (NumVerts &lt; 3) {
      return;
   }
   /* Scan through the destination polygon vertices and find the top of the
      left and right edges, taking advantage of our knowledge that vertices run
      in a clockwise direction (else this polygon wouldn&rsquo;t be visible due to 
      backface removal) */
   MinY = 32767;
   MaxY = -32768;
   for (i=0; i&lt;NumVerts; i++) {
      if (VertexPtr[i].Y &lt; MinY) {
         MinY = VertexPtr[i].Y;
         MinVert = i;
      }
      if (VertexPtr[i].Y &gt; MaxY) {
         MaxY = VertexPtr[i].Y;
         MaxVert = i;
      }
   }
   /* Reject flat (0-pixel-high) polygons */
   if (MinY &gt;= MaxY) {
      return;
   }
   /* The destination Y coordinate is not edge specific; it applies to
      both edges, since we always step Y by 1 */
   DestY = MinY;
   /* Set up to scan the initial left and right edges of the source and
      destination polygons. We always step the destination polygon edges
      by one in Y, so calculate the corresponding destination X step for
      each edge, and then the corresponding source image X and Y steps */
   LeftEdge.Direction = -1;   /* set up left edge first */
   SetUpEdge(&amp;LeftEdge, MinVert);
   RightEdge.Direction = 1;   /* set up right edge */
   SetUpEdge(&amp;RightEdge, MinVert);
   /* Step down destination edges one scan line at a time. At each scan
      line, find the corresponding edge points in the source image. Scan
      between the edge points in the source, drawing the corresponding
      pixels across the current scan line in the destination polygon. (We
      know which way the left and right edges run through the vertex list
      because visible (non-backface-culled) polygons always have the vertices
      in clockwise order as seen from the viewpoint) */
   for (;;) {
      /* Done if off bottom of clip rectangle */
      if (DestY &gt;= ClipMaxY) {
         return;
      }
      /* Draw only if inside Y bounds of clip rectangle */
      if (DestY &gt;= ClipMinY) {
         /* Draw the scan line between the two current edges */
         ScanOutLine(&amp;LeftEdge, &amp;RightEdge);
      }
      /* Advance the source and destination polygon edges, ending if we&rsquo;ve
         scanned all the way to the bottom of the polygon */
      if (!StepEdge(&amp;LeftEdge)) {
         break;
      }
      if (!StepEdge(&amp;RightEdge)) {
         break;
      }
      DestY++;
   }
}
/* Steps an edge one scan line in the destination, and the corresponding
   distance in the source. If an edge runs out, starts a new edge if there
   is one. Returns 1 for success, or 0 if there are no more edges to scan. */
int StepEdge(EdgeScan * Edge)
{
   /* Count off the scan line we stepped last time; if this edge is
      finished, try to start another one */
   if (--Edge-&gt;RemainingScans == 0) {
      /* Set up the next edge; done if there is no next edge */
      if (SetUpEdge(Edge, Edge-&gt;CurrentEnd) == 0) {
         return(0);  /* no more edges; done drawing polygon */
      }
      return(1);     /* all set to draw the new edge */
   }
   /* Step the current source edge */
   Edge-&gt;SourceX += Edge-&gt;SourceStepX;
   Edge-&gt;SourceY += Edge-&gt;SourceStepY;
   /* Step dest X with Bresenham-style variables, to get precise dest pixel
      placement and avoid gaps */
   Edge-&gt;DestX += Edge-&gt;DestXIntStep;  /* whole pixel step */
   /* Do error term stuff for fractional pixel X step handling */
   if ((Edge-&gt;DestXErrTerm += Edge-&gt;DestXAdjUp) &gt; 0) {
      Edge-&gt;DestX += Edge-&gt;DestXDirection;
      Edge-&gt;DestXErrTerm -= Edge-&gt;DestXAdjDown;
   }
   return(1);
}
/* Sets up an edge to be scanned; the edge starts at StartVert and proceeds
   in direction Edge-&gt;Direction through the vertex list. Edge-&gt;Direction must
   be set prior to call; -1 to scan a left edge (backward through the vertex
   list), 1 to scan a right edge (forward through the vertex list).
   Automatically skips over 0-height edges. Returns 1 for success, or 0 if
   there are no more edges to scan. */
int SetUpEdge(EdgeScan * Edge, int StartVert)
{
   int NextVert, DestXWidth;
   Fixedpoint DestYHeight;
   for (;;) {
      /* Done if this edge starts at the bottom vertex */
      if (StartVert == MaxVert) {
         return(0);
      }
      /* Advance to the next vertex, wrapping if we run off the start or end
         of the vertex list */
      NextVert = StartVert + Edge-&gt;Direction;
      if (NextVert &gt;= NumVerts) {
         NextVert = 0;
      } else if (NextVert &lt; 0) {
         NextVert = NumVerts - 1;
      }
      /* Calculate the variables for this edge and done if this is not a
         zero-height edge */
      if ((Edge-&gt;RemainingScans =
            VertexPtr[NextVert].Y - VertexPtr[StartVert].Y) != 0) {
         DestYHeight = INT_TO_FIXED(Edge-&gt;RemainingScans);
         Edge-&gt;CurrentEnd = NextVert;
         Edge-&gt;SourceX = INT_TO_FIXED(TexVertsPtr[StartVert].X);
         Edge-&gt;SourceY = INT_TO_FIXED(TexVertsPtr[StartVert].Y);
         Edge-&gt;SourceStepX = FixedDiv(INT_TO_FIXED(TexVertsPtr[NextVert].X) -
               Edge-&gt;SourceX, DestYHeight);
         Edge-&gt;SourceStepY = FixedDiv(INT_TO_FIXED(TexVertsPtr[NextVert].Y) -
               Edge-&gt;SourceY, DestYHeight);
         /* Set up Bresenham-style variables for dest X stepping */
         Edge-&gt;DestX = VertexPtr[StartVert].X;
         if ((DestXWidth =
               (VertexPtr[NextVert].X - VertexPtr[StartVert].X)) &lt; 0) {
            /* Set up for drawing right to left */
            Edge-&gt;DestXDirection = -1;
            DestXWidth = -DestXWidth;
            Edge-&gt;DestXErrTerm = 1 - Edge-&gt;RemainingScans;
            Edge-&gt;DestXIntStep = -(DestXWidth / Edge-&gt;RemainingScans);
         } else {
            /* Set up for drawing left to right */
            Edge-&gt;DestXDirection = 1;
            Edge-&gt;DestXErrTerm = 0;
            Edge-&gt;DestXIntStep = DestXWidth / Edge-&gt;RemainingScans;
         }
         Edge-&gt;DestXAdjUp = DestXWidth % Edge-&gt;RemainingScans;
         Edge-&gt;DestXAdjDown = Edge-&gt;RemainingScans;
         return(1);  /* success */
      }
      StartVert = NextVert;   /* keep looking for a non-0-height edge */
   }
}
/* Texture-map-draw the scan line between two edges. */
void ScanOutLine(EdgeScan * LeftEdge, EdgeScan * RightEdge)
{
   Fixedpoint SourceX = LeftEdge-&gt;SourceX;
   Fixedpoint SourceY = LeftEdge-&gt;SourceY;
   int DestX = LeftEdge-&gt;DestX;
   int DestXMax = RightEdge-&gt;DestX;
   Fixedpoint DestWidth;
   Fixedpoint SourceXStep, SourceYStep;
   /* Nothing to do if fully X clipped */
   if ((DestXMax &lt;= ClipMinX) || (DestX &gt;= ClipMaxX)) {
      return;
   }
   if ((DestXMax - DestX) &lt;= 0) {
      return;  /* nothing to draw */
   }
   /* Width of destination scan line, for scaling. Note: because this is an
      integer-based scaling, it can have a total error of as much as nearly
      one pixel. For more precise scaling, also maintain a fixed-point DestX
      in each edge, and use it for scaling. If this is done, it will also
      be necessary to nudge the source start coordinates to the right by an
      amount corresponding to the distance from the the real (fixed-point)
      DestX and the first pixel (at an integer X) to be drawn) */
   DestWidth = INT_TO_FIXED(DestXMax - DestX);
   /* Calculate source steps that correspond to each dest X step (across
      the scan line) */
   SourceXStep = FixedDiv(RightEdge-&gt;SourceX - SourceX, DestWidth);
   SourceYStep = FixedDiv(RightEdge-&gt;SourceY - SourceY, DestWidth);
   /* Clip right edge if necessary */
   if (DestXMax &gt; ClipMaxX) {
      DestXMax = ClipMaxX;
   }
   /* Clip left edge if necssary */
   if (DestX &lt; ClipMinX) {
      SourceX += SourceXStep * (ClipMinX - DestX);
      SourceY += SourceYStep * (ClipMinX - DestX);
      DestX = ClipMinX;
   }
   /* Scan across the destination scan line, updating the source image
      position accordingly */
   for (; DestX&lt;DestXMax; DestX++) {
      /* Get currently mapped pixel out of image and draw it to screen */
      WritePixelX(DestX, DestY,
            GET_IMAGE_PIXEL(TexMapBits, TexMapWidth,
            FIXED_TO_INT(SourceX), FIXED_TO_INT(SourceY)) );
      /* Point to the next source pixel */
      SourceX += SourceXStep;
      SourceY += SourceYStep;
   }
}
</PRE>
<!-- END CODE //-->
<P>No matter how you slice it, DDA texture mapping beats boring, single-color polygons nine ways to Sunday. The big downside is that it&rsquo;s much slower than a normal polygon fill; move the ball close to the screen in DEMO1, and watch things slow down when one of those big texture maps comes around. Of course, that&rsquo;s partly because the code is all in C; some well-chosen optimizations would work wonders. In the next chapter we&rsquo;ll discuss texture mapping further, crank up the speed of our texture mapper, and attend to some rough spots that remain in the DDA texture mapping implementation, most notably in the area of exactly which texture pixels map to which destination pixels as a polygon rotates.
</P>
<P>And, in case you&rsquo;re curious, yes, there is a bear in DEMO1. I wouldn&rsquo;t say he looks much like a Pooh-type bear, but he&rsquo;s a bear nonetheless. He does tend to look a little startled when you flip the ball around so that he&rsquo;s zipping by on his head, but, heck, you would too in the same situation. And remember, when you buy the next VGA megahit, <I>Bears in Space</I>, you saw it here first.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="56-02.html">Previous</A></TD>
<TD><A HREF="index.html">Table of Contents</A></TD>
<TD><A HREF="57-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
Graphics Programming Black Book &copy; 2001 Michael Abrash
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

<!-- BEGIN SUB FOOTER -->
</BODY>
</HTML>

<!-- END FOOTER -->


